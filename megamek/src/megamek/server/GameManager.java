/*
 * Copyright (c) 2022 - The MegaMek Team. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 */
package megamek.server;

import com.thoughtworks.xstream.XStream;
import megamek.MMConstants;
import megamek.MegaMek;
import megamek.client.bot.princess.BehaviorSettings;
import megamek.client.ui.swing.GUIPreferences;
import megamek.common.*;
import megamek.common.Building.DemolitionCharge;
import megamek.common.actions.*;
import megamek.common.annotations.Nullable;
import megamek.common.containers.PlayerIDandList;
import megamek.common.enums.BasementType;
import megamek.common.enums.GamePhase;
import megamek.common.enums.WeaponSortOrder;
import megamek.common.event.GameListener;
import megamek.common.event.GameVictoryEvent;
import megamek.common.force.Force;
import megamek.common.force.Forces;
import megamek.common.net.enums.PacketCommand;
import megamek.common.net.packets.Packet;
import megamek.common.options.GameOptions;
import megamek.common.options.IBasicOption;
import megamek.common.options.IOption;
import megamek.common.options.OptionsConstants;
import megamek.common.preference.PreferenceManager;
import megamek.common.util.BoardUtilities;
import megamek.common.util.EmailService;
import megamek.common.util.SerializationHelper;
import megamek.common.util.StringUtil;
import megamek.common.util.fileUtils.MegaMekFile;
import megamek.common.verifier.*;
import megamek.common.weapons.*;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.server.commands.*;
import megamek.server.victory.VictoryResult;
import org.apache.logging.log4j.LogManager;

import java.awt.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.*;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;
import java.util.zip.GZIPOutputStream;

/**
 * Manages the Game and processes player actions.
 */
public class GameManager implements IGameManager {
    private static class EntityTargetPair {
        Entity ent;

        Targetable target;

        EntityTargetPair (Entity e, Targetable t) {
            ent = e;
            target = t;
        }

        @Override
        public boolean equals(@Nullable Object o) {
            if (this == o) {
                return true;
            } else if ((null == o) || (getClass() != o.getClass())) {
                return false;
            } else {
                final EntityTargetPair other = (EntityTargetPair) o;
                return Objects.equals(ent, other.ent) && Objects.equals(target, other.target);
            }
        }

        @Override
        public int hashCode() {
            return Objects.hash(ent, target);
        }
    }

    private static final String DEFAULT_BOARD = MapSettings.BOARD_GENERATED;

    private Game game = new Game();

    private Vector<Report> vPhaseReport = new Vector<>();

    public Vector<Report> getvPhaseReport() {
        return vPhaseReport;
    }

    // Track buildings that are affected by an entity's movement.
    private Hashtable<Building, Boolean> affectedBldgs = new Hashtable<>();

    // Track Physical Action results, HACK to deal with opposing pushes
    // canceling each other
    private Vector<PhysicalResult> physicalResults = new Vector<>();

    private Vector<DynamicTerrainProcessor> terrainProcessors = new Vector<>();

    private static EntityVerifier entityVerifier;

    private ArrayList<int[]> scheduledNukes = new ArrayList<>();

    /**
     * Stores a set of <code>Coords</code> that have changed during this phase.
     */
    private Set<Coords> hexUpdateSet = new LinkedHashSet<>();

    private List<DemolitionCharge> explodingCharges = new ArrayList<>();

    /**
     * Keeps track of what team a player requested to join.
     */
    private int requestedTeam = Player.TEAM_NONE;

    /**
     * Keeps track of which player made a request to change teams.
     */
    private Player playerChangingTeam = null;

    /**
     * Flag that is set to true when all players have voted to allow another
     * player to change teams.
     */
    private boolean changePlayersTeam = false;

    /**
     * Keeps track of which player made a request to become Game Master.
     */
    private Player playerRequestingGameMaster = null;

    /**
     * Special packet queue for client feedback requests.
     */
    private final ConcurrentLinkedQueue<Server.ReceivedPacket> cfrPacketQueue = new ConcurrentLinkedQueue<>();

    public GameManager() {
        game.getOptions().initialize();
        game.getOptions().loadOptions();

        game.setPhase(GamePhase.LOUNGE);
        MapSettings mapSettings = game.getMapSettings();
        mapSettings.setBoardsAvailableVector(ServerBoardHelper.scanForBoards(mapSettings));
        mapSettings.setNullBoards(DEFAULT_BOARD);

        // register terrain processors
        terrainProcessors.add(new FireProcessor(this));
        terrainProcessors.add(new SmokeProcessor(this));
        terrainProcessors.add(new GeyserProcessor(this));
        terrainProcessors.add(new ElevatorProcessor(this));
        terrainProcessors.add(new ScreenProcessor(this));
        terrainProcessors.add(new WeatherProcessor(this));
        terrainProcessors.add(new QuicksandProcessor(this));
    }

    @Override
    public List<ServerCommand> getCommandList(Server server) {
        List<ServerCommand> commands = new ArrayList<>();
        commands.add(new DefeatCommand(server));
        commands.add(new ExportListCommand(server));
        commands.add(new FixElevationCommand(server, this));
        commands.add(new HelpCommand(server));
        commands.add(new KickCommand(server));
        commands.add(new ListSavesCommand(server));
        commands.add(new LocalSaveGameCommand(server));
        commands.add(new LocalLoadGameCommand(server));
        commands.add(new ResetCommand(server));
        commands.add(new RollCommand(server));
        commands.add(new SaveGameCommand(server));
        commands.add(new LoadGameCommand(server));
        commands.add(new SeeAllCommand(server, this));
        commands.add(new SingleBlindCommand(server, this));
        commands.add(new SkipCommand(server, this));
        commands.add(new VictoryCommand(server, this));
        commands.add(new WhoCommand(server));
        commands.add(new TeamCommand(server));
        commands.add(new ShowTileCommand(server, this));
        commands.add(new ShowEntityCommand(server, this));
        commands.add(new RulerCommand(server, this));
        commands.add(new ShowValidTargetsCommand(server, this));
        commands.add(new AddBotCommand(server, this));
        commands.add(new CheckBVCommand(server));
        commands.add(new CheckBVTeamCommand(server));
        commands.add(new NukeCommand(server, this));
        commands.add(new TraitorCommand(server, this));
        commands.add(new ListEntitiesCommand(server, this));
        commands.add(new AssignNovaNetServerCommand(server, this));
        commands.add(new AllowTeamChangeCommand(server, this));
        commands.add(new JoinTeamCommand(server));
        commands.add(new AllowGameMasterCommand(server, this));
        commands.add(new GameMasterCommand(server));
        return commands;
    }

    @Override
    public Game getGame() {
        return game;
    }

    @Override
    public void setGame(IGame g) {
        if (!(g instanceof Game)) {
            LogManager.getLogger().error("Attempted to set game to incorrect class.");
            return;
        }
        // game listeners are transient so we need to save and restore them
        Vector<GameListener> gameListenersClone = new Vector<>(getGame().getGameListeners());

        game = (Game) g;

        for (GameListener listener : gameListenersClone) {
            getGame().addGameListener(listener);
        }

        List<Integer> orphanEntities = new ArrayList<>();

        // reattach the transient fields and ghost the players
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            ent.setGame(game);

            if (ent.getOwner() == null) {
                orphanEntities.add(ent.getId());
                continue;
            }

            if (ent instanceof Mech) {
                ((Mech) ent).setBAGrabBars();
                ((Mech) ent).setProtomechClampMounts();
            }
            if (ent instanceof Tank) {
                ((Tank) ent).setBAGrabBars();
            }
        }

        game.removeEntities(orphanEntities, IEntityRemovalConditions.REMOVE_UNKNOWN);

        game.setOutOfGameEntitiesVector(game.getOutOfGameEntitiesVector());
        for (Enumeration<Player> e = game.getPlayers(); e.hasMoreElements(); ) {
            Player p = e.nextElement();
            p.setGame(game);
            p.setGhost(true);
        }
        // might need to restore weapon type for some attacks that take multiple
        // turns (like artillery)
        for (Enumeration<AttackHandler> a = game.getAttacks(); a.hasMoreElements(); ) {
            AttackHandler handler = a.nextElement();
            if (handler instanceof WeaponHandler) {
                ((WeaponHandler) handler).restore();
            }
        }

        game.getForces().setGame(game);
    }

    /**
     * Reset the game back to the lounge.
     */
    @Override
    public void resetGame() {
        // remove all entities
        getGame().reset();
        send(createEntitiesPacket());
        send(new Packet(PacketCommand.SENDING_MINEFIELDS, new Vector<>()));

        // remove ghosts
        List<Player> ghosts = new ArrayList<>();
        for (Enumeration<Player> players = getGame().getPlayers(); players.hasMoreElements(); ) {
            Player p = players.nextElement();
            if (p.isGhost()) {
                ghosts.add(p);
            } else {
                // non-ghosts set their starting positions to any
                p.setStartingPos(Board.START_ANY);
                transmitPlayerUpdate(p);
            }
        }

        for (Player p : ghosts) {
            getGame().removePlayer(p.getId());
            send(new Packet(PacketCommand.PLAYER_REMOVE, p.getId()));
        }

        // reset all players
        resetPlayersDone();
        transmitAllPlayerDones();

        // Write end of game to stdout so controlling scripts can rotate logs.
        LogManager.getLogger().info(LocalDateTime.now() + " END OF GAME");

        if (Server.getServerInstance().getEmailService() != null) {
            Server.getServerInstance().getEmailService().reset();
        }

        changePhase(GamePhase.LOUNGE);
    }

    @Override
    public void requestGameMaster(Player player) {
        playerRequestingGameMaster = player;
    }

    public boolean isGameMasterRequestInProgress() {
        return playerRequestingGameMaster != null;
    }

    public Player getPlayerRequestingGameMaster() {
        return playerRequestingGameMaster;
    }

    public void processGameMasterRequest() {
        if (playerRequestingGameMaster != null) {
            setGameMaster(playerRequestingGameMaster, true);
            playerRequestingGameMaster = null;
        }
    }

    public void setGameMaster(Player player, boolean gameMaster) {
        player.setGameMaster(gameMaster);
        transmitPlayerUpdate(player);
        sendServerChat(player.getName() + " set GameMaster: " + player.getGameMaster());
    }

    public void setSingleBlind(Player player, boolean singleBlind) {
        player.setSingleBlind(singleBlind);
        transmitPlayerUpdate(player);
        sendServerChat(player.getName() + " set SingleBlind: " + player.getSingleBlind());
    }

    public void setSeeAll(Player player, boolean seeAll) {
        player.setSeeAll(seeAll);
        transmitPlayerUpdate(player);
        sendServerChat(player.getName() + " set SeeAll: " + player.getSeeAll());
    }

    @Override
    public void requestTeamChange(int team, Player player) {
        requestedTeam = team;
        playerChangingTeam = player;
        changePlayersTeam = false;
    }

    public void allowTeamChange() {
        changePlayersTeam = true;
    }

    public boolean isTeamChangeRequestInProgress() {
        return playerChangingTeam != null;
    }

    public Player getPlayerRequestingTeamChange() {
        return playerChangingTeam;
    }

    public int getRequestedTeam() {
        return requestedTeam;
    }

    private void processTeamChangeRequest() {
        if (playerChangingTeam != null) {
            playerChangingTeam.setTeam(requestedTeam);
            getGame().setupTeams();
            transmitPlayerUpdate(playerChangingTeam);
            String teamString = "Team " + requestedTeam + "!";
            if (requestedTeam == Player.TEAM_UNASSIGNED) {
                teamString = " unassigned!";
            } else if (requestedTeam == Player.TEAM_NONE) {
                teamString = " lone wolf!";
            }
            sendServerChat(playerChangingTeam.getName() + " has changed teams to " + teamString);
            playerChangingTeam = null;
        }
        changePlayersTeam = false;
    }

    /**
     * automatically save the game
     */
    public void autoSave() {
        String fileName = "autosave";
        if (PreferenceManager.getClientPreferences().stampFilenames()) {
            fileName = StringUtil.addDateTimeStamp(fileName);
        }
        saveGame(fileName, getGame().getOptions().booleanOption(OptionsConstants.BASE_AUTOSAVE_MSG));
    }

    /**
     * save the game and send it to the specified connection
     *
     * @param connId     The <code>int</code> connection id to send to
     * @param sFile      The <code>String</code> filename to use
     * @param sLocalPath The <code>String</code> path to the file to be used on the
     *                   client
     */
    @Override
    public void sendSaveGame(int connId, String sFile, String sLocalPath) {
        saveGame(sFile, false);
        String sFinalFile = sFile;
        if (!sFinalFile.endsWith(MMConstants.SAVE_FILE_GZ_EXT)) {
            if (sFinalFile.endsWith(MMConstants.SAVE_FILE_EXT)) {
                sFinalFile = sFile + ".gz";
            } else {
                sFinalFile = sFile + MMConstants.SAVE_FILE_GZ_EXT;
            }
        }
        sLocalPath = sLocalPath.replaceAll("\\|", " ");
        String localFile = MMConstants.SAVEGAME_DIR + File.separator + sFinalFile;
        try (InputStream in = new FileInputStream(localFile); InputStream bin = new BufferedInputStream(in)) {
            List<Integer> data = new ArrayList<>();
            int input;
            while ((input = bin.read()) != -1) {
                data.add(input);
            }
            send(connId, new Packet(PacketCommand.SEND_SAVEGAME, sFinalFile, data, sLocalPath));
            sendChat(connId, "***Server", "Save game has been sent to you.");
        } catch (Exception ex) {
            LogManager.getLogger().error("Unable to load file: " + localFile, ex);
        }
    }

    /**
     * save the game
     *
     * @param sFile    The <code>String</code> filename to use
     * @param sendChat A <code>boolean</code> value whether or not to announce the
     *                 saving to the server chat.
     */
    public void saveGame(String sFile, boolean sendChat) {
        // We need to strip the .gz if it exists,
        // otherwise we'll double up on it.
        if (sFile.endsWith(".gz")) {
            sFile = sFile.replace(".gz", "");
        }

        String sFinalFile = sFile;
        if (!sFinalFile.endsWith(MMConstants.SAVE_FILE_EXT)) {
            sFinalFile = sFile + MMConstants.SAVE_FILE_EXT;
        }
        File sDir = new File(MMConstants.SAVEGAME_DIR);
        if (!sDir.exists()) {
            sDir.mkdir();
        }

        sFinalFile = sDir + File.separator + sFinalFile;

        try (OutputStream os = new FileOutputStream(sFinalFile + ".gz");
             OutputStream gzo = new GZIPOutputStream(os);
             Writer writer = new OutputStreamWriter(gzo, StandardCharsets.UTF_8)) {
            SerializationHelper.getSaveGameXStream().toXML(getGame(), writer);
        } catch (Exception e) {
            LogManager.getLogger().error("Unable to save file: " + sFinalFile, e);
        }

        if (sendChat) {
            sendChat("MegaMek", "Game saved to " + sFinalFile);
        }
    }

    /**
     * save the game
     *
     * @param sFile The <code>String</code> filename to use
     */
    @Override
    public void saveGame(String sFile) {
        saveGame(sFile, true);
    }


    @Override
    public void disconnect(Player player) {
        // in the lounge, just remove all entities for that player
        if (getGame().getPhase().isLounge()) {
            removeAllEntitiesOwnedBy(player);
        }

        // if a player has active entities, he becomes a ghost
        // except the VICTORY_PHASE when the disconnected
        // player is most likely the Bot disconnected after receiving
        // the COMMAND_END_OF_GAME command
        // see the Bug 1225949.
        // Ghost players (Bots mostly) are now removed during the
        // resetGame(), so we don't need to do it here.
        // This fixes Bug 3399000 without reintroducing 1225949
        if (getGame().getPhase().isVictory() || getGame().getPhase().isLounge() || player.isObserver()) {
            getGame().removePlayer(player.getId());
            send(new Packet(PacketCommand.PLAYER_REMOVE, player.getId()));
            // Prevent situation where all players but the disconnected one
            // are done, and the disconnecting player causes the game to start
            if (getGame().getPhase().isLounge()) {
                resetActivePlayersDone();
            }
        } else {
            player.setGhost(true);
            player.setDone(true);
            transmitPlayerUpdate(player);
        }

        // make sure the game advances
        if (getGame().getPhase().hasTurns() && (null != getGame().getTurn())) {
            if (getGame().getTurn().isValid(player.getId(), getGame())) {
                sendGhostSkipMessage(player);
            }
        } else {
            checkReady();
        }

        // notify other players
        sendServerChat(player.getName() + " disconnected.");

        // log it
        LogManager.getLogger().info("s: removed player " + player.getName());

        // Reset the game after Elvis has left the building.
        if (0 == getGame().getNoOfPlayers()) {
            resetGame();
        }
    }

    /**
     * Checks each player to see if he has no entities, and if true, sets the
     * observer flag for that player. An exception is that there are no
     * observers during the lounge phase.
     */
    public void checkForObservers() {
        for (Enumeration<Player> e = getGame().getPlayers(); e.hasMoreElements(); ) {
            Player p = e.nextElement();
            p.setObserver((getGame().getEntitiesOwnedBy(p) < 1) && !getGame().getPhase().isLounge());
        }
    }

    @Override
    public void removeAllEntitiesOwnedBy(Player player) {
        int pid = player.getId();
        Forces forces = game.getForces();
        // Disentangle everything!
        // remove other player's forces from player's forces
        forces.getAllForces().stream()
                .filter(f -> !f.isTopLevel())
                .filter(f -> f.getOwnerId() != pid)
                .filter(f -> forces.getForce(f.getParentId()).getOwnerId() == pid)
                .forEach(forces::promoteForce);

        // remove other player's units from player's forces
        game.getEntitiesVector().stream()
                .filter(e -> e.getOwnerId() != pid)
                .filter(Entity::partOfForce)
                .filter(e -> forces.getForce(e.getForceId()).getOwnerId() == pid)
                .forEach(forces::removeEntityFromForces);

        // delete forces of player
        forces.deleteForces(forces.getAllForces().stream()
                .filter(f -> f.getOwnerId() == pid)
                .filter(f -> f.isTopLevel() || !forces.getOwner(f.getParentId()).equals(player))
                .collect(Collectors.toList()));

        Collection<Entity> delEntities = game.getEntitiesVector().stream()
                .filter(e -> e.getOwner().equals(player))
                .collect(Collectors.toList());

        // remove entities of player from any forces, disembark and C3 disconnect them
        delEntities.forEach(forces::removeEntityFromForces);
        ServerLobbyHelper.lobbyUnload(game, delEntities);
        ServerLobbyHelper.performC3Disconnect(game, delEntities);

        // delete entities of player
        delEntities.forEach(e -> game.removeEntity(e.getId(), IEntityRemovalConditions.REMOVE_NEVER_JOINED));

        // send full update
        send(createFullEntitiesPacket());
    }

    private void resetEntityRound() {
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity entity = e.next();
            entity.newRound(game.getRoundCount());
        }
    }

    public void send(Packet p) {
        Server.getServerInstance().send(p);
    }

    public void send(int connId, Packet p) {
        Server.getServerInstance().send(connId, p);
    }

    public void transmitPlayerUpdate(Player p) {
        Server.getServerInstance().transmitPlayerUpdate(p);
    }

    /**
     * Sends out the player info updates for all players to all connections
     */
    private void transmitAllPlayerUpdates() {
        for (var player: getGame().getPlayersVector()) {
            transmitPlayerUpdate(player);
        }
    }

    public void sendServerChat(String message) {
        Server.getServerInstance().sendServerChat(message);
    }

    public void sendServerChat(int connId, String message) {
        Server.getServerInstance().sendServerChat(connId, message);
    }

    public void sendChat(String origin, String message) {
        Server.getServerInstance().sendChat(origin, message);
    }

    public void sendChat(int connId, String origin, String message) {
        Server.getServerInstance().sendChat(connId, origin, message);
    }

    /**
     * Sends a player the info they need to look at the current phase. This is
     * triggered when a player first connects to the server.
     */
    @Override
    public void sendCurrentInfo(int connId) {
        send(connId, createGameSettingsPacket());
        send(connId, createPlanetaryConditionsPacket());

        Player player = getGame().getPlayer(connId);
        if (null != player) {
            send(connId, new Packet(PacketCommand.SENDING_MINEFIELDS, player.getMinefields()));

            if (getGame().getPhase().isLounge()) {
                send(connId, createMapSettingsPacket());
                send(createMapSizesPacket());
                // Send Entities *after* the Lounge Phase Change
                send(connId, new Packet(PacketCommand.PHASE_CHANGE, getGame().getPhase()));
                if (doBlind()) {
                    send(connId, createFilteredFullEntitiesPacket(player));
                } else {
                    send(connId, createFullEntitiesPacket());
                }
            } else {
                send(connId, new Packet(PacketCommand.ROUND_UPDATE, getGame().getRoundCount()));
                send(connId, createBoardPacket());
                send(connId, createAllReportsPacket(player));

                // Send entities *before* other phase changes.
                if (doBlind()) {
                    send(connId, createFilteredFullEntitiesPacket(player));
                } else {
                    send(connId, createFullEntitiesPacket());
                }
                player.setDone(getGame().getEntitiesOwnedBy(player) <= 0);
                send(connId, new Packet(PacketCommand.PHASE_CHANGE, getGame().getPhase()));
            }

            // LOUNGE triggers a Game.reset() on the client, which wipes out
            // the PlanetaryCondition, so resend
            if (game.getPhase().isLounge()) {
                send(connId, createPlanetaryConditionsPacket());
            }

            if (game.getPhase().isFiring() || game.getPhase().isTargeting()
                    || game.getPhase().isOffboard() || game.getPhase().isPhysical()) {
                // can't go above, need board to have been sent
                send(connId, createAttackPacket(getGame().getActionsVector(), 0));
                send(connId, createAttackPacket(getGame().getChargesVector(), 1));
                send(connId, createAttackPacket(getGame().getRamsVector(), 1));
                send(connId, createAttackPacket(getGame().getTeleMissileAttacksVector(), 1));
            }

            if (getGame().getPhase().hasTurns() && getGame().hasMoreTurns()) {
                send(connId, createTurnVectorPacket());
                send(connId, createTurnIndexPacket(connId));
            } else if (!getGame().getPhase().isLounge() && !getGame().getPhase().isStartingScenario()) {
                endCurrentPhase();
            }

            send(connId, createArtilleryPacket(player));
            send(connId, createFlarePacket());
            send(connId, createSpecialHexDisplayPacket(connId));
            send(connId, new Packet(PacketCommand.PRINCESS_SETTINGS, getGame().getBotSettings()));
        }
    }

    /**
     * Resend entities to the player called by SeeAll command
     */
    public void sendEntities(int connId) {
        if (doBlind()) {
            send(connId, createFilteredEntitiesPacket(game.getPlayer(connId), null));
        } else {
            send(connId, createEntitiesPacket());
        }
    }

    @Override
    public void handleCfrPacket(Server.ReceivedPacket rp) {
        synchronized (cfrPacketQueue) {
            cfrPacketQueue.add(rp);
            cfrPacketQueue.notifyAll();
        }
    }

    @Override
    public void handlePacket(int connId, Packet packet) {
        final Player player = game.getPlayer(connId);
        switch (packet.getCommand()) {
            case PLAYER_READY:
                receivePlayerDone(packet, connId);
                send(createPlayerDonePacket(connId));
                checkReady();
                break;
            case PRINCESS_SETTINGS:
                if (player != null) {
                    if (game.getBotSettings() == null) {
                        game.setBotSettings(new HashMap<>());
                    }

                    game.getBotSettings().put(player.getName(), (BehaviorSettings) packet.getObject(0));
                }
                break;
            case REROLL_INITIATIVE:
                receiveInitiativeRerollRequest(packet, connId);
                break;
            case FORWARD_INITIATIVE:
                receiveForwardIni(connId);
                break;
            case BLDG_EXPLODE:
                Building.DemolitionCharge charge = (Building.DemolitionCharge) packet.getData()[0];
                if (charge.playerId == connId) {
                    if (!explodingCharges.contains(charge)) {
                        explodingCharges.add(charge);
                        Player p = game.getPlayer(connId);
                        sendServerChat(p.getName() + " has touched off explosives "
                                + "(handled in end phase)!");
                    }
                }
                break;
            case ENTITY_MOVE:
                receiveMovement(packet, connId);
                break;
            case ENTITY_DEPLOY:
                receiveDeployment(packet, connId);
                break;
            case ENTITY_DEPLOY_UNLOAD:
                receiveDeploymentUnload(packet, connId);
                break;
            case DEPLOY_MINEFIELDS:
                receiveDeployMinefields(packet, connId);
                break;
            case ENTITY_ATTACK:
                receiveAttack(packet, connId);
                break;
            case ENTITY_PREPHASE:
                receivePrephase(packet, connId);
                break;
            case ENTITY_GTA_HEX_SELECT:
                receiveGroundToAirHexSelectPacket(packet, connId);
                break;
            case ENTITY_ADD:
                receiveEntityAdd(packet, connId);
                resetPlayersDone();
                break;
            case ENTITY_UPDATE:
                receiveEntityUpdate(packet, connId);
                resetPlayersDone();
                break;
            case ENTITY_MULTIUPDATE:
                receiveEntitiesUpdate(packet, connId);
                resetPlayersDone();
                break;
            case ENTITY_ASSIGN:
                ServerLobbyHelper.receiveEntitiesAssign(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case FORCE_UPDATE:
                ServerLobbyHelper.receiveForceUpdate(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case FORCE_ADD:
                ServerLobbyHelper.receiveForceAdd(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case FORCE_DELETE:
                receiveForcesDelete(packet, connId);
                resetPlayersDone();
                break;
            case FORCE_PARENT:
                ServerLobbyHelper.receiveForceParent(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case FORCE_ADD_ENTITY:
                ServerLobbyHelper.receiveAddEntititesToForce(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case FORCE_ASSIGN_FULL:
                ServerLobbyHelper.receiveForceAssignFull(packet, connId, getGame(), this);
                resetPlayersDone();
                break;
            case ENTITY_LOAD:
                receiveEntityLoad(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case ENTITY_MODECHANGE:
                receiveEntityModeChange(packet, connId);
                break;
            case ENTITY_SENSORCHANGE:
                receiveEntitySensorChange(packet, connId);
                break;
            case ENTITY_SINKSCHANGE:
                receiveEntitySinksChange(packet, connId);
                break;
            case ENTITY_ACTIVATE_HIDDEN:
                receiveEntityActivateHidden(packet, connId);
                break;
            case ENTITY_NOVA_NETWORK_CHANGE:
                receiveEntityNovaNetworkModeChange(packet, connId);
                break;
            case ENTITY_MOUNTED_FACING_CHANGE:
                receiveEntityMountedFacingChange(packet, connId);
                break;
            case ENTITY_CALLEDSHOTCHANGE:
                receiveEntityCalledShotChange(packet, connId);
                break;
            case ENTITY_SYSTEMMODECHANGE:
                receiveEntitySystemModeChange(packet, connId);
                break;
            case ENTITY_AMMOCHANGE:
                receiveEntityAmmoChange(packet, connId);
                break;
            case ENTITY_REMOVE:
                receiveEntityDelete(packet, connId);
                resetPlayersDone();
                break;
            case ENTITY_WORDER_UPDATE:
                Object[] data = packet.getData();
                Entity ent = game.getEntity((Integer) data[0]);
                if (ent != null) {
                    WeaponSortOrder order = (WeaponSortOrder) data[1];
                    ent.setWeaponSortOrder(order);
                    // Used by the client but is set in setWeaponSortOrder
                    ent.setWeapOrderChanged(false);
                    if (order.isCustom()) {
                        // Unchecked cause of limitations in Java when casting to a collection
                        @SuppressWarnings(value = "unchecked")
                        Map<Integer, Integer> customWeaponOrder = (Map<Integer, Integer>) data[2];
                        ent.setCustomWeaponOrder(customWeaponOrder);
                    }
                }
                break;
            case SENDING_GAME_SETTINGS:
                if (receiveGameOptions(packet, connId)) {
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createGameSettingsPacket());
                    receiveGameOptionsAux(packet, connId);
                }
                break;
            case SENDING_MAP_SETTINGS:
                if (game.getPhase().isBefore(GamePhase.DEPLOYMENT)) {
                    MapSettings newSettings = (MapSettings) packet.getObject(0);
                    if (!game.getMapSettings().equalMapGenParameters(newSettings)) {
                        sendServerChat("Player " + player.getName() + " changed map settings");
                    }
                    MapSettings mapSettings = newSettings;
                    mapSettings.setBoardsAvailableVector(ServerBoardHelper.scanForBoards(mapSettings));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    game.setMapSettings(mapSettings);
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createMapSettingsPacket());
                }
                break;
            case SENDING_MAP_DIMENSIONS:
                if (game.getPhase().isBefore(GamePhase.DEPLOYMENT)) {
                    MapSettings newSettings = (MapSettings) packet.getObject(0);
                    if (!game.getMapSettings().equalMapGenParameters(newSettings)) {
                        sendServerChat("Player " + player.getName() + " changed map dimensions");
                    }
                    MapSettings mapSettings = newSettings;
                    mapSettings.setBoardsAvailableVector(ServerBoardHelper.scanForBoards(mapSettings));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    game.setMapSettings(mapSettings);
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createMapSettingsPacket());
                }
                break;
            case SENDING_PLANETARY_CONDITIONS:
                if (game.getPhase().isBefore(GamePhase.DEPLOYMENT)) {
                    PlanetaryConditions conditions = (PlanetaryConditions) packet.getObject(0);
                    sendServerChat("Player " + player.getName() + " changed planetary conditions");
                    game.setPlanetaryConditions(conditions);
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createPlanetaryConditionsPacket());
                }
                break;
            case UNLOAD_STRANDED:
                receiveUnloadStranded(packet, connId);
                break;
            case SET_ARTILLERY_AUTOHIT_HEXES:
                receiveArtyAutoHitHexes(packet, connId);
                break;
            case CUSTOM_INITIATIVE:
                receiveCustomInit(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case SQUADRON_ADD:
                receiveSquadronAdd(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case RESET_ROUND_DEPLOYMENT:
                game.setupRoundDeployment();
                break;
            case SPECIAL_HEX_DISPLAY_DELETE:
                game.getBoard().removeSpecialHexDisplay((Coords) packet.getObject(0),
                        (SpecialHexDisplay) packet.getObject(1));
                sendSpecialHexDisplayPackets();
                break;
            case SPECIAL_HEX_DISPLAY_APPEND:
                game.getBoard().addSpecialHexDisplay((Coords) packet.getObject(0),
                        (SpecialHexDisplay) packet.getObject(1));
                sendSpecialHexDisplayPackets();
                break;
            case PLAYER_TEAM_CHANGE:
                ServerLobbyHelper.receiveLobbyTeamChange(packet, connId, getGame(), this);
                break;
        }
    }

    /**
     * Check a list of entity Ids for doomed entities and destroy those.
     */
    private void destroyDoomedEntities(Vector<Integer> entityIds) {
        Vector<Entity> toRemove = new Vector<>(0, 10);
        for (Integer entityId : entityIds) {
            Entity entity = game.getEntity(entityId);
            if (entity.isDoomed()) {
                entity.setDestroyed(true);

                // Is this unit swarming somebody? Better let go before
                // it's too late.
                final int swarmedId = entity.getSwarmTargetId();
                if (Entity.NONE != swarmedId) {
                    final Entity swarmed = game.getEntity(swarmedId);
                    swarmed.setSwarmAttackerId(Entity.NONE);
                    entity.setSwarmTargetId(Entity.NONE);
                    Report r = new Report(5165);
                    r.subject = swarmedId;
                    r.addDesc(swarmed);
                    addReport(r);
                    entityUpdate(swarmedId);
                }
            }

            if (entity.isDestroyed()) {
                toRemove.addElement(entity);
            }
        }

        // actually remove all flagged entities
        for (Entity entity : toRemove) {
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
            if (!entity.isSalvage()) {
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
            }

            // If we removed a unit during the movement phase that hasn't moved, remove its turn.
            if (getGame().getPhase().isMovement() && entity.isSelectableThisTurn()) {
                getGame().removeTurnFor(entity);
                send(createTurnVectorPacket());
            }
            entityUpdate(entity.getId());
            game.removeEntity(entity.getId(), condition);
            send(createRemoveEntityPacket(entity.getId(), condition));
        }
    }

    /**
     * Deploys elligible offboard entities.
     */
    private void deployOffBoardEntities() {
        // place off board entities actually off-board
        Iterator<Entity> entities = game.getEntities();
        while (entities.hasNext()) {
            Entity en = entities.next();
            if (en.isOffBoard() && !en.isDeployed()) {
                en.deployOffBoard(game.getRoundCount());
            }
        }
    }

    /**
     * Called at the beginning of each phase. Sets and resets any entity
     * parameters that need to be reset.
     */
    private void resetEntityPhase(GamePhase phase) {
        // first, mark doomed entities as destroyed and flag them
        Vector<Entity> toRemove = new Vector<>(0, 10);
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();
            entity.newPhase(phase);
            if (entity.isDoomed()) {
                entity.setDestroyed(true);

                // Is this unit swarming somebody? Better let go before it's too late.
                final int swarmedId = entity.getSwarmTargetId();
                if (Entity.NONE != swarmedId) {
                    final Entity swarmed = game.getEntity(swarmedId);
                    swarmed.setSwarmAttackerId(Entity.NONE);
                    entity.setSwarmTargetId(Entity.NONE);
                    Report r = new Report(5165);
                    r.subject = swarmedId;
                    r.addDesc(swarmed);
                    addReport(r);
                    entityUpdate(swarmedId);
                }
            }

            if (entity.isDestroyed()) {
                if (game.getEntity(entity.getTransportId()) != null
                        && game.getEntity(entity.getTransportId()).isLargeCraft()) {
                    // Leaving destroyed entities in DropShip bays alone here
                } else {
                    toRemove.addElement(entity);
                }
            }
        }

        // actually remove all flagged entities
        for (Entity entity : toRemove) {
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
            if (!entity.isSalvage()) {
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
            }

            entityUpdate(entity.getId());
            game.removeEntity(entity.getId(), condition);
            send(createRemoveEntityPacket(entity.getId(), condition));
        }

        // do some housekeeping on all the remaining
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();

            entity.applyDamage();

            entity.reloadEmptyWeapons();

            // reset damage this phase
            // telemissiles need a record of damage last phase
            entity.damageThisRound += entity.damageThisPhase;
            entity.damageThisPhase = 0;
            entity.engineHitsThisPhase = 0;
            entity.rolledForEngineExplosion = false;
            entity.dodging = false;
            entity.setShutDownThisPhase(false);
            entity.setStartupThisPhase(false);

            // reset done to false

            if (phase.isDeployment()) {
                entity.setDone(!entity.shouldDeploy(game.getRoundCount()));
            } else {
                entity.setDone(false);
            }

            // reset spotlights
            entity.setIlluminated(false);
            entity.setUsedSearchlight(false);
            entity.setCarefulStand(false);
            entity.setNetworkBAP(false);

            if (entity instanceof MechWarrior) {
                ((MechWarrior) entity).setLanded(true);
            }
        }
        game.clearIlluminatedPositions();
        send(new Packet(PacketCommand.CLEAR_ILLUM_HEXES));
    }

    /**
     * Called during the end phase. Checks each entity for ASEW effects counters and decrements them by 1 if greater than 0
     */
    public void decrementASEWTurns() {
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();
            // Decrement ASEW effects
            if ((entity.getEntityType() & Entity.ETYPE_DROPSHIP) == Entity.ETYPE_DROPSHIP) {
                Dropship d = (Dropship) entity;
                for (int loc = 0; loc < d.locations(); loc++) {
                    if (d.getASEWAffected(loc) > 0) {
                        d.setASEWAffected(loc, d.getASEWAffected(loc) - 1);
                    }
                }
            } else if ((entity.getEntityType() & Entity.ETYPE_JUMPSHIP) != 0) {
                Jumpship j = (Jumpship) entity;
                for (int loc = 0; loc < j.locations(); loc++) {
                    if (j.getASEWAffected(loc) > 0) {
                        j.setASEWAffected(loc, j.getASEWAffected(loc) - 1);
                    }
                }
            } else {
                if (entity.getASEWAffected() > 0) {
                    entity.setASEWAffected(entity.getASEWAffected() - 1);
                }
            }
        }
    }

    /**
     * Called at the beginning of certain phases to make every player not ready.
     */
    private void resetPlayersDone() {
        if ((getGame().getPhase().isReport()) && (!getGame().getPhase().isVictory())) {
            return;
        }

        for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
            final Player player = i.nextElement();
            player.setDone(false);
        }
        transmitAllPlayerDones();
    }

    /**
     * Called at the beginning of certain phases to make every active player not
     * ready.
     */
    private void resetActivePlayersDone() {
        for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
            final Player player = i.nextElement();
            player.setDone(game.getEntitiesOwnedBy(player) <= 0);
        }
        transmitAllPlayerDones();
    }

    /**
     * Writes the victory report
     */
    private void prepareVictoryReport() {
        // remove carcasses to the graveyard
        Vector<Entity> toRemove = new Vector<>();
        for (Entity e : game.getEntitiesVector()) {
            if (e.isCarcass() && !e.isDestroyed()) {
                toRemove.add(e);
            }
        }
        for (Entity e : toRemove) {
            destroyEntity(e, "crew death", false, true);
            game.removeEntity(e.getId(), IEntityRemovalConditions.REMOVE_SALVAGEABLE);
            e.setDestroyed(true);
        }

        addReport(new Report(7000, Report.PUBLIC));

        // Declare the victor
        Report r = new Report(1210);
        r.type = Report.PUBLIC;
        if (game.getVictoryTeam() == Player.TEAM_NONE) {
            Player player = game.getPlayer(game.getVictoryPlayerId());
            if (null == player) {
                r.messageId = 7005;
            } else {
                r.messageId = 7010;
                r.add(player.getColorForPlayer());
            }
        } else {
            // Team victory
            r.messageId = 7015;
            r.add(game.getVictoryTeam());
        }
        addReport(r);

        // Show player BVs
        Enumeration<Player> players = game.getPlayers();
        while (players.hasMoreElements()) {
            Player player = players.nextElement();
            // Observers without initial entities get ignored
            if (player.isObserver() && (player.getInitialEntityCount() == 0)) {
                continue;
            }
            r = new Report(7016, Report.PUBLIC);
            r.add(player.getColorForPlayer());
            r.add(player.getBV());
            r.add(player.getInitialBV());
            r.add(Double.toString(Math.round((double) player.getBV() / player.getInitialBV() * 10000.0) / 100.0));
            r.add(player.getFledBV());
            r.add(player.getEntityCount());
            r.add(player.getInitialEntityCount());
            r.add(Double.toString(Math.round(((double) player.getEntityCount() / player.getInitialEntityCount()) * 10000.0) / 100.0));
            addReport(r);
        }

        // List the survivors
        Iterator<Entity> survivors = game.getEntities();
        if (survivors.hasNext()) {
            addReport(new Report(7020, Report.PUBLIC));
            while (survivors.hasNext()) {
                Entity entity = survivors.next();

                if (!entity.isDeployed()) {
                    continue;
                }

                addReport(entity.victoryReport());
            }
        }
        // List units that never deployed
        Iterator<Entity> undeployed = game.getEntities();
        if (undeployed.hasNext()) {
            boolean wroteHeader = false;

            while (undeployed.hasNext()) {
                Entity entity = undeployed.next();

                if (entity.isDeployed()) {
                    continue;
                }

                if (!wroteHeader) {
                    addReport(new Report(7075, Report.PUBLIC));
                    wroteHeader = true;
                }

                addReport(entity.victoryReport());
            }
        }
        // List units that retreated
        Enumeration<Entity> retreat = game.getRetreatedEntities();
        if (retreat.hasMoreElements()) {
            addReport(new Report(7080, Report.PUBLIC));
            while (retreat.hasMoreElements()) {
                Entity entity = retreat.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // List destroyed units
        Enumeration<Entity> graveyard = game.getGraveyardEntities();
        if (graveyard.hasMoreElements()) {
            addReport(new Report(7085, Report.PUBLIC));
            while (graveyard.hasMoreElements()) {
                Entity entity = graveyard.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // List devastated units (not salvageable)
        Enumeration<Entity> devastated = game.getDevastatedEntities();
        if (devastated.hasMoreElements()) {
            addReport(new Report(7090, Report.PUBLIC));

            while (devastated.hasMoreElements()) {
                Entity entity = devastated.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // Let player know about entitystatus.txt file
        addReport(new Report(7095, Report.PUBLIC));
    }

    /**
     * Generates a detailed report for campaign use
     */
    private String getDetailedVictoryReport() {
        StringBuilder sb = new StringBuilder();

        Vector<Entity> vAllUnits = new Vector<>();
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vAllUnits.addElement(i.next());
        }

        for (Enumeration<Entity> i = game.getRetreatedEntities(); i.hasMoreElements(); ) {
            vAllUnits.addElement(i.nextElement());
        }

        for (Enumeration<Entity> i = game.getGraveyardEntities(); i.hasMoreElements(); ) {
            vAllUnits.addElement(i.nextElement());
        }

        for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
            // Record the player.
            Player p = i.nextElement();
            sb.append("++++++++++ ").append(p.getName()).append(" ++++++++++\n");

            // Record the player's alive, retreated, or salvageable units.
            for (int x = 0; x < vAllUnits.size(); x++) {
                Entity e = vAllUnits.elementAt(x);
                if (e.getOwner() == p) {
                    sb.append(UnitStatusFormatter.format(e));
                }
            }

            // Record the player's devastated units.
            Enumeration<Entity> devastated = game.getDevastatedEntities();
            if (devastated.hasMoreElements()) {
                sb.append("=============================================================\n");
                sb.append("The following utterly destroyed units are not available for salvage:\n");
                while (devastated.hasMoreElements()) {
                    Entity e = devastated.nextElement();
                    if (e.getOwner() == p) {
                        sb.append(e.getShortName());
                        for (int pos = 0; pos < e.getCrew().getSlotCount(); pos++) {
                            sb.append(", ").append(e.getCrew().getNameAndRole(pos)).append(" (")
                                    .append(e.getCrew().getGunnery()).append('/')
                                    .append(e.getCrew().getPiloting()).append(")\n");
                        }
                    }
                }
                sb.append("=============================================================\n");
            }
        }

        return sb.toString();
    }

    /**
     * Forces victory for the specified player, or his/her team at the end of the round.
     */
    public void forceVictory(Player victor) {
        game.setForceVictory(true);
        if (victor.getTeam() == Player.TEAM_NONE) {
            game.setVictoryPlayerId(victor.getId());
            game.setVictoryTeam(Player.TEAM_NONE);
        } else {
            game.setVictoryPlayerId(Player.PLAYER_NONE);
            game.setVictoryTeam(victor.getTeam());
        }

        Vector<Player> playersVector = game.getPlayersVector();
        for (int i = 0; i < playersVector.size(); i++) {
            Player player = playersVector.elementAt(i);
            player.setAdmitsDefeat(false);
        }
    }

    /**
     * Called when a player declares that he is "done." Checks to see if all
     * players are done, and if so, moves on to the next phase.
     */
    private void checkReady() {
        // check if all active players are done
        for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
            final Player player = i.nextElement();
            if (!player.isGhost() && !player.isObserver() && !player.isDone()) {
                return;
            }
        }

        // Tactical Genius pilot special ability (lvl 3)
        if (game.getNoOfInitiativeRerollRequests() > 0) {
            resetActivePlayersDone();
            game.rollInitAndResolveTies();

            determineTurnOrder(GamePhase.INITIATIVE);
            clearReports();
            writeInitiativeReport(true);
            sendReport(true);
            return; // don't end the phase yet, players need to see new report
        }

        // need at least one entity in the game for the lounge phase to end
        if (!getGame().getPhase().hasTurns()
                && (!getGame().getPhase().isLounge() || (getGame().getNoOfEntities() > 0))) {
            endCurrentPhase();
        }
    }

    /**
     * Called when the current player has done his current turn and the turn
     * counter needs to be advanced. Also enforces the "protos_move_multi" and
     * the "protos_move_multi" option. If the player has just moved
     * infantry/protos with a "normal" turn, adds up to
     * Game.INF_AND_PROTOS_MOVE_MULTI - 1 more infantry/proto-specific turns
     * after the current turn.
     */
    private void endCurrentTurn(Entity entityUsed) {
        // Enforce "inf_move_multi" and "protos_move_multi" options.
        // The "isNormalTurn" flag is checking to see if any non-Infantry
        // or non-ProtoMech units can move during the current turn.
        boolean turnsChanged = false;
        boolean outOfOrder = false;
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())
                && (entityUsed != null)
                && !turn.isValid(entityUsed.getOwnerId(), game)
                && !entityUsed.turnWasInterrupted()) {
            // turn played out of order
            outOfOrder = true;
            entityUsed.setDone(false);
            GameTurn removed = null;
            try {
                removed = game.removeFirstTurnFor(entityUsed);
            } catch (Exception e) {
                LogManager.getLogger().error("", e);
            }
            entityUsed.setDone(true);
            turnsChanged = true;
            if (removed != null) {
                turn = removed;
            }
        }
        final GamePhase currPhase = game.getPhase();
        final GameOptions gameOpts = game.getOptions();
        final int playerId = null == entityUsed ? Player.PLAYER_NONE : entityUsed.getOwnerId();
        boolean infMoved = entityUsed instanceof Infantry;
        boolean infMoveMulti = gameOpts.booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)
                && (currPhase.isMovement() || currPhase.isDeployment() || currPhase.isInitiative());
        boolean protosMoved = entityUsed instanceof Protomech;
        boolean protosMoveMulti = gameOpts.booleanOption(OptionsConstants.INIT_PROTOS_MOVE_MULTI);
        boolean tanksMoved = entityUsed instanceof Tank;
        boolean tanksMoveMulti = gameOpts.booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)
                && (currPhase.isMovement() || currPhase.isDeployment() || currPhase.isInitiative());
        boolean meksMoved = entityUsed instanceof Mech;
        boolean meksMoveMulti = gameOpts.booleanOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)
                && (currPhase.isMovement() || currPhase.isDeployment() || currPhase.isInitiative());

        // If infantry or protos move multi see if any
        // other unit types can move in the current turn.
        int multiMask = 0;
        if (infMoveMulti && infMoved) {
            multiMask = GameTurn.CLASS_INFANTRY;
        } else if (protosMoveMulti && protosMoved) {
            multiMask = GameTurn.CLASS_PROTOMECH;
        } else if (tanksMoveMulti && tanksMoved) {
            multiMask = GameTurn.CLASS_TANK;
        } else if (meksMoveMulti && meksMoved) {
            multiMask = GameTurn.CLASS_MECH;
        }

        // In certain cases, a new SpecificEntityTurn could have been added for
        // the Entity whose turn we are ending as the next turn. If this has
        // happened, the remaining entity count will be off and we must ensure
        // that the SpecificEntityTurn for this unit remains the next turn
        List<GameTurn> turnVector = game.getTurnVector();
        int turnIndex = game.getTurnIndex();
        boolean usedEntityNotDone = false;
        if ((turnIndex + 1) < turnVector.size()) {
            GameTurn nextTurn = turnVector.get(turnIndex + 1);
            if (nextTurn instanceof GameTurn.SpecificEntityTurn) {
                GameTurn.SpecificEntityTurn seTurn = (GameTurn.SpecificEntityTurn) nextTurn;
                if ((entityUsed != null) && (seTurn.getEntityNum() == entityUsed.getId())) {
                    turnIndex++;
                    usedEntityNotDone = true;
                }
            }
        }

        // Was the turn we just took added as part of a multi-turn?
        //  This determines if we should add more multi-turns
        boolean isMultiTurn = turn.isMultiTurn();

        // Unless overridden by the "protos_move_multi" option, all ProtoMechs
        // in a unit declare fire, and they don't mix with infantry.
        if (protosMoved && !protosMoveMulti && !isMultiTurn) {
            // What's the unit number and ID of the entity used?
            final short movingUnit = entityUsed.getUnitNumber();
            final int movingId = entityUsed.getId();

            // How many other ProtoMechs are in the unit that can fire?
            int protoTurns = game.getSelectedEntityCount(new EntitySelector() {
                private final int ownerId = playerId;

                private final int entityId = movingId;

                private final short unitNum = movingUnit;

                @Override
                public boolean accept(Entity entity) {
                    return (entity instanceof Protomech)
                            && entity.isSelectableThisTurn()
                            && (ownerId == entity.getOwnerId())
                            && (entityId != entity.getId())
                            && (unitNum == entity.getUnitNumber());
                }
            });

            // Add the correct number of turns for the ProtoMech unit number.
            for (int i = 0; i < protoTurns; i++) {
                GameTurn newTurn = new GameTurn.UnitNumberTurn(playerId, movingUnit);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }
        // Otherwise, we may need to add turns for the "*_move_multi" options.
        else if (((infMoved && infMoveMulti) || (protosMoved && protosMoveMulti)) && !isMultiTurn) {
            int remaining = 0;

            // Calculate the number of EntityClassTurns need to be added.
            if (infMoveMulti && infMoved) {
                remaining += getGame().getInfantryLeft(playerId);
            }

            if (protosMoveMulti && protosMoved) {
                remaining += getGame().getProtoMeksLeft(playerId);
            }

            if (usedEntityNotDone) {
                remaining--;
            }

            int moreInfAndProtoTurns = Math.min(
                    gameOpts.intOption(OptionsConstants.INIT_INF_PROTO_MOVE_MULTI) - 1, remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreInfAndProtoTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        if (tanksMoved && tanksMoveMulti && !isMultiTurn) {
            int remaining = game.getVehiclesLeft(playerId);
            if (usedEntityNotDone) {
                remaining--;
            }
            int moreVeeTurns = Math.min(
                    gameOpts.intOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT_NUMBER) - 1,
                    remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreVeeTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        if (meksMoved && meksMoveMulti && !isMultiTurn) {
            int remaining = game.getMechsLeft(playerId);
            if (usedEntityNotDone) {
                remaining--;
            }
            int moreMekTurns = Math.min(
                    gameOpts.intOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT_NUMBER) - 1,
                    remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreMekTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        // brief everybody on the turn update, if they changed
        if (turnsChanged) {
            send(createTurnVectorPacket());
        }

        // move along
        if (outOfOrder) {
            send(createTurnIndexPacket(playerId));
        } else {
            changeToNextTurn(playerId);
        }
    }

    /**
     * Changes the current phase, does some bookkeeping and then tells the
     * players.
     *
     * @param phase the <code>int</code> id of the phase to change to
     */
    private void changePhase(GamePhase phase) {
        game.setLastPhase(game.getPhase());
        game.setPhase(phase);

        // prepare for the phase
        prepareForPhase(phase);

        if (phase.isPlayable(getGame())) {
            // tell the players about the new phase
            send(new Packet(PacketCommand.PHASE_CHANGE, phase));

            // post phase change stuff
            executePhase(phase);
        } else {
            endCurrentPhase();
        }
    }

    /**
     * Prepares for, presumably, the next phase. This typically involves
     * resetting the states of entities in the game and making sure the client
     * has the information it needs for the new phase.
     *
     * @param phase the <code>int</code> id of the phase to prepare for
     */
    private void prepareForPhase(GamePhase phase) {
        switch (phase) {
            case LOUNGE:
                clearReports();
                MapSettings mapSettings = game.getMapSettings();
                mapSettings.setBoardsAvailableVector(ServerBoardHelper.scanForBoards(mapSettings));
                mapSettings.setNullBoards(DEFAULT_BOARD);
                send(createMapSettingsPacket());
                send(createMapSizesPacket());
                checkForObservers();
                transmitAllPlayerUpdates();
                break;
            case INITIATIVE:
                // remove the last traces of last round
                game.handleInitiativeCompensation();
                game.resetActions();
                game.resetTagInfo();
                sendTagInfoReset();
                clearReports();
                resetEntityRound();
                resetEntityPhase(phase);
                checkForObservers();
                transmitAllPlayerUpdates();

                // roll 'em
                resetActivePlayersDone();
                rollInitiative();
                //Cockpit command consoles that switched crew on the previous round are ineligible for force
                // commander initiative bonus. Now that initiative is rolled, clear the flag.
                game.getEntities().forEachRemaining(e -> e.getCrew().resetActedFlag());

                if (!game.shouldDeployThisRound()) {
                    incrementAndSendGameRound();
                }

                // setIneligible(phase);
                determineTurnOrder(phase);
                writeInitiativeReport(false);

                // checks for environmental survival
                checkForConditionDeath();

                checkForBlueShieldDamage();
                if (game.getBoard().inAtmosphere()) {
                    checkForAtmosphereDeath();
                }
                if (game.getBoard().inSpace()) {
                    checkForSpaceDeath();
                }

                LogManager.getLogger().info("Round " + game.getRoundCount() + " memory usage: " + MegaMek.getMemoryUsed());
                break;
            case DEPLOY_MINEFIELDS:
                checkForObservers();
                transmitAllPlayerUpdates();
                resetActivePlayersDone();
                setIneligible(phase);

                Enumeration<Player> e = game.getPlayers();
                Vector<GameTurn> turns = new Vector<>();
                while (e.hasMoreElements()) {
                    Player p = e.nextElement();
                    if (p.hasMinefields() && game.getBoard().onGround()) {
                        GameTurn gt = new GameTurn(p.getId());
                        turns.addElement(gt);
                    }
                }
                game.setTurnVector(turns);
                game.resetTurnIndex();

                // send turns to all players
                send(createTurnVectorPacket());
                break;
            case SET_ARTILLERY_AUTOHIT_HEXES:
                deployOffBoardEntities();
                checkForObservers();
                transmitAllPlayerUpdates();
                resetActivePlayersDone();
                setIneligible(phase);

                Enumeration<Player> players = game.getPlayers();
                Vector<GameTurn> turn = new Vector<>();

                // Walk through the players of the game, and add
                // a turn for all players with artillery weapons.
                while (players.hasMoreElements()) {
                    // Get the next player.
                    final Player p = players.nextElement();

                    // Does the player have any artillery-equipped units?
                    EntitySelector playerArtySelector = new EntitySelector() {
                        private Player owner = p;

                        @Override
                        public boolean accept(Entity entity) {
                            return owner.equals(entity.getOwner()) && entity.isEligibleForArtyAutoHitHexes();
                        }
                    };

                    if (game.getSelectedEntities(playerArtySelector).hasNext()) {
                        // Yes, the player has arty-equipped units.
                        GameTurn gt = new GameTurn(p.getId());
                        turn.addElement(gt);
                    }
                }
                game.setTurnVector(turn);
                game.resetTurnIndex();

                // send turns to all players
                send(createTurnVectorPacket());
                break;
            case PREMOVEMENT:
            case MOVEMENT:
            case DEPLOYMENT:
            case PREFIRING:
            case FIRING:
            case PHYSICAL:
            case TARGETING:
            case OFFBOARD:
                deployOffBoardEntities();

                // Check for activating hidden units
                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {
                    for (Entity ent : game.getEntitiesVector()) {
                        if (ent.getHiddenActivationPhase() == phase) {
                            ent.setHidden(false);
                        }
                    }
                }
                // Update visibility indications if using double blind.
                if (doBlind()) {
                    updateVisibilityIndicator(null);
                }
                resetEntityPhase(phase);
                checkForObservers();
                transmitAllPlayerUpdates();
                resetActivePlayersDone();
                setIneligible(phase);
                determineTurnOrder(phase);
                // send(createEntitiesPacket());
                entityAllUpdate();
                clearReports();
                doTryUnstuck();
                break;
            case END:
                resetEntityPhase(phase);
                clearReports();
                resolveHeat();
                if (game.getPlanetaryConditions().isSandBlowing()
                        && (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_LIGHT_GALE)) {
                    addReport(resolveBlowingSandDamage());
                }
                addReport(resolveControlRolls());
                addReport(checkForTraitors());
                // write End Phase header
                addReport(new Report(5005, Report.PUBLIC));
                checkLayExplosives();
                resolveHarJelRepairs();
                resolveEmergencyCoolantSystem();
                checkForSuffocation();
                game.getPlanetaryConditions().determineWind();
                send(createPlanetaryConditionsPacket());

                applyBuildingDamage();
                addReport(game.ageFlares());
                send(createFlarePacket());
                resolveAmmoDumps();
                resolveCrewWakeUp();
                resolveConsoleCrewSwaps();
                resolveSelfDestruct();
                resolveShutdownCrashes();
                checkForIndustrialEndOfTurn();
                resolveMechWarriorPickUp();
                resolveVeeINarcPodRemoval();
                resolveFortify();

                // Moved this to the very end because it makes it difficult to see
                // more important updates when you have 300+ messages of smoke filling
                // whatever hex. Please don't move it above the other things again.
                // Thanks! Ralgith - 2018/03/15
                hexUpdateSet.clear();
                for (DynamicTerrainProcessor tp : terrainProcessors) {
                    tp.doEndPhaseChanges(vPhaseReport);
                }
                sendChangedHexes(hexUpdateSet);

                checkForObservers();
                transmitAllPlayerUpdates();
                entityAllUpdate();
                break;
            case INITIATIVE_REPORT: {
                autoSave();
                // Show player BVs
                Enumeration<Player> players2 = game.getPlayers();
                while (players2.hasMoreElements()) {
                    Player player = players2.nextElement();
                    // Observers without initial entities get ignored
                    if (player.isObserver() && (player.getInitialEntityCount() == 0)) {
                        continue;
                    }
                    Report r = new Report(7016, Report.PUBLIC);
                    if (doBlind() && suppressBlindBV()) {
                        r.type = Report.PLAYER;
                        r.player = player.getId();
                    }
                    r.add(player.getColorForPlayer());
                    r.add(player.getBV());
                    r.add(player.getInitialBV());
                    r.add(Double.toString(Math.round(((double) player.getBV() / player.getInitialBV()) * 10000.0) / 100.0));
                    r.add(player.getFledBV());
                    r.add(player.getEntityCount());
                    r.add(player.getInitialEntityCount());
                    r.add(Double.toString(Math.round(((double) player.getEntityCount() / player.getInitialEntityCount()) * 10000.0) / 100.0));
                    addReport(r);
                }
            }
            case TARGETING_REPORT:
            case MOVEMENT_REPORT:
            case OFFBOARD_REPORT:
            case FIRING_REPORT:
            case PHYSICAL_REPORT:
            case END_REPORT:
                resetActivePlayersDone();
                sendReport();
                entityAllUpdate();
                if (game.getOptions().booleanOption(OptionsConstants.BASE_PARANOID_AUTOSAVE)) {
                    autoSave();
                }
                break;
            case VICTORY:
                resetPlayersDone();
                clearReports();
                prepareVictoryReport();
                game.addReports(vPhaseReport);
                // Before we send the full entities packet we need to loop
                // through the fighters in squadrons and damage them.
                for (Iterator<Entity> ents = game.getEntities(); ents.hasNext(); ) {
                    Entity entity = ents.next();
                    if ((entity.isFighter()) && !(entity instanceof FighterSquadron)) {
                        if (entity.isPartOfFighterSquadron() || entity.isCapitalFighter()) {
                            ((IAero) entity).doDisbandDamage();
                        }
                    }
                    // fix the armor and SI of aeros if using aero sanity rules for
                    // the MUL
                    if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)
                            && (entity instanceof Aero)) {
                        // need to rescale SI and armor
                        int scale = 1;
                        if (entity.isCapitalScale()) {
                            scale = 10;
                        }
                        Aero a = (Aero) entity;
                        int currentSI = a.getSI() / (2 * scale);
                        a.set0SI(a.get0SI() / (2 * scale));
                        if (currentSI > 0) {
                            a.setSI(currentSI);
                        }
                        //Fix for #587. MHQ tracks fighters at standard scale and doesn't (currently)
                        //track squadrons. Squadrons don't save to MUL either, so... only convert armor for JS/WS/SS?
                        //Do we ever need to save capital fighter armor to the final MUL or entityStatus?
                        if (!entity.hasETypeFlag(Entity.ETYPE_JUMPSHIP)) {
                            scale = 1;
                        }
                        if (scale > 1) {
                            for (int loc = 0; loc < entity.locations(); loc++) {
                                int currentArmor = entity.getArmor(loc) / scale;
                                if (entity.getOArmor(loc) > 0) {
                                    entity.initializeArmor(entity.getOArmor(loc) / scale, loc);
                                }
                                if (entity.getArmor(loc) > 0) {
                                    entity.setArmor(currentArmor, loc);
                                }
                            }
                        }
                    }
                }
                EmailService mailer = Server.getServerInstance().getEmailService();
                if (mailer != null) {
                    for (var player: mailer.getEmailablePlayers(game)) {
                        try {
                            var message = mailer.newReportMessage(
                                    game, vPhaseReport, player
                            );
                            mailer.send(message);
                        } catch (Exception ex) {
                            LogManager.getLogger().error("Error sending email" + ex);
                        }
                    }
                }
                send(createFullEntitiesPacket());
                send(createReportPacket(null));
                send(createEndOfGamePacket());
                break;
            default:
                break;
        }
    }

    /**
     * Do anything we seed to start the new phase, such as give a turn to the
     * first player to play.
     */
    private void executePhase(GamePhase phase) {
        switch (phase) {
            case EXCHANGE:
                resetPlayersDone();
                // Update initial BVs, as things may have been modified in lounge
                for (Entity e : game.getEntitiesVector()) {
                    e.setInitialBV(e.calculateBattleValue(false, false));
                }
                calculatePlayerInitialCounts();
                // Build teams vector
                game.setupTeams();
                applyBoardSettings();
                game.getPlanetaryConditions().determineWind();
                send(createPlanetaryConditionsPacket());
                // transmit the board to everybody
                send(createBoardPacket());
                game.setupRoundDeployment();
                game.setVictoryContext(new HashMap<>());
                game.createVictoryConditions();
                // some entities may need to be checked and updated
                checkEntityExchange();
                break;
            case MOVEMENT:
                // write Movement Phase header to report
                addReport(new Report(2000, Report.PUBLIC));
            case PREMOVEMENT:
            case SET_ARTILLERY_AUTOHIT_HEXES:
            case DEPLOY_MINEFIELDS:
            case DEPLOYMENT:
            case PREFIRING:
            case FIRING:
            case PHYSICAL:
            case TARGETING:
            case OFFBOARD:
                changeToNextTurn(-1);
                if (game.getOptions().booleanOption(OptionsConstants.BASE_PARANOID_AUTOSAVE)) {
                    autoSave();
                }
                break;
            default:
                break;
        }
    }

    /**
     * Calculates the initial count and BV for all players, and thus should only be called at the
     * start of a game
     */
    public void calculatePlayerInitialCounts() {
        for (final Enumeration<Player> players = game.getPlayers(); players.hasMoreElements(); ) {
            final Player player = players.nextElement();
            player.setInitialEntityCount(player.getEntityCount());
            player.setInitialBV(player.getBV());
        }
    }

    /**
     * loop through entities in the exchange phase (i.e. after leaving
     * chat lounge) and do any actions that need to be done
     */
    public void checkEntityExchange() {
        for (Iterator<Entity> entities = game.getEntities(); entities.hasNext(); ) {
            Entity entity = entities.next();
            // apply bombs
            if (entity.isBomber()) {
                ((IBomber) entity).applyBombs();
            }

            if (entity.isAero()) {
                IAero a = (IAero) entity;
                if (a.isSpaceborne()) {
                    // altitude and elevation don't matter in space
                    a.liftOff(0);
                } else {
                    // check for grounding
                    if (game.getBoard().inAtmosphere() && !entity.isAirborne()) {
                        // you have to be airborne on the atmospheric map
                        a.liftOff(entity.getAltitude());
                    }
                }

                if (entity.isFighter()) {
                    a.updateWeaponGroups();
                    entity.loadAllWeapons();
                }
            }

            // if units were loaded in the chat lounge, I need to keep track of
            // it here because they can get dumped in the deployment phase
            if (!entity.getLoadedUnits().isEmpty()) {
                Vector<Integer> v = new Vector<>();
                for (Entity en : entity.getLoadedUnits()) {
                    v.add(en.getId());
                }
                entity.setLoadedKeepers(v);
            }

            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)
                    && (entity.isAero())) {
                Aero a = null;
                if (entity instanceof Aero) {
                    a = (Aero) entity;
                }
                if (entity.isCapitalScale()) {
                    if (a != null) {
                        int currentSI = a.getSI() * 20;
                        a.initializeSI(a.get0SI() * 20);
                        a.setSI(currentSI);
                    }
                    if (entity.isCapitalFighter()) {
                        ((IAero) entity).autoSetCapArmor();
                        ((IAero) entity).autoSetFatalThresh();
                    } else {
                        // all armor and SI is going to be at standard scale, so
                        // we need to adjust
                        for (int loc = 0; loc < entity.locations(); loc++) {
                            if (entity.getArmor(loc) > 0) {
                                int currentArmor = entity.getArmor(loc) * 10;
                                entity.initializeArmor(entity.getOArmor(loc) * 10, loc);
                                entity.setArmor(currentArmor, loc);

                            }
                        }
                    }
                } else if (a != null) {
                    int currentSI = a.getSI() * 2;
                    a.initializeSI(a.get0SI() * 2);
                    a.setSI(currentSI);
                }
            }
            if (entity.getsAutoExternalSearchlight()) {
                entity.setExternalSearchlight(true);
            }
            entityUpdate(entity.getId());

            // Remove hot-loading some from LRMs for meks
            if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_HOTLOAD_IN_GAME)) {
                for (Entity e : game.getEntitiesVector()) {
                    // Vehicles are allowed to hot load, just meks cannot
                    if (!(e instanceof Mech)) {
                        continue;
                    }
                    for (Mounted weapon : e.getWeaponList()) {
                        weapon.getType().removeMode("HotLoad");
                    }
                    for (Mounted ammo : e.getAmmo()) {
                        ammo.getType().removeMode("HotLoad");
                    }
                }
            }
        }
    }

    /**
     * Ends this phase and moves on to the next.
     */
    private void endCurrentPhase() {
        switch (game.getPhase()) {
            case LOUNGE:
                game.addReports(vPhaseReport);
                changePhase(GamePhase.EXCHANGE);
                break;
            case EXCHANGE:
            case STARTING_SCENARIO:
                game.addReports(vPhaseReport);
                changePhase(GamePhase.SET_ARTILLERY_AUTOHIT_HEXES);
                break;
            case SET_ARTILLERY_AUTOHIT_HEXES:
                sendSpecialHexDisplayPackets();
                Enumeration<Player> e = game.getPlayers();
                boolean mines = false;
                while (e.hasMoreElements() && !mines) {
                    Player p = e.nextElement();
                    if (p.hasMinefields()) {
                        mines = true;
                    }
                }
                game.addReports(vPhaseReport);
                if (mines) {
                    changePhase(GamePhase.DEPLOY_MINEFIELDS);
                } else {
                    changePhase(GamePhase.INITIATIVE);
                }
                break;
            case DEPLOY_MINEFIELDS:
                changePhase(GamePhase.INITIATIVE);
                break;
            case DEPLOYMENT:
                game.clearDeploymentThisRound();
                game.checkForCompleteDeployment();
                Enumeration<Player> pls = game.getPlayers();
                while (pls.hasMoreElements()) {
                    Player p = pls.nextElement();
                    p.adjustStartingPosForReinforcements();
                }

                if (game.getRoundCount() < 1) {
                    changePhase(GamePhase.INITIATIVE);
                } else {
                    changePhase(GamePhase.TARGETING);
                }
                break;
            case INITIATIVE:
                resolveWhatPlayersCanSeeWhatUnits();
                detectSpacecraft();
                game.addReports(vPhaseReport);
                changePhase(GamePhase.INITIATIVE_REPORT);
                break;
            case INITIATIVE_REPORT:
                // NOTE: now that aeros can come and go from the battlefield, I
                // need
                // to update the
                // deployment table every round. I think this it is OK to go
                // here.
                // (Taharqa)
                game.setupRoundDeployment();
                // boolean doDeploy = game.shouldDeployThisRound() &&
                // (game.getLastPhase() != Game.Phase.DEPLOYMENT);
                if (game.shouldDeployThisRound()) {
                    changePhase(GamePhase.DEPLOYMENT);
                } else {
                    changePhase(GamePhase.TARGETING);
                }
                break;
            case PREMOVEMENT:
                changePhase(GamePhase.MOVEMENT);
                break;
            case MOVEMENT:
                detectHiddenUnits();
                ServerHelper.detectMinefields(game, vPhaseReport, this);
                updateSpacecraftDetection();
                detectSpacecraft();
                resolveWhatPlayersCanSeeWhatUnits();
                doAllAssaultDrops();
                addMovementHeat();
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls()); // Skids cause damage in
                // movement phase
                checkForFlamingDamage();
                checkForTeleMissileAttacks();
                cleanupDestroyedNarcPods();
                checkForFlawedCooling();
                resolveCallSupport();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.MOVEMENT_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(GamePhase.OFFBOARD);
                }
                break;
            case MOVEMENT_REPORT:
                changePhase(GamePhase.OFFBOARD);
                break;
            case PREFIRING:
                changePhase(GamePhase.FIRING);
                break;
            case FIRING:
                // write Weapon Attack Phase header
                addReport(new Report(3000, Report.PUBLIC));
                resolveWhatPlayersCanSeeWhatUnits();
                resolveAllButWeaponAttacks();
                resolveSelfDestructions();
                reportGhostTargetRolls();
                reportLargeCraftECCMRolls();
                resolveOnlyWeaponAttacks();
                assignAMS();
                handleAttacks();
                resolveScheduledNukes();
                applyBuildingDamage();
                checkForPSRFromDamage();
                cleanupDestroyedNarcPods();
                addReport(resolvePilotingRolls());
                checkForFlawedCooling();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.FIRING_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    sendReport();
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.PHYSICAL);
                }
                break;
            case FIRING_REPORT:
                changePhase(GamePhase.PHYSICAL);
                break;
            case PHYSICAL:
                resolveWhatPlayersCanSeeWhatUnits();
                resolvePhysicalAttacks();
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls());
                resolveSinkVees();
                cleanupDestroyedNarcPods();
                checkForFlawedCooling();
                checkForChainWhipGrappleChecks();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.PHYSICAL_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(GamePhase.END);
                }
                break;
            case PHYSICAL_REPORT:
                changePhase(GamePhase.END);
                break;
            case TARGETING:
                vPhaseReport.addElement(new Report(1035, Report.PUBLIC));
                resolveAllButWeaponAttacks();
                resolveOnlyWeaponAttacks();
                handleAttacks();
                // check reports
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.TARGETING_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    vPhaseReport.addElement(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(GamePhase.PREMOVEMENT);
                }

                sendSpecialHexDisplayPackets();
                for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
                    Player player = i.nextElement();
                    int connId = player.getId();
                    send(connId, createArtilleryPacket(player));
                }

                break;
            case OFFBOARD:
                // write Offboard Attack Phase header
                addReport(new Report(1100, Report.PUBLIC));
                resolveAllButWeaponAttacks(); // torso twist or flip arms
                // possible
                resolveOnlyWeaponAttacks(); // should only be TAG at this point
                handleAttacks();
                for (Enumeration<Player> i = game.getPlayers(); i.hasMoreElements(); ) {
                    Player player = i.nextElement();
                    int connId = player.getId();
                    send(connId, createArtilleryPacket(player));
                }
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls());

                cleanupDestroyedNarcPods();
                checkForFlawedCooling();

                sendSpecialHexDisplayPackets();
                sendTagInfoUpdates();

                // check reports
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.OFFBOARD_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(GamePhase.PREFIRING);
                }
                break;
            case OFFBOARD_REPORT:
                sendSpecialHexDisplayPackets();
                changePhase(GamePhase.PREFIRING);
                break;
            case TARGETING_REPORT:
                changePhase(GamePhase.PREMOVEMENT);
                break;
            case END:
                // remove any entities that died in the heat/end phase before
                // checking for victory
                resetEntityPhase(GamePhase.END);
                boolean victory = victory(); // note this may add reports
                // check phase report
                // HACK: hardcoded message ID check
                if ((vPhaseReport.size() > 3) || ((vPhaseReport.size() > 1)
                        && (vPhaseReport.elementAt(1).messageId != 1205))) {
                    game.addReports(vPhaseReport);
                    changePhase(GamePhase.END_REPORT);
                } else {
                    // just the heat and end headers, so we'll add
                    // the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    if (victory) {
                        changePhase(GamePhase.VICTORY);
                    } else {
                        changePhase(GamePhase.INITIATIVE);
                    }
                }
                // Decrement the ASEWAffected counter
                decrementASEWTurns();

                break;
            case END_REPORT:
                if (changePlayersTeam) {
                    processTeamChangeRequest();
                }
                if (victory()) {
                    changePhase(GamePhase.VICTORY);
                } else {
                    changePhase(GamePhase.INITIATIVE);
                }
                break;
            case VICTORY:
                GameVictoryEvent gve = new GameVictoryEvent(this, game);
                game.processGameEvent(gve);
                transmitGameVictoryEventToAll();
                resetGame();
                break;
            default:
                break;
        }

        // Any hidden units that activated this phase, should clear their
        // activating phase
        for (Entity ent : game.getEntitiesVector()) {
            if (ent.getHiddenActivationPhase() == game.getPhase()) {
                ent.setHiddenActivationPhase(GamePhase.UNKNOWN);
            }
        }
    }

    private void sendSpecialHexDisplayPackets() {
        for (Player player : game.getPlayersVector()) {
            send(createSpecialHexDisplayPacket(player.getId()));
        }
    }

    private void sendTagInfoUpdates() {
        send(new Packet(PacketCommand.SENDING_TAG_INFO, getGame().getTagInfo()));
    }

    public void sendTagInfoReset() {
        send(new Packet(PacketCommand.RESET_TAG_INFO));
    }

    /**
     * Increment's the server's game round and send it to all the clients
     */
    private void incrementAndSendGameRound() {
        game.incrementRoundCount();
        send(new Packet(PacketCommand.ROUND_UPDATE, getGame().getRoundCount()));
    }

    /**
     * Hand over a turn to the next player. This is only possible if you haven't
     * yet started your turn (i.e. not yet moved anything like infantry where
     * you have to move multiple units)
     *
     * @param connectionId - connection id of the player sending the packet
     */
    private void receiveForwardIni(int connectionId) {
        // this is the player sending the packet
        Player current = game.getPlayer(connectionId);

        if (game.getTurn().getPlayerNum() != current.getId()) {
            // this player is not the current player, so just ignore this
            // command!
            return;
        }
        // if individual initiative is active we cannot forward our initiative
        // ever!
        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {
            return;
        }

        // if the player isn't on a team, there is no next team by definition. Skip the rest.
        Team currentPlayerTeam = game.getTeamForPlayer(current);
        if (currentPlayerTeam == null) {
            return;
        }

        // get the next player from the team this player is on.
        Player next = currentPlayerTeam.getNextValidPlayer(current, game);

        while (!next.equals(current)) {
            // if the chosen player is a valid player, we change the turn order and
            // inform the clients.
            if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)
                    && (game.getTurnForPlayer(next.getId()) != null)) {

                int currentTurnIndex = game.getTurnIndex();
                // now look for the next occurrence of player next in the turn order
                List<GameTurn> turns = game.getTurnVector();
                GameTurn turn = game.getTurn();
                // not entirely necessary. As we will also check this for the
                // activity of the button but to be sure do it on the server too.
                boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)
                        && !(turn instanceof GameTurn.UnitNumberTurn)
                        && !(turn instanceof GameTurn.UnloadStrandedTurn);
                if (!isGeneralMoveTurn) {
                    // if this is not a general turn the player cannot forward his turn.
                    return;
                }

                // if it is an EntityClassTurn we have to check make sure, that the
                // turn it is exchanged with is the same kind of turn!
                // in fact this requires an access function to the mask of an
                // EntityClassTurn.
                boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);
                int classMask = 0;
                if (isEntityClassTurn) {
                    classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();
                }

                boolean switched = false;
                int nextTurnId = 0;
                for (int i = currentTurnIndex; i < turns.size(); i++) {
                    // if we find a turn for the specific player, swap the current
                    // player with the player noted there
                    // and stop
                    if (turns.get(i).isValid(next.getId(), game)) {
                        nextTurnId = i;
                        if (isEntityClassTurn) {
                            // if we had an EntityClassTurn
                            if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {
                                // and found another EntityClassTurn
                                if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {
                                    // both have to refer to the SAME class(es) or
                                    // they need to be rejected.
                                    continue;
                                }
                            } else {
                                continue;
                            }
                        }
                        switched = true;
                        break;
                    }
                }

                // update turn order
                if (switched) {
                    game.swapTurnOrder(currentTurnIndex, nextTurnId);
                    // update the turn packages for all players.
                    send(createTurnVectorPacket());
                    send(createTurnIndexPacket(connectionId));
                    return;
                }
                // if nothing changed return without doing anything
            }

            next = currentPlayerTeam.getNextValidPlayer(next, game);
        }
    }

    /**
     * Tries to change to the next turn. If there are no more turns, ends the
     * current phase. If the player whose turn it is next is not connected, we
     * allow the other players to skip that player.
     */
    private void changeToNextTurn(int prevPlayerId) {
        boolean minefieldPhase = game.getPhase().isDeployMinefields();
        boolean artyPhase = game.getPhase().isSetArtilleryAutohitHexes();

        GameTurn nextTurn = null;
        Entity nextEntity = null;
        while (game.hasMoreTurns() && (null == nextEntity)) {
            nextTurn = game.changeToNextTurn();
            nextEntity = game.getEntity(game.getFirstEntityNum(nextTurn));
            if (minefieldPhase || artyPhase) {
                break;
            }
        }

        // if there aren't any more valid turns, end the phase
        // note that some phases don't use entities
        if (((null == nextEntity) && !minefieldPhase) || ((null == nextTurn) && minefieldPhase)) {
            endCurrentPhase();
            return;
        }

        Player player = game.getPlayer(nextTurn.getPlayerNum());

        if ((player != null) && (game.getEntitiesOwnedBy(player) == 0)) {
            endCurrentTurn(null);
            return;
        }

        if (prevPlayerId != -1) {
            send(createTurnIndexPacket(prevPlayerId));
        } else {
            send(createTurnIndexPacket(player != null ? player.getId() : Player.PLAYER_NONE));
        }

        if ((null != player) && player.isGhost()) {
            sendGhostSkipMessage(player);
        } else if ((null == game.getFirstEntity()) && (null != player) && !minefieldPhase && !artyPhase) {
            sendTurnErrorSkipMessage(player);
        }
    }

    /**
     * Sends out a notification message indicating that a ghost player may be
     * skipped.
     *
     * @param ghost - the <code>Player</code> who is ghosted. This value must not
     *              be <code>null</code>.
     */
    private void sendGhostSkipMessage(Player ghost) {
        String message = "Player '" + ghost.getName() +
                "' is disconnected.  You may skip his/her current turn with the /skip command.";
        sendServerChat(message);
    }

    /**
     * Sends out a notification message indicating that the current turn is an
     * error and should be skipped.
     *
     * @param skip - the <code>Player</code> who is to be skipped. This value
     *             must not be <code>null</code>.
     */
    private void sendTurnErrorSkipMessage(Player skip) {
        String message = "Player '" + skip.getName() +
                "' has no units to move.  You should skip his/her/your current turn with the /skip command. " +
                "You may want to report this error at https://github.com/MegaMek/megamek/issues";
        sendServerChat(message);
    }

    /**
     * Skips the current turn. This only makes sense in phases that have turns.
     * Operates by finding an entity to move and then doing nothing with it.
     */
    public void skipCurrentTurn() {
        // find an entity to skip...
        Entity toSkip = game.getFirstEntity();

        switch (game.getPhase()) {
            case DEPLOYMENT:
                // allow skipping during deployment,
                // we need that when someone removes a unit.
                endCurrentTurn(null);
                break;
            case MOVEMENT:
                if (toSkip != null) {
                    processMovement(toSkip, new MovePath(game, toSkip), null);
                }
                endCurrentTurn(toSkip);
                break;
            case FIRING:
            case PHYSICAL:
            case TARGETING:
            case OFFBOARD:
                if (toSkip != null) {
                    processAttack(toSkip, new Vector<>(0));
                }
                endCurrentTurn(toSkip);
                break;
            case PREMOVEMENT:
            case PREFIRING:
                endCurrentTurn(toSkip);
            default:
                break;
        }
    }

    /**
     * Returns true if the current turn may be skipped. Ghost players' turns are
     * skippable, and a turn should be skipped if there's nothing to move.
     */
    public boolean isTurnSkippable() {
        GameTurn turn = game.getTurn();
        if (null == turn) {
            return false;
        }
        Player player = game.getPlayer(turn.getPlayerNum());
        return (null == player) || player.isGhost() || (game.getFirstEntity() == null);
    }

    /**
     * Returns true if victory conditions have been met. Victory conditions are
     * when there is only one player left with mechs or only one team. will also
     * add some reports to reporting
     */
    public boolean victory() {
        VictoryResult vr = game.getVictoryResult();
        for (Report r : vr.processVictory(game)) {
            addReport(r);
        }
        return vr.victory();
    }// end victory

    private boolean isPlayerForcedVictory() {
        // check game options
        if (!game.getOptions().booleanOption(OptionsConstants.VICTORY_SKIP_FORCED_VICTORY)) {
            return false;
        }

        if (!game.isForceVictory()) {
            return false;
        }

        for (Player player : game.getPlayersVector()) {
            if ((player.getId() == game.getVictoryPlayerId()) || ((player.getTeam() == game.getVictoryTeam())
                    && (game.getVictoryTeam() != Player.TEAM_NONE))) {
                continue;
            }

            if (!player.admitsDefeat()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Applies board settings. This loads and combines all the boards that were
     * specified into one mega-board and sets that board as current.
     */
    public void applyBoardSettings() {
        MapSettings mapSettings = game.getMapSettings();
        mapSettings.chooseSurpriseBoards();
        Board[] sheetBoards = new Board[mapSettings.getMapWidth() * mapSettings.getMapHeight()];
        List<Boolean> rotateBoard = new ArrayList<>();
        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {
            sheetBoards[i] = new Board();
            String name = mapSettings.getBoardsSelectedVector().get(i);
            boolean isRotated = false;
            if (name.startsWith(Board.BOARD_REQUEST_ROTATION)) {
                // only rotate boards with an even width
                if ((mapSettings.getBoardWidth() % 2) == 0) {
                    isRotated = true;
                }
                name = name.substring(Board.BOARD_REQUEST_ROTATION.length());
            }
            if (name.startsWith(MapSettings.BOARD_GENERATED)
                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {
                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);
            } else {
                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + ".board").getFile());
                BoardUtilities.flip(sheetBoards[i], isRotated, isRotated);
            }
            rotateBoard.add(isRotated);
        }
        Board newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(),
                mapSettings.getBoardHeight(), mapSettings.getMapWidth(),
                mapSettings.getMapHeight(), sheetBoards, rotateBoard,
                mapSettings.getMedium());
        if (game.getOptions().getOption(OptionsConstants.BASE_BRIDGECF).intValue() > 0) {
            newBoard.setBridgeCF(game.getOptions().getOption(OptionsConstants.BASE_BRIDGECF).intValue());
        }
        if (!game.getOptions().booleanOption(OptionsConstants.BASE_RANDOM_BASEMENTS)) {
            newBoard.setRandomBasementsOff();
        }
        if (game.getPlanetaryConditions().isTerrainAffected()) {
            BoardUtilities.addWeatherConditions(newBoard, game.getPlanetaryConditions().getWeather(),
                    game.getPlanetaryConditions().getWindStrength());
        }
        game.setBoard(newBoard);
    }

    /**
     * Rolls initiative for all the players.
     */
    private void rollInitiative() {
        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {
            TurnOrdered.rollInitiative(game.getEntitiesVector(), false);
        } else {
            // Roll for initiative on the teams.
            TurnOrdered.rollInitiative(game.getTeams(),
                    game.getOptions().booleanOption(OptionsConstants.INIT_INITIATIVE_STREAK_COMPENSATION)
                            && !game.shouldDeployThisRound());
        }

        transmitAllPlayerUpdates();
    }

    private Vector<GameTurn> initGameTurnsWithStranded(TurnVectors team_order) {
        Vector<GameTurn> turns = new Vector<>(team_order.getTotalTurns()
                + team_order.getEvenTurns());

        // Stranded units only during movement phases, rebuild the turns vector
        // TODO maybe move this to Premovemnt?
        if (game.getPhase().isMovement()) {
            // See if there are any loaded units stranded on immobile transports.
            Iterator<Entity> strandedUnits = game.getSelectedEntities(
                    entity -> game.isEntityStranded(entity));
            if (strandedUnits.hasNext()) {
                // Add a game turn to unload stranded units, if this
                // is the movement phase.
                turns = new Vector<>(team_order.getTotalTurns()
                        + team_order.getEvenTurns() + 1);
                turns.addElement(new GameTurn.UnloadStrandedTurn(strandedUnits));
            }
        }
        return turns;
    }

    /**
     * Determines the turn oder for a given phase (with individual init)
     *
     * @param phase the <code>int</code> id of the phase
     */
    private void determineTurnOrderIUI(GamePhase phase) {
        for (Iterator<Entity> loop = game.getEntities(); loop.hasNext();) {
            final Entity entity = loop.next();
            entity.resetOtherTurns();
            if (entity.isSelectableThisTurn()) {
                entity.incrementOtherTurns();
            }
        }

        List<Entity> entities;
        // If the protos move multi option isn't on, protos move as a unit
        // Need to adjust entities vector otherwise we'll have too many turns
        // when first proto in a unit moves, new turns get added so rest of the
        // unit will move
        boolean protosMoveMulti = game.getOptions().booleanOption(
                OptionsConstants.INIT_PROTOS_MOVE_MULTI);
        if (!protosMoveMulti) {
            entities = new ArrayList<>(game.getEntitiesVector().size());
            Set<Short> movedUnits = new HashSet<>();
            for (Entity e : game.getEntitiesVector()) {
                // This only effects Protos for the time being
                if (!(e instanceof Protomech)) {
                    entities.add(e);
                    continue;
                }
                short unitNumber = e.getUnitNumber();
                if ((unitNumber == Entity.NONE)
                        || !movedUnits.contains(unitNumber)) {
                    entities.add(e);
                    if (unitNumber != Entity.NONE) {
                        movedUnits.add(unitNumber);
                    }
                }
            }
        } else {
            entities = game.getEntitiesVector();
        }
        // Now, generate the global order of all teams' turns.
        TurnVectors team_order = TurnOrdered.generateTurnOrder(entities, game);

        // Now, we collect everything into a single vector.
        Vector<GameTurn> turns = initGameTurnsWithStranded(team_order);

        // add the turns (this is easy)
        while (team_order.hasMoreElements()) {
            Entity e = (Entity) team_order.nextElement();
            if (e.isSelectableThisTurn()) {
                if (!protosMoveMulti && (e instanceof Protomech) && (e.getUnitNumber() != Entity.NONE)) {
                    turns.addElement(new GameTurn.UnitNumberTurn(e.getOwnerId(), e.getUnitNumber()));
                } else {
                    turns.addElement(new GameTurn.SpecificEntityTurn(e.getOwnerId(), e.getId()));
                }
            }
        }

        // set fields in game
        game.setTurnVector(turns);
        game.resetTurnIndex();

        // send turns to all players
        send(createTurnVectorPacket());
    }

    /**
     * Determines the turn order for a given phase
     *
     * @param phase the <code>int</code> id of the phase
     */
    private void determineTurnOrder(GamePhase phase) {
        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {
            determineTurnOrderIUI(phase);
            return;
        }
        // and/or deploy even according to game options.
        boolean infMoveEven = (game.getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_EVEN)
                && (game.getPhase().isInitiative() || game.getPhase().isMovement()))
                || (game.getOptions().booleanOption(OptionsConstants.INIT_INF_DEPLOY_EVEN)
                        && game.getPhase().isDeployment());
        boolean infMoveMulti = game.getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)
                && (game.getPhase().isInitiative() || game.getPhase().isMovement()
                        || game.getPhase().isDeployment());
        boolean protosMoveEven = (game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_EVEN)
                && (game.getPhase().isInitiative() || game.getPhase().isMovement()
                        || game.getPhase().isDeployment()))
                || (game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_EVEN)
                        && game.getPhase().isDeployment());
        boolean protosMoveMulti = game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_MULTI);
        boolean protosMoveByPoint = !protosMoveMulti;
        boolean tankMoveByLance = game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)
                && (game.getPhase().isInitiative() || game.getPhase().isMovement()
                        || game.getPhase().isDeployment());
        boolean mekMoveByLance = game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)
                && (game.getPhase().isInitiative() || game.getPhase().isMovement()
                        || game.getPhase().isDeployment());

        int evenMask = 0;
        if (infMoveEven) {
            evenMask += GameTurn.CLASS_INFANTRY;
        }

        if (protosMoveEven) {
            evenMask += GameTurn.CLASS_PROTOMECH;
        }
        // Reset all of the Players' turn category counts
        for (Enumeration<Player> loop = game.getPlayers(); loop.hasMoreElements(); ) {
            final Player player = loop.nextElement();
            player.resetEvenTurns();
            player.resetMultiTurns();
            player.resetOtherTurns();
            player.resetSpaceStationTurns();
            player.resetJumpshipTurns();
            player.resetWarshipTurns();
            player.resetDropshipTurns();
            player.resetSmallCraftTurns();
            player.resetAeroTurns();

            // Add turns for ProtoMechs weapons declaration.
            if (protosMoveByPoint) {

                // How many ProtoMechs does the player have?
                Iterator<Entity> playerProtos = game.getSelectedEntities(new EntitySelector() {
                    private final int ownerId = player.getId();

                    @Override
                    public boolean accept(Entity entity) {
                        return (entity instanceof Protomech)
                                && (ownerId == entity.getOwnerId())
                                && entity.isSelectableThisTurn();
                    }
                });
                HashSet<Integer> points = new HashSet<>();
                int numPlayerProtos = 0;
                for (; playerProtos.hasNext(); ) {
                    Entity proto = playerProtos.next();
                    numPlayerProtos++;
                    points.add((int) proto.getUnitNumber());
                }
                int numProtoUnits = (int) Math.ceil(numPlayerProtos / 5.0);
                if (!protosMoveEven) {
                    numProtoUnits = points.size();
                }
                for (int unit = 0; unit < numProtoUnits; unit++) {
                    if (protosMoveEven) {
                        player.incrementEvenTurns();
                    } else {
                        player.incrementOtherTurns();
                    }
                }

            } // End handle-proto-firing-turns

        } // Handle the next player

        // Go through all entities, and update the turn categories of the
        // entity's player. The teams get their totals from their players.
        // N.B. ProtoMechs declare weapons fire based on their point.
        for (Iterator<Entity> loop = game.getEntities(); loop.hasNext();) {
            final Entity entity = loop.next();
            if (entity.isSelectableThisTurn()) {
                final Player player = entity.getOwner();
                if ((entity instanceof SpaceStation)
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementSpaceStationTurns();
                } else if ((entity instanceof Warship)
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementWarshipTurns();
                } else if ((entity instanceof Jumpship)
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementJumpshipTurns();
                } else if ((entity instanceof Dropship) && entity.isAirborne()
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementDropshipTurns();
                } else if ((entity instanceof SmallCraft) && entity.isAirborne()
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementSmallCraftTurns();
                } else if (entity.isAirborne()
                        && (game.getPhase().isMovement() || game.getPhase().isDeployment())) {
                    player.incrementAeroTurns();
                } else if ((entity instanceof Infantry)) {
                    if (infMoveEven) {
                        player.incrementEvenTurns();
                    } else if (infMoveMulti) {
                        player.incrementMultiTurns(GameTurn.CLASS_INFANTRY);
                    } else {
                        player.incrementOtherTurns();
                    }
                } else if (entity instanceof Protomech) {
                    if (!protosMoveByPoint) {
                        if (protosMoveEven) {
                            player.incrementEvenTurns();
                        } else if (protosMoveMulti) {
                            player.incrementMultiTurns(GameTurn.CLASS_PROTOMECH);
                        } else {
                            player.incrementOtherTurns();
                        }
                    }
                } else if ((entity instanceof Tank) && tankMoveByLance) {
                    player.incrementMultiTurns(GameTurn.CLASS_TANK);
                } else if ((entity instanceof Mech) && mekMoveByLance) {
                    player.incrementMultiTurns(GameTurn.CLASS_MECH);
                } else {
                    player.incrementOtherTurns();
                }
            }
        }

        // Generate the turn order for the Players *within*
        // each Team. Map the teams to their turn orders.
        // Count the number of teams moving this turn.
        int nTeams = game.getNoOfTeams();
        Hashtable<Team, TurnVectors> allTeamTurns = new Hashtable<>(nTeams);
        Hashtable<Team, int[]> evenTrackers = new Hashtable<>(nTeams);
        int numTeamsMoving = 0;
        for (Team team : game.getTeams()) {
            allTeamTurns.put(team, team.determineTeamOrder(game));

            // Track both the number of times we've checked the team for
            // "leftover" turns, and the number of "leftover" turns placed.
            int[] evenTracker = new int[2];
            evenTrackers.put(team, evenTracker);

            // Count this team if it has any "normal" moves.
            if (team.getNormalTurns(game) > 0) {
                numTeamsMoving++;
            }
        }

        // Now, generate the global order of all teams' turns.
        TurnVectors team_order = TurnOrdered.generateTurnOrder(game.getTeams(), game);

        // Now, we collect everything into a single vector.
        Vector<GameTurn> turns = initGameTurnsWithStranded(team_order);

        // Walk through the global order, assigning turns
        // for individual players to the single vector.
        // Keep track of how many turns we've added to the vector.
        Team prevTeam = null;
        int min = team_order.getMin();
        for (int numTurn = 0; team_order.hasMoreElements(); numTurn++) {
            Team team = (Team) team_order.nextElement();
            TurnVectors withinTeamTurns = allTeamTurns.get(team);

            int[] evenTracker = evenTrackers.get(team);
            float teamEvenTurns = team.getEvenTurns();

            // Calculate the number of "even" turns to add for this team.
            int numEven = 0;
            if (1 == numTeamsMoving) {
                // If there's only one team moving, we don't need to bother
                // with the evenTracker, just make sure the even turns are
                // evenly distributed
                numEven += (int) Math.round(teamEvenTurns / min);
            } else if (prevTeam == null) {
                // Increment the number of times we've checked for "leftovers".
                evenTracker[0]++;

                // The first team to move just adds the "baseline" turns.
                numEven += Math.round(teamEvenTurns / min);
            } else if (!team.equals(prevTeam)) {
                // Increment the number of times we've checked for "leftovers".
                evenTracker[0]++;

                // This weird equation attempts to spread the "leftover"
                // turns across the turn's moves in a "fair" manner.
                // It's based on the number of times we've checked for
                // "leftovers" the number of "leftovers" we started with,
                // the number of times we've added a turn for a "leftover",
                // and the total number of times we're going to check.
                numEven += (int) Math.ceil(((evenTracker[0] * (teamEvenTurns % min)) / min) - 0.5)
                        - evenTracker[1];

                // Update the number of turns actually added for "leftovers".
                evenTracker[1] += numEven;

                // Add the "baseline" number of turns.
                numEven += Math.round(teamEvenTurns / min);
            }

            // Record this team for the next move.
            prevTeam = team;

            int aeroMask = GameTurn.CLASS_AERO + GameTurn.CLASS_SMALL_CRAFT
                    + GameTurn.CLASS_DROPSHIP + GameTurn.CLASS_JUMPSHIP
                    + GameTurn.CLASS_WARSHIP + GameTurn.CLASS_SPACE_STATION;
            GameTurn turn;
            Player player;
            if (withinTeamTurns.hasMoreNormalElements()) {
                // Not a placeholder... get the player who moves next.
                player = (Player) withinTeamTurns.nextNormalElement();

                // If we've added all "normal" turns, allocate turns
                // for the infantry and/or ProtoMechs moving even.
                if (numTurn >= team_order.getTotalTurns()) {
                    turn = new GameTurn.EntityClassTurn(player.getId(), evenMask);
                }
                // If either Infantry or ProtoMechs move even, only allow
                // the other classes to move during the "normal" turn.
                else if (infMoveEven || protosMoveEven) {
                    int newMask = evenMask;
                    // if this is the movement phase, then don't allow Aeros on normal turns
                    if (getGame().getPhase().isMovement() || getGame().getPhase().isDeployment()) {
                        newMask += aeroMask;
                    }
                    turn = new GameTurn.EntityClassTurn(player.getId(), ~newMask);
                } else {
                    // Otherwise, let anyone move... well, almost anybody; Aero don't get normal
                    // turns during the movement phase
                    if (getGame().getPhase().isMovement() || getGame().getPhase().isDeployment()) {
                        turn = new GameTurn.EntityClassTurn(player.getId(), ~aeroMask);
                    } else {
                        turn = new GameTurn(player.getId());
                    }
                }
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreSpaceStationElements()) {
                player = (Player) withinTeamTurns.nextSpaceStationElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_SPACE_STATION);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreJumpshipElements()) {
                player = (Player) withinTeamTurns.nextJumpshipElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_JUMPSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreWarshipElements()) {
                player = (Player) withinTeamTurns.nextWarshipElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_WARSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreDropshipElements()) {
                player = (Player) withinTeamTurns.nextDropshipElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_DROPSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreSmallCraftElements()) {
                player = (Player) withinTeamTurns.nextSmallCraftElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_SMALL_CRAFT);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreAeroElements()) {
                player = (Player) withinTeamTurns.nextAeroElement();
                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_AERO);
                turns.addElement(turn);
            }

            // Add the calculated number of "even" turns.
            // Allow the player at least one "normal" turn before the
            // "even" turns to help with loading infantry in deployment.
            while ((numEven > 0) && withinTeamTurns.hasMoreEvenElements()) {
                Player evenPlayer = (Player) withinTeamTurns.nextEvenElement();
                turns.addElement(new GameTurn.EntityClassTurn(evenPlayer.getId(), evenMask));
                numEven--;
            }
        }

        // set fields in game
        game.setTurnVector(turns);
        game.resetTurnIndex();

        // send turns to all players
        send(createTurnVectorPacket());
    }

    /**
     * Write the initiative results to the report
     */
    private void writeInitiativeReport(boolean abbreviatedReport) {
        // write to report
        Report r;
        boolean deployment = false;
        if (!abbreviatedReport) {
            r = new Report(1210);
            r.type = Report.PUBLIC;
            if (game.getLastPhase().isDeployment() || game.isDeploymentComplete()
                    || !game.shouldDeployThisRound()) {
                r.messageId = 1000;
                r.add(game.getRoundCount());
            } else {
                deployment = true;
                if (game.getRoundCount() == 0) {
                    r.messageId = 1005;
                } else {
                    r.messageId = 1010;
                    r.add(game.getRoundCount());
                }
            }
            addReport(r);
            // write separator
            addReport(new Report(1200, Report.PUBLIC));
        } else {
            addReport(new Report(1210, Report.PUBLIC));
        }

        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {
            r = new Report(1040, Report.PUBLIC);
            addReport(r);
            for (Enumeration<GameTurn> e = game.getTurns(); e.hasMoreElements(); ) {
                GameTurn t = e.nextElement();
                if (t instanceof GameTurn.SpecificEntityTurn) {
                    Entity entity = game.getEntity(((GameTurn.SpecificEntityTurn) t).getEntityNum());
                    if (entity.getDeployRound() <= game.getRoundCount()) {
                        r = new Report(1045);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(entity.getInitiative().toString());
                        addReport(r);
                    }
                } else {
                    Player player = game.getPlayer(t.getPlayerNum());
                    if (null != player) {
                        r = new Report(1050, Report.PUBLIC);
                        r.add(player.getColorForPlayer());
                        addReport(r);
                    }
                }
            }
        } else {
            for (Team team : game.getTeams()) {
                // Teams with no active players can be ignored
                if (team.isObserverTeam()) {
                    continue;
                }

                // If there is only one non-observer player, list
                // them as the 'team', and use the team initiative
                if (team.getNonObserverSize() == 1) {
                    final Player player = team.nonObserverPlayers().get(0);
                    r = new Report(1015, Report.PUBLIC);
                    r.add(player.getColorForPlayer());
                    r.add(team.getInitiative().toString());
                    addReport(r);
                } else {
                    // Multiple players. List the team, then break it down.
                    r = new Report(1015, Report.PUBLIC);
                    r.add(Player.TEAM_NAMES[team.getId()]);
                    r.add(team.getInitiative().toString());
                    addReport(r);
                    for (Player player : team.nonObserverPlayers()) {
                        r = new Report(1015, Report.PUBLIC);
                        r.indent();
                        r.add(player.getName());
                        r.add(player.getInitiative().toString());
                        addReport(r);
                    }
                }
            }

            if (!doBlind()) {
                // The turn order is different in movement phase
                // if a player has any "even" moving units.
                r = new Report(1020, Report.PUBLIC);

                boolean hasEven = false;
                for (Enumeration<GameTurn> i = game.getTurns(); i.hasMoreElements(); ) {
                    GameTurn turn = i.nextElement();
                    Player player = game.getPlayer(turn.getPlayerNum());
                    if (null != player) {
                        r.add(player.getName());
                        if (player.getEvenTurns() > 0) {
                            hasEven = true;
                        }
                    }
                }
                r.newlines = 2;
                addReport(r);
                if (hasEven) {
                    r = new Report(1021, Report.PUBLIC);
                    if ((game.getOptions().booleanOption(OptionsConstants.INIT_INF_DEPLOY_EVEN)
                            || game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_EVEN))
                            && !game.getLastPhase().isEndReport()) {
                        r.choose(true);
                    } else {
                        r.choose(false);
                    }
                    r.indent();
                    r.newlines = 2;
                    addReport(r);
                }
            }
        }

        if (!abbreviatedReport) {
            // remaining deployments
            Comparator<Entity> comp = Comparator.comparingInt(Entity::getDeployRound);
            comp = comp.thenComparingInt(Entity::getOwnerId);
            comp = comp.thenComparingInt(Entity::getStartingPos);
            List<Entity> ue = game.getEntitiesVector().stream().filter(e -> e.getDeployRound() > game.getRoundCount()).sorted(comp).collect(Collectors.toList());
            if (!ue.isEmpty()) {
                r = new Report(1060, Report.PUBLIC);
                addReport(r);
                int round = -1;

                for (Entity entity : ue) {
                    if (round != entity.getDeployRound()) {
                        round = entity.getDeployRound();
                        r = new Report(1065, Report.PUBLIC);
                        r.add(round);
                        addReport(r);
                    }

                    r = new Report(1066);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    String s = IStartingPositions.START_LOCATION_NAMES[entity.getStartingPos()];
                    r.add(s);
                    addReport(r);
                }

                r = new Report(1210, Report.PUBLIC);
                r.newlines = 2;
                addReport(r);
            }

            // we don't much care about wind direction and such in a hard vacuum
            if (!game.getBoard().inSpace()) {
                // Wind direction and strength
                Report rWindDir = new Report(1025, Report.PUBLIC);
                rWindDir.add(game.getPlanetaryConditions().getWindDirDisplayableName());
                rWindDir.newlines = 0;
                Report rWindStr = new Report(1030, Report.PUBLIC);
                rWindStr.add(game.getPlanetaryConditions().getWindDisplayableName());
                rWindStr.newlines = 0;
                Report rWeather = new Report(1031, Report.PUBLIC);
                rWeather.add(game.getPlanetaryConditions().getWeatherDisplayableName());
                rWeather.newlines = 0;
                Report rLight = new Report(1032, Report.PUBLIC);
                rLight.add(game.getPlanetaryConditions().getLightDisplayableName());
                Report rVis = new Report(1033, Report.PUBLIC);
                rVis.add(game.getPlanetaryConditions().getFogDisplayableName());
                addReport(rWindDir);
                addReport(rWindStr);
                addReport(rWeather);
                addReport(rLight);
                addReport(rVis);
            }

            if (deployment) {
                addNewLines();
            }
        }
    }

    private void applyDropShipLandingDamage(Coords centralPos, Entity killer) {
        // first cycle through hexes to figure out final elevation
        Hex centralHex = game.getBoard().getHex(centralPos);
        if (null == centralHex) {
            // shouldn't happen
            return;
        }
        int finalElev = centralHex.getLevel();
        if (!centralHex.containsTerrain(Terrains.PAVEMENT)
                && !centralHex.containsTerrain(Terrains.ROAD)) {
            finalElev--;
        }
        Vector<Coords> positions = new Vector<>();
        positions.add(centralPos);
        for (int i = 0; i < 6; i++) {
            Coords pos = centralPos.translated(i);
            Hex hex = game.getBoard().getHex(pos);
            if (null == hex) {
                continue;
            }
            if (hex.getLevel() < finalElev) {
                finalElev = hex.getLevel();
            }
            positions.add(pos);
        }
        // ok now cycle through hexes and make all changes
        for (Coords pos : positions) {
            Hex hex = game.getBoard().getHex(pos);
            hex.setLevel(finalElev);
            // get rid of woods and replace with rough
            if (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {
                hex.removeTerrain(Terrains.WOODS);
                hex.removeTerrain(Terrains.JUNGLE);
                hex.removeTerrain(Terrains.FOLIAGE_ELEV);
                hex.addTerrain(new Terrain(Terrains.ROUGH, 1));
            }
            sendChangedHex(pos);
        }

        applyDropShipProximityDamage(centralPos, killer);
    }

    private void applyDropShipProximityDamage(Coords centralPos, Entity killer) {
        applyDropShipProximityDamage(centralPos, false, 0, killer);
    }

    /**
     * apply damage to units and buildings within a certain radius of a landing
     * or lifting off DropShip
     *
     * @param centralPos - the Coords for the central position of the DropShip
     */
    private void applyDropShipProximityDamage(Coords centralPos, boolean rearArc, int facing,
                                              Entity killer) {
        Vector<Integer> alreadyHit = new Vector<>();

        // anything in the central hex or adjacent hexes is destroyed
        Hashtable<Coords, Vector<Entity>> positionMap = game.getPositionMap();
        for (Entity en : game.getEntitiesVector(centralPos)) {
            if (!en.isAirborne()) {
                addReport(destroyEntity(en, "DropShip proximity damage", false, false));
                alreadyHit.add(en.getId());
            }
        }
        Building bldg = game.getBoard().getBuildingAt(centralPos);
        if (null != bldg) {
            collapseBuilding(bldg, positionMap, centralPos, vPhaseReport);
        }
        for (int i = 0; i < 6; i++) {
            Coords pos = centralPos.translated(i);
            for (Entity en : game.getEntitiesVector(pos)) {
                if (!en.isAirborne()) {
                    addReport(destroyEntity(en, "DropShip proximity damage", false, false));
                }
                alreadyHit.add(en.getId());
            }
            bldg = game.getBoard().getBuildingAt(pos);
            if (null != bldg) {
                collapseBuilding(bldg, positionMap, pos, vPhaseReport);
            }
        }

        // Report r;
        // ok now I need to look at the damage rings - start at 2 and go to 7
        for (int i = 2; i < 8; i++) {
            int damageDice = (8 - i) * 2;
            List<Coords> ring = centralPos.allAtDistance(i);
            for (Coords pos : ring) {
                if (rearArc && !Compute.isInArc(centralPos, facing, pos, Compute.ARC_AFT)) {
                    continue;
                }

                alreadyHit = artilleryDamageHex(pos, centralPos, damageDice, null, killer.getId(),
                        killer, null, false, 0, vPhaseReport, false,
                        alreadyHit, true);
            }
        }
        destroyDoomedEntities(alreadyHit);
    }

    /**
     * Marks ineligible entities as not ready for this phase
     */
    private void setIneligible(GamePhase phase) {
        Vector<Entity> assistants = new Vector<>();
        boolean assistable = false;

        if (isPlayerForcedVictory()) {
            assistants.addAll(game.getEntitiesVector());
        } else {
            for (Entity entity : game.getEntitiesVector()) {
                if (entity.isEligibleFor(phase)) {
                    assistable = true;
                } else {
                    assistants.addElement(entity);
                }
            }
        }
        for (Entity assistant : assistants) {
            if (!assistable || !assistant.canAssist(phase)) {
                assistant.setDone(true);
            }
        }
    }

    /**
     * Have the loader load the indicated unit. The unit being loaded loses its
     * turn.
     *
     * @param loader - the <code>Entity</code> that is loading the unit.
     * @param unit   - the <code>Entity</code> being loaded.
     */
    private void loadUnit(Entity loader, Entity unit, int bayNumber) {
        // ProtoMechs share a single turn for a Point. When loading one we don't remove its turn
        // unless it's the last unit in the Point to act.
        int remainingProtos = 0;
        if (unit.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
            remainingProtos = game.getSelectedEntityCount(en -> en.hasETypeFlag(Entity.ETYPE_PROTOMECH)
                    && en.getId() != unit.getId()
                    && en.isSelectableThisTurn()
                    && en.getOwnerId() == unit.getOwnerId()
                    && en.getUnitNumber() == unit.getUnitNumber());
        }

        if (!getGame().getPhase().isLounge() && !unit.isDone() && (remainingProtos == 0)) {
            // Remove the *last* friendly turn (removing the *first* penalizes
            // the opponent too much, and re-calculating moves is too hard).
            game.removeTurnFor(unit);
            send(createTurnVectorPacket());
        }

        // When loading an Aero into a squadron in the lounge, make sure the
        // loaded aero has the same bomb loadout as the squadron
        // We want to do this before the fighter is loaded: when the fighter
        // is loaded into the squadron, the squadrons bombing attacks are
        // adjusted based on the bomb loadout on the fighter.
        if (getGame().getPhase().isLounge() && (loader instanceof FighterSquadron)) {
            ((IBomber) unit).setBombChoices(((FighterSquadron) loader).getBombChoices());
        }

        // Load the unit. Do not check for elevation during deployment
        boolean checkElevation = !getGame().getPhase().isLounge()
                && !getGame().getPhase().isDeployment();
        loader.load(unit, checkElevation, bayNumber);

        // The loaded unit is being carried by the loader.
        unit.setTransportId(loader.getId());

        // Remove the loaded unit from the screen.
        unit.setPosition(null);

        // set deployment round of the loadee to equal that of the loader
        unit.setDeployRound(loader.getDeployRound());

        // Update the loading unit's passenger count, if it's a large craft
        if ((loader instanceof SmallCraft) || (loader instanceof Jumpship)) {
            // Don't add DropShip crew to a JumpShip or station's passenger list
            if (!unit.isLargeCraft()) {
                loader.setNPassenger(loader.getNPassenger() + unit.getCrew().getSize());
            }
        }

        // Update the loaded unit.
        entityUpdate(unit.getId());
        entityUpdate(loader.getId());
    }

    /**
     * Have the loader tow the indicated unit. The unit being towed loses its
     * turn.
     *
     * @param loader - the <code>Entity</code> that is towing the unit.
     * @param unit   - the <code>Entity</code> being towed.
     */
    private void towUnit(Entity loader, Entity unit) {
        if (!getGame().getPhase().isLounge() && !unit.isDone()) {
            // Remove the *last* friendly turn (removing the *first* penalizes
            // the opponent too much, and re-calculating moves is too hard).
            game.removeTurnFor(unit);
            send(createTurnVectorPacket());
        }

        loader.towUnit(unit.getId());

        // set deployment round of the loadee to equal that of the loader
        unit.setDeployRound(loader.getDeployRound());

        // Update the loader and towed units.
        entityUpdate(unit.getId());
        entityUpdate(loader.getId());
    }

    /**
     * Have the tractor drop the indicated trailer. This will also disconnect all
     * trailers that follow the one dropped.
     *
     * @param tractor
     *            - the <code>Entity</code> that is disconnecting the trailer.
     * @param unloaded
     *            - the <code>Targetable</code> unit being unloaded.
     * @param pos
     *            - the <code>Coords</code> for the unloaded unit.
     * @return <code>true</code> if the unit was successfully unloaded,
     *         <code>false</code> if the trailer isn't carried by tractor.
     */
    private boolean disconnectUnit(Entity tractor, Targetable unloaded, Coords pos) {
        // We can only unload Entities.
        Entity trailer;
        if (unloaded instanceof Entity) {
            trailer = (Entity) unloaded;
        } else {
            return false;
        }
        // disconnectUnit() updates anything behind 'trailer' too, so copy
        // the list of trailers before we alter it so entityUpdate() can be
        // run on all of them. Also, add the entity towing Trailer to the list
        List<Integer> trailerList = new ArrayList<>(trailer.getConnectedUnits());
        trailerList.add(trailer.getTowedBy());

        // Unload the unit.
        tractor.disconnectUnit(trailer.getId());

        // Update the tractor and all affected trailers.
        for (int id : trailerList) {
            entityUpdate(id);
        }
        entityUpdate(trailer.getId());
        entityUpdate(tractor.getId());

        // Unloaded successfully.
        return true;
    }

    private boolean unloadUnit(Entity unloader, Targetable unloaded,
                               Coords pos, int facing, int elevation) {
        return unloadUnit(unloader, unloaded, pos, facing, elevation, false,
                false);
    }

    /**
     * Have the unloader unload the indicated unit. The unit being unloaded may
     * or may not gain a turn
     *
     * @param unloader
     *            - the <code>Entity</code> that is unloading the unit.
     * @param unloaded
     *            - the <code>Targetable</code> unit being unloaded.
     * @param pos
     *            - the <code>Coords</code> for the unloaded unit.
     * @param facing
     *            - the <code>int</code> facing for the unloaded unit.
     * @param elevation
     *            - the <code>int</code> elevation at which to unload, if both
     *            loader and loaded units use VTOL movement.
     * @param evacuation
     *            - a <code>boolean</code> indicating whether this unit is being
     *            unloaded as a result of its carrying units destruction
     * @return <code>true</code> if the unit was successfully unloaded,
     *         <code>false</code> if the unit isn't carried in unloader.
     */
    private boolean unloadUnit(Entity unloader, Targetable unloaded,
                               Coords pos, int facing, int elevation, boolean evacuation,
                               boolean duringDeployment) {

        // We can only unload Entities.
        Entity unit;
        if (unloaded instanceof Entity) {
            unit = (Entity) unloaded;
        } else {
            return false;
        }

        // Unload the unit.
        if (!unloader.unload(unit)) {
            return false;
        }

        // The unloaded unit is no longer being carried.
        unit.setTransportId(Entity.NONE);

        // Place the unloaded unit onto the screen.
        unit.setPosition(pos);

        // Units unloaded onto the screen are deployed.
        if (pos != null) {
            unit.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        unit.setFacing(facing);
        unit.setSecondaryFacing(facing);

        Hex hex = game.getBoard().getHex(pos);
        boolean isBridge = (hex != null)
                && hex.containsTerrain(Terrains.PAVEMENT);

        if (hex == null) {
            unit.setElevation(elevation);
        } else if (unloader.getMovementMode() == EntityMovementMode.VTOL) {
            if (unit.getMovementMode() == EntityMovementMode.VTOL) {
                // Flying units unload to the same elevation as the flying
                // transport
                unit.setElevation(elevation);
            } else if (game.getBoard().getBuildingAt(pos) != null) {
                // non-flying unit unloaded from a flying onto a building
                // -> sit on the roof
                unit.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
            } else {
                while (elevation >= -hex.depth()) {
                    if (unit.isElevationValid(elevation, hex)) {
                        unit.setElevation(elevation);
                        break;
                    }
                    elevation--;
                    // If unit is landed, the while loop breaks before here
                    // And unit.moved will be MOVE_NONE
                    // If we can jump, use jump
                    if (unit.getJumpMP() > 0) {
                        unit.moved = EntityMovementType.MOVE_JUMP;
                    } else { // Otherwise, use walk trigger check for ziplines
                        unit.moved = EntityMovementType.MOVE_WALK;
                    }
                }
                if (!unit.isElevationValid(elevation, hex)) {
                    return false;
                }
            }
        } else if (game.getBoard().getBuildingAt(pos) != null) {
            // non flying unit unloading units into a building
            // -> sit in the building at the same elevation
            unit.setElevation(elevation);
        } else if (hex.terrainLevel(Terrains.WATER) > 0) {
            if ((unit.getMovementMode() == EntityMovementMode.HOVER)
                    || (unit.getMovementMode() == EntityMovementMode.WIGE)
                    || (unit.getMovementMode() == EntityMovementMode.HYDROFOIL)
                    || (unit.getMovementMode() == EntityMovementMode.NAVAL)
                    || (unit.getMovementMode() == EntityMovementMode.SUBMARINE)
                    || (unit.getMovementMode() == EntityMovementMode.INF_UMU)
                    || hex.containsTerrain(Terrains.ICE) || isBridge) {
                // units that can float stay on the surface, or we go on the
                // bridge
                // this means elevation 0, because elevation is relative to the
                // surface
                unit.setElevation(0);
            }
        } else {
            // default to the floor of the hex.
            // unit elevation is relative to the surface
            unit.setElevation(hex.floor() - hex.getLevel());
        }

        // Check for zip lines PSR -- MOVE_WALK implies ziplines
        if (unit.moved == EntityMovementType.MOVE_WALK) {
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_ZIPLINES)
                    && (unit instanceof Infantry)
                    && !((Infantry) unit).isMechanized()) {

                // Handle zip lines
                PilotingRollData psr = getEjectModifiers(game, unit, 0, false,
                        unit.getPosition(), "Anti-mek skill");
                // Factor in Elevation
                if (unloader.getElevation() > 0) {
                    psr.addModifier(unloader.getElevation(), "elevation");
                }
                int roll = Compute.d6(2);

                // Report ziplining
                Report r = new Report(9920);
                r.subject = unit.getId();
                r.addDesc(unit);
                r.newlines = 0;
                addReport(r);

                // Report TN
                r = new Report(9921);
                r.subject = unit.getId();
                r.add(psr.getValue());
                r.add(psr.getDesc());
                r.add(roll);
                r.newlines = 0;
                addReport(r);

                if (roll < psr.getValue()) { // Failure!
                    r = new Report(9923);
                    r.subject = unit.getId();
                    r.add(psr.getValue());
                    r.add(roll);
                    addReport(r);

                    HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    hit.setIgnoreInfantryDoubleDamage(true);
                    addReport(damageEntity(unit, hit, 5));
                } else { //  Report success
                    r = new Report(9922);
                    r.subject = unit.getId();
                    r.add(psr.getValue());
                    r.add(roll);
                    addReport(r);
                }
                addNewLines();
            } else {
                return false;
            }
        }

        addReport(doSetLocationsExposure(unit, hex, false, unit.getElevation()));

        // unlike other unloaders, entities unloaded from droppers can still
        // move (unless infantry)
        if (!evacuation && (unloader instanceof SmallCraft)
                && !(unit instanceof Infantry)) {
            unit.setUnloaded(false);
            unit.setDone(false);

            // unit uses half of walk mp and is treated as moving one hex
            unit.mpUsed = unit.getOriginalWalkMP() / 2;
            unit.delta_distance = 1;
        }

        // If we unloaded during deployment, allow a turn
        if (duringDeployment) {
            unit.setUnloaded(false);
            unit.setDone(false);
        }

        //Update the transport unit's passenger count, if it's a large craft
        if (unloader instanceof SmallCraft || unloader instanceof Jumpship) {
            //Don't add dropship crew to a jumpship or station's passenger list
            if (!unit.isLargeCraft()) {
                unloader.setNPassenger(Math.max(0, unloader.getNPassenger() - unit.getCrew().getSize()));
            }
        }

        // Update the unloaded unit.
        entityUpdate(unit.getId());

        // Unloaded successfully.
        return true;
    }

    /**
     * Do a piloting skill check to attempt landing
     *
     * @param entity The <code>Entity</code> that is landing
     * @param roll   The <code>PilotingRollData</code> to be used for this landing.
     */
    private void attemptLanding(Entity entity, PilotingRollData roll) {
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return;
        }

        // okay, print the info
        Report r = new Report(9605);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9606);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        // boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            int mof = roll.getValue() - diceRoll;
            int damage = 10 * (mof);
            // Report damage taken
            r = new Report(9609);
            r.indent();
            r.addDesc(entity);
            r.add(damage);
            r.add(mof);
            addReport(r);

            int side = ToHitData.SIDE_FRONT;
            if ((entity instanceof Aero) && ((Aero) entity).isSpheroid()) {
                side = ToHitData.SIDE_REAR;
            }
            while (damage > 0) {
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, side);
                addReport(damageEntity(entity, hit, 10));
                damage -= 10;
            }
            // suc = false;
        } else {
            r.choose(true);
            addReport(r);
            // suc = true;
        }
    }

    private boolean launchUnit(Entity unloader, Targetable unloaded,
                               Coords pos, int facing, int velocity, int altitude, int[] moveVec,
                               int bonus) {

        Entity unit;
        if (unloaded instanceof Entity && unloader instanceof Aero) {
            unit = (Entity) unloaded;
        } else {
            return false;
        }

        // must be an ASF, Small Craft, or DropShip
        if (!unit.isAero() || unit instanceof Jumpship) {
            return false;
        }
        IAero a = (IAero) unit;

        Report r;

        // Unload the unit.
        if (!unloader.unload(unit)) {
            return false;
        }

        // The unloaded unit is no longer being carried.
        unit.setTransportId(Entity.NONE);

        // pg. 86 of TW: launched fighters can move in fire in the turn they are
        // unloaded
        unit.setUnloaded(false);

        // Place the unloaded unit onto the screen.
        unit.setPosition(pos);

        // Units unloaded onto the screen are deployed.
        if (pos != null) {
            unit.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        unit.setFacing(facing);
        unit.setSecondaryFacing(facing);

        // the velocity of the unloaded unit is the same as the loader
        a.setCurrentVelocity(velocity);
        a.setNextVelocity(velocity);

        // if using advanced movement then set vectors
        unit.setVectors(moveVec);

        unit.setAltitude(altitude);

        // it seems that the done button is still being set and I can't figure
        // out where
        unit.setDone(false);

        // if the bonus was greater than zero then too many fighters were
        // launched and they
        // must all make control rolls
        if (bonus > 0) {
            PilotingRollData psr = unit.getBasePilotingRoll();
            psr.addModifier(bonus, "safe launch rate exceeded");
            int ctrlroll = Compute.d6(2);
            r = new Report(9375);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.add(psr);
            r.add(ctrlroll);
            r.indent(1);
            if (ctrlroll < psr.getValue()) {
                r.choose(false);
                addReport(r);
                // damage the unit
                int damage = 10 * (psr.getValue() - ctrlroll);
                HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                Vector<Report> rep = damageEntity(unit, hit, damage);
                Report.indentAll(rep, 1);
                rep.lastElement().newlines++;
                addReport(rep);
                // did we destroy the unit?
                if (unit.isDoomed()) {
                    // Clean out the entity.
                    unit.setDestroyed(true);
                    game.moveToGraveyard(unit.getId());
                    send(createRemoveEntityPacket(unit.getId()));
                }
            } else {
                // avoided damage
                r.choose(true);
                r.newlines++;
                addReport(r);
            }
        } else {
            r = new Report(9374);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.indent(1);
            r.newlines++;
            addReport(r);
        }

        // launching from an OOC vessel causes damage
        // same thing if faster than 2 velocity in atmosphere
        if ((((Aero) unloader).isOutControlTotal() && !unit.isDoomed())
                || ((((Aero) unloader).getCurrentVelocity() > 2) && !game
                .getBoard().inSpace())) {
            int damageRoll = Compute.d6(2);
            int damage = damageRoll * 10;
            r = new Report(9385);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.add(damage);
            addReport(r);
            HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
            addReport(damageEntity(unit, hit, damage));
            // did we destroy the unit?
            if (unit.isDoomed()) {
                // Clean out the entity.
                unit.setDestroyed(true);
                game.moveToGraveyard(unit.getId());
                send(createRemoveEntityPacket(unit.getId()));
            }
        }

        // Update the unloaded unit.
        entityUpdate(unit.getId());

        // Set the turn mask. We need to be specific otherwise we run the risk
        // of having a unit of another class consume the turn and leave the
        // unloaded unit without a turn
        int turnMask;
        List<GameTurn> turnVector = game.getTurnVector();
        if (unit instanceof Dropship) {
            turnMask = GameTurn.CLASS_DROPSHIP;
        } else if (unit instanceof SmallCraft) {
            turnMask = GameTurn.CLASS_SMALL_CRAFT;
        } else {
            turnMask = GameTurn.CLASS_AERO;
        }
        // Add one, otherwise we consider the turn we're currently processing
        int turnInsertIdx = game.getTurnIndex() + 1;
        // We have to figure out where to insert this turn, to maintain proper
        // space turn order (JumpShips, Small Craft, DropShips, Aeros)
        for (; turnInsertIdx < turnVector.size(); turnInsertIdx++) {
            GameTurn turn = turnVector.get(turnInsertIdx);
            if (turn.isValidEntity(unit, game)) {
                break;
            }
        }

        // ok add another turn for the unloaded entity so that it can move
        GameTurn newTurn = new GameTurn.EntityClassTurn(unit.getOwner().getId(), turnMask);
        game.insertTurnAfter(newTurn, turnInsertIdx);
        // brief everybody on the turn update
        send(createTurnVectorPacket());

        return true;
    }

    public void dropUnit(Entity drop, Entity entity, Coords curPos, int altitude) {
        // Unload the unit.
        entity.unload(drop);
        // The unloaded unit is no longer being carried.
        drop.setTransportId(Entity.NONE);

        // OK according to Welshman's pending ruling, when on the ground map
        // units should be deployed in the ring two hexes away from the DropShip
        // optimally, we should let people choose here, but that would be
        // complicated
        // so for now I am just going to distribute them. I will give each unit
        // the first
        // emptiest hex that has no water or magma in it.
        // I will start the circle based on the facing of the dropper
        // Spheroid - facing
        // Aerodyne - opposite of facing
        // http://www.classicbattletech.com/forums/index.php?topic=65600.msg1568089#new
        if (game.getBoard().onGround() && (null != curPos)) {
            boolean selected = false;
            int count;
            int max = 0;
            int facing = entity.getFacing();
            if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {
                // no real rule for this but it seems to make sense that units
                // would drop behind an
                // aerodyne rather than in front of it
                facing = (facing + 3) % 6;
            }
            boolean checkDanger = true;
            while (!selected) {
                // we can get caught in an infinite loop if all available hexes
                // are dangerous, so check for this
                boolean allDanger = true;
                for (int i = 0; i < 6; i++) {
                    int dir = (facing + i) % 6;
                    Coords newPos = curPos.translated(dir, 2);
                    count = 0;
                    if (game.getBoard().contains(newPos)) {
                        Hex newHex = game.getBoard().getHex(newPos);
                        Building bldg = game.getBoard().getBuildingAt(newPos);
                        boolean danger = newHex.containsTerrain(Terrains.WATER)
                                || newHex.containsTerrain(Terrains.MAGMA)
                                || (null != bldg);
                        for (Entity unit : game.getEntitiesVector(newPos)) {
                            if ((unit.getAltitude() == altitude)
                                    && !unit.isAero()) {
                                count++;
                            }
                        }
                        if ((count <= max) && (!danger || !checkDanger)) {
                            selected = true;
                            curPos = newPos;
                            break;
                        }
                        if (!danger) {
                            allDanger = false;
                        }
                    }
                    newPos = newPos.translated((dir + 2) % 6);
                    count = 0;
                    if (game.getBoard().contains(newPos)) {
                        Hex newHex = game.getBoard().getHex(newPos);
                        Building bldg = game.getBoard().getBuildingAt(newPos);
                        boolean danger = newHex.containsTerrain(Terrains.WATER)
                                || newHex.containsTerrain(Terrains.MAGMA)
                                || (null != bldg);
                        for (Entity unit : game.getEntitiesVector(newPos)) {
                            if ((unit.getAltitude() == altitude) && !unit.isAero()) {
                                count++;
                            }
                        }
                        if ((count <= max) && (!danger || !checkDanger)) {
                            selected = true;
                            curPos = newPos;
                            break;
                        }
                        if (!danger) {
                            allDanger = false;
                        }
                    }
                }
                if (allDanger && checkDanger) {
                    checkDanger = false;
                } else {
                    max++;
                }
            }
        }

        // Place the unloaded unit onto the screen.
        drop.setPosition(curPos);

        // Units unloaded onto the screen are deployed.
        if (curPos != null) {
            drop.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        drop.setFacing(entity.getFacing());
        drop.setSecondaryFacing(entity.getFacing());

        drop.setAltitude(altitude);
        entityUpdate(drop.getId());
    }

    /**
     * Record that the given building has been affected by the current entity's
     * movement. At the end of the entity's movement, notify the clients about
     * the updates.
     *
     * @param bldg     - the <code>Building</code> that has been affected.
     * @param collapse - a <code>boolean</code> value that specifies that the
     *                 building collapsed (when <code>true</code>).
     */
    private void addAffectedBldg(Building bldg, boolean collapse) {
        // If the building collapsed, then the clients have already
        // been notified, so remove it from the notification list.
        if (collapse) {
            affectedBldgs.remove(bldg);
        } else { // Otherwise, make sure that this building is tracked.
            affectedBldgs.put(bldg, Boolean.FALSE);
        }
    }

    /**
     * Walk through the building hexes that were affected by the recent entity's
     * movement. Notify the clients about the updates to all affected entities
     * and non-collapsed buildings. The affected hexes is then cleared for the
     * next entity's movement.
     */
    private void applyAffectedBldgs() {
        // Build a list of Building updates.
        Vector<Building> bldgUpdates = new Vector<>();

        // Only send a single turn update.
        boolean bTurnsChanged = false;

        // Walk the set of buildings.
        Enumeration<Building> bldgs = affectedBldgs.keys();
        while (bldgs.hasMoreElements()) {
            final Building bldg = bldgs.nextElement();

            // Walk through the building's coordinates.
            Enumeration<Coords> bldgCoords = bldg.getCoords();
            while (bldgCoords.hasMoreElements()) {
                final Coords coords = bldgCoords.nextElement();
                // Walk through the entities at these coordinates.
                for (Entity entity : game.getEntitiesVector(coords)) {
                    // Is the entity infantry?
                    if (entity instanceof Infantry) {
                        // Is the infantry dead?
                        if (entity.isDoomed() || entity.isDestroyed()) {
                            // Has the entity taken a turn?
                            if (!entity.isDone()) {
                                // Dead entities don't take turns.
                                game.removeTurnFor(entity);
                                bTurnsChanged = true;
                            } // End entity-still-to-move

                            // Clean out the dead entity.
                            entity.setDestroyed(true);
                            game.moveToGraveyard(entity.getId());
                            send(createRemoveEntityPacket(entity.getId()));
                        } else { // Infantry that aren't dead are damaged.
                            entityUpdate(entity.getId());
                        }
                    } // End entity-is-infantry
                } // Check the next entity.
            } // Handle the next hex in this building.
            // Add this building to the report.
            bldgUpdates.addElement(bldg);
        } // Handle the next affected building.

        // Did we update the turns?
        if (bTurnsChanged) {
            send(createTurnVectorPacket());
        }

        // Are there any building updates?
        if (!bldgUpdates.isEmpty()) {
            // Send the building updates to the clients.
            sendChangedBuildings(bldgUpdates);

            // Clear the list of affected buildings.
            affectedBldgs.clear();
        }

        // And we're done.
    } // End private void applyAffectedBldgs()

    /**
     * Receives an entity movement packet, and if valid, executes it and ends
     * the current turn.
     */
    private void receiveMovement(Packet packet, int connId) {
        Map<EntityTargetPair, LosEffects> losCache = new HashMap<>();
        Entity entity = game.getEntity(packet.getIntValue(0));
        MovePath md = (MovePath) packet.getObject(1);
        md.setGame(getGame());
        md.setEntity(entity);

        // is this the right phase?
        if (!getGame().getPhase().isMovement()) {
            LogManager.getLogger().error("Server got movement packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())) {
            turn = game.getTurnForPlayer(connId);
        }

        if ((turn == null) || !turn.isValid(connId, entity, game)) {
            String msg = "error: server got invalid movement packet from " + "connection " + connId;
            if (entity != null) {
                msg += ", Entity: " + entity.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            LogManager.getLogger().error(msg);
            return;
        }

        // looks like mostly everything's okay
        processMovement(entity, md, losCache);

        // The attacker may choose to break a chain whip grapple by expending MP
        if ((entity.getGrappled() != Entity.NONE)
                && entity.isChainWhipGrappled() && entity.isGrappleAttacker()
                && (md.getMpUsed() > 0)) {

            Entity te = game.getEntity(entity.getGrappled());
            Report r = new Report(4316);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.addDesc(te);
            addReport(r);

            entity.setGrappled(Entity.NONE, false);
            te.setGrappled(Entity.NONE, false);

            entityUpdate(entity.getId());
            entityUpdate(te.getId());
        }

        // check the LOS of any telemissiles owned by this entity
        for (int missileId : entity.getTMTracker().getMissiles()) {
            Entity tm = game.getEntity(missileId);
            if ((null != tm) && !tm.isDestroyed()
                    && (tm instanceof TeleMissile)) {
                if (LosEffects.calculateLOS(game, entity, tm).canSee()) {
                    ((TeleMissile) tm).setOutContact(false);
                } else {
                    ((TeleMissile) tm).setOutContact(true);
                }
                entityUpdate(tm.getId());
            }
        }

        // Notify the clients about any building updates.
        applyAffectedBldgs();

        // Unit movement may detect hidden units
        detectHiddenUnits();

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(losCache);
        }

        // An entity that is not vulnerable to anti-TSM green smoke that has stayed in a smoke-filled
        // hex takes damage.
        if ((md.getHexesMoved() == 0)
                && game.getBoard().contains(md.getFinalCoords())
                && (game.getBoard().getHex(md.getFinalCoords()).terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_GREEN)
                && entity.antiTSMVulnerable()) {
            addReport(doGreenSmokeDamage(entity));
        }

        // This entity's turn is over.
        // N.B. if the entity fell, a *new* turn has already been added.
        endCurrentTurn(entity);
    }

    /**
     * makes a unit skid or sideslip on the board
     *
     * @param entity    the unit which should skid
     * @param start     the coordinates of the hex the unit was in prior to skidding
     * @param elevation the elevation of the unit
     * @param direction the direction of the skid
     * @param distance  the number of hexes skidded
     * @param step      the MoveStep which caused the skid
     * @return true if the entity was removed from play
     */
    private boolean processSkid(Entity entity, Coords start, int elevation,
                                int direction, int distance, MoveStep step,
                                EntityMovementType moveType) {
        return processSkid(entity, start, elevation, direction, distance, step, moveType, false);
    }

    /**
     * makes a unit skid or sideslip on the board
     *
     * @param entity    the unit which should skid
     * @param start     the coordinates of the hex the unit was in prior to skidding
     * @param elevation the elevation of the unit
     * @param direction the direction of the skid
     * @param distance  the number of hexes skidded
     * @param step      the MoveStep which caused the skid
     * @param flip      whether the skid resulted from a failure maneuver result of major skid
     * @return true if the entity was removed from play
     */
    private boolean processSkid(Entity entity, Coords start, int elevation,
                                int direction, int distance, MoveStep step,
                                EntityMovementType moveType, boolean flip) {
        Coords nextPos = start;
        Coords curPos = nextPos;
        Hex curHex = game.getBoard().getHex(start);
        Report r;
        int skidDistance = 0; // actual distance moved
        // Flipping vehicles take tonnage/10 points of damage for every hex they enter.
        int flipDamage = (int) Math.ceil(entity.getWeight() / 10.0);
        while (!entity.isDoomed() && (distance > 0)) {
            nextPos = curPos.translated(direction);
            // Is the next hex off the board?
            if (!game.getBoard().contains(nextPos)) {

                // Can the entity skid off the map?
                if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {
                    // Yup. One dead entity.
                    game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED);
                    send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED));
                    r = new Report(2030, Report.PUBLIC);
                    r.addDesc(entity);
                    addReport(r);

                    for (Entity e : entity.getLoadedUnits()) {
                        game.removeEntity(e.getId(), IEntityRemovalConditions.REMOVE_PUSHED);
                        send(createRemoveEntityPacket(e.getId(), IEntityRemovalConditions.REMOVE_PUSHED));
                    }
                    Entity swarmer = game.getEntity(entity.getSwarmAttackerId());
                    if (swarmer != null) {
                        if (!swarmer.isDone()) {
                            game.removeTurnFor(swarmer);
                            swarmer.setDone(true);
                            send(createTurnVectorPacket());
                        }
                        game.removeEntity(swarmer.getId(), IEntityRemovalConditions.REMOVE_PUSHED);
                        send(createRemoveEntityPacket(swarmer.getId(), IEntityRemovalConditions.REMOVE_PUSHED));
                    }
                    // The entity's movement is completed.
                    return true;

                }
                // Nope. Update the report.
                r = new Report(2035);
                r.subject = entity.getId();
                r.indent();
                addReport(r);
                // Stay in the current hex and stop skidding.
                break;
            }

            Hex nextHex = game.getBoard().getHex(nextPos);
            distance -= nextHex.movementCost(entity) + 1;
            // By default, the unit is going to fall to the floor of the next
            // hex
            int curAltitude = elevation + curHex.getLevel();
            int nextAltitude = nextHex.floor();

            // but VTOL keep altitude
            if (entity.getMovementMode() == EntityMovementMode.VTOL) {
                nextAltitude = Math.max(nextAltitude, curAltitude);
            } else {
                // Is there a building to "catch" the unit?
                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                    // unit will land on the roof, if at a higher level,
                    // otherwise it will skid through the wall onto the same
                    // floor.
                    // don't change this if the building starts at an elevation
                    // higher than the unit
                    // (e.g. the building is on a hill). Otherwise, we skid into
                    // solid earth.
                    if (curAltitude >= nextHex.floor()) {
                        nextAltitude = Math.min(curAltitude,
                                nextHex.getLevel() + nextHex.terrainLevel(Terrains.BLDG_ELEV));
                    }
                }
                // Is there a bridge to "catch" the unit?
                if (nextHex.containsTerrain(Terrains.BRIDGE)) {
                    // unit will land on the bridge, if at a higher level,
                    // and the bridge exits towards the current hex,
                    // otherwise the bridge has no effect
                    int exitDir = (direction + 3) % 6;
                    exitDir = 1 << exitDir;
                    if ((nextHex.getTerrain(Terrains.BRIDGE).getExits() & exitDir) == exitDir) {
                        nextAltitude = Math.min(curAltitude,
                                Math.max(nextAltitude,
                                        nextHex.getLevel() + nextHex.terrainLevel(Terrains.BRIDGE_ELEV)));
                    }
                }
                if ((nextAltitude <= nextHex.getLevel())
                        && (curAltitude >= curHex.getLevel())) {
                    // Hovercraft and WiGEs can "skid" over water.
                    // all units can skid over ice.
                    if ((entity.getMovementMode().equals(EntityMovementMode.HOVER)
                            || entity.getMovementMode().equals(EntityMovementMode.WIGE))
                            && nextHex.containsTerrain(Terrains.WATER)) {
                        nextAltitude = nextHex.getLevel();
                    } else {
                        if (nextHex.containsTerrain(Terrains.ICE)) {
                            nextAltitude = nextHex.getLevel();
                        }
                    }
                }
                if (entity.getMovementMode() == EntityMovementMode.WIGE
                        && elevation > 0 && nextAltitude < curAltitude) {
                    // Airborne WiGEs drop to one level above the surface
                    if (entity.climbMode()) {
                        nextAltitude = curAltitude;
                    } else {
                        nextAltitude++;
                    }
                }
            }

            // The elevation the skidding unit will occupy in next hex
            int nextElevation = nextAltitude - nextHex.getLevel();

            boolean crashedIntoTerrain = curAltitude < nextAltitude;
            if (entity.getMovementMode() == EntityMovementMode.VTOL
                    && (nextHex.containsTerrain(Terrains.WOODS)
                    || nextHex.containsTerrain(Terrains.JUNGLE))
                    && nextElevation <= nextHex.terrainLevel(Terrains.FOLIAGE_ELEV)) {
                crashedIntoTerrain = true;

            }

            if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                Building bldg = game.getBoard().getBuildingAt(nextPos);

                if (bldg.getType() == Building.WALL) {
                    crashedIntoTerrain = true;
                }

                if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                    crashedIntoTerrain = true;
                }
            }

            // however WiGE can gain 1 level to avoid crashing into the terrain.
            if (entity.getMovementMode() == EntityMovementMode.WIGE && (elevation > 0)) {
                if (curAltitude == nextHex.floor()) {
                    nextElevation = 1;
                    crashedIntoTerrain = false;
                } else if ((entity instanceof LandAirMech) && (curAltitude + 1 == nextHex.floor())) {
                    // LAMs in AirMech mode skid across terrain that is two levels higher rather than crashing,
                    // Reset the skid distance for skid damage calculations.
                    nextElevation = 0;
                    skidDistance = 0;
                    crashedIntoTerrain = false;
                    r = new Report(2102);
                    r.subject = entity.getId();
                    r.indent();
                    addReport(r);
                }
            }

            Entity crashDropShip = null;
            for (Entity en : game.getEntitiesVector(nextPos)) {
                if ((en instanceof Dropship) && !en.isAirborne()
                        && (nextAltitude <= (en.relHeight()))) {
                    crashDropShip = en;
                }
            }

            if (crashedIntoTerrain) {
                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                    Building bldg = game.getBoard().getBuildingAt(nextPos);

                    // If you crash into a wall you want to stop in the hex
                    // before the wall not in the wall
                    // Like a building.
                    if (bldg.getType() == Building.WALL) {
                        r = new Report(2047);
                    } else if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                        r = new Report(2049);
                    } else {
                        r = new Report(2045);
                    }

                } else {
                    r = new Report(2045);
                }

                r.subject = entity.getId();
                r.indent();
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                        || (entity.getMovementMode() == EntityMovementMode.VTOL)) {
                    int hitSide = (step.getFacing() - direction) + 6;
                    hitSide %= 6;
                    int table = 0;
                    switch (hitSide) { // quite hackish... I think it ought to work, though.
                        case 0: // can this happen?
                            table = ToHitData.SIDE_FRONT;
                            break;
                        case 1:
                        case 2:
                            table = ToHitData.SIDE_LEFT;
                            break;
                        case 3:
                            table = ToHitData.SIDE_REAR;
                            break;
                        case 4:
                        case 5:
                            table = ToHitData.SIDE_RIGHT;
                            break;
                    }
                    elevation = nextElevation;
                    if (entity instanceof Tank) {
                        addReport(crashVTOLorWiGE((Tank) entity, false, true,
                                distance, curPos, elevation, table));
                    }

                    if ((nextHex.containsTerrain(Terrains.WATER) && !nextHex
                            .containsTerrain(Terrains.ICE))
                            || nextHex.containsTerrain(Terrains.WOODS)
                            || nextHex.containsTerrain(Terrains.JUNGLE)) {
                        addReport(destroyEntity(entity, "could not land in crash site"));
                    } else if (elevation < nextHex.terrainLevel(Terrains.BLDG_ELEV)) {
                        Building bldg = game.getBoard().getBuildingAt(nextPos);

                        // If you crash into a wall you want to stop in the hex
                        // before the wall not in the wall
                        // Like a building.
                        if (bldg.getType() == Building.WALL) {
                            addReport(destroyEntity(entity, "crashed into a wall"));
                            break;
                        }
                        if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                            addReport(destroyEntity(entity, "crashed into a gun emplacement"));
                            break;
                        }

                        addReport(destroyEntity(entity, "crashed into building"));
                    } else {
                        entity.setPosition(nextPos);
                        entity.setElevation(0);
                        addReport(doEntityDisplacementMinefieldCheck(entity,
                                curPos, nextPos, nextElevation));
                    }
                    break;

                }
                // skidding into higher terrain does weight/20
                // damage in 5pt clusters to front.
                int damage = ((int) entity.getWeight() + 19) / 20;
                while (damage > 0) {
                    int table = ToHitData.HIT_NORMAL;
                    int side = entity.sideTable(nextPos);
                    if (entity instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    }
                    HitData hitData = entity.rollHitLocation(table, side);
                    hitData.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    addReport(damageEntity(entity, hitData, Math.min(5, damage)));
                    damage -= 5;
                }
                // Stay in the current hex and stop skidding.
                break;
            }

            // did we hit a DropShip. Oww!
            // Taharqa: The rules on how to handle this are completely missing, so I am assuming
            // we assign damage as per an accidental charge, but do not displace
            // the DropShip and end the skid
            else if (null != crashDropShip) {
                r = new Report(2050);
                r.subject = entity.getId();
                r.indent();
                r.add(crashDropShip.getShortName(), true);
                r.add(nextPos.getBoardNum(), true);
                addReport(r);
                ChargeAttackAction caa = new ChargeAttackAction(entity.getId(),
                        crashDropShip.getTargetType(),
                        crashDropShip.getId(),
                        crashDropShip.getPosition());
                ToHitData toHit = caa.toHit(game, true);
                resolveChargeDamage(entity, crashDropShip, toHit, direction);
                if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                        || (entity.getMovementMode() == EntityMovementMode.VTOL)) {
                    int hitSide = (step.getFacing() - direction) + 6;
                    hitSide %= 6;
                    int table = 0;
                    switch (hitSide) { // quite hackish... I think it ought to work, though.
                        case 0: // can this happen?
                            table = ToHitData.SIDE_FRONT;
                            break;
                        case 1:
                        case 2:
                            table = ToHitData.SIDE_LEFT;
                            break;
                        case 3:
                            table = ToHitData.SIDE_REAR;
                            break;
                        case 4:
                        case 5:
                            table = ToHitData.SIDE_RIGHT;
                            break;
                    }
                    elevation = nextElevation;
                    addReport(crashVTOLorWiGE((VTOL) entity, false, true,
                            distance, curPos, elevation, table));
                    break;
                }
                if (!crashDropShip.isDoomed() && !crashDropShip.isDestroyed()
                        && !game.isOutOfGame(crashDropShip)) {
                    break;
                }
            }

            // Have skidding units suffer falls (off a cliff).
            else if ( (curAltitude > (nextAltitude + entity.getMaxElevationChange())
                    || (curHex.hasCliffTopTowards(nextHex) && curAltitude > nextAltitude) )
                    && !(entity.getMovementMode() == EntityMovementMode.WIGE && elevation > curHex.ceiling())) {
                addReport(doEntityFallsInto(entity, entity.getElevation(), curPos, nextPos,
                        entity.getBasePilotingRoll(moveType), true));
                addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));
                // Stay in the current hex and stop skidding.
                break;
            }

            // Get any building in the hex.
            Building bldg = null;
            if (nextElevation < nextHex.terrainLevel(Terrains.BLDG_ELEV)) {
                // We will only run into the building if its at a higher level,
                // otherwise we skid over the roof
                bldg = game.getBoard().getBuildingAt(nextPos);
            }
            boolean bldgSuffered = false;
            boolean stopTheSkid = false;
            // Does the next hex contain an entities?
            // ASSUMPTION: hurt EVERYONE in the hex.
            Iterator<Entity> targets = game.getEntities(nextPos);
            if (targets.hasNext()) {
                List<Entity> avoidedChargeUnits = new ArrayList<>();
                boolean skidChargeHit = false;
                while (targets.hasNext()) {
                    Entity target = targets.next();

                    if ((target.getElevation() > (nextElevation + entity.getHeight()))
                            || (target.relHeight() < nextElevation)) {
                        // target is not in the way
                        continue;
                    }

                    // Can the target avoid the skid?
                    if (!target.isDone()) {
                        if (target instanceof Infantry) {
                            r = new Report(2420);
                            r.subject = target.getId();
                            r.addDesc(target);
                            addReport(r);
                            continue;
                        } else if (target instanceof Protomech) {
                            if (target != Compute.stackingViolation(game, entity, nextPos, null)) {
                                r = new Report(2420);
                                r.subject = target.getId();
                                r.addDesc(target);
                                addReport(r);
                                continue;
                            }
                        } else {
                            PilotingRollData psr = target.getBasePilotingRoll();
                            psr.addModifier(0, "avoiding collision");
                            if (psr.getValue() == TargetRoll.AUTOMATIC_FAIL
                                    || psr.getValue() == TargetRoll.IMPOSSIBLE) {
                                r = new Report(2426);
                                r.subject = target.getId();
                                r.addDesc(target);
                                r.add(psr.getDesc());
                                addReport(r);
                            } else {
                                int roll = Compute.d6(2);
                                r = new Report(2425);
                                r.subject = target.getId();
                                r.addDesc(target);
                                r.add(psr);
                                r.add(psr.getDesc());
                                r.add(roll);
                                addReport(r);
                                if (roll >= psr.getValue()) {
                                    game.removeTurnFor(target);
                                    avoidedChargeUnits.add(target);
                                    continue;
                                    // TODO : the charge should really be suspended
                                    // and resumed after the target moved.
                                }
                            }
                        }
                    }

                    // Mechs and vehicles get charged,
                    // but need to make a to-hit roll
                    if ((target instanceof Mech) || (target instanceof Tank)
                            || (target instanceof Aero)) {
                        ChargeAttackAction caa = new ChargeAttackAction(
                                entity.getId(), target.getTargetType(),
                                target.getId(), target.getPosition());
                        ToHitData toHit = caa.toHit(game, true);

                        // roll
                        int roll = Compute.d6(2);
                        // Update report.
                        r = new Report(2050);
                        r.subject = entity.getId();
                        r.indent();
                        r.add(target.getShortName(), true);
                        r.add(nextPos.getBoardNum(), true);
                        r.newlines = 0;
                        addReport(r);
                        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
                            roll = -12;
                            r = new Report(2055);
                            r.subject = entity.getId();
                            r.add(toHit.getDesc());
                            r.newlines = 0;
                            addReport(r);
                        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
                            r = new Report(2060);
                            r.subject = entity.getId();
                            r.add(toHit.getDesc());
                            r.newlines = 0;
                            addReport(r);
                            roll = Integer.MAX_VALUE;
                        } else {
                            // report the roll
                            r = new Report(2065);
                            r.subject = entity.getId();
                            r.add(toHit);
                            r.add(roll);
                            r.newlines = 0;
                            addReport(r);
                        }

                        // Resolve a charge against the target.
                        // ASSUMPTION: buildings block damage for
                        // *EACH* entity charged.
                        if (roll < toHit.getValue()) {
                            r = new Report(2070);
                            r.subject = entity.getId();
                            addReport(r);
                        } else {
                            // Resolve the charge.
                            resolveChargeDamage(entity, target, toHit, direction);
                            // HACK: set the entity's location
                            // to the original hex again, for the other targets
                            if (targets.hasNext()) {
                                entity.setPosition(curPos);
                            }
                            bldgSuffered = true;
                            skidChargeHit = true;
                            // The skid ends here if the target lives.
                            if (!target.isDoomed() && !target.isDestroyed()
                                    && !game.isOutOfGame(target)) {
                                stopTheSkid = true;
                            }
                        }

                        // if we don't do this here,
                        // we can have a mech without a leg
                        // standing on the field and moving
                        // as if it still had his leg after
                        // getting skid-charged.
                        if (!target.isDone()) {
                            addReport(resolvePilotingRolls(target));
                            game.resetPSRs(target);
                            target.applyDamage();
                            addNewLines();
                        }

                    }

                    // Resolve "move-through" damage on infantry.
                    // Infantry inside of a building don't get a
                    // move-through, but suffer "bleed through"
                    // from the building.
                    else if ((target instanceof Infantry) && (bldg != null)) {
                        // Update report.
                        r = new Report(2075);
                        r.subject = entity.getId();
                        r.indent();
                        r.add(target.getShortName(), true);
                        r.add(nextPos.getBoardNum(), true);
                        r.newlines = 0;
                        addReport(r);

                        // Infantry don't have different
                        // tables for punches and kicks
                        HitData hit = target.rollHitLocation(ToHitData.HIT_NORMAL,
                                Compute.targetSideTable(entity, target));
                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                        // Damage equals tonnage, divided by 5.
                        // ASSUMPTION: damage is applied in one hit.
                        addReport(damageEntity(target, hit, (int) Math.round(entity.getWeight() / 5)));
                        addNewLines();
                    }

                    // Has the target been destroyed?
                    if (target.isDoomed()) {
                        // Has the target taken a turn?
                        if (!target.isDone()) {
                            // Dead entities don't take turns.
                            game.removeTurnFor(target);
                            send(createTurnVectorPacket());
                        } // End target-still-to-move

                        // Clean out the entity.
                        target.setDestroyed(true);
                        game.moveToGraveyard(target.getId());
                        send(createRemoveEntityPacket(target.getId()));
                    }
                    // Update the target's position,
                    // unless it is off the game map.
                    if (!game.isOutOfGame(target)) {
                        entityUpdate(target.getId());
                    }
                } // Check the next entity in the hex.

                if (skidChargeHit) {
                    // HACK: set the entities position to that
                    // hex's coords, because we had to move the entity
                    // back earlier for the other targets
                    entity.setPosition(nextPos);
                }
                for (Entity e : avoidedChargeUnits) {
                    GameTurn newTurn = new GameTurn.SpecificEntityTurn(e.getOwner().getId(), e.getId());
                    // Prevents adding extra turns for multi-turns
                    newTurn.setMultiTurn(true);
                    game.insertNextTurn(newTurn);
                    send(createTurnVectorPacket());
                }
            }

            // Handle the building in the hex.
            if (bldg != null) {
                // Report that the entity has entered the bldg.
                r = new Report(2080);
                r.subject = entity.getId();
                r.indent();
                r.add(bldg.getName());
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                // If the building hasn't already suffered
                // damage, then apply charge damage to the
                // building and displace the entity inside.
                // ASSUMPTION: you don't charge the building
                // if Tanks or Mechs were charged.
                int chargeDamage = ChargeAttackAction.getDamageFor(entity, game
                                .getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE),
                        entity.delta_distance);
                if (!bldgSuffered) {
                    Vector<Report> reports = damageBuilding(bldg, chargeDamage, nextPos);
                    for (Report report : reports) {
                        report.subject = entity.getId();
                    }
                    addReport(reports);

                    // Apply damage to the attacker.
                    int toAttacker = ChargeAttackAction.getDamageTakenBy(entity, bldg, nextPos);
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(nextPos));
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    addReport(damageEntity(entity, hit, toAttacker));
                    addNewLines();

                    entity.setPosition(nextPos);
                    entity.setElevation(nextElevation);
                    addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));
                    curPos = nextPos;
                } // End buildings-suffer-too

                // Any infantry in the building take damage
                // equal to the building being charged.
                // ASSUMPTION: infantry take no damage from the
                // building absorbing damage from
                // Tanks and Mechs being charged.
                addReport(damageInfantryIn(bldg, chargeDamage, nextPos));

                // If a building still stands, then end the skid,
                // and add it to the list of affected buildings.
                if (bldg.getCurrentCF(nextPos) > 0) {
                    stopTheSkid = true;
                    if (bldg.rollBasement(nextPos, game.getBoard(), vPhaseReport)) {
                        sendChangedHex(nextPos);
                        Vector<Building> buildings = new Vector<>();
                        buildings.add(bldg);
                        sendChangedBuildings(buildings);
                    }
                    addAffectedBldg(bldg, checkBuildingCollapseWhileMoving(bldg, entity, nextPos));
                } else {
                    // otherwise it collapses immediately on our head
                    checkForCollapse(bldg, game.getPositionMap(), nextPos, true, vPhaseReport);
                }
            } // End handle-building.

            // Do we stay in the current hex and stop skidding?
            if (stopTheSkid) {
                break;
            }

            // Update entity position and elevation
            entity.setPosition(nextPos);
            entity.setElevation(nextElevation);
            addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));
            skidDistance++;

            // Check for collapse of any building the entity might be on
            Building roof = game.getBoard().getBuildingAt(nextPos);
            if (roof != null) {
                if (checkForCollapse(roof, game.getPositionMap(), nextPos, true, vPhaseReport)) {
                    break; // stop skidding if the building collapsed
                }
            }

            // Can the skidding entity enter the next hex from this?
            // N.B. can skid along roads.
            if ((entity.isLocationProhibited(start) || entity.isLocationProhibited(nextPos))
                    && !Compute.canMoveOnPavement(game, curPos, nextPos, step)) {
                // Update report.
                r = new Report(2040);
                r.subject = entity.getId();
                r.indent();
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                // If the prohibited terrain is water, entity is destroyed
                if ((nextHex.terrainLevel(Terrains.WATER) > 0)
                        && (entity instanceof Tank)
                        && (entity.getMovementMode() != EntityMovementMode.HOVER)
                        && (entity.getMovementMode() != EntityMovementMode.WIGE)) {
                    addReport(destroyEntity(entity,
                            "skidded into a watery grave", false, true));
                }

                // otherwise, damage is weight/5 in 5pt clusters
                int damage = ((int) entity.getWeight() + 4) / 5;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(
                                    ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
                            Math.min(5, damage)));
                    damage -= 5;
                }
                // and unit is immobile
                if (entity instanceof Tank) {
                    ((Tank) entity).immobilize();
                }

                // Stay in the current hex and stop skidding.
                break;
            }

            if ((nextHex.terrainLevel(Terrains.WATER) > 0)
                    && (entity.getMovementMode() != EntityMovementMode.HOVER)
                    && (entity.getMovementMode() != EntityMovementMode.WIGE)) {
                // water ends the skid
                break;
            }

            // check for breaking magma crust
            // note that this must sequentially occur before the next 'entering liquid magma' check
            // otherwise, magma crust won't have a chance to break
            ServerHelper.checkAndApplyMagmaCrust(nextHex, nextElevation, entity, curPos, false, vPhaseReport, this);
            ServerHelper.checkEnteringMagma(nextHex, nextElevation, entity, this);

            // is the next hex a swamp?
            PilotingRollData rollTarget = entity.checkBogDown(step, moveType, nextHex, curPos, nextPos,
                    step.getElevation(), Compute.canMoveOnPavement(game, curPos, nextPos, step));

            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Taharqa: According to TacOps, you automatically stick if you
                // are skidding, (pg. 63)
                // if (0 < doSkillCheckWhileMoving(entity, curPos, nextPos,
                // rollTarget, false)) {
                entity.setStuck(true);
                r = new Report(2081);
                r.subject = entity.getId();
                r.add(entity.getDisplayName(), true);
                addReport(r);
                // check for quicksand
                addReport(checkQuickSand(nextPos));
                // check for accidental stacking violation
                Entity violation = Compute.stackingViolation(game, entity.getId(), curPos);
                if (violation != null) {
                    // target gets displaced, because of low elevation
                    Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), curPos,
                            direction);
                    addReport(doEntityDisplacement(violation, curPos, targetDest,
                            new PilotingRollData(violation.getId(), 0, "domino effect")));
                    // Update the violating entity's position on the client.
                    entityUpdate(violation.getId());
                }
                // stay here and stop skidding, see bug 1115608
                break;
            }

            // Update the position and keep skidding.
            curPos = nextPos;
            curHex = nextHex;
            elevation = nextElevation;
            r = new Report(2085);
            r.subject = entity.getId();
            r.indent();
            r.add(curPos.getBoardNum(), true);
            addReport(r);

            if (flip && entity instanceof Tank) {
                doVehicleFlipDamage((Tank) entity, flipDamage, direction < 3, skidDistance - 1);
            }

        } // Handle the next skid hex.

        // If the skidding entity violates stacking,
        // displace targets until it doesn't.
        curPos = entity.getPosition();
        Entity target = Compute.stackingViolation(game, entity.getId(), curPos);
        while (target != null) {
            nextPos = Compute.getValidDisplacement(game, target.getId(), target.getPosition(), direction);
            // ASSUMPTION
            // There should always be *somewhere* that
            // the target can go... last skid hex if
            // nothing else is available.
            if (null == nextPos) {
                // But I don't trust the assumption fully.
                // Report the error and try to continue.
                LogManager.getLogger().error("The skid of " + entity.getShortName()
                        + " should displace " + target.getShortName()
                        + " in hex " + curPos.getBoardNum()
                        + " but there is nowhere to go.");
                break;
            }
            // indent displacement
            r = new Report(1210, Report.PUBLIC);
            r.indent();
            r.newlines = 0;
            addReport(r);
            addReport(doEntityDisplacement(target, curPos, nextPos, null));
            addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, entity.getElevation()));
            target = Compute.stackingViolation(game, entity.getId(), curPos);
        }

        // Mechs suffer damage for every hex skidded.
        // For QuadVees in vehicle mode, apply
        // damage only if flipping.
        boolean mechDamage = ((entity instanceof Mech)
                && !((entity.getMovementMode() == EntityMovementMode.WIGE) && (entity.getElevation() > 0)));
        if (entity instanceof QuadVee && entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE) {
            mechDamage = flip;
        }
        if (mechDamage) {
            // Calculate one half falling damage times skid length.
            int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);

            // report skid damage
            r = new Report(2090);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(damage);
            addReport(r);

            // standard damage loop
            // All skid damage is to the front.
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                addReport(damageEntity(entity, hit, cluster));
                damage -= cluster;
            }
            addNewLines();
        }

        if (flip && entity instanceof Tank) {
            addReport(applyCriticalHit(entity, Entity.NONE, new CriticalSlot(0, Tank.CRIT_CREW_STUNNED),
                    true, 0, false));
        } else if (flip && entity instanceof QuadVee && entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE) {
            // QuadVees don't suffer stunned crew criticals; require PSR to avoid damage instead.
            PilotingRollData prd = entity.getBasePilotingRoll();
            addReport(checkPilotAvoidFallDamage(entity, 1, prd));
        }

        // Clean up the entity if it has been destroyed.
        if (entity.isDoomed()) {
            entity.setDestroyed(true);
            game.moveToGraveyard(entity.getId());
            send(createRemoveEntityPacket(entity.getId()));

            // The entity's movement is completed.
            return true;
        }

        // Let the player know the ordeal is over.
        r = new Report(2095);
        r.subject = entity.getId();
        r.indent();
        addReport(r);

        return false;
    }

    /**
     * Roll on the failed vehicle maneuver table.
     *
     * @param entity    The vehicle that failed the maneuver.
     * @param curPos    The coordinates of the hex in which the maneuver was attempted.
     * @param turnDirection The difference between the intended final facing and the starting facing
     *                      (-1 for left turn, 1 for right turn, 0 for not turning).
     * @param prevStep  The <code>MoveStep</code> immediately preceding the one being processed.
     *                  Cannot be null; if the check is made for the first step of the path,
     *                  use the current step.
     * @param lastStepMoveType  The <code>EntityMovementType</code> of the last step in the path.
     * @param distance  The distance moved so far during the phase; used to calculate any potential skid.
     * @param modifier  The modifier to the maneuver failure roll.
     * @return          true if the maneuver failure result ends the unit's turn.
     */
    private boolean processFailedVehicleManeuver(Entity entity, Coords curPos, int turnDirection,
                                                 MoveStep prevStep, boolean isBackwards, EntityMovementType lastStepMoveType, int distance,
                                                 int modifier, int marginOfFailure) {
        Hex curHex = game.getBoard().getHex(curPos);
        if (entity.getMovementMode() == EntityMovementMode.WHEELED
                && !curHex.containsTerrain(Terrains.PAVEMENT)) {
            modifier += 2;
        }
        if (entity.getMovementMode() == EntityMovementMode.VTOL) {
            modifier += 2;
        } else if (entity.getMovementMode() == EntityMovementMode.HOVER
                || (entity.getMovementMode() == EntityMovementMode.WIGE && entity instanceof Tank)
                || entity.getMovementMode() == EntityMovementMode.HYDROFOIL) {
            modifier += 4;
        }
        if (entity.getWeightClass() < EntityWeightClass.WEIGHT_MEDIUM
                || entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {
            modifier++;
        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_HEAVY
                || entity.getWeightClass() == EntityWeightClass.WEIGHT_LARGE_SUPPORT) {
            modifier--;
        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_ASSAULT
                || entity.getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY) {
            modifier -= 2;
        }
        boolean turnEnds = false;
        boolean motiveDamage = false;
        int motiveDamageMod = 0;
        boolean skid = false;
        boolean flip = false;
        boolean isGroundVehicle = ((entity instanceof Tank)
                && ((entity.getMovementMode() == EntityMovementMode.TRACKED)
                || (entity.getMovementMode() == EntityMovementMode.WHEELED)));

        int roll = Compute.d6(2);

        Report r = new Report(2505);
        r.subject = entity.getId();
        r.newlines = 0;
        r.indent(2);
        addReport(r);
        r = new Report(6310);
        r.subject = entity.getId();
        r.add(roll);
        r.newlines = 0;
        addReport(r);
        r = new Report(3340);
        r.add(modifier);
        r.subject = entity.getId();
        r.newlines = 0;
        addReport(r);

        r = new Report(1210);
        r.subject = entity.getId();
        roll += modifier;
        if (roll < 8) {
            r.messageId = 2506;
            // minor fishtail, fail to turn
            turnDirection = 0;
        } else if (roll < 10) {
            r.messageId = 2507;
            // moderate fishtail, turn an extra hexside and roll for motive damage at -1.
            if (turnDirection == 0) {
                turnDirection = Compute.d6() < 4? -1 : 1;
            } else {
                turnDirection *= 2;
            }
            motiveDamage = true;
            motiveDamageMod = -1;
        } else if (roll < 12) {
            r.messageId = 2508;
            // serious fishtail, turn an extra hexside and roll for motive damage. Turn ends.
            if (turnDirection == 0) {
                turnDirection = Compute.d6() < 4? -1 : 1;
            } else {
                turnDirection *= 2;
            }
            motiveDamage = true;
            turnEnds = true;
        } else {
            r.messageId = 2509;
            // Turn fails and vehicle skids
            // Wheeled and naval vehicles start to flip if the roll is high enough.
            if (roll > 13) {
                if (entity.getMovementMode() == EntityMovementMode.WHEELED) {
                    r.messageId = 2510;
                    flip = true;
                } else if (entity.getMovementMode() == EntityMovementMode.NAVAL
                        || entity.getMovementMode() == EntityMovementMode.HYDROFOIL) {
                    entity.setDoomed(true);
                    r.messageId = 2511;
                }
            }
            skid = true;
            turnEnds = true;
        }
        addReport(r);
        entity.setFacing((entity.getFacing() + turnDirection + 6) % 6);
        entity.setSecondaryFacing(entity.getFacing());
        if (motiveDamage && isGroundVehicle) {
            addReport(vehicleMotiveDamage((Tank) entity, motiveDamageMod));
        }
        if (skid && !entity.isDoomed()) {
            if (!flip && isGroundVehicle) {
                addReport(vehicleMotiveDamage((Tank) entity, 0));
            }

            int skidDistance = (int) Math.round((double) (distance - 1) / 2);
            if (flip && entity.getMovementMode() == EntityMovementMode.WHEELED) {
                // Wheeled vehicles that start to flip reduce the skid distance by one hex.
                skidDistance--;
            } else if (entity.getMovementMode() == EntityMovementMode.HOVER
                    || entity.getMovementMode() == EntityMovementMode.VTOL
                    || entity.getMovementMode() == EntityMovementMode.WIGE) {
                skidDistance = Math.min(marginOfFailure, distance);
            }
            if (skidDistance > 0) {
                int skidDirection = prevStep.getFacing();
                if (isBackwards) {
                    skidDirection = (skidDirection + 3) % 6;
                }
                processSkid(entity, curPos, prevStep.getElevation(), skidDirection, skidDistance,
                        prevStep, lastStepMoveType, flip);
            }
        }
        return turnEnds;
    }

    private void doVehicleFlipDamage(Tank entity, int damage, boolean startRight, int flipCount) {
        HitData hit;

        int index = flipCount % 4;
        // If there is no turret, we do side-side-bottom
        if (entity.hasNoTurret()) {
            index = flipCount % 3;
            if (index > 0) {
                index++;
            }
        }
        switch (index) {
            case 0:
                hit = new HitData(startRight ? Tank.LOC_RIGHT : Tank.LOC_LEFT);
                break;
            case 1:
                hit = new HitData(Tank.LOC_TURRET);
                break;
            case 2:
                hit = new HitData(startRight ? Tank.LOC_LEFT : Tank.LOC_RIGHT);
                break;
            default:
                hit = null; //Motive damage instead
        }
        if (hit != null) {
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(entity, hit, damage));
            // If the vehicle has two turrets, they both take full damage.
            if ((hit.getLocation() == Tank.LOC_TURRET) && !(entity.hasNoDualTurret())) {
                hit = new HitData(Tank.LOC_TURRET_2);
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                addReport(damageEntity(entity, hit, damage));
            }
        } else {
            addReport(vehicleMotiveDamage(entity, 1));
        }
    }

    /**
     * processes a potential collision
     *
     * @param entity
     * @param target
     * @param src
     * @return
     */
    private boolean processCollision(Entity entity, Entity target, Coords src) {
        Report r;

        r = new Report(9035);
        r.subject = entity.getId();
        r.add(entity.getDisplayName());
        r.add(target.getDisplayName());
        addReport(r);
        boolean partial = (Compute.d6() == 6);
        // if aero chance to avoid
        if ((target.isAero())
                && (target.mpUsed < target.getRunMPwithoutMASC())
                && !((IAero) target).isOutControlTotal() && !target.isImmobile()) {
            // give them a control roll to avoid the collision
            // TODO : I should make this voluntary really
            IAero ta = (IAero) target;
            PilotingRollData psr = target.getBasePilotingRoll();
            psr.addModifier(0, "avoiding collision");
            int ctrlroll = Compute.d6(2);
            r = new Report(9045);
            r.subject = target.getId();
            r.add(target.getDisplayName());
            r.add(psr);
            r.add(ctrlroll);
            r.newlines = 0;
            r.indent(2);
            if (ctrlroll < psr.getValue()) {
                r.choose(false);
                addReport(r);
            } else {
                // avoided collision
                r.choose(true);
                addReport(r);
                // two possibilities:
                // 1) the target already moved, but had MP left - check for
                // control roll conditions
                // 2) the target had not yet moved, move them in straight line
                if (!target.isDone()) {
                    int vel = ta.getCurrentVelocity();
                    MovePath md = new MovePath(game, target);
                    while (vel > 0) {
                        md.addStep(MovePath.MoveStepType.FORWARDS);
                        vel--;
                    }
                    game.removeTurnFor(target);
                    send(createTurnVectorPacket());
                    processMovement(target, md, null);
                    // for some reason it is not clearing out turn
                } else {
                    // what needs to get checked?
                    // this move puts them at over-thrust
                    target.moved = EntityMovementType.MOVE_OVER_THRUST;
                    // they may have exceeded SI, only add if they hadn't
                    // exceeded it before
                    if (target.mpUsed <= ta.getSI()) {
                        PilotingRollData rollTarget = ta.checkThrustSITotal(
                                target.getRunMPwithoutMASC(), target.moved);
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                            game.addControlRoll(new PilotingRollData(
                                    target.getId(), 0,
                                    "Thrust spent during turn exceeds SI"));
                        }
                    }
                    target.mpUsed = target.getRunMPwithoutMASC();
                }
                return false;
            }
        } else {
            // can't avoid collision - write report
            r = new Report(9040);
            r.subject = entity.getId();
            r.add(entity.getDisplayName());
            r.indent(2);
            addReport(r);
        }

        // if we are still here, then collide
        ToHitData toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, "Its a collision");
        toHit.setSideTable(target.sideTable(src));
        resolveRamDamage((IAero) entity, target, toHit, partial, false);

        // Has the target been destroyed?
        if (target.isDoomed()) {
            // Has the target taken a turn?
            if (!target.isDone()) {
                // Dead entities don't take turns.
                game.removeTurnFor(target);
                send(createTurnVectorPacket());
            } // End target-still-to-move
            // Clean out the entity.
            target.setDestroyed(true);
            game.moveToGraveyard(target.getId());
            send(createRemoveEntityPacket(target.getId()));
        }
        // Update the target's position,
        // unless it is off the game map.
        if (!game.isOutOfGame(target)) {
            entityUpdate(target.getId());
        }

        return true;
    }

    private boolean checkCrash(Entity entity, Coords pos, int altitude) {
        // only Aeros can crash
        if (!entity.isAero()) {
            return false;
        }
        // no crashing in space
        if (game.getBoard().inSpace()) {
            return false;
        }
        // if aero on the ground map, then only crash if elevation is zero
        else if (game.getBoard().onGround()) {
            return altitude <= 0;
        }
        // we must be in atmosphere
        // if we're off the map, assume hex ceiling 0
        // Hexes with elevations < 0 are treated as 0 altitude
        int ceiling = 0;
        if (game.getBoard().getHex(pos) != null) {
            ceiling = Math.max(0, game.getBoard().getHex(pos).ceiling(true));
        }
        return ceiling >= altitude;
    }

    private Vector<Report> processCrash(Entity entity, int vel, Coords c) {
        Vector<Report> vReport = new Vector<>();
        Report r;
        if (c == null) {
            r = new Report(9701);
            r.subject = entity.getId();
            vReport.add(r);
            vReport.addAll(destroyEntity(entity, "crashed off the map", true, true));
            return vReport;
        }

        if (game.getBoard().inAtmosphere()) {
            r = new Report(9393, Report.PUBLIC);
            r.indent();
            r.addDesc(entity);
            vReport.add(r);
            entity.setDoomed(true);
        } else {
            ((IAero) entity).land();
        }

        // we might hit multiple hexes, if we're a DropShip, so we do some
        // checks for all of them
        List<Coords> coords = new ArrayList<>();
        coords.add(c);
        Hex h = game.getBoard().getHex(c);
        int crateredElevation;
        boolean containsWater = false;
        if (h.containsTerrain(Terrains.WATER)) {
            crateredElevation = Math.min(2, h.depth() + 1);
            containsWater = true;
        } else {
            crateredElevation = h.getLevel() - 2;
        }
        if (entity instanceof Dropship) {
            for (int i = 0; i < 6; i++) {
                Coords adjCoords = c.translated(i);
                if (!game.getBoard().contains(adjCoords)) {
                    continue;
                }
                Hex adjHex = game.getBoard().getHex(adjCoords);
                coords.add(adjCoords);
                if (adjHex.containsTerrain(Terrains.WATER)) {
                    if (containsWater) {
                        int newDepth = Math.min(2, adjHex.depth() + 1);
                        if (newDepth > crateredElevation) {
                            crateredElevation = newDepth;
                        }
                    } else {
                        crateredElevation = Math.min(2, adjHex.depth() + 1);
                        containsWater = true;
                    }
                } else if (!containsWater && (adjHex.getLevel() < crateredElevation)) {
                    crateredElevation = adjHex.getLevel();
                }
            }
        }
        // Units with velocity zero are treated like that had velocity two
        if (vel < 1) {
            vel = 2;
        }

        // deal crash damage only once
        boolean damageDealt = false;
        for (Coords hitCoords : coords) {
            int orig_crash_damage = Compute.d6(2) * 10 * vel;
            int crash_damage = orig_crash_damage;
            int direction = entity.getFacing();
            // first check for buildings
            Building bldg = game.getBoard().getBuildingAt(hitCoords);
            if ((null != bldg) && (bldg.getType() == Building.HARDENED)) {
                crash_damage *= 2;
            }
            if (null != bldg) {
                collapseBuilding(bldg, game.getPositionMap(), hitCoords, true, vReport);
            }
            if (!damageDealt) {
                r = new Report(9700, Report.PUBLIC);
                r.indent();
                r.addDesc(entity);
                r.add(crash_damage);
                vReport.add(r);
                while (crash_damage > 0) {
                    HitData hit;
                    if ((entity instanceof SmallCraft) && ((SmallCraft) entity).isSpheroid()) {
                        hit = entity.rollHitLocation(ToHitData.HIT_SPHEROID_CRASH, ToHitData.SIDE_REAR);
                    } else {
                        hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    }

                    if (crash_damage > 10) {
                        vReport.addAll(damageEntity(entity, hit, 10));
                    } else {
                        vReport.addAll(damageEntity(entity, hit, crash_damage));
                    }
                    crash_damage -= 10;
                }
                damageDealt = true;
            }

            // ok, now lets cycle through the entities in this spot and
            // potentially
            // damage them
            for (Entity victim : game.getEntitiesVector(hitCoords)) {
                if (victim.getId() == entity.getId()) {
                    continue;
                }
                if (((victim.getElevation() > 0) && victim
                        .isAirborneVTOLorWIGE()) || (victim.getAltitude() > 0)) {
                    continue;
                }
                // if the crasher is a DropShip and the victim is not a mech,
                // then it is automatically destroyed
                if ((entity instanceof Dropship) && !(victim instanceof Mech)) {
                    vReport.addAll(destroyEntity(victim, "hit by crashing DropShip"));
                } else {
                    crash_damage = orig_crash_damage / 2;
                    // roll dice to see if they got hit
                    int target = 2;
                    if (victim instanceof Infantry) {
                        target = 3;
                    }
                    int roll = Compute.d6();
                    r = new Report(9705, Report.PUBLIC);
                    r.indent();
                    r.addDesc(victim);
                    r.add(target);
                    r.add(crash_damage);
                    r.add(roll);
                    if (roll > target) {
                        r.choose(true);
                        vReport.add(r);
                        // apply half the crash damage in 5 point clusters
                        // (check
                        // hit tables)
                        while (crash_damage > 0) {
                            HitData hit = victim.rollHitLocation(
                                    ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                            if (victim instanceof Mech) {
                                hit = victim.rollHitLocation(
                                        ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);
                            }
                            if (victim instanceof Protomech) {
                                hit = victim.rollHitLocation(
                                        ToHitData.HIT_SPECIAL_PROTO, ToHitData.SIDE_FRONT);
                            }
                            if (crash_damage > 5) {
                                vReport.addAll(damageEntity(victim, hit, 5));
                            } else {
                                vReport.addAll(damageEntity(victim, hit, crash_damage));
                            }
                            crash_damage -= 5;
                        }

                    } else {
                        r.choose(false);
                        vReport.add(r);
                    }
                }

                if (!victim.isDoomed() && !victim.isDestroyed()) {
                    // entity displacement
                    Coords dest = Compute.getValidDisplacement(game, victim.getId(), hitCoords, direction);
                    if (null != dest) {
                        doEntityDisplacement(
                                victim,
                                hitCoords,
                                dest,
                                new PilotingRollData(victim.getId(), 0, "crash"));
                    } else if (!(victim instanceof Dropship)) {
                        // destroy entity - but not DropShips which are immovable
                        addReport(destroyEntity(victim, "impossible displacement",
                                victim instanceof Mech, victim instanceof Mech));
                    }
                }

            }

            // reduce woods
            h = game.getBoard().getHex(hitCoords);
            if (h.containsTerrain(Terrains.WOODS)) {
                if (entity instanceof Dropship) {
                    h.removeTerrain(Terrains.WOODS);
                    h.removeTerrain(Terrains.FOLIAGE_ELEV);
                    h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                } else {
                    int level = h.terrainLevel(Terrains.WOODS) - 1;
                    int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);
                    h.removeTerrain(Terrains.WOODS);
                    if (level > 0) {
                        h.addTerrain(new Terrain(Terrains.WOODS, level));
                        h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, folEl == 1 ? 1 : 2));
                    } else {
                        h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                        h.removeTerrain(Terrains.FOLIAGE_ELEV);
                    }
                }
            }
            // do the same for jungles
            if (h.containsTerrain(Terrains.JUNGLE)) {
                if (entity instanceof Dropship) {
                    h.removeTerrain(Terrains.JUNGLE);
                    h.removeTerrain(Terrains.FOLIAGE_ELEV);
                    h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                } else {
                    int level = h.terrainLevel(Terrains.JUNGLE) - 1;
                    int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);
                    h.removeTerrain(Terrains.JUNGLE);
                    if (level > 0) {
                        h.addTerrain(new Terrain(Terrains.JUNGLE, level));
                        h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, folEl == 1 ? 1 : 2));
                    } else {
                        h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                        h.removeTerrain(Terrains.FOLIAGE_ELEV);
                    }
                }
            }
            if (entity instanceof Dropship) {
                if (!containsWater) {
                    h.setLevel(crateredElevation);
                } else {
                    if (!h.containsTerrain(Terrains.WATER)) {
                        h.removeAllTerrains();
                    }
                    h.addTerrain(new Terrain(Terrains.WATER, crateredElevation, false, 0));
                }
            }
            sendChangedHex(hitCoords);
        }

        // check for a stacking violation - which should only happen in the
        // case of grounded dropships, because they are not movable
        if (null != Compute.stackingViolation(game, entity.getId(), c)) {
            Coords dest = Compute.getValidDisplacement(game, entity.getId(), c,
                    Compute.d6() - 1);
            if (null != dest) {
                doEntityDisplacement(entity, c, dest, null);
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                vPhaseReport.addAll(destroyEntity(entity,
                        "impossible displacement", entity instanceof Mech,
                        entity instanceof Mech));
            }
        }

        // Check for watery death
        h = game.getBoard().getHex(c);
        if (h.containsTerrain(Terrains.WATER) && !entity.isDestroyed()
                && !entity.isDoomed()) {
            int lethalDepth;
            if (entity instanceof Dropship) {
                lethalDepth = 2;
            } else {
                lethalDepth = 1;
            }

            if (h.depth() >= lethalDepth) {
                // Oh snap... we is dead
                vReport.addAll(destroyEntity(entity,
                        "crashing into deep water", true, true));
            }
        }

        return vReport;
    }

    /**
     * Process any flee movement actions, including flying off the map
     *
     * @param movePath   The move path which resulted in an entity leaving the map.
     * @param flewOff    whether this fleeing is a result of accidentally flying off the
     *                   map
     * @param returnable the number of rounds until the unit can return to the map (-1
     *                   if it can't return)
     * @return Vector of turn reports.
     */
    private Vector<Report> processLeaveMap(MovePath movePath, boolean flewOff, int returnable) {
        Entity entity = movePath.getEntity();
        Vector<Report> vReport = new Vector<>();
        Report r;
        // Unit has fled the battlefield.
        r = new Report(2005, Report.PUBLIC);
        if (flewOff) {
            r = new Report(9370, Report.PUBLIC);
        }
        r.addDesc(entity);
        addReport(r);
        OffBoardDirection fleeDirection;
        if (movePath.getFinalCoords().getY() <= 0) {
            fleeDirection = OffBoardDirection.NORTH;
        } else if (movePath.getFinalCoords().getY() >= (getGame().getBoard().getHeight() - 1)) {
            fleeDirection = OffBoardDirection.SOUTH;
        } else if (movePath.getFinalCoords().getX() <= 0) {
            fleeDirection = OffBoardDirection.WEST;
        } else {
            fleeDirection = OffBoardDirection.EAST;
        }

        if (returnable > -1) {

            entity.setDeployed(false);
            entity.setDeployRound(1 + game.getRoundCount() + returnable);
            entity.setPosition(null);
            entity.setDone(true);
            if (entity.isAero()) {
                // If we're flying off because we're OOC, when we come back we
                // should no longer be OOC
                // If we don't, this causes a major problem as aeros tend to
                // return, re-deploy then
                // fly off again instantly.
                ((IAero) entity).setOutControl(false);
            }
            switch (fleeDirection) {
                case WEST:
                    entity.setStartingPos(Board.START_W);
                    break;
                case NORTH:
                    entity.setStartingPos(Board.START_N);
                    break;
                case EAST:
                    entity.setStartingPos(Board.START_E);
                    break;
                case SOUTH:
                    entity.setStartingPos(Board.START_S);
                    break;
                default:
                    entity.setStartingPos(Board.START_EDGE);
            }
            entityUpdate(entity.getId());
            return vReport;
        } else {
            ServerHelper.clearBloodStalkers(game, entity.getId(), this);
        }

        // Is the unit carrying passengers or trailers?
        final List<Entity> passengers = new ArrayList<>(entity.getLoadedUnits());
        if (!entity.getAllTowedUnits().isEmpty()) {
            for (int id : entity.getAllTowedUnits()) {
                Entity towed = game.getEntity(id);
                passengers.add(towed);
            }
        }
        if (!passengers.isEmpty()) {
            for (Entity passenger : passengers) {
                // Unit has fled the battlefield.
                r = new Report(2010, Report.PUBLIC);
                r.indent();
                r.addDesc(passenger);
                addReport(r);
                passenger.setRetreatedDirection(fleeDirection);
                game.removeEntity(passenger.getId(),
                        IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(passenger.getId(),
                        IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        }

        // Handle any picked up MechWarriors
        for (Integer mechWarriorId : entity.getPickedUpMechWarriors()) {
            Entity mw = game.getEntity(mechWarriorId);

            if (mw == null) {
                continue;
            }

            // Is the MechWarrior an enemy?
            int condition = IEntityRemovalConditions.REMOVE_IN_RETREAT;
            r = new Report(2010);
            if (mw.isCaptured()) {
                r = new Report(2015);
                condition = IEntityRemovalConditions.REMOVE_CAPTURED;
            } else {
                mw.setRetreatedDirection(fleeDirection);
            }
            game.removeEntity(mw.getId(), condition);
            send(createRemoveEntityPacket(mw.getId(), condition));
            r.addDesc(mw);
            r.indent();
            addReport(r);
        }
        // Is the unit being swarmed?
        final int swarmerId = entity.getSwarmAttackerId();
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);

            // Has the swarmer taken a turn?
            if (!swarmer.isDone()) {
                // Dead entities don't take turns.
                game.removeTurnFor(swarmer);
                send(createTurnVectorPacket());

            } // End swarmer-still-to-move

            // Unit has fled the battlefield.
            swarmer.setSwarmTargetId(Entity.NONE);
            entity.setSwarmAttackerId(Entity.NONE);
            r = new Report(2015, Report.PUBLIC);
            r.indent();
            r.addDesc(swarmer);
            addReport(r);
            game.removeEntity(swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED);
            send(createRemoveEntityPacket(swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED));
        }
        entity.setRetreatedDirection(fleeDirection);
        game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
        send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));
        return vReport;
    }

    /**
     * Steps through an entity movement packet, executing it.
     *
     * @param entity   The Entity that is moving
     * @param md       The MovePath that defines how the Entity moves
     * @param losCache A cache that stores Los between various Entities and
     *                 targets.  In double blind games, we may need to compute a
     *                 lot of LosEffects, so caching them can really speed
     *                 things up.
     */
    private void processMovement(Entity entity, MovePath md, Map<EntityTargetPair,
            LosEffects> losCache) {
        // Make sure the cache isn't null
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        Report r;
        boolean sideslipped = false; // for VTOL side slipping
        PilotingRollData rollTarget;

        // check for fleeing
        if (md.contains(MovePath.MoveStepType.FLEE)) {
            addReport(processLeaveMap(md, false, -1));
            return;
        }

        if (md.contains(MovePath.MoveStepType.EJECT)) {
            if (entity.isLargeCraft() && !entity.isCarcass()) {
                r = new Report(2026);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                Aero ship = (Aero) entity;
                ship.setEjecting(true);
                entityUpdate(ship.getId());
                Coords legalPos = entity.getPosition();
                //Get the step so we can pass it in and get the abandon coords from it
                for (final Enumeration<MoveStep> i = md.getSteps(); i
                        .hasMoreElements();) {
                    final MoveStep step = i.nextElement();
                    if (step.getType() == MovePath.MoveStepType.EJECT) {
                        legalPos = step.getTargetPosition();
                    }
                }
                addReport(ejectSpacecraft(ship, ship.isSpaceborne(), (ship.isAirborne() && !ship.isSpaceborne()), legalPos));
                //If we're grounded or destroyed by crew loss, end movement
                if (entity.isDoomed() || (!entity.isSpaceborne() && !entity.isAirborne())) {
                    return;
                }
            } else if ((entity instanceof Mech) || (entity instanceof Aero)) {
                r = new Report(2020);
                r.subject = entity.getId();
                r.add(entity.getCrew().getName());
                r.addDesc(entity);
                addReport(r);
                addReport(ejectEntity(entity, false));
                return;
            } else if ((entity instanceof Tank) && !entity.isCarcass()) {
                r = new Report(2025);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(ejectEntity(entity, false));
                return;
            }
        }

        if (md.contains(MovePath.MoveStepType.CAREFUL_STAND)) {
            entity.setCarefulStand(true);
        }
        if (md.contains(MovePath.MoveStepType.BACKWARDS)) {
            entity.setMovedBackwards(true);
            if (md.getMpUsed() > entity.getWalkMP()) {
                entity.setPowerReverse(true);
            }
        }

        if (md.contains(MovePath.MoveStepType.TAKEOFF) && entity.isAero()) {
            IAero a = (IAero) entity;
            a.setCurrentVelocity(1);
            a.liftOff(1);
            if (entity instanceof Dropship) {
                applyDropShipProximityDamage(md.getFinalCoords(), true, md.getFinalFacing(), entity);
            }
            checkForTakeoffDamage(a);
            entity.setPosition(entity.getPosition().translated(entity.getFacing(), a.getTakeOffLength()));
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MovePath.MoveStepType.VTAKEOFF) && entity.isAero()) {
            IAero a = (IAero) entity;
            rollTarget = a.checkVerticalTakeOff();
            if (doVerticalTakeOffCheck(entity, rollTarget)) {
                a.setCurrentVelocity(0);
                a.liftOff(1);
                if (entity instanceof Dropship) {
                    applyDropShipProximityDamage(md.getFinalCoords(), (Dropship) a);
                }
                checkForTakeoffDamage(a);
            }
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MovePath.MoveStepType.LAND) && entity.isAero()) {
            IAero a = (IAero) entity;
            rollTarget = a.checkLanding(md.getLastStepMovementType(), md.getFinalVelocity(),
                    md.getFinalCoords(), md.getFinalFacing(), false);
            attemptLanding(entity, rollTarget);
            a.land();
            entity.setPosition(md.getFinalCoords().translated(md.getFinalFacing(),
                    a.getLandingLength()));
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MovePath.MoveStepType.VLAND) && entity.isAero()) {
            IAero a = (IAero) entity;
            rollTarget = a.checkLanding(md.getLastStepMovementType(),
                    md.getFinalVelocity(), md.getFinalCoords(),
                    md.getFinalFacing(), true);
            attemptLanding(entity, rollTarget);
            if (entity instanceof Dropship) {
                applyDropShipLandingDamage(md.getFinalCoords(), (Dropship) a);
            }
            a.land();
            entity.setPosition(md.getFinalCoords());
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        // okay, proceed with movement calculations
        Coords lastPos = entity.getPosition();
        Coords curPos = entity.getPosition();
        Hex firstHex = game.getBoard().getHex(curPos); // Used to check for start/end magma damage
        int curFacing = entity.getFacing();
        int curVTOLElevation = entity.getElevation();
        int curElevation;
        int lastElevation = entity.getElevation();
        int curAltitude = entity.getAltitude();
        boolean curClimbMode = entity.climbMode();
        // if the entity already used some MPs,
        // it previously tried to get up and fell,
        // and then got another turn. set moveType
        // and overallMoveType accordingly
        // (these are all cleared by Entity.newRound)
        int distance = entity.delta_distance;
        int mpUsed = entity.mpUsed;
        EntityMovementType moveType = entity.moved;
        EntityMovementType overallMoveType;
        boolean firstStep;
        boolean wasProne = entity.isProne();
        boolean fellDuringMovement = false;
        boolean crashedDuringMovement = false;
        boolean dropshipStillUnloading = false;
        boolean detectedHiddenHazard = false;
        boolean turnOver;
        int prevFacing = curFacing;
        Hex prevHex = game.getBoard().getHex(curPos);
        final boolean isInfantry = entity instanceof Infantry;
        AttackAction charge = null;
        RamAttackAction ram = null;
        // cache this here, otherwise changing MP in the turn causes
        // erroneous gravity PSRs
        int cachedGravityLimit = -1;
        int thrustUsed = 0;
        int j = 0;
        boolean didMove;
        boolean recovered = false;
        Entity loader = null;
        boolean continueTurnFromPBS = false;
        boolean continueTurnFromFishtail = false;
        boolean continueTurnFromLevelDrop = false;
        boolean continueTurnFromCliffAscent = false;

        // get a list of coordinates that the unit passed through this turn
        // so that I can later recover potential bombing targets
        // it may already have some values
        Vector<Coords> passedThrough = entity.getPassedThrough();
        passedThrough.add(curPos);
        List<Integer> passedThroughFacing = entity.getPassedThroughFacing();
        passedThroughFacing.add(curFacing);

        // Compile the move - don't clip
        // Clipping could affect hidden units; illegal steps aren't processed
        md.compile(game, entity, false);

        // if advanced movement is being used then set the new vectors based on
        // move path
        entity.setVectors(md.getFinalVectors());

        overallMoveType = md.getLastStepMovementType();

        // check for starting in liquid magma
        if ((game.getBoard().getHex(entity.getPosition())
                .terrainLevel(Terrains.MAGMA) == 2)
                && (entity.getElevation() == 0)) {
            doMagmaDamage(entity, false);
        }

        // set acceleration used to default
        if (entity.isAero()) {
            ((IAero) entity).setAccLast(false);
        }

        // check for dropping troops and drop them
        if (entity.isDropping() && !md.contains(MovePath.MoveStepType.HOVER)) {
            entity.setAltitude(entity.getAltitude() - game.getPlanetaryConditions().getDropRate());
            // they may have changed their facing
            if (md.length() > 0) {
                entity.setFacing(md.getFinalFacing());
            }
            passedThrough.add(entity.getPosition());
            entity.setPassedThrough(passedThrough);
            passedThroughFacing.add(entity.getFacing());
            entity.setPassedThroughFacing(passedThroughFacing);
            // We may still need to process any conversions for dropping LAMs
            if (entity instanceof LandAirMech && md.contains(MovePath.MoveStepType.CONVERT_MODE)) {
                entity.setMovementMode(md.getFinalConversionMode());
                entity.setConvertingNow(true);
                r = new Report(1210);
                r.subject = entity.getId();
                r.addDesc(entity);
                if (entity.getMovementMode() == EntityMovementMode.WIGE) {
                    r.messageId = 2452;
                } else if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {
                    r.messageId = 2453;
                } else {
                    r.messageId = 2450;
                }
                addReport(r);
            }
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        // iterate through steps
        firstStep = true;
        turnOver = false;
        /* Bug 754610: Revert fix for bug 702735. */
        MoveStep prevStep = null;

        List<Entity> hiddenEnemies = new ArrayList<>();
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {
            for (Entity e : game.getEntitiesVector()) {
                if (e.isHidden() && e.isEnemyOf(entity) && (e.getPosition() != null)) {
                    hiddenEnemies.add(e);
                }
            }
        }

        Vector<UnitLocation> movePath = new Vector<>();
        EntityMovementType lastStepMoveType = md.getLastStepMovementType();
        for (final Enumeration<MoveStep> i = md.getSteps(); i.hasMoreElements();) {
            final MoveStep step = i.nextElement();
            EntityMovementType stepMoveType = step.getMovementType(md.isEndStep(step));
            wasProne = entity.isProne();
            boolean isPavementStep = step.isPavementStep();
            entity.inReverse = step.isThisStepBackwards();
            boolean entityFellWhileAttemptingToStand = false;
            boolean isOnGround = !i.hasMoreElements();
            isOnGround |= stepMoveType != EntityMovementType.MOVE_JUMP;
            isOnGround &= step.getElevation() < 1;

            // Check for hidden units point blank shots
            if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {
                for (Entity e : hiddenEnemies) {
                    int dist = e.getPosition().distance(step.getPosition());
                    // Checking for same hex and stacking violation
                    if ((dist == 0) && !continueTurnFromPBS
                            && (Compute.stackingViolation(game, entity.getId(),
                            step.getPosition()) != null)) {
                        // Moving into hex of a hidden unit detects the unit
                        e.setHidden(false);
                        entityUpdate(e.getId());
                        r = new Report(9960);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        r.add(e.getPosition().getBoardNum());
                        vPhaseReport.addElement(r);
                        // Report the block
                        if (doBlind()) {
                            r = new Report(9961);
                            r.subject = e.getId();
                            r.addDesc(e);
                            r.addDesc(entity);
                            r.add(step.getPosition().getBoardNum());
                            addReport(r);
                        }
                        // Report halted movement
                        r = new Report(9962);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(step.getPosition().getBoardNum());
                        addReport(r);
                        addNewLines();
                        Report.addNewline(vPhaseReport);
                        // If we aren't at the end, send a special report
                        if ((game.getTurnIndex() + 1) < game.getTurnVector().size()) {
                            send(e.getOwner().getId(), createSpecialReportPacket());
                            send(entity.getOwner().getId(), createSpecialReportPacket());
                        }
                        entity.setDone(true);
                        entityUpdate(entity.getId(), movePath, true, losCache);
                        return;
                        // Potential point-blank shot
                    } else if ((dist == 1) && !e.madePointblankShot()) {
                        entity.setPosition(step.getPosition());
                        entity.setFacing(step.getFacing());
                        // If not set, BV icons could have wrong facing
                        entity.setSecondaryFacing(step.getFacing());
                        // Update entity position on client
                        send(e.getOwnerId(), createEntityPacket(entity.getId(), null));
                        boolean tookPBS = processPointblankShotCFR(e, entity);
                        // Movement should be interrupted
                        if (tookPBS) {
                            // Attacking reveals hidden unit
                            e.setHidden(false);
                            entityUpdate(e.getId());
                            r = new Report(9960);
                            r.addDesc(entity);
                            r.subject = entity.getId();
                            r.add(e.getPosition().getBoardNum());
                            vPhaseReport.addElement(r);
                            continueTurnFromPBS = true;

                            curFacing = entity.getFacing();
                            curPos = entity.getPosition();
                            mpUsed = step.getMpUsed();
                            break;
                        }
                    }
                }
            }

            // stop for illegal movement
            if (stepMoveType == EntityMovementType.MOVE_ILLEGAL) {
                break;
            }

            // Extra damage if first and last hex are magma
            if (firstStep) {
                firstHex = game.getBoard().getHex(curPos);
            }
            // stop if the entity already killed itself
            if (entity.isDestroyed() || entity.isDoomed()) {
                break;
            }

            if (entity.getMovementMode() == EntityMovementMode.WIGE) {
                if (step.getType() == MovePath.MoveStepType.UP && !entity.isAirborneVTOLorWIGE()) {
                    entity.setWigeLiftoffHover(true);
                } else if (step.getType() == MovePath.MoveStepType.HOVER) {
                    entity.setWigeLiftoffHover(true);
                    entity.setAssaultDropInProgress(false);
                } else if (step.getType() == MovePath.MoveStepType.DOWN && step.getClearance() == 0) {
                    // If this is the first step, use the Entity's starting elevation
                    int elevation = (prevStep == null) ? entity.getElevation() : prevStep.getElevation();
                    if (entity instanceof LandAirMech) {
                        addReport(landAirMech((LandAirMech) entity, step.getPosition(), elevation,
                                distance));
                    } else if (entity instanceof Protomech) {
                        addReport(landGliderPM((Protomech) entity, step.getPosition(), elevation,
                                distance));
                    }
                    // landing always ends movement whether successful or not
                }
            }

            // check for MASC failure on first step
            // also check Tanks because they can have superchargers that act
            // like MASc
            if (firstStep && ((entity instanceof Mech) || (entity instanceof Tank))) {
                // Not necessarily a fall, but we need to give them a new turn to plot movement with
                // likely reduced MP.
                fellDuringMovement = checkMASCFailure(entity, md) || checkSuperchargerFailure(entity, md);
            }

            if (firstStep) {
                rollTarget = entity.checkGunningIt(overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                            curPos, rollTarget, false);
                    if (mof > 0) {
                        // Since this is the first step, we don't have a previous step so we'll pass
                        // this one in case it's needed to process a skid.
                        if (processFailedVehicleManeuver(entity, curPos, 0, step,
                                step.isThisStepBackwards(), lastStepMoveType, distance, 2, mof)) {
                            if (md.hasActiveMASC() || md.hasActiveSupercharger()) {
                                mpUsed = entity.getRunMP();
                            } else {
                                mpUsed = entity.getRunMPwithoutMASC();
                            }

                            turnOver = true;
                            distance = entity.delta_distance;
                            curFacing = entity.getFacing();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        } else if (entity.getFacing() != curFacing) {
                            // If the facing doesn't change we had a minor fishtail that doesn't require
                            // stopping movement.
                            continueTurnFromFishtail = true;
                            curFacing = entity.getFacing();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        }
                    }
                }
            }

            // Check for failed maneuver for overdrive on first step. The rules for overdrive do not
            // state this explicitly, but since combining overdrive with gunning it requires two rolls
            // and gunning does state explicitly that the roll is made before movement, this
            // implies the same for overdrive.
            if (firstStep && (overallMoveType == EntityMovementType.MOVE_SPRINT
                    || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
                rollTarget = entity.checkUsingOverdrive(EntityMovementType.MOVE_SPRINT);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                            curPos, rollTarget, false);
                    if (mof > 0) {
                        if (processFailedVehicleManeuver(entity, curPos, 0, step, step.isThisStepBackwards(),
                                lastStepMoveType, distance, 2, mof)) {
                            if (md.hasActiveMASC() || md.hasActiveSupercharger()) {
                                mpUsed = entity.getRunMP();
                            } else {
                                mpUsed = entity.getRunMPwithoutMASC();
                            }

                            turnOver = true;
                            distance = entity.delta_distance;
                            curFacing = entity.getFacing();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        } else if (entity.getFacing() != curFacing) {
                            // If the facing doesn't change we had a minor fishtail that doesn't require
                            // stopping movement.
                            continueTurnFromFishtail = true;
                            curFacing = entity.getFacing();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        }
                    }
                }
            }

            if (step.getType() == MovePath.MoveStepType.CONVERT_MODE) {
                entity.setConvertingNow(true);

                // Non-omni QuadVees converting to vehicle mode dump any riding BA in the
                // starting hex if they fail to make an anti-mech check.
                // http://bg.battletech.com/forums/index.php?topic=55263.msg1271423#msg1271423
                if (entity instanceof QuadVee && entity.getConversionMode() == QuadVee.CONV_MODE_MECH
                        && !entity.isOmni()) {
                    for (Entity rider : entity.getExternalUnits()) {
                        addReport(checkDropBAFromConverting(entity, rider, curPos, curFacing,
                                false, false, false));
                    }
                } else if ((entity.getEntityType() & Entity.ETYPE_LAND_AIR_MECH) != 0) {
                    //External units on LAMs, including swarmers, fall automatically and take damage,
                    // and the LAM itself may take one or more criticals.
                    for (Entity rider : entity.getExternalUnits()) {
                        addReport(checkDropBAFromConverting(entity, rider, curPos, curFacing, true, true, true));
                    }
                    final int swarmerId = entity.getSwarmAttackerId();
                    if (Entity.NONE != swarmerId) {
                        addReport(checkDropBAFromConverting(entity, game.getEntity(swarmerId),
                                curPos, curFacing, true, true, true));
                    }
                }

                continue;
            }

            // did the entity move?
            didMove = step.getDistance() > distance;

            // check for aero stuff
            if (entity.isAirborne() && entity.isAero()) {
                IAero a = (IAero) entity;
                j++;

                // increment straight moves (can't do it at end, because not all
                // steps may be processed)
                a.setStraightMoves(step.getNStraight());

                // TODO : change the way this check is made
                if (!didMove && (md.length() != j)) {
                    thrustUsed += step.getMp();
                } else {
                    // if this was the last move and distance was zero, then add
                    // thrust
                    if (!didMove && (md.length() == j)) {
                        thrustUsed += step.getMp();
                    }
                    // then we moved to a new hex or the last step so check
                    // conditions
                    // structural damage
                    rollTarget = a.checkThrustSI(thrustUsed, overallMoveType);
                    if ((rollTarget.getValue() != TargetRoll.CHECK_FALSE)
                            && !(entity instanceof FighterSquadron) && !game.useVectorMove()) {
                        if (!doSkillCheckInSpace(entity, rollTarget)) {
                            a.setSI(a.getSI() - 1);
                            if (entity instanceof LandAirMech) {
                                addReport(criticalEntity(entity, Mech.LOC_CT, false, 0, 1));
                            }
                            // check for destruction
                            if (a.getSI() == 0) {
                                // Lets auto-eject if we can!
                                if (a instanceof LandAirMech) {
                                    // LAMs eject if the CT destroyed switch is on
                                    LandAirMech lam = (LandAirMech) a;
                                    if (lam.isAutoEject()
                                            && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                            || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                            && lam.isCondEjectCTDest()))) {
                                        addReport(ejectEntity(entity, true, false));
                                    }
                                } else {
                                    // Aeros eject if the SI Destroyed switch is on
                                    Aero aero = (Aero) a;
                                    if (aero.isAutoEject()
                                            && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                            || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                            && aero.isCondEjectSIDest()))) {
                                        addReport(ejectEntity(entity, true, false));
                                    }
                                }
                                addReport(destroyEntity(entity, "Structural Integrity Collapse",
                                        false));
                            }
                        }
                    }

                    // check for pilot damage
                    int hits = entity.getCrew().getHits();
                    int health = 6 - hits;

                    if ((thrustUsed > (2 * health)) && !game.useVectorMove()
                            && !(entity instanceof TeleMissile)) {
                        int targetRoll = 2 + (thrustUsed - (2 * health))
                                + (2 * hits);
                        resistGForce(entity, targetRoll);
                    }

                    thrustUsed = 0;
                }

                if (step.getType() == MovePath.MoveStepType.RETURN) {
                    a.setCurrentVelocity(md.getFinalVelocity());
                    entity.setAltitude(curAltitude);
                    processLeaveMap(md, true, Compute.roundsUntilReturn(game, entity));
                    return;
                }

                if (step.getType() == MovePath.MoveStepType.OFF) {
                    a.setCurrentVelocity(md.getFinalVelocity());
                    entity.setAltitude(curAltitude);
                    processLeaveMap(md, true, -1);
                    return;
                }

                rollTarget = a.checkRolls(step, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(entity.getId(), 0, "excess roll"));
                }

                rollTarget = a.checkManeuver(step, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    if (!doSkillCheckManeuver(entity, rollTarget)) {
                        a.setFailedManeuver(true);
                        int forward = Math.max(step.getVelocityLeft() / 2, 1);
                        if (forward < step.getVelocityLeft()) {
                            fellDuringMovement = true;
                        }
                        // multiply forward by 16 when on ground hexes
                        if (game.getBoard().onGround()) {
                            forward *= 16;
                        }
                        while (forward > 0) {
                            curPos = curPos.translated(step.getFacing());
                            forward--;
                            distance++;
                            a.setStraightMoves(a.getStraightMoves() + 1);
                            // make sure it didn't fly off the map
                            if (!game.getBoard().contains(curPos)) {
                                a.setCurrentVelocity(md.getFinalVelocity());
                                processLeaveMap(md, true, Compute.roundsUntilReturn(game, entity));
                                return;
                                // make sure it didn't crash
                            } else if (checkCrash(entity, curPos, step.getAltitude())) {
                                addReport(processCrash(entity, step.getVelocity(), curPos));
                                forward = 0;
                                fellDuringMovement = false;
                                crashedDuringMovement = true;
                            }
                        }
                        break;
                    }
                }

                // if out of control, check for possible collision
                if (didMove && a.isOutControlTotal()) {
                    Iterator<Entity> targets = game.getEntities(step.getPosition());
                    if (targets.hasNext()) {
                        // Somebody here so check to see if there is a collision
                        int checkRoll = Compute.d6(2);
                        // TODO : change this to 11 for Large Craft
                        int targetRoll = 11;
                        if ((a instanceof Dropship) || (entity instanceof Jumpship)) {
                            targetRoll = 10;
                        }
                        if (checkRoll >= targetRoll) {
                            // this gets complicated, I need to check for each
                            // unit type
                            // by order of movement sub-phase
                            Vector<Integer> potentialSpaceStation = new Vector<>();
                            Vector<Integer> potentialWarShip = new Vector<>();
                            Vector<Integer> potentialJumpShip = new Vector<>();
                            Vector<Integer> potentialDropShip = new Vector<>();
                            Vector<Integer> potentialSmallCraft = new Vector<>();
                            Vector<Integer> potentialASF = new Vector<>();

                            while (targets.hasNext()) {
                                int id = targets.next().getId();
                                Entity ce = game.getEntity(id);
                                // if we are in atmosphere and not the same altitude
                                // then skip
                                if (!game.getBoard().inSpace() && (ce.getAltitude() != curAltitude)) {
                                    continue;
                                }
                                // you can't collide with yourself
                                if (ce.equals(a)) {
                                    continue;
                                }
                                if (ce instanceof SpaceStation) {
                                    potentialSpaceStation.addElement(id);
                                } else if (ce instanceof Warship) {
                                    potentialWarShip.addElement(id);
                                } else if (ce instanceof Jumpship) {
                                    potentialJumpShip.addElement(id);
                                } else if (ce instanceof Dropship) {
                                    potentialDropShip.addElement(id);
                                } else if (ce instanceof SmallCraft) {
                                    potentialSmallCraft.addElement(id);
                                } else {
                                    // ASF can actually include anything,
                                    // because we might
                                    // have combat dropping troops
                                    potentialASF.addElement(id);
                                }
                            }

                            // ok now go through and see if these have anybody in them
                            int chosen;
                            Entity target;
                            Coords destination;

                            if (!potentialSpaceStation.isEmpty()) {
                                chosen = Compute.randomInt(potentialSpaceStation.size());
                                target = game.getEntity(potentialSpaceStation.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            } else if (!potentialWarShip.isEmpty()) {
                                chosen = Compute.randomInt(potentialWarShip.size());
                                target = game.getEntity(potentialWarShip.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            } else if (!potentialJumpShip.isEmpty()) {
                                chosen = Compute.randomInt(potentialJumpShip.size());
                                target = game.getEntity(potentialJumpShip.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            } else if (!potentialDropShip.isEmpty()) {
                                chosen = Compute.randomInt(potentialDropShip.size());
                                target = game.getEntity(potentialDropShip.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            } else if (!potentialSmallCraft.isEmpty()) {
                                chosen = Compute.randomInt(potentialSmallCraft.size());
                                target = game.getEntity(potentialSmallCraft.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            } else if (!potentialASF.isEmpty()) {
                                chosen = Compute.randomInt(potentialASF.size());
                                target = game.getEntity(potentialASF.elementAt(chosen));
                                destination = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = destination;
                                    break;
                                }
                            }
                        }
                    }
                }

                // if in the atmosphere, check for a potential crash
                if (checkCrash(entity, step.getPosition(), step.getAltitude())) {
                    addReport(processCrash(entity, md.getFinalVelocity(), curPos));
                    crashedDuringMovement = true;
                    // don't do the rest
                    break;
                }

                // handle fighter launching
                if (step.getType() == MovePath.MoveStepType.LAUNCH) {
                    TreeMap<Integer, Vector<Integer>> launched = step.getLaunched();
                    Set<Integer> bays = launched.keySet();
                    Iterator<Integer> bayIter = bays.iterator();
                    Bay currentBay;
                    while (bayIter.hasNext()) {
                        int bayId = bayIter.next();
                        currentBay = entity.getFighterBays().elementAt(bayId);
                        Vector<Integer> launches = launched.get(bayId);
                        int nLaunched = launches.size();
                        // need to make some decisions about how to handle the
                        // distribution
                        // of fighters to doors beyond the launch rate. The most
                        // sensible thing
                        // is probably to distribute them evenly.
                        int doors = currentBay.getCurrentDoors();
                        int[] distribution = new int[doors];
                        for (int l = 0; l < nLaunched; l++) {
                            distribution[l % doors] = distribution[l % doors] + 1;
                        }
                        // ok, now lets launch them
                        r = new Report(9380);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nLaunched);
                        r.add("bay " + currentBay.getBayNumber() + " (" + doors + " doors)");
                        addReport(r);
                        int currentDoor = 0;
                        int fighterCount = 0;
                        boolean doorDamage = false;
                        for (int fighterId : launches) {
                            // check to see if we are in the same door
                            fighterCount++;

                            // check for door damage
                            Report doorReport = null;
                            if (!doorDamage && (distribution[currentDoor] > 2) && (fighterCount > 2)) {
                                doorReport = new Report(9378);
                                doorReport.subject = entity.getId();
                                doorReport.indent(2);
                                int roll = Compute.d6(2);
                                doorReport.add(roll);
                                if (roll == 2) {
                                    doorDamage = true;
                                    doorReport.choose(true);
                                    currentBay.destroyDoorNext();
                                } else {
                                    doorReport.choose(false);
                                }
                                doorReport.newlines++;
                            }

                            if (fighterCount > distribution[currentDoor]) {
                                // move to a new door
                                currentDoor++;
                                fighterCount = 0;
                                doorDamage = false;
                            }
                            int bonus = Math.max(0,
                                    distribution[currentDoor] - 2);

                            Entity fighter = game.getEntity(fighterId);
                            if (!launchUnit(entity, fighter, curPos, curFacing, step.getVelocity(),
                                    step.getAltitude(), step.getVectors(), bonus)) {
                                LogManager.getLogger().error("Server was told to unload "
                                        + fighter.getDisplayName() + " from " + entity.getDisplayName()
                                        + " into " + curPos.getBoardNum());
                            }
                            if (doorReport != null) {
                                addReport(doorReport);
                            }
                        }
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                }

                // handle DropShip undocking
                if (step.getType() == MovePath.MoveStepType.UNDOCK) {
                    TreeMap<Integer, Vector<Integer>> launched = step.getLaunched();
                    Set<Integer> collars = launched.keySet();
                    Iterator<Integer> collarIter = collars.iterator();
                    while (collarIter.hasNext()) {
                        int collarId = collarIter.next();
                        Vector<Integer> launches = launched.get(collarId);
                        int nLaunched = launches.size();
                        // ok, now lets launch them
                        r = new Report(9380);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nLaunched);
                        r.add("collar " + collarId);
                        addReport(r);
                        for (int dropShipId : launches) {
                            // check to see if we are in the same door
                            Entity ds = game.getEntity(dropShipId);
                            if (!launchUnit(entity, ds, curPos, curFacing,
                                    step.getVelocity(), step.getAltitude(),
                                    step.getVectors(), 0)) {
                                LogManager.getLogger().error("Error! Server was told to unload "
                                        + ds.getDisplayName() + " from "
                                        + entity.getDisplayName() + " into "
                                        + curPos.getBoardNum());
                            }
                        }
                    }
                }

                // handle combat drops
                if (step.getType() == MovePath.MoveStepType.DROP) {
                    TreeMap<Integer, Vector<Integer>> dropped = step.getLaunched();
                    Set<Integer> bays = dropped.keySet();
                    Iterator<Integer> bayIter = bays.iterator();
                    Bay currentBay;
                    while (bayIter.hasNext()) {
                        int bayId = bayIter.next();
                        currentBay = entity.getTransportBays().elementAt(bayId);
                        Vector<Integer> drops = dropped.get(bayId);
                        int nDropped = drops.size();
                        // ok, now lets drop them
                        r = new Report(9386);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nDropped);
                        addReport(r);
                        for (int unitId : drops) {
                            if (Compute.d6(2) == 2) {
                                r = new Report(9390);
                                r.subject = entity.getId();
                                r.indent(1);
                                r.add(currentBay.getType());
                                addReport(r);
                                currentBay.destroyDoorNext();
                            }
                            Entity drop = game.getEntity(unitId);
                            dropUnit(drop, entity, curPos, step.getAltitude());
                        }
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                }
            }

            // check piloting skill for getting up
            rollTarget = entity.checkGetUp(step, overallMoveType);

            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Unless we're an ICE- or fuel cell-powered IndustrialMech,
                // standing up builds heat.
                if ((entity instanceof Mech) && entity.hasEngine() && !(((Mech) entity).isIndustrial()
                        && ((entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)
                        || (entity.getEngine().getEngineType() == Engine.FUEL_CELL)))) {
                    entity.heatBuildup += 1;
                }
                entity.setProne(false);
                // entity.setHullDown(false);
                wasProne = false;
                game.resetPSRs(entity);
                entityFellWhileAttemptingToStand = !doSkillCheckInPlace(entity, rollTarget);
            }
            // did the entity just fall?
            if (entityFellWhileAttemptingToStand) {
                moveType = stepMoveType;
                curFacing = entity.getFacing();
                curPos = entity.getPosition();
                mpUsed = step.getMpUsed();
                fellDuringMovement = true;
                if (!entity.isCarefulStand()) {
                    break;
                }
            } else if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                entity.setHullDown(false);
            }

            if (step.getType() == MovePath.MoveStepType.UNJAM_RAC) {
                entity.setUnjammingRAC(true);
                game.addAction(new UnjamAction(entity.getId()));

                // for Aeros this will end movement prematurely
                // if we break
                if (!(entity.isAirborne())) {
                    break;
                }
            }

            if (step.getType() == MovePath.MoveStepType.LAY_MINE) {
                layMine(entity, step.getMineToLay(), step.getPosition());
                continue;
            }

            if (step.getType() == MovePath.MoveStepType.CLEAR_MINEFIELD) {
                ClearMinefieldAction cma = new ClearMinefieldAction(entity.getId(), step.getMinefield());
                entity.setClearingMinefield(true);
                game.addAction(cma);
                break;
            }

            if ((step.getType() == MovePath.MoveStepType.SEARCHLIGHT)
                    && entity.hasSearchlight()) {
                final boolean SearchOn = !entity.isUsingSearchlight();
                entity.setSearchlightState(SearchOn);
                if (doBlind()) { // if double blind, we may need to filter the
                    // players that receive this message
                    Vector<Player> playersVector = game.getPlayersVector();
                    Vector<Player> vCanSee = whoCanSee(entity);
                    for (Player p : playersVector) {
                        if (vCanSee.contains(p)) { // Player sees the unit
                            sendServerChat(p.getId(),
                                    entity.getDisplayName()
                                            + " switched searchlight "
                                            + (SearchOn ? "on" : "off") + '.');
                        } else {
                            sendServerChat(p.getId(),
                                    "An unseen unit" + " switched searchlight "
                                            + (SearchOn ? "on" : "off") + '.');
                        }
                    }
                } else { // No double blind, everyone can see this
                    sendServerChat(
                            entity.getDisplayName() + " switched searchlight "
                                    + (SearchOn ? "on" : "off") + '.');
                }
            }

            // set most step parameters
            moveType = stepMoveType;
            distance = step.getDistance();
            mpUsed = step.getMpUsed();

            if (cachedGravityLimit < 0) {
                cachedGravityLimit = EntityMovementType.MOVE_JUMP == moveType
                        ? entity.getJumpMP(false)
                        : entity.getRunningGravityLimit();
            }
            // check for charge
            if (step.getType() == MovePath.MoveStepType.CHARGE) {
                if (entity.canCharge()) {
                    checkExtremeGravityMovement(entity, step, lastStepMoveType,
                            curPos, cachedGravityLimit);
                    Targetable target = step.getTarget(game);
                    if (target != null) {
                        ChargeAttackAction caa = new ChargeAttackAction(
                                entity.getId(), target.getTargetType(),
                                target.getId(), target.getPosition());
                        entity.setDisplacementAttack(caa);
                        game.addCharge(caa);
                        charge = caa;
                    } else {
                        String message = "Illegal charge!! " + entity.getDisplayName() +
                                " is attempting to charge a null target!";
                        LogManager.getLogger().info(message);
                        sendServerChat(message);
                        return;
                    }
                } else if (entity.isAirborneVTOLorWIGE() && entity.canRam()) {
                    checkExtremeGravityMovement(entity, step, lastStepMoveType,
                            curPos, cachedGravityLimit);
                    Targetable target = step.getTarget(game);
                    if (target != null) {
                        AirmechRamAttackAction raa = new AirmechRamAttackAction(
                                entity.getId(), target.getTargetType(),
                                target.getId(), target.getPosition());
                        entity.setDisplacementAttack(raa);
                        entity.setRamming(true);
                        game.addCharge(raa);
                        charge = raa;
                    } else {
                        String message = "Illegal charge!! " + entity.getDisplayName() + " is attempting to charge a null target!";
                        LogManager.getLogger().info(message);
                        sendServerChat(message);
                        return;
                    }
                } else {
                    sendServerChat("Illegal charge!! I don't think "
                            + entity.getDisplayName()
                            + " should be allowed to charge,"
                            + " but the client of "
                            + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                            + entity.getOwner().getName()
                            + " is running MegaMek " + MMConstants.VERSION
                            + ", or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues");
                    return;
                }
                break;
            }

            // check for dfa
            if (step.getType() == MovePath.MoveStepType.DFA) {
                if (entity.canDFA()) {
                    checkExtremeGravityMovement(entity, step, lastStepMoveType, curPos, cachedGravityLimit);
                    Targetable target = step.getTarget(game);

                    int targetType;
                    int targetID;

                    // if it's a valid target, then simply pass along the type and ID
                    if (target != null) {
                        targetID = target.getId();
                        targetType = target.getTargetType();
                        // if the target has become invalid somehow, or was incorrectly declared in the first place
                        // log the error, then put some defaults in for the DFA and proceed as if the target had been moved/destroyed
                    } else {
                        String errorMessage = "Illegal DFA by " + entity.getDisplayName() + " against non-existent entity at " + step.getTargetPosition();
                        sendServerChat(errorMessage);
                        LogManager.getLogger().error(errorMessage);
                        targetID = Entity.NONE;
                        // doesn't really matter, DFA processing will cut out early if target resolves as null
                        targetType = Targetable.TYPE_ENTITY;
                    }

                    DfaAttackAction daa = new DfaAttackAction(entity.getId(),
                            targetType, targetID,
                            step.getPosition());
                    entity.setDisplacementAttack(daa);
                    entity.setElevation(step.getElevation());
                    game.addCharge(daa);
                    charge = daa;

                } else {
                    sendServerChat("Illegal DFA!! I don't think "
                            + entity.getDisplayName()
                            + " should be allowed to DFA,"
                            + " but the client of "
                            + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                            + entity.getOwner().getName()
                            + " is running MegaMek " + MMConstants.VERSION
                            + ", or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues");
                    return;
                }

                break;
            }

            // check for ram
            if (step.getType() == MovePath.MoveStepType.RAM) {
                if (entity.canRam()) {
                    Targetable target = step.getTarget(game);
                    RamAttackAction raa = new RamAttackAction(entity.getId(),
                            target.getTargetType(), target.getId(),
                            target.getPosition());
                    entity.setRamming(true);
                    game.addRam(raa);
                    ram = raa;
                } else {
                    sendServerChat("Illegal ram!! I don't think "
                            + entity.getDisplayName()
                            + " should be allowed to charge,"
                            + " but the client of "
                            + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                            + entity.getOwner().getName()
                            + " is running MegaMek " + MMConstants.VERSION
                            + ", or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues");
                    return;
                }
                break;
            }

            if (step.isVTOLBombingStep()) {
                ((IBomber) entity).setVTOLBombTarget(step.getTarget(game));
            } else if (step.isStrafingStep() && (entity instanceof VTOL)) {
                ((VTOL) entity).getStrafingCoords().add(step.getPosition());
            }

            if ((step.getType() == MovePath.MoveStepType.ACC) || (step.getType() == MovePath.MoveStepType.ACCN)) {
                if (entity.isAero()) {
                    IAero a = (IAero) entity;
                    if (step.getType() == MovePath.MoveStepType.ACCN) {
                        a.setAccLast(true);
                    } else {
                        a.setAccDecNow(true);
                        a.setCurrentVelocity(a.getCurrentVelocity() + 1);
                    }
                    a.setNextVelocity(a.getNextVelocity() + 1);
                }
            }

            if ((step.getType() == MovePath.MoveStepType.DEC) || (step.getType() == MovePath.MoveStepType.DECN)) {
                if (entity.isAero()) {
                    IAero a = (IAero) entity;
                    if (step.getType() == MovePath.MoveStepType.DECN) {
                        a.setAccLast(true);
                    } else {
                        a.setAccDecNow(true);
                        a.setCurrentVelocity(a.getCurrentVelocity() - 1);
                    }
                    a.setNextVelocity(a.getNextVelocity() - 1);
                }
            }

            if (step.getType() == MovePath.MoveStepType.EVADE) {
                entity.setEvading(true);
            }

            if (step.getType() == MovePath.MoveStepType.BRACE) {
                entity.setBraceLocation(step.getBraceLocation());
            }

            if (step.getType() == MovePath.MoveStepType.SHUTDOWN) {
                entity.performManualShutdown();
                sendServerChat(entity.getDisplayName() + " has shutdown.");
            }

            if (step.getType() == MovePath.MoveStepType.STARTUP) {
                entity.performManualStartup();
                sendServerChat(entity.getDisplayName() + " has started up.");
            }

            if (step.getType() == MovePath.MoveStepType.SELF_DESTRUCT) {
                entity.setSelfDestructing(true);
            }

            if (step.getType() == MovePath.MoveStepType.ROLL) {
                if (entity.isAero()) {
                    IAero a = (IAero) entity;
                    a.setRolled(!a.isRolled());
                }
            }

            // check for dig in or fortify
            if (entity instanceof Infantry) {
                Infantry inf = (Infantry) entity;
                if (step.getType() == MovePath.MoveStepType.DIG_IN) {
                    inf.setDugIn(Infantry.DUG_IN_WORKING);
                    continue;
                } else if (step.getType() == MovePath.MoveStepType.FORTIFY) {
                    if (!inf.hasWorkingMisc(MiscType.F_TRENCH_CAPABLE)) {
                        sendServerChat(entity.getDisplayName()
                                + " failed to fortify because it is missing suitable equipment");
                    }
                    inf.setDugIn(Infantry.DUG_IN_FORTIFYING1);
                    continue;
                } else if ((step.getType() != MovePath.MoveStepType.TURN_LEFT)
                        && (step.getType() != MovePath.MoveStepType.TURN_RIGHT)) {
                    // other movement clears dug in status
                    inf.setDugIn(Infantry.DUG_IN_NONE);
                }

                if (step.getType() == MovePath.MoveStepType.TAKE_COVER) {
                    if (Infantry.hasValidCover(game, step.getPosition(),
                            step.getElevation())) {
                        inf.setTakingCover(true);
                    } else {
                        sendServerChat(entity.getDisplayName()
                                + " failed to take cover: "
                                + "no valid unit found in "
                                + step.getPosition());
                    }
                }
            }

            // check for tank fortify
            if (entity instanceof Tank) {
                Tank tnk = (Tank) entity;
                if (step.getType() == MovePath.MoveStepType.FORTIFY) {
                    if (!tnk.hasWorkingMisc(MiscType.F_TRENCH_CAPABLE)) {
                        sendServerChat(entity.getDisplayName()
                                + " failed to fortify because it is missing suitable equipment");
                    }
                    tnk.setDugIn(Tank.DUG_IN_FORTIFYING1);
                }
            }

            // If we have turned, check whether we have fulfilled any turn mode requirements.
            if ((step.getType() == MovePath.MoveStepType.TURN_LEFT || step.getType() == MovePath.MoveStepType.TURN_RIGHT)
                    && entity.usesTurnMode()) {
                int straight = 0;
                if (prevStep != null) {
                    straight = prevStep.getNStraight();
                }
                rollTarget = entity.checkTurnModeFailure(overallMoveType, straight,
                        md.getMpUsed(), step.getPosition());
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                            curPos, rollTarget, false);
                    if (mof > 0) {
                        if (processFailedVehicleManeuver(entity, curPos,
                                step.getFacing() - curFacing,
                                (null == prevStep) ?step : prevStep,
                                step.isThisStepBackwards(),
                                lastStepMoveType, distance, mof, mof)) {
                            if (md.hasActiveMASC() || md.hasActiveSupercharger()) {
                                mpUsed = entity.getRunMP();
                            } else {
                                mpUsed = entity.getRunMPwithoutMASC();
                            }

                            turnOver = true;
                            distance = entity.delta_distance;
                        } else {
                            continueTurnFromFishtail = true;
                        }
                        curFacing = entity.getFacing();
                        curPos = entity.getPosition();
                        entity.setSecondaryFacing(curFacing);
                        break;
                    }
                }
            }

            if (step.getType() == MovePath.MoveStepType.BOOTLEGGER) {
                rollTarget = entity.getBasePilotingRoll();
                entity.addPilotingModifierForTerrain(rollTarget);
                rollTarget.addModifier(0, "bootlegger maneuver");
                int mof = doSkillCheckWhileMoving(entity, lastElevation,
                        curPos, curPos, rollTarget, false);
                if (mof > 0) {
                    // If the bootlegger maneuver fails, we treat it as a turn in a random direction.
                    processFailedVehicleManeuver(entity, curPos, Compute.d6() < 4 ? -1 : 1,
                            (null == prevStep) ? step : prevStep,
                            step.isThisStepBackwards(), lastStepMoveType, distance, 2, mof);
                    curFacing = entity.getFacing();
                    curPos = entity.getPosition();
                    break;
                }
            }

            // set last step parameters
            curPos = step.getPosition();
            if (!((entity.getJumpType() == Mech.JUMP_BOOSTER) && step.isJumping())) {
                curFacing = step.getFacing();
            }
            // check if a building PSR will be needed later, before setting the
            // new elevation
            int buildingMove = entity.checkMovementInBuilding(step, prevStep, curPos, lastPos);
            curVTOLElevation = step.getElevation();
            curAltitude = step.getAltitude();
            curElevation = step.getElevation();
            curClimbMode = step.climbMode();
            // set elevation in case of collapses
            entity.setElevation(step.getElevation());
            // set climb mode in case of skid
            entity.setClimbMode(curClimbMode);

            Hex curHex = game.getBoard().getHex(curPos);

            // when first entering a building, we need to roll what type
            // of basement it has
            if (isOnGround && curHex.containsTerrain(Terrains.BUILDING)) {
                Building bldg = game.getBoard().getBuildingAt(curPos);
                if (bldg.rollBasement(curPos, game.getBoard(), vPhaseReport)) {
                    sendChangedHex(curPos);
                    Vector<Building> buildings = new Vector<>();
                    buildings.add(bldg);
                    sendChangedBuildings(buildings);
                }
            }

            // check for automatic unstick
            if (entity.canUnstickByJumping() && entity.isStuck()
                    && (moveType == EntityMovementType.MOVE_JUMP)) {
                entity.setStuck(false);
                entity.setCanUnstickByJumping(false);
            }

            // check for leap
            if (!lastPos.equals(curPos)
                    && (stepMoveType != EntityMovementType.MOVE_JUMP) && (entity instanceof Mech)
                    && !entity.isAirborne() && (step.getClearance() <= 0)  // Don't check airborne LAMs
                    && game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEAPING)) {
                int leapDistance = (lastElevation
                        + game.getBoard().getHex(lastPos).getLevel())
                        - (curElevation + curHex.getLevel());
                if (leapDistance > 2) {
                    // skill check for leg damage
                    rollTarget = entity.getBasePilotingRoll(stepMoveType);
                    entity.addPilotingModifierForTerrain(rollTarget, curPos);
                    rollTarget.append(new PilotingRollData(entity.getId(),
                            2 * leapDistance, "leaping (leg damage)"));
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                            lastPos, curPos, rollTarget, false)) {
                        // do leg damage
                        addReport(damageEntity(entity, new HitData(Mech.LOC_LLEG), leapDistance));
                        addReport(damageEntity(entity, new HitData(Mech.LOC_RLEG), leapDistance));
                        addNewLines();
                        addReport(criticalEntity(entity, Mech.LOC_LLEG, false, 0, 0));
                        addNewLines();
                        addReport(criticalEntity(entity, Mech.LOC_RLEG, false, 0, 0));
                        if (entity instanceof QuadMech) {
                            addReport(damageEntity(entity, new HitData(Mech.LOC_LARM), leapDistance));
                            addReport(damageEntity(entity, new HitData(Mech.LOC_RARM), leapDistance));
                            addNewLines();
                            addReport(criticalEntity(entity, Mech.LOC_LARM, false, 0, 0));
                            addNewLines();
                            addReport(criticalEntity(entity, Mech.LOC_RARM, false, 0, 0));
                        }
                    }
                    // skill check for fall
                    rollTarget = entity.getBasePilotingRoll(stepMoveType);
                    entity.addPilotingModifierForTerrain(rollTarget, curPos);
                    rollTarget.append(new PilotingRollData(entity.getId(),
                            leapDistance, "leaping (fall)"));
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                            lastPos, curPos, rollTarget, false)) {
                        entity.setElevation(lastElevation);
                        addReport(doEntityFallsInto(entity, lastElevation,
                                lastPos, curPos,
                                entity.getBasePilotingRoll(overallMoveType), false));
                    }
                }
            }

            // Check for skid.
            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,
                    prevStep, step, prevFacing, curFacing, lastPos, curPos,
                    isInfantry, distance - 1);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Have an entity-meaningful PSR message.
                boolean psrFailed;
                int startingFacing = entity.getFacing();
                if (entity instanceof Mech) {
                    // We need to ensure that falls will happen from the proper
                    // facing
                    entity.setFacing(curFacing);
                    psrFailed = (0 < doSkillCheckWhileMoving(entity,
                            lastElevation, lastPos, lastPos, rollTarget, true));
                } else {
                    psrFailed = (0 < doSkillCheckWhileMoving(entity,
                            lastElevation, lastPos, lastPos, rollTarget, false));
                }

                // Does the entity skid?
                if (psrFailed) {

                    if (entity instanceof Tank) {
                        addReport(vehicleMotiveDamage((Tank) entity, 0));
                    }

                    curPos = lastPos;
                    int skidDistance = (int) Math.round((double) (distance - 1) / 2);
                    int skidDirection = prevFacing;

                    // All charge damage is based upon
                    // the pre-skid move distance.
                    entity.delta_distance = distance - 1;

                    // Attacks against a skidding target have additional +2.
                    moveType = EntityMovementType.MOVE_SKID;

                    // What is the first hex in the skid?
                    if (step.isThisStepBackwards()) {
                        skidDirection = (skidDirection + 3) % 6;
                    }

                    if (processSkid(entity, curPos, prevStep.getElevation(),
                            skidDirection, skidDistance, prevStep,
                            lastStepMoveType)) {
                        return;
                    }

                    // set entity parameters
                    curFacing = entity.getFacing();
                    curPos = entity.getPosition();
                    entity.setSecondaryFacing(curFacing);

                    // skid consumes all movement
                    if (md.hasActiveMASC() || md.hasActiveSupercharger()) {
                        mpUsed = entity.getRunMP();
                    } else {
                        mpUsed = entity.getRunMPwithoutMASC();
                    }

                    entity.moved = moveType;
                    fellDuringMovement = true;
                    turnOver = true;
                    distance = entity.delta_distance;
                    break;

                } else { // End failed-skid-psr
                    // If the check succeeded, restore the facing we had before
                    // if it failed, the fall will have changed facing
                    entity.setFacing(startingFacing);
                }

            } // End need-skid-psr

            // check sideslip
            if ((entity instanceof VTOL)
                    || (entity.getMovementMode() == EntityMovementMode.HOVER)
                    || (entity.getMovementMode() == EntityMovementMode.WIGE
                    && step.getClearance() > 0)) {
                rollTarget = entity.checkSideSlip(moveType, prevHex,
                        overallMoveType, prevStep, prevFacing, curFacing,
                        lastPos, curPos, distance);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    int moF = doSkillCheckWhileMoving(entity, lastElevation,
                            lastPos, curPos, rollTarget, false);
                    if (moF > 0) {
                        int elev;
                        int sideslipDistance;
                        int skidDirection;
                        Coords start;
                        if (step.getType() == MovePath.MoveStepType.LATERAL_LEFT
                                || step.getType() == MovePath.MoveStepType.LATERAL_RIGHT
                                || step.getType() == MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS
                                || step.getType() == MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS) {
                            // A failed controlled sideslip always results in moving one additional hex
                            // in the direction of the intentional sideslip.
                            elev = step.getElevation();
                            sideslipDistance = 1;
                            skidDirection = lastPos.direction(curPos);
                            start = curPos;
                        } else {
                            elev = (null == prevStep) ? curElevation : prevStep.getElevation();
                            // maximum distance is hexes moved / 2
                            sideslipDistance = Math.min(moF, distance / 2);
                            skidDirection = prevFacing;
                            start = lastPos;
                        }
                        if (sideslipDistance > 0) {
                            sideslipped = true;
                            r = new Report(2100);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(sideslipDistance);
                            addReport(r);

                            if (processSkid(entity, start, elev, skidDirection,
                                    sideslipDistance, (null == prevStep) ? step : prevStep,
                                    lastStepMoveType)) {
                                return;
                            }

                            if (!entity.isDestroyed() && !entity.isDoomed()
                                    && (mpUsed < entity.getRunMP())) {
                                fellDuringMovement = true; // No, but it should
                                // work...
                            }

                            if ((entity.getElevation() == 0)
                                    && ((entity.getMovementMode() == EntityMovementMode.VTOL)
                                    || (entity.getMovementMode() == EntityMovementMode.WIGE))) {
                                turnOver = true;
                            }
                            // set entity parameters
                            curFacing = step.getFacing();
                            curPos = entity.getPosition();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        }
                    }
                }
            }

            // check if we've moved into rubble
            boolean isLastStep = step.equals(md.getLastStep());
            rollTarget = entity.checkRubbleMove(step, overallMoveType, curHex,
                    lastPos, curPos, isLastStep, isPavementStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos,
                        rollTarget, true);
            }

            // check if we are using reckless movement
            rollTarget = entity.checkRecklessMove(step, overallMoveType, curHex,
                    lastPos, curPos, prevHex);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                if (entity instanceof Mech) {
                    doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                            curPos, rollTarget, true);
                } else if (entity instanceof Tank) {
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                            lastPos, curPos, rollTarget, false)) {
                        // assume VTOLs in flight are always in clear terrain
                        if ((0 == curHex.terrainsPresent())
                                || (step.getClearance() > 0)) {
                            if (entity instanceof VTOL) {
                                r = new Report(2208);
                            } else {
                                r = new Report(2206);
                            }
                            r.addDesc(entity);
                            r.subject = entity.getId();
                            addReport(r);
                            mpUsed = step.getMpUsed() + 1;
                            fellDuringMovement = true;
                            break;
                        }
                        r = new Report(2207);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        addReport(r);
                        // until we get a rules clarification assume that the
                        // entity is both giver and taker
                        // for charge damage
                        HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                        addReport(damageEntity(entity, hit, ChargeAttackAction
                                .getDamageTakenBy(entity, entity)));
                        turnOver = true;
                        break;
                    }
                }
            }

            // check for breaking magma crust unless we are jumping over the hex
            if (stepMoveType != EntityMovementType.MOVE_JUMP) {
                if (!curPos.equals(lastPos)) {
                    ServerHelper.checkAndApplyMagmaCrust(curHex, step.getElevation(), entity, curPos, false, vPhaseReport, this);
                    ServerHelper.checkEnteringMagma(curHex, step.getElevation(), entity, this);
                }
            }

            // check for last move ending in magma TODO: build report for end of move
            if (!i.hasMoreElements() && curHex.terrainLevel(Terrains.MAGMA) == 2
                    && firstHex.terrainLevel(Terrains.MAGMA) == 2) {
                r = new Report(2404);
                r.addDesc(entity);
                r.subject = entity.getId();
                addReport(r);
                doMagmaDamage(entity, false);
            }

            // check if we've moved into a swamp
            rollTarget = entity.checkBogDown(step, lastStepMoveType, curHex,
                    lastPos, curPos, lastElevation, isPavementStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                if (0 < doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                        curPos, rollTarget, false)) {
                    entity.setStuck(true);
                    entity.setCanUnstickByJumping(true);
                    r = new Report(2081);
                    r.add(entity.getDisplayName());
                    r.subject = entity.getId();
                    addReport(r);
                    // check for quicksand
                    addReport(checkQuickSand(curPos));
                    // check for accidental stacking violation
                    Entity violation = Compute.stackingViolation(game,
                            entity.getId(), curPos);
                    if (violation != null) {
                        // target gets displaced, because of low elevation
                        int direction = lastPos.direction(curPos);
                        Coords targetDest = Compute.getValidDisplacement(game,
                                entity.getId(), curPos, direction);
                        addReport(doEntityDisplacement(violation, curPos,
                                targetDest,
                                new PilotingRollData(violation.getId(), 0,
                                        "domino effect")));
                        // Update the violating entity's position on the client.
                        entityUpdate(violation.getId());
                    }
                    break;
                }
            }

            // check to see if we are a mech and we've moved OUT of fire
            Hex lastHex = game.getBoard().getHex(lastPos);
            if (entity instanceof Mech) {
                if (!lastPos.equals(curPos) && (prevStep != null)
                        && ((lastHex.containsTerrain(Terrains.FIRE)
                        && (prevStep.getElevation() <= 1))
                        || (lastHex.containsTerrain(Terrains.MAGMA)
                        && (prevStep.getElevation() == 0)))
                        && ((stepMoveType != EntityMovementType.MOVE_JUMP)
                        // Bug #828741 -- jumping bypasses fire, but not
                        // on the
                        // first step
                        // getMpUsed -- total MP used to this step
                        // getMp -- MP used in this step
                        // the difference will always be 0 on the "first
                        // step"
                        // of a jump,
                        // and >0 on a step in the midst of a jump
                        || (0 == (step.getMpUsed() - step.getMp())))) {
                    int heat = 0;
                    if (lastHex.containsTerrain(Terrains.FIRE)) {
                        heat += 2;
                    }
                    if (lastHex.terrainLevel(Terrains.MAGMA) == 1) {
                        heat += 2;
                    } else if (lastHex.terrainLevel(Terrains.MAGMA) == 2) {
                        heat += 5;
                    }
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heat /= 2;
                    }
                    entity.heatFromExternal += heat;
                    r = new Report(2115);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(heat);
                    addReport(r);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
            }

            // check to see if we are not a mech and we've moved INTO fire
            if (!(entity instanceof Mech)) {
                boolean underwater = game.getBoard().getHex(curPos)
                        .containsTerrain(Terrains.WATER)
                        && (game.getBoard().getHex(curPos).depth() > 0)
                        && (step.getElevation() < game.getBoard().getHex(curPos).getLevel());
                if (game.getBoard().getHex(curPos).containsTerrain(
                        Terrains.FIRE) && !lastPos.equals(curPos)
                        && (stepMoveType != EntityMovementType.MOVE_JUMP)
                        && (step.getElevation() <= 1) && !underwater) {
                    doFlamingDamage(entity, curPos);
                }
            }

            if ((game.getBoard().getHex(curPos).terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_GREEN)
                    && !stepMoveType.equals(EntityMovementType.MOVE_JUMP) && entity.antiTSMVulnerable()) {
                addReport(doGreenSmokeDamage(entity));
            }

            // check for extreme gravity movement
            if (!i.hasMoreElements() && !firstStep) {
                checkExtremeGravityMovement(entity, step, lastStepMoveType, curPos, cachedGravityLimit);
            }

            // check for revealed minefields;
            // unless we get errata about it, we assume that the check is done
            // every time we enter a new hex
            if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_BAP)
                    && !lastPos.equals(curPos)) {
                if (ServerHelper.detectMinefields(game, entity, curPos, vPhaseReport, this) ||
                        ServerHelper.detectHiddenUnits(game, entity, curPos, vPhaseReport, this)) {
                    detectedHiddenHazard = true;

                    if (i.hasMoreElements() && (stepMoveType != EntityMovementType.MOVE_JUMP)) {
                        md.clear();
                    }
                }
            }

            // check for minefields. have to check both new hex and new elevation
            // VTOLs may land and submarines may rise or lower into a minefield
            // jumping units may end their movement with a turn but should still check at end of movement
            if (!lastPos.equals(curPos) || (lastElevation != curElevation) ||
                    ((stepMoveType == EntityMovementType.MOVE_JUMP) && !i.hasMoreElements())) {
                boolean boom = false;
                if (isOnGround) {
                    boom = checkVibrabombs(entity, curPos, false, lastPos, curPos, vPhaseReport);
                }
                if (game.containsMinefield(curPos)) {
                    // set the new position temporarily, because
                    // infantry otherwise would get double damage
                    // when moving from clear into mined woods
                    entity.setPosition(curPos);
                    if (enterMinefield(entity, curPos, step.getElevation(),
                            isOnGround, vPhaseReport)) {
                        // resolve any piloting rolls from damage unless unit
                        // was jumping
                        if (stepMoveType != EntityMovementType.MOVE_JUMP) {
                            addReport(resolvePilotingRolls(entity));
                            game.resetPSRs(entity);
                        }
                        boom = true;
                    }
                    if (wasProne || !entity.isProne()) {
                        entity.setPosition(lastPos);
                    }
                }
                // did anything go boom?
                if (boom) {
                    // set fell during movement so that entity will get another
                    // chance to move with any motive damage
                    // taken account of (functions the same as MASC failure)
                    // only do this if they had more steps (and they were not
                    // jumping
                    if (i.hasMoreElements() && (stepMoveType != EntityMovementType.MOVE_JUMP)) {
                        md.clear();
                        fellDuringMovement = true;
                    }
                    // reset mines if anything detonated
                    resetMines();
                }
            }

            // infantry discovers minefields if they end their move
            // in a minefield.
            if (!lastPos.equals(curPos) && !i.hasMoreElements() && isInfantry) {
                if (game.containsMinefield(curPos)) {
                    Player owner = entity.getOwner();
                    for (Minefield mf : game.getMinefields(curPos)) {
                        if (!owner.containsMinefield(mf)) {
                            r = new Report(2120);
                            r.subject = entity.getId();
                            r.add(entity.getShortName(), true);
                            addReport(r);
                            revealMinefield(owner, mf);
                        }
                    }
                }
            }

            // check if we've moved into water
            rollTarget = entity.checkWaterMove(step, lastStepMoveType, curHex,
                    lastPos, curPos, isPavementStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Swarmers need special handling.
                final int swarmerId = entity.getSwarmAttackerId();
                boolean swarmerDone = true;
                Entity swarmer = null;
                if (Entity.NONE != swarmerId) {
                    swarmer = game.getEntity(swarmerId);
                    swarmerDone = swarmer.isDone();
                }

                // Now do the skill check.
                entity.setFacing(curFacing);
                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos, rollTarget, true);

                // Swarming infantry platoons may drown.
                if (curHex.terrainLevel(Terrains.WATER) > 1) {
                    drownSwarmer(entity, curPos);
                }

                // Do we need to remove a game turn for the swarmer
                if (!swarmerDone && (swarmer != null)
                        && (swarmer.isDoomed() || swarmer.isDestroyed())) {
                    // We have to diddle with the swarmer's
                    // status to get its turn removed.
                    swarmer.setDone(false);
                    swarmer.setUnloaded(false);

                    // Dead entities don't take turns.
                    game.removeTurnFor(swarmer);
                    send(createTurnVectorPacket());

                    // Return the original status.
                    swarmer.setDone(true);
                    swarmer.setUnloaded(true);
                }

                // check for inferno wash-off
                checkForWashedInfernos(entity, curPos);
            }

            // In water, may or may not be a new hex, necessary to
            // check during movement, for breach damage, and always
            // set dry if appropriate
            // TODO : possibly make the locations local and set later
            addReport(doSetLocationsExposure(entity, curHex,
                    stepMoveType == EntityMovementType.MOVE_JUMP,
                    step.getElevation()));

            // check for breaking ice by breaking through from below
            if ((lastElevation < 0) && (step.getElevation() == 0)
                    && lastHex.containsTerrain(Terrains.ICE)
                    && lastHex.containsTerrain(Terrains.WATER)
                    && (stepMoveType != EntityMovementType.MOVE_JUMP)
                    && !lastPos.equals(curPos)) {
                // need to temporarily reset entity's position so it doesn't
                // fall in the ice
                entity.setPosition(curPos);
                r = new Report(2410);
                r.addDesc(entity);
                addReport(r);
                addReport(resolveIceBroken(lastPos));
                // ok now set back
                entity.setPosition(lastPos);
            }
            // check for breaking ice by stepping on it
            if (curHex.containsTerrain(Terrains.ICE)
                    && curHex.containsTerrain(Terrains.WATER)
                    && (stepMoveType != EntityMovementType.MOVE_JUMP)
                    && !lastPos.equals(curPos) && !(entity instanceof Infantry)
                    && !(isPavementStep && curHex.containsTerrain(Terrains.BRIDGE))) {
                if (step.getElevation() == 0) {
                    int roll = Compute.d6(1);
                    r = new Report(2118);
                    r.addDesc(entity);
                    r.add(roll);
                    r.subject = entity.getId();
                    addReport(r);
                    if (roll == 6) {
                        entity.setPosition(curPos);
                        addReport(resolveIceBroken(curPos));
                        curPos = entity.getPosition();
                    }
                }
                // or intersecting it
                else if ((step.getElevation() + entity.height()) == 0) {
                    r = new Report(2410);
                    r.addDesc(entity);
                    addReport(r);
                    addReport(resolveIceBroken(curPos));
                }
            }

            // Handle loading units.
            if (step.getType() == MovePath.MoveStepType.LOAD) {

                // Find the unit being loaded.
                Entity loaded = null;
                Iterator<Entity> entities = game.getEntities(curPos);
                while (entities.hasNext()) {

                    // Is the other unit friendly and not the current entity?
                    loaded = entities.next();

                    // This should never ever happen, but just in case...
                    if (loaded.equals(null)) {
                        continue;
                    }

                    if (!entity.isEnemyOf(loaded) && !entity.equals(loaded)) {
                        // The moving unit should be able to load the other
                        // unit and the other should be able to have a turn.
                        if (!entity.canLoad(loaded) || !loaded.isLoadableThisTurn()) {
                            // Something is fishy in Denmark.
                            LogManager.getLogger().error(entity.getShortName() + " can not load " + loaded.getShortName());
                            loaded = null;
                        } else {
                            // Have the deployed unit load the indicated unit.
                            loadUnit(entity, loaded, loaded.getTargetBay());

                            // Stop looking.
                            break;
                        }

                    } else {
                        // Nope. Discard it.
                        loaded = null;
                    }

                } // Handle the next entity in this hex.

                // We were supposed to find someone to load.
                if (loaded == null) {
                    LogManager.getLogger().error("Could not find unit for " + entity.getShortName() + " to load in " + curPos);
                }

            } // End STEP_LOAD

            // Handle towing units.
            if (step.getType() == MovePath.MoveStepType.TOW) {

                // Find the unit being loaded.
                Entity loaded;
                loaded = game.getEntity(entity.getTowing());

                // This should never ever happen, but just in case...
                if (loaded == null) {
                    LogManager.getLogger().error("Could not find unit for " + entity.getShortName() + " to tow.");
                    continue;
                }

                // The moving unit should be able to tow the other
                // unit and the other should be able to have a turn.
                //FIXME: I know this check duplicates functions already performed when enabling the Tow button.
                //This code made more sense as borrowed from "Load" where we actually rechecked the hex for the target unit.
                //Do we need it here for safety, client/server sync or can this be further streamlined?
                if (!entity.canTow(loaded.getId())) {
                    // Something is fishy in Denmark.
                    LogManager.getLogger().error(entity.getShortName() + " can not tow " + loaded.getShortName());
                } else {
                    // Have the deployed unit load the indicated unit.
                    towUnit(entity, loaded);
                }
            } // End STEP_TOW

            // Handle mounting units to small craft/DropShip
            if (step.getType() == MovePath.MoveStepType.MOUNT) {
                Targetable mountee = step.getTarget(game);
                if (mountee instanceof Entity) {
                    Entity dropShip = (Entity) mountee;
                    if (!dropShip.canLoad(entity)) {
                        // Something is fishy in Denmark.
                        LogManager.getLogger().error(dropShip.getShortName() + " can not load " + entity.getShortName());
                    } else {
                        // Have the indicated unit load this unit.
                        entity.setDone(true);
                        loadUnit(dropShip, entity, entity.getTargetBay());
                        Bay currentBay = dropShip.getBay(entity);
                        if ((null != currentBay) && (Compute.d6(2) == 2)) {
                            r = new Report(9390);
                            r.subject = entity.getId();
                            r.indent(1);
                            r.add(currentBay.getType());
                            addReport(r);
                            currentBay.destroyDoorNext();
                        }
                        // Stop looking.
                        entityUpdate(dropShip.getId());
                        return;
                    }
                }
            } // End STEP_MOUNT

            // handle fighter recovery, and also DropShip docking with another large craft
            if (step.getType() == MovePath.MoveStepType.RECOVER) {

                loader = game.getEntity(step.getRecoveryUnit());
                boolean isDS = (entity instanceof Dropship);

                rollTarget = entity.getBasePilotingRoll(overallMoveType);
                if (loader.mpUsed > 0) {
                    rollTarget.addModifier(5, "carrier used thrust");
                }
                if (entity.getPartialRepairs().booleanOption("aero_collar_crit")) {
                    rollTarget.addModifier(2, "misrepaired docking collar");
                }
                if (isDS && (((Dropship) entity).getCollarType() == Dropship.COLLAR_PROTOTYPE)) {
                    rollTarget.addModifier(2, "prototype kf-boom");
                }
                int ctrlroll = Compute.d6(2);
                if (isDS) {
                    r = new Report(9388);
                } else {
                    r = new Report(9381);
                }
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                r.add(loader.getDisplayName());
                r.add(rollTarget);
                r.add(ctrlroll);
                r.newlines = 0;
                r.indent(1);
                if (ctrlroll < rollTarget.getValue()) {
                    r.choose(false);
                    addReport(r);
                    // damage unit
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    addReport(damageEntity(entity, hit, 2 * (rollTarget.getValue() - ctrlroll)));
                } else {
                    r.choose(true);
                    addReport(r);
                    recovered = true;
                }
                // check for door damage
                if (ctrlroll == 2) {
                    loader.damageDoorRecovery(entity);
                    r = new Report(9384);
                    r.subject = entity.getId();
                    r.indent(0);
                    r.add(loader.getDisplayName());
                    addReport(r);
                }
            }

            // handle fighter squadron joining
            if (step.getType() == MovePath.MoveStepType.JOIN) {
                loader = game.getEntity(step.getRecoveryUnit());
                recovered = true;
            }

            // Handle unloading units.
            if (step.getType() == MovePath.MoveStepType.UNLOAD) {
                Targetable unloaded = step.getTarget(game);
                Coords unloadPos = curPos;
                int unloadFacing = curFacing;
                if (null != step.getTargetPosition()) {
                    unloadPos = step.getTargetPosition();
                    unloadFacing = curPos.direction(unloadPos);
                }
                if (!unloadUnit(entity, unloaded, unloadPos, unloadFacing,
                        step.getElevation())) {
                    LogManager.getLogger().error("Server was told to unload "
                            + unloaded.getDisplayName() + " from "
                            + entity.getDisplayName() + " into "
                            + curPos.getBoardNum());
                }
                // some additional stuff to take care of for small
                // craft/DropShip unloading
                if ((entity instanceof SmallCraft) && (unloaded instanceof Entity)) {
                    Bay currentBay = entity.getBay((Entity) unloaded);
                    if ((null != currentBay) && (Compute.d6(2) == 2)) {
                        r = new Report(9390);
                        r.subject = entity.getId();
                        r.indent(1);
                        r.add(currentBay.getType());
                        addReport(r);
                        currentBay.destroyDoorNext();
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                    entityUpdate(entity.getId());
                    // ok now add another turn for the transport so it can
                    // continue to unload units
                    if (!entity.getUnitsUnloadableFromBays().isEmpty()) {
                        dropshipStillUnloading = true;
                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(
                                entity.getOwner().getId(), entity.getId());
                        // Need to set the new turn's multiTurn state
                        newTurn.setMultiTurn(true);
                        game.insertNextTurn(newTurn);
                    }
                    // ok add another turn for the unloaded entity so that it can move
                    if (!(unloaded instanceof Infantry)) {
                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(
                                ((Entity) unloaded).getOwner().getId(),
                                ((Entity) unloaded).getId());
                        // Need to set the new turn's multiTurn state
                        newTurn.setMultiTurn(true);
                        game.insertNextTurn(newTurn);
                    }
                    // brief everybody on the turn update
                    send(createTurnVectorPacket());
                }
            }

            // Handle disconnecting trailers.
            if (step.getType() == MovePath.MoveStepType.DISCONNECT) {
                Targetable unloaded = step.getTarget(game);
                Coords unloadPos = curPos;
                if (null != step.getTargetPosition()) {
                    unloadPos = step.getTargetPosition();
                }
                if (!disconnectUnit(entity, unloaded, unloadPos)) {
                    LogManager.getLogger().error(String.format(
                            "Server was told to disconnect %s from %s into %s",
                            unloaded.getDisplayName(), entity.getDisplayName(), curPos.getBoardNum()));
                }
            }

            // moving backwards over elevation change
            if (((step.getType() == MovePath.MoveStepType.BACKWARDS)
                    || (step.getType() == MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS)
                    || (step.getType() == MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS))
                    && !(md.isJumping()
                    && (entity.getJumpType() == Mech.JUMP_BOOSTER))
                    && (lastHex.getLevel() + lastElevation != curHex.getLevel() + step.getElevation())
                    && !(entity instanceof VTOL)
                    && !(curClimbMode
                    && curHex.containsTerrain(Terrains.BRIDGE)
                    && ((curHex.terrainLevel(Terrains.BRIDGE_ELEV) + curHex.getLevel())
                    == (prevHex.getLevel()
                    + (prevHex.containsTerrain(Terrains.BRIDGE)
                    ? prevHex.terrainLevel(Terrains.BRIDGE_ELEV)
                    : 0))))) {

                // per TacOps, if the mech is walking backwards over an elevation change and falls
                // it falls into the lower hex. The caveat is if it already fell from some other PSR in this
                // invocation of processMovement, then it can't fall again.
                if ((entity instanceof Mech)
                        && (curHex.getLevel() < game.getBoard().getHex(lastPos).getLevel())
                        && !entity.hasFallen()) {
                    rollTarget = entity.getBasePilotingRoll(overallMoveType);
                    rollTarget.addModifier(0, "moving backwards over an elevation change");
                    doSkillCheckWhileMoving(entity, entity.getElevation(),
                            curPos, curPos, rollTarget, true);
                } else if ((entity instanceof Mech) && !entity.hasFallen()) {
                    rollTarget = entity.getBasePilotingRoll(overallMoveType);
                    rollTarget.addModifier(0, "moving backwards over an elevation change");
                    doSkillCheckWhileMoving(entity, lastElevation, lastPos, lastPos, rollTarget, true);
                } else if (entity instanceof Tank) {
                    rollTarget = entity.getBasePilotingRoll(overallMoveType);
                    rollTarget.addModifier(0, "moving backwards over an elevation change");
                    if (doSkillCheckWhileMoving(entity, entity.getElevation(), curPos, lastPos,
                            rollTarget, false) < 0) {
                        curPos = lastPos;
                    }
                }
            }

            // Handle non-infantry moving into a building.
            if (buildingMove > 0) {
                // Get the building being exited.
                Building bldgExited = null;
                if ((buildingMove & 1) == 1) {
                    bldgExited = game.getBoard().getBuildingAt(lastPos);
                }

                // Get the building being entered.
                Building bldgEntered = null;
                if ((buildingMove & 2) == 2) {
                    bldgEntered = game.getBoard().getBuildingAt(curPos);
                }

                // ProtoMechs changing levels within a building cause damage
                if (((buildingMove & 8) == 8) && (entity instanceof Protomech)) {
                    Building bldg = game.getBoard().getBuildingAt(curPos);
                    Vector<Report> vBuildingReport = damageBuilding(bldg, 1, curPos);
                    for (Report report : vBuildingReport) {
                        report.subject = entity.getId();
                    }
                    addReport(vBuildingReport);
                }

                boolean collapsed = false;
                if ((bldgEntered != null)) {
                    String reason;
                    if (bldgExited == null) {
                        // If we're not leaving a building, just handle the "entered".
                        reason = "entering";
                    } else if (bldgExited.equals(bldgEntered) && !(entity instanceof Protomech)
                            && !(entity instanceof Infantry)) {
                        // If we're moving within the same building, just handle the "within".
                        reason = "moving in";
                    } else {
                        // If we have different buildings, roll for each.
                        reason = "entering";
                    }

                    passBuildingWall(entity, bldgEntered, lastPos, curPos, distance, reason,
                            step.isThisStepBackwards(), lastStepMoveType, true);
                    addAffectedBldg(bldgEntered, collapsed);
                }

                // Clean up the entity if it has been destroyed.
                if (entity.isDoomed()) {
                    entity.setDestroyed(true);
                    game.moveToGraveyard(entity.getId());
                    send(createRemoveEntityPacket(entity.getId()));

                    // The entity's movement is completed.
                    return;
                }

                // TODO : what if a building collapses into rubble?
            }

            if (stepMoveType != EntityMovementType.MOVE_JUMP
                    && (step.getClearance() == 0
                    || (entity.getMovementMode().isWiGE() && (step.getClearance() == 1))
                    || curElevation == curHex.terrainLevel(Terrains.BLDG_ELEV)
                    || curElevation == curHex.terrainLevel(Terrains.BRIDGE_ELEV))) {
                Building bldg = game.getBoard().getBuildingAt(curPos);
                if ((bldg != null) && (entity.getElevation() >= 0)) {
                    boolean wigeFlyingOver = entity.getMovementMode() == EntityMovementMode.WIGE
                            && ((curHex.containsTerrain(Terrains.BLDG_ELEV)
                            && curElevation > curHex.terrainLevel(Terrains.BLDG_ELEV)) ||
                            (curHex.containsTerrain(Terrains.BRIDGE_ELEV)
                                    && curElevation > curHex.terrainLevel(Terrains.BRIDGE_ELEV)));
                    boolean collapse = checkBuildingCollapseWhileMoving(bldg, entity, curPos);
                    addAffectedBldg(bldg, collapse);
                    // If the building is collapsed by a WiGE flying over it, the WiGE drops one level of elevation.
                    // This could invalidate the remainder of the movement path, so we will send it back to the client.
                    if (collapse && wigeFlyingOver) {
                        curElevation--;
                        r = new Report(2378);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                        continueTurnFromLevelDrop = true;
                        entity.setPosition(curPos);
                        entity.setFacing(curFacing);
                        entity.setSecondaryFacing(curFacing);
                        entity.setElevation(curElevation);
                        break;
                    }
                }
            }

            // Sheer Cliffs, TO p.39
            boolean vehicleAffectedByCliff = entity instanceof Tank
                    && !entity.isAirborneVTOLorWIGE();
            boolean quadveeVehMode = entity instanceof QuadVee
                    && ((QuadVee) entity).getConversionMode() == QuadVee.CONV_MODE_VEHICLE;
            boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech)
                    && moveType != EntityMovementType.MOVE_JUMP
                    && !entity.isAero();
            // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
            // Everything that does not have a 1 or 2 level drop shouldn't be handled as a cliff
            int stepHeight = curElevation + curHex.getLevel()
                    - (lastElevation + prevHex.getLevel());
            boolean isUpCliff = !lastPos.equals(curPos)
                    && curHex.hasCliffTopTowards(prevHex)
                    && (stepHeight == 1 || stepHeight == 2);
            boolean isDownCliff = !lastPos.equals(curPos)
                    && prevHex.hasCliffTopTowards(curHex)
                    && (stepHeight == -1 || stepHeight == -2);

            // Vehicles (exc. WIGE/VTOL) moving down a cliff
            if (vehicleAffectedByCliff && isDownCliff && !isPavementStep) {
                rollTarget = entity.getBasePilotingRoll(stepMoveType);
                rollTarget.append(new PilotingRollData(entity.getId(), 0, "moving down a sheer cliff"));
                if (doSkillCheckWhileMoving(entity, lastElevation,
                        lastPos, curPos, rollTarget, false) > 0) {
                    addReport(vehicleMotiveDamage((Tank) entity, 0));
                    addNewLines();
                    turnOver = true;
                    break;
                }
            }

            // Mechs and Protomechs moving down a cliff
            // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133
            if (mechAffectedByCliff && !quadveeVehMode && isDownCliff && !isPavementStep) {
                rollTarget = entity.getBasePilotingRoll(moveType);
                rollTarget.append(new PilotingRollData(entity.getId(), -stepHeight - 1, "moving down a sheer cliff"));
                if (doSkillCheckWhileMoving(entity, lastElevation,
                        lastPos, curPos, rollTarget, true) > 0) {
                    addNewLines();
                    turnOver = true;
                    break;
                }
            }

            // Mechs moving up a cliff
            if (mechAffectedByCliff && !quadveeVehMode && isUpCliff && !isPavementStep) {
                rollTarget = entity.getBasePilotingRoll(moveType);
                rollTarget.append(new PilotingRollData(entity.getId(), stepHeight, "moving up a sheer cliff"));
                if (doSkillCheckWhileMoving(entity, lastElevation,
                        lastPos, lastPos, rollTarget, false) > 0) {
                    r = new Report(2209);
                    r.addDesc(entity);
                    r.subject = entity.getId();
                    addReport(r);
                    addNewLines();
                    curPos = entity.getPosition();
                    mpUsed = step.getMpUsed();
                    continueTurnFromCliffAscent = true;
                    break;
                }
            }

            // did the entity just fall?
            if (!wasProne && entity.isProne()) {
                curFacing = entity.getFacing();
                curPos = entity.getPosition();
                mpUsed = step.getMpUsed();
                fellDuringMovement = true;
                break;
            }

            // dropping prone intentionally?
            if (step.getType() == MovePath.MoveStepType.GO_PRONE) {
                mpUsed = step.getMpUsed();
                rollTarget = entity.checkDislodgeSwarmers(step, overallMoveType);
                if (rollTarget.getValue() == TargetRoll.CHECK_FALSE) {
                    // Not being swarmed
                    entity.setProne(true);
                    // check to see if we washed off infernos
                    checkForWashedInfernos(entity, curPos);
                } else {
                    // Being swarmed
                    entity.setPosition(curPos);
                    if (doDislodgeSwarmerSkillCheck(entity, rollTarget, curPos)) {
                        // Entity falls
                        curFacing = entity.getFacing();
                        curPos = entity.getPosition();
                        fellDuringMovement = true;
                        break;
                    }
                    // roll failed, go prone but don't dislodge swarmers
                    entity.setProne(true);
                    // check to see if we washed off infernos
                    checkForWashedInfernos(entity, curPos);
                    break;
                }
            }

            // going hull down
            if (step.getType() == MovePath.MoveStepType.HULL_DOWN) {
                mpUsed = step.getMpUsed();
                entity.setHullDown(true);
            }

            // Check for crushing buildings by Dropships/Mobile Structures
            for (Coords pos : step.getCrushedBuildingLocs()) {
                Building bldg = game.getBoard().getBuildingAt(pos);
                Hex hex = game.getBoard().getHex(pos);

                r = new Report(3443);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(bldg.getName());
                vPhaseReport.add(r);

                final int cf = bldg.getCurrentCF(pos);
                final int numFloors = Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));
                vPhaseReport.addAll(damageBuilding(bldg, 150, " is crushed for ", pos));
                int damage = (int) Math.round((cf / 10.0) * numFloors);
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                vPhaseReport.addAll(damageEntity(entity, hit, damage));
            }

            // Track this step's location.
            movePath.addElement(new UnitLocation(entity.getId(), curPos,
                    curFacing, step.getElevation()));

            // if the lastpos is not the same as the current position
            // then add the current position to the list of places passed
            // through
            if (!curPos.equals(lastPos)) {
                passedThrough.add(curPos);
                passedThroughFacing.add(curFacing);
            }

            // update lastPos, prevStep, prevFacing & prevHex
            if (!curPos.equals(lastPos)) {
                prevFacing = curFacing;
            }
            lastPos = curPos;
            lastElevation = curElevation;
            prevStep = step;
            prevHex = curHex;

            firstStep = false;

            // if we moved at all, we are no longer bracing "for free", except for when
            // the current step IS bracing
            if ((mpUsed > 0) && (step.getType() != MovePath.MoveStepType.BRACE)) {
                entity.setBraceLocation(Entity.LOC_NONE);
            }
        }

        // set entity parameters
        entity.setPosition(curPos);
        entity.setFacing(curFacing);
        entity.setSecondaryFacing(curFacing);
        entity.delta_distance = distance;
        entity.moved = moveType;
        entity.mpUsed = mpUsed;
        entity.setClimbMode(curClimbMode);
        if (!sideslipped && !fellDuringMovement && !crashedDuringMovement
                && (entity.getMovementMode() == EntityMovementMode.VTOL)) {
            entity.setElevation(curVTOLElevation);
        }
        entity.setAltitude(curAltitude);
        entity.setClimbMode(curClimbMode);

        // add a list of places passed through
        entity.setPassedThrough(passedThrough);
        entity.setPassedThroughFacing(passedThroughFacing);

        // if we ran with destroyed hip or gyro, we need a psr
        rollTarget = entity.checkRunningWithDamage(overallMoveType);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE && entity.canFall()) {
            doSkillCheckInPlace(entity, rollTarget);
        }

        // if we sprinted with MASC or a supercharger, then we need a PSR
        rollTarget = entity.checkSprintingWithMASCXorSupercharger(overallMoveType,
                entity.mpUsed);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE && entity.canFall()) {
            doSkillCheckInPlace(entity, rollTarget);
        }

        // if we used ProtoMech myomer booster, roll 2d6
        // pilot damage on a 2
        if ((entity instanceof Protomech) && ((Protomech) entity).hasMyomerBooster()
                && (md.getMpUsed() > ((Protomech) entity)
                .getRunMPwithoutMyomerBooster(true, false, false))) {
            r = new Report(2373);
            r.addDesc(entity);
            r.subject = entity.getId();
            int roll = Compute.d6(2);
            r.add(roll);
            if (roll > 2) {
                r.choose(true);
                addReport(r);
            } else {
                r.choose(false);
                addReport(r);
                addReport(damageCrew(entity, 1));
            }
        }

        rollTarget = entity.checkSprintingWithMASCAndSupercharger(overallMoveType, entity.mpUsed);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
            doSkillCheckInPlace(entity, rollTarget);
        }
        if ((md.getLastStepMovementType() == EntityMovementType.MOVE_SPRINT)
                && (md.hasActiveMASC() || md.hasActiveSupercharger()) && entity.canFall()) {
            doSkillCheckInPlace(entity, entity.getBasePilotingRoll(EntityMovementType.MOVE_SPRINT));
        }

        if (entity.isAirborne() && entity.isAero()) {

            IAero a = (IAero) entity;
            int thrust = md.getMpUsed();

            // consume fuel
            if (((entity.isAero())
                    && game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_FUEL_CONSUMPTION))
                    || (entity instanceof TeleMissile)) {
                int fuelUsed = ((IAero) entity).getFuelUsed(thrust);
                a.useFuel(fuelUsed);
            }

            // JumpShips and space stations need to reduce accumulated thrust if
            // they spend some
            if (entity instanceof Jumpship) {
                Jumpship js = (Jumpship) entity;
                double penalty = 0.0;
                // JumpShips do not accumulate thrust when they make a turn or
                // change velocity
                if (md.contains(MovePath.MoveStepType.TURN_LEFT) || md.contains(MovePath.MoveStepType.TURN_RIGHT)) {
                    // I need to subtract the station keeping thrust from their
                    // accumulated thrust
                    // because they did not actually use it
                    penalty = js.getStationKeepingThrust();
                }
                if (thrust > 0) {
                    penalty = thrust;
                }
                if (penalty > 0.0) {
                    js.setAccumulatedThrust(Math.max(0, js.getAccumulatedThrust() - penalty));
                }
            }

            // check to see if thrust exceeded SI

            rollTarget = a.checkThrustSITotal(thrust, overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                game.addControlRoll(new PilotingRollData(entity.getId(), 0,
                        "Thrust spent during turn exceeds SI"));
            }

            if (!game.getBoard().inSpace()) {
                rollTarget = a.checkVelocityDouble(md.getFinalVelocity(),
                        overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(entity.getId(), 0,
                            "Velocity greater than 2x safe thrust"));
                }

                rollTarget = a.checkDown(md.getFinalNDown(), overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(
                            new PilotingRollData(entity.getId(), md.getFinalNDown(),
                                    "descended more than two altitudes"));
                }

                // check for hovering
                rollTarget = a.checkHover(md);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(
                            new PilotingRollData(entity.getId(), 0, "hovering"));
                }

                // check for aero stall
                rollTarget = a.checkStall(md);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    r = new Report(9391);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    game.addControlRoll(new PilotingRollData(entity.getId(), 0,
                            "stalled out"));
                    entity.setAltitude(entity.getAltitude() - 1);
                    // check for crash
                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {
                        addReport(processCrash(entity, 0, entity.getPosition()));
                    }
                }

                // check to see if spheroids should lose one altitude
                if (a.isSpheroid() && !a.isSpaceborne()
                        && a.isAirborne() && (md.getFinalNDown() == 0) && (md.getMpUsed() == 0)) {
                    r = new Report(9392);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    entity.setAltitude(entity.getAltitude() - 1);
                    // check for crash
                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {
                        addReport(processCrash(entity, 0, entity.getPosition()));
                    }
                } else if (entity instanceof EscapePods && entity.isAirborne() && md.getFinalVelocity() < 2) {
                    //Atmospheric Escape Pods that drop below velocity 2 lose altitude as dropping units
                    entity.setAltitude(entity.getAltitude()
                            - game.getPlanetaryConditions().getDropRate());
                    r = new Report(6676);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(game.getPlanetaryConditions().getDropRate());
                    addReport(r);
                }
            }
        }

        // We need to check for the removal of hull-down for tanks.
        // Tanks can just drive out of hull-down: if the tank was hull-down
        // and doesn't end hull-down we can remove the hull-down status
        if (entity.isHullDown() && !md.getFinalHullDown()
                && (entity instanceof Tank
                || (entity instanceof QuadVee && entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {
            entity.setHullDown(false);
        }

        // If the entity is being swarmed, erratic movement may dislodge the
        // fleas.
        final int swarmerId = entity.getSwarmAttackerId();
        if ((Entity.NONE != swarmerId) && md.contains(MovePath.MoveStepType.SHAKE_OFF_SWARMERS)) {
            final Entity swarmer = game.getEntity(swarmerId);
            rollTarget = entity.getBasePilotingRoll(overallMoveType);

            entity.addPilotingModifierForTerrain(rollTarget);

            // Add a +4 modifier.
            if (md.getLastStepMovementType() == EntityMovementType.MOVE_VTOL_RUN) {
                rollTarget.addModifier(2,
                        "dislodge swarming infantry with VTOL movement");
            } else {
                rollTarget.addModifier(4, "dislodge swarming infantry");
            }

            // If the swarmer has Assault claws, give a 1 modifier.
            // We can stop looking when we find our first match.
            for (Mounted mount : swarmer.getMisc()) {
                EquipmentType equip = mount.getType();
                if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {
                    rollTarget.addModifier(1, "swarmer has magnetic claws");
                    break;
                }
            }

            // okay, print the info
            r = new Report(2125);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);

            // roll
            final int diceRoll = Compute.d6(2);
            r = new Report(2130);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            if (diceRoll < rollTarget.getValue()) {
                r.choose(false);
                addReport(r);
            } else {
                // Dislodged swarmers don't get turns.
                game.removeTurnFor(swarmer);
                send(createTurnVectorPacket());

                // Update the report and the swarmer's status.
                r.choose(true);
                addReport(r);
                entity.setSwarmAttackerId(Entity.NONE);
                swarmer.setSwarmTargetId(Entity.NONE);

                Hex curHex = game.getBoard().getHex(curPos);

                // Did the infantry fall into water?
                if (curHex.terrainLevel(Terrains.WATER) > 0) {
                    // Swarming infantry die.
                    swarmer.setPosition(curPos);
                    r = new Report(2135);
                    r.subject = entity.getId();
                    r.indent();
                    r.addDesc(swarmer);
                    addReport(r);
                    addReport(destroyEntity(swarmer, "a watery grave", false));
                } else {
                    // Swarming infantry take a 3d6 point hit.
                    // ASSUMPTION : damage should not be doubled.
                    r = new Report(2140);
                    r.subject = entity.getId();
                    r.indent();
                    r.addDesc(swarmer);
                    r.add("3d6");
                    addReport(r);
                    addReport(damageEntity(swarmer,
                            swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
                            Compute.d6(3)));
                    addNewLines();
                    swarmer.setPosition(curPos);
                }
                entityUpdate(swarmerId);
            } // End successful-PSR

        } // End try-to-dislodge-swarmers

        // but the danger isn't over yet! landing from a jump can be risky!
        if ((overallMoveType == EntityMovementType.MOVE_JUMP) && !entity.isMakingDfa()) {
            final Hex curHex = game.getBoard().getHex(curPos);
            // check for damaged criticals
            rollTarget = entity.checkLandingWithDamage(overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, rollTarget);
            }
            // check for prototype JJs
            rollTarget = entity.checkLandingWithPrototypeJJ(overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, rollTarget);
            }
            // check for jumping into heavy woods
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {
                rollTarget = entity.checkLandingInHeavyWoods(overallMoveType, curHex);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    doSkillCheckInPlace(entity, rollTarget);
                }
            }
            // Mechanical jump boosters fall damage
            if (md.shouldMechanicalJumpCauseFallDamage()) {
                vPhaseReport.addAll(doEntityFallsInto(entity,
                        entity.getElevation(), md.getJumpPathHighestPoint(),
                        curPos, entity.getBasePilotingRoll(overallMoveType),
                        false, entity.getJumpMP()));
            }
            // jumped into water?
            int waterLevel = curHex.terrainLevel(Terrains.WATER);
            if (curHex.containsTerrain(Terrains.ICE) && (waterLevel > 0)) {
                if (!(entity instanceof Infantry)) {
                    // check for breaking ice
                    int roll = Compute.d6(1);
                    r = new Report(2122);
                    r.add(entity.getDisplayName(), true);
                    r.add(roll);
                    r.subject = entity.getId();
                    addReport(r);
                    if (roll >= 4) {
                        // oops!
                        entity.setPosition(curPos);
                        addReport(resolveIceBroken(curPos));
                        curPos = entity.getPosition();
                    } else {
                        // TacOps: immediate PSR with +4 for terrain. If you
                        // fall then may break the ice after all
                        rollTarget = entity.checkLandingOnIce(overallMoveType, curHex);
                        if (!doSkillCheckInPlace(entity, rollTarget)) {
                            // apply damage now, or it will show up as a
                            // possible breach, if ice is broken
                            entity.applyDamage();
                            roll = Compute.d6(1);
                            r = new Report(2118);
                            r.addDesc(entity);
                            r.add(roll);
                            r.subject = entity.getId();
                            addReport(r);
                            if (roll == 6) {
                                entity.setPosition(curPos);
                                addReport(resolveIceBroken(curPos));
                                curPos = entity.getPosition();
                            }
                        }
                    }
                }
            } else if (!(prevStep.climbMode() && curHex.containsTerrain(Terrains.BRIDGE))
                    && !(entity.getMovementMode() == EntityMovementMode.HOVER)) {
                rollTarget = entity.checkWaterMove(waterLevel, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    // For falling elevation, Entity must not on hex surface
                    int currElevation = entity.getElevation();
                    entity.setElevation(0);
                    boolean success = doSkillCheckInPlace(entity, rollTarget);
                    if (success) {
                        entity.setElevation(currElevation);
                    }
                }
                if (waterLevel > 1) {
                    // Any swarming infantry will be destroyed.
                    drownSwarmer(entity, curPos);
                }
            }

            // check for building collapse
            Building bldg = game.getBoard().getBuildingAt(curPos);
            if (bldg != null) {
                checkForCollapse(bldg, game.getPositionMap(), curPos, true,
                        vPhaseReport);
            }

            // Don't interact with terrain when jumping onto a building or a bridge
            if (entity.getElevation() == 0) {
                ServerHelper.checkAndApplyMagmaCrust(curHex, entity.getElevation(), entity, curPos, true, vPhaseReport, this);
                ServerHelper.checkEnteringMagma(curHex, entity.getElevation(), entity, this);

                // jumped into swamp? maybe stuck!
                if (curHex.getBogDownModifier(entity.getMovementMode(),
                        entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
                    if (entity instanceof Mech) {
                        entity.setStuck(true);
                        r = new Report(2121);
                        r.add(entity.getDisplayName(), true);
                        r.subject = entity.getId();
                        addReport(r);
                        // check for quicksand
                        addReport(checkQuickSand(curPos));
                    } else if (!entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {
                        rollTarget = new PilotingRollData(entity.getId(),
                                5, "entering boggy terrain");
                        rollTarget.append(new PilotingRollData(entity.getId(),
                                curHex.getBogDownModifier(entity.getMovementMode(),
                                        entity instanceof LargeSupportTank),
                                "avoid bogging down"));
                        if (0 < doSkillCheckWhileMoving(entity, entity.getElevation(), curPos, curPos,
                                rollTarget, false)) {
                            entity.setStuck(true);
                            r = new Report(2081);
                            r.add(entity.getDisplayName());
                            r.subject = entity.getId();
                            addReport(r);
                            // check for quicksand
                            addReport(checkQuickSand(curPos));
                        }
                    }
                }
            }
            // If the entity is being swarmed, jumping may dislodge the fleas.
            if (Entity.NONE != swarmerId) {
                final Entity swarmer = game.getEntity(swarmerId);
                rollTarget = entity.getBasePilotingRoll(overallMoveType);

                entity.addPilotingModifierForTerrain(rollTarget);

                // Add a +4 modifier.
                rollTarget.addModifier(4, "dislodge swarming infantry");

                // If the swarmer has Assault claws, give a 1 modifier.
                // We can stop looking when we find our first match.
                if (swarmer.hasWorkingMisc(MiscType.F_MAGNET_CLAW, -1)) {
                    rollTarget.addModifier(1, "swarmer has magnetic claws");
                }

                // okay, print the info
                r = new Report(2125);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);

                // roll
                final int diceRoll = Compute.d6(2);
                r = new Report(2130);
                r.subject = entity.getId();
                r.add(rollTarget.getValueAsString());
                r.add(rollTarget.getDesc());
                r.add(diceRoll);
                if (diceRoll < rollTarget.getValue()) {
                    r.choose(false);
                    addReport(r);
                } else {
                    // Dislodged swarmers don't get turns.
                    game.removeTurnFor(swarmer);
                    send(createTurnVectorPacket());

                    // Update the report and the swarmer's status.
                    r.choose(true);
                    addReport(r);
                    entity.setSwarmAttackerId(Entity.NONE);
                    swarmer.setSwarmTargetId(Entity.NONE);

                    // Did the infantry fall into water?
                    if (curHex.terrainLevel(Terrains.WATER) > 0) {
                        // Swarming infantry die.
                        swarmer.setPosition(curPos);
                        r = new Report(2135);
                        r.subject = entity.getId();
                        r.indent();
                        r.addDesc(swarmer);
                        addReport(r);
                        addReport(destroyEntity(swarmer, "a watery grave", false));
                    } else {
                        // Swarming infantry take a 3d6 point hit.
                        // ASSUMPTION : damage should not be doubled.
                        r = new Report(2140);
                        r.subject = entity.getId();
                        r.indent();
                        r.addDesc(swarmer);
                        r.add("3d6");
                        addReport(r);
                        addReport(damageEntity(swarmer,
                                swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
                                Compute.d6(3)));
                        addNewLines();
                        swarmer.setPosition(curPos);
                    }
                    entityUpdate(swarmerId);
                } // End successful-PSR

            } // End try-to-dislodge-swarmers

            // one more check for inferno wash-off
            checkForWashedInfernos(entity, curPos);

            // a jumping tank needs to roll for movement damage
            if (entity instanceof Tank) {
                int modifier = 0;
                if (curHex.containsTerrain(Terrains.ROUGH)
                        || curHex.containsTerrain(Terrains.WOODS)
                        || curHex.containsTerrain(Terrains.JUNGLE)) {
                    modifier = 1;
                }
                r = new Report(2126);
                r.subject = entity.getId();
                r.addDesc(entity);
                vPhaseReport.add(r);
                vPhaseReport.addAll(vehicleMotiveDamage((Tank) entity, modifier,
                        false, -1, true));
                Report.addNewline(vPhaseReport);
            }

        } // End entity-is-jumping

        //If converting to another mode, set the final movement mode and report it
        if (entity.isConvertingNow()) {
            r = new Report(1210);
            r.subject = entity.getId();
            r.addDesc(entity);
            if (entity instanceof QuadVee && entity.isProne()
                    && entity.getConversionMode() == QuadVee.CONV_MODE_MECH) {
                //Fall while converting to vehicle mode cancels conversion.
                entity.setConvertingNow(false);
                r.messageId = 2454;
            } else {
                // LAMs converting from fighter mode need to have the elevation set properly.
                if (entity.isAero()) {
                    if (md.getFinalConversionMode() == EntityMovementMode.WIGE
                            && entity.getAltitude() > 0 && entity.getAltitude() <= 3) {
                        entity.setElevation(entity.getAltitude() * 10);
                        entity.setAltitude(0);
                    } else {
                        Hex hex = game.getBoard().getHex(entity.getPosition());
                        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {
                            entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
                        } else {
                            entity.setElevation(0);
                        }
                    }
                }
                entity.setMovementMode(md.getFinalConversionMode());
                if (entity instanceof Mech && ((Mech) entity).hasTracks()) {
                    r.messageId = 2455;
                    r.choose(entity.getMovementMode() == EntityMovementMode.TRACKED);
                } else if (entity.getMovementMode() == EntityMovementMode.TRACKED
                        || entity.getMovementMode() == EntityMovementMode.WHEELED) {
                    r.messageId = 2451;
                } else if (entity.getMovementMode() == EntityMovementMode.WIGE) {
                    r.messageId = 2452;
                } else if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {
                    r.messageId = 2453;
                } else {
                    r.messageId = 2450;
                }
                if (entity.isAero()) {
                    int altitude = entity.getAltitude();
                    if (altitude == 0 && md.getFinalElevation() >= 8) {
                        altitude = 1;
                    }
                    if (altitude == 0) {
                        ((IAero) entity).land();
                    } else {
                        ((IAero) entity).liftOff(altitude);
                    }
                }
            }
            addReport(r);
        }

        // update entity's locations' exposure
        vPhaseReport.addAll(doSetLocationsExposure(entity,
                game.getBoard().getHex(curPos), false, entity.getElevation()));

        // Check the falls_end_movement option to see if it should be able to
        // move on.
        // Need to check here if the 'Mech actually went from non-prone to prone
        // here because 'fellDuringMovement' is sometimes abused just to force
        // another turn and so doesn't reliably tell us.
        boolean continueTurnFromFall = !(game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_FALLS_END_MOVEMENT)
                && (entity instanceof Mech) && !wasProne && entity.isProne())
                && (fellDuringMovement && !entity.isCarefulStand()) // Careful standing takes up the whole turn
                && !turnOver && (entity.mpUsed < entity.getRunMP())
                && (overallMoveType != EntityMovementType.MOVE_JUMP);
        if ((continueTurnFromFall || continueTurnFromPBS || continueTurnFromFishtail || continueTurnFromLevelDrop || continueTurnFromCliffAscent
                || detectedHiddenHazard)
                && entity.isSelectableThisTurn() && !entity.isDoomed()) {
            entity.applyDamage();
            entity.setDone(false);
            entity.setTurnInterrupted(true);

            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());
            // Need to set the new turn's multiTurn state
            newTurn.setMultiTurn(true);
            game.insertNextTurn(newTurn);
            // brief everybody on the turn update
            send(createTurnVectorPacket());

            // let everyone know about what just happened
            if (vPhaseReport.size() > 1) {
                send(entity.getOwner().getId(), createSpecialReportPacket());
            }
        } else {
            if (entity.getMovementMode() == EntityMovementMode.WIGE) {
                Hex hex = game.getBoard().getHex(curPos);
                if (md.automaticWiGELanding(false)) {
                    // try to land safely; LAMs require a psr when landing with gyro or leg actuator
                    // damage and ProtoMechs always require a roll
                    int elevation = (null == prevStep) ? entity.getElevation() : prevStep.getElevation();
                    if (entity.hasETypeFlag(Entity.ETYPE_LAND_AIR_MECH)) {
                        addReport(landAirMech((LandAirMech) entity, entity.getPosition(), elevation,
                                entity.delta_distance));
                    } else if (entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
                        vPhaseReport.addAll(landGliderPM((Protomech) entity, entity.getPosition(),
                                elevation, entity.delta_distance));
                    } else {
                        r = new Report(2123);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        vPhaseReport.add(r);
                    }

                    if (hex.containsTerrain(Terrains.BLDG_ELEV)) {
                        Building bldg = game.getBoard().getBuildingAt(entity.getPosition());
                        entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
                        addAffectedBldg(bldg, checkBuildingCollapseWhileMoving(bldg,
                                entity, entity.getPosition()));
                    } else if (entity.isLocationProhibited(entity.getPosition(), 0)
                            && !hex.hasPavement()) {
                        // crash
                        r = new Report(2124);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        vPhaseReport.add(r);
                        vPhaseReport.addAll(crashVTOLorWiGE((Tank) entity));
                    } else {
                        entity.setElevation(0);
                    }

                    // Check for stacking violations in the target hex
                    Entity violation = Compute.stackingViolation(game,
                            entity.getId(), entity.getPosition());
                    if (violation != null) {
                        PilotingRollData prd = new PilotingRollData(
                                violation.getId(), 2, "fallen on");
                        if (violation instanceof Dropship) {
                            violation = entity;
                            prd = null;
                        }
                        Coords targetDest = Compute.getValidDisplacement(game,
                                violation.getId(), entity.getPosition(), 0);
                        if (targetDest != null) {
                            vPhaseReport.addAll(doEntityDisplacement(violation,
                                    entity.getPosition(), targetDest, prd));
                            // Update the violating entity's position on the
                            // client.
                            entityUpdate(violation.getId());
                        } else {
                            // ack! automatic death! Tanks
                            // suffer an ammo/power plant hit.
                            // TODO : a Mech suffers a Head Blown Off crit.
                            vPhaseReport.addAll(destroyEntity(violation,
                                    "impossible displacement",
                                    violation instanceof Mech,
                                    violation instanceof Mech));
                        }
                    }
                } else if (!entity.hasETypeFlag(Entity.ETYPE_LAND_AIR_MECH)
                        && !entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {

                    // we didn't land, so we go to elevation 1 above the terrain
                    // features
                    // it might have been higher than one due to the extra MPs
                    // it can spend to stay higher during movement, but should
                    // end up at one

                    entity.setElevation(Math.min(entity.getElevation(),
                            1 + hex.maxTerrainFeatureElevation(
                                    game.getBoard().inAtmosphere())));
                }
            }

            // If we've somehow gotten here as an airborne LAM with a destroyed side torso
            // (such as conversion while dropping), crash now.
            if (entity instanceof LandAirMech
                    && (entity.isLocationBad(Mech.LOC_RT) || entity.isLocationBad(Mech.LOC_LT))) {
                r = new Report(9710);
                r.subject = entity.getId();
                r.addDesc(entity);
                if (entity.isAirborneVTOLorWIGE()) {
                    addReport(r);
                    crashAirMech(entity, new PilotingRollData(entity.getId(), TargetRoll.AUTOMATIC_FAIL,
                            "side torso destroyed"), vPhaseReport);
                } else if (entity.isAirborne() && entity.isAero()) {
                    addReport(r);
                    addReport(processCrash(entity, ((IAero) entity).getCurrentVelocity(), entity.getPosition()));
                }
            }

            entity.setDone(true);
        }

        if (dropshipStillUnloading) {
            // turns should have already been inserted but we need to set the
            // entity as not done
            entity.setDone(false);
        }

        // If the entity is being swarmed, update the attacker's position.
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            swarmer.setPosition(curPos);
            // If the hex is on fire, and the swarming infantry is
            // *not* Battle Armor, it drops off.
            if (!(swarmer instanceof BattleArmor) && game.getBoard()
                    .getHex(curPos).containsTerrain(Terrains.FIRE)) {
                swarmer.setSwarmTargetId(Entity.NONE);
                entity.setSwarmAttackerId(Entity.NONE);
                r = new Report(2145);
                r.subject = entity.getId();
                r.indent();
                r.add(swarmer.getShortName(), true);
                addReport(r);
            }
            entityUpdate(swarmerId);
        }

        // Update the entity's position,
        // unless it is off the game map.
        if (!game.isOutOfGame(entity)) {
            entityUpdate(entity.getId(), movePath, true, losCache);
            if (entity.isDoomed()) {
                send(createRemoveEntityPacket(entity.getId(),
                        entity.getRemovalCondition()));
            }
        }

        //If the entity is towing trailers, update the position of those trailers
        if (!entity.getAllTowedUnits().isEmpty()) {
            List<Integer> reversedTrailers = new ArrayList<>(entity.getAllTowedUnits()); // initialize with a copy (no need to initialize to an empty list first)
            Collections.reverse(reversedTrailers); // reverse in-place
            List<Coords> trailerPath = initializeTrailerCoordinates(entity, reversedTrailers); // no need to initialize to an empty list first
            processTrailerMovement(entity, trailerPath);
        }

        // recovered units should now be recovered and dealt with
        if (entity.isAero() && recovered && (loader != null)) {

            if (loader.isCapitalFighter()) {
                if (!(loader instanceof FighterSquadron)) {
                    // this is a solo capital fighter so we need to add a new
                    // squadron and load both the loader and loadee
                    FighterSquadron fs = new FighterSquadron();
                    fs.setDeployed(true);
                    fs.setId(game.getNextEntityId());
                    fs.setCurrentVelocity(((Aero) loader).getCurrentVelocity());
                    fs.setNextVelocity(((Aero) loader).getNextVelocity());
                    fs.setVectors(loader.getVectors());
                    fs.setFacing(loader.getFacing());
                    fs.setOwner(entity.getOwner());
                    // set velocity and heading the same as parent entity
                    game.addEntity(fs);
                    send(createAddEntityPacket(fs.getId()));
                    // make him not get a move this turn
                    fs.setDone(true);
                    // place on board
                    fs.setPosition(loader.getPosition());
                    loadUnit(fs, loader, -1);
                    loader = fs;
                    entityUpdate(fs.getId());
                }
                loader.load(entity);
            } else {
                loader.recover(entity);
                entity.setRecoveryTurn(5);
            }

            // The loaded unit is being carried by the loader.
            entity.setTransportId(loader.getId());

            // Remove the loaded unit from the screen.
            entity.setPosition(null);

            // Update the loaded unit.
            entityUpdate(entity.getId());
        }

        // even if load was unsuccessful, I may need to update the loader
        if (null != loader) {
            entityUpdate(loader.getId());
        }

        // if using double blind, update the player on new units he might see
        if (doBlind()) {
            send(entity.getOwner().getId(),
                    createFilteredEntitiesPacket(entity.getOwner(), losCache));
        }

        // if we generated a charge attack, report it now
        if (charge != null) {
            send(createAttackPacket(charge, 1));
        }

        // if we generated a ram attack, report it now
        if (ram != null) {
            send(createAttackPacket(ram, 1));
        }
        if ((entity instanceof Mech) && entity.hasEngine() && ((Mech) entity).isIndustrial()
                && !entity.hasEnvironmentalSealing()
                && (entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)) {
            if ((!entity.isProne()
                    && (game.getBoard().getHex(entity.getPosition())
                    .terrainLevel(Terrains.WATER) >= 2))
                    || (entity.isProne()
                    && (game.getBoard().getHex(entity.getPosition())
                    .terrainLevel(Terrains.WATER) == 1))) {
                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(true);

            } else {
                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(false);
            }
        }
    }

    /**
     * Updates the position of any towed trailers.
     *
     * @param tractor    The Entity that is moving
     * @param trainPath  The path all trailers are following?
     */
    private void processTrailerMovement(Entity tractor, List<Coords> trainPath) {
        for (int eId : tractor.getAllTowedUnits()) {
            Entity trailer = game.getEntity(eId);
            // if the Tractor didn't move anywhere, stay where we are
            if (tractor.delta_distance == 0) {
                trailer.delta_distance = tractor.delta_distance;
                trailer.moved = tractor.moved;
                trailer.setSecondaryFacing(trailer.getFacing());
                trailer.setDone(true);
                entityUpdate(eId);
                continue;
            }
            int stepNumber; // The Coords in trainPath that this trailer should move to
            Coords trailerPos;
            int trailerNumber = tractor.getAllTowedUnits().indexOf(eId);
            double trailerPositionOffset = (trailerNumber + 1); //Offset so we get the right position index
            // Unless the tractor is superheavy, put the first trailer in its hex.
            // Technically this would be true for a superheavy trailer too, but only a superheavy tractor can tow one.
            if (trailerNumber == 0 && !tractor.isSuperHeavy()) {
                trailer.setPosition(tractor.getPosition());
                trailer.setFacing(tractor.getFacing());
            } else {
                // If the trailer is superheavy, place it in a hex by itself
                if (trailer.isSuperHeavy()) {
                    trailerPositionOffset ++;
                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);
                    trailerPos = trainPath.get(stepNumber);
                    trailer.setPosition(trailerPos);
                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) >= 0) {
                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));
                    }
                } else if (tractor.isSuperHeavy()) {
                    // If the tractor is superheavy, we can put two trailers in each hex
                    // starting trailer 0 in the hex behind the tractor
                    trailerPositionOffset = (Math.ceil((trailerPositionOffset / 2.0)) + 1);
                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);
                    trailerPos = trainPath.get(stepNumber);
                    trailer.setPosition(trailerPos);
                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) >= 0) {
                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));
                    }
                } else {
                    // Otherwise, we can put two trailers in each hex
                    // starting trailer 1 in the hex behind the tractor
                    trailerPositionOffset ++;
                    trailerPositionOffset = Math.ceil((trailerPositionOffset / 2.0));
                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);
                    trailerPos = trainPath.get(stepNumber);
                    trailer.setPosition(trailerPos);
                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) >= 0) {
                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));
                    }
                }
            }
            // trailers are immobile by default. Match the tractor's movement here
            trailer.delta_distance = tractor.delta_distance;
            trailer.moved = tractor.moved;
            trailer.setSecondaryFacing(trailer.getFacing());
            trailer.setDone(true);
            entityUpdate(eId);
        }
    }

    /**
     * Flips the order of a tractor's towed trailers list by index and
     * adds their starting coordinates to a list of hexes the tractor passed through
     *
     * @return  Returns the properly sorted list of all train coordinates
     */
    public List<Coords> initializeTrailerCoordinates(Entity tractor, List<Integer> allTowedTrailers) {
        List<Coords> trainCoords = new ArrayList<>();
        for (int trId : allTowedTrailers) {
            Entity trailer = game.getEntity(trId);
            Coords position = trailer.getPosition();
            //Duplicates foul up the works...
            if (!trainCoords.contains(position)) {
                trainCoords.add(position);
            }
        }
        for (Coords c : tractor.getPassedThrough()) {
            if (!trainCoords.contains(c)) {
                trainCoords.add(c);
            }
        }
        return trainCoords;
    }

    /**
     * Checks whether the entity used MASC or a supercharger during movement, and if so checks for
     * and resolves any failures.
     *
     * @param entity  The unit using MASC/supercharger
     * @param md      The current <code>MovePath</code>
     * @return        Whether the unit failed the check
     */
    private boolean checkMASCFailure(Entity entity, MovePath md) {
        HashMap<Integer, List<CriticalSlot>> crits = new HashMap<>();
        Vector<Report> vReport = new Vector<>();
        if (entity.checkForMASCFailure(md, vReport, crits)) {
            boolean mascFailure = true;
            // Check to see if the pilot can reroll due to Edge
            if (entity.getCrew().hasEdgeRemaining()
                    && entity.getCrew().getOptions()
                    .booleanOption(OptionsConstants.EDGE_WHEN_MASC_FAILS)) {
                entity.getCrew().decreaseEdge();
                // Need to reset the MASCUsed flag
                entity.setMASCUsed(false);
                // Report to notify user that masc check was rerolled
                Report masc_report = new Report(6501);
                masc_report.subject = entity.getId();
                masc_report.indent(2);
                masc_report.addDesc(entity);
                vReport.add(masc_report);
                // Report to notify user how much edge pilot has left
                masc_report = new Report(6510);
                masc_report.subject = entity.getId();
                masc_report.indent(2);
                masc_report.addDesc(entity);
                masc_report.add(entity.getCrew().getOptions()
                        .intOption(OptionsConstants.EDGE));
                vReport.addElement(masc_report);
                // Recheck MASC failure
                if (!entity.checkForMASCFailure(md, vReport, crits)) {
                    // The reroll passed, don't process the failure
                    mascFailure = false;
                    addReport(vReport);
                }
            }
            // Check for failure and process it
            if (mascFailure) {
                addReport(vReport);
                ApplyMASCOrSuperchargerCriticals(entity, md, crits);
                return true;
            }
        } else {
            addReport(vReport);
        }
        return false;
    }

    /**
     * Checks whether the entity used a supercharger during movement, and if so checks for
     * and resolves any failures.
     *
     * @param entity  The unit using MASC/supercharger
     * @param md      The current <code>MovePath</code>
     * @return        Whether the unit failed the check
     */
    private boolean checkSuperchargerFailure(Entity entity, MovePath md) {
        HashMap<Integer, List<CriticalSlot>> crits = new HashMap<>();
        Vector<Report> vReport = new Vector<>();
        if (entity.checkForSuperchargerFailure(md, vReport, crits)) {
            boolean superchargerFailure = true;
            // Check to see if the pilot can reroll due to Edge
            if (entity.getCrew().hasEdgeRemaining()
                    && entity.getCrew().getOptions()
                    .booleanOption(OptionsConstants.EDGE_WHEN_MASC_FAILS)) {
                entity.getCrew().decreaseEdge();
                // Need to reset the SuperchargerUsed flag
                entity.setSuperchargerUsed(false);
                // Report to notify user that supercharger check was rerolled
                Report supercharger_report = new Report(6501);
                supercharger_report.subject = entity.getId();
                supercharger_report.indent(2);
                supercharger_report.addDesc(entity);
                vReport.add(supercharger_report);
                // Report to notify user how much edge pilot has left
                supercharger_report = new Report(6510);
                supercharger_report.subject = entity.getId();
                supercharger_report.indent(2);
                supercharger_report.addDesc(entity);
                supercharger_report.add(entity.getCrew().getOptions()
                        .intOption(OptionsConstants.EDGE));
                vReport.addElement(supercharger_report);
                // Recheck Supercharger failure
                if (!entity.checkForSuperchargerFailure(md, vReport, crits)) {
                    // The reroll passed, don't process the failure
                    superchargerFailure = false;
                    addReport(vReport);
                }
            }
            // Check for failure and process it
            if (superchargerFailure) {
                addReport(vReport);
                // If this is supercharger failure we need to damage the supercharger as well as
                // the additional criticals. For mechs this requires the additional step of finding
                // the slot and marking it as hit so it can't absorb future damage.
                Mounted supercharger = entity.getSuperCharger();
                if ((null != supercharger) && supercharger.curMode().equals("Armed")) {
                    if (entity.hasETypeFlag(Entity.ETYPE_MECH)) {
                        final int loc = supercharger.getLocation();
                        for (int slot = 0; slot < entity.getNumberOfCriticals(loc); slot++) {
                            final CriticalSlot crit = entity.getCritical(loc, slot);
                            if ((null != crit) && (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)
                                    && (crit.getMount().getType().equals(supercharger.getType()))) {
                                addReport(applyCriticalHit(entity, loc, crit,
                                        true, 0, false));
                                break;
                            }
                        }
                    } else {
                        supercharger.setHit(true);
                    }
                    supercharger.setMode("Off");
                }
                ApplyMASCOrSuperchargerCriticals(entity, md, crits);
                return true;
            }
        } else {
            addReport(vReport);
        }
        return false;
    }

    private void ApplyMASCOrSuperchargerCriticals(Entity entity, MovePath md,
                                                  HashMap<Integer, List<CriticalSlot>> crits ) {
        for (Integer loc : crits.keySet()) {
            List<CriticalSlot> lcs = crits.get(loc);
            for (CriticalSlot cs : lcs) {
                // HACK: if loc is -1, we need to deal motive damage to
                // the tank, the severity of which is stored in the critslot index
                if (loc == -1) {
                    addReport(vehicleMotiveDamage((Tank) entity,
                            0, true, cs.getIndex()));
                } else {
                    addReport(applyCriticalHit(entity, loc, cs,
                            true, 0, false));
                }
            }
        }
        // do any PSR immediately
        addReport(resolvePilotingRolls(entity));
        game.resetPSRs(entity);
        // let the player replot their move as MP might be changed
        md.clear();
    }

    /**
     * LAMs or QuadVees converting from leg mode may force any carried infantry (including swarming)
     * to fall into the current hex. A LAM may suffer damage.
     *
     * @param carrier       The <code>Entity</code> making the conversion.
     * @param rider         The <code>Entity</code> possibly being forced off.
     * @param curPos        The coordinates of the hex where the conversion starts.
     * @param curFacing     The carrier's facing when conversion starts.
     * @param automatic     Whether the infantry falls automatically. If false, an anti-mech roll is made
     *                      to see whether it stays mounted.
     * @param infDamage     If true, the infantry takes falling damage, +1D6 for conventional.
     * @param carrierDamage If true, the carrier takes damage from converting while carrying infantry.
     */
    private Vector<Report> checkDropBAFromConverting(Entity carrier, Entity rider, Coords curPos, int curFacing,
                                                     boolean automatic, boolean infDamage, boolean carrierDamage) {
        Vector<Report> reports = new Vector<>();
        Report r;
        PilotingRollData prd = rider.getBasePilotingRoll(EntityMovementType.MOVE_NONE);
        boolean falls = automatic;
        if (automatic) {
            r = new Report(2465);
            r.subject = rider.getId();
            r.addDesc(rider);
            r.addDesc(carrier);
        } else {
            r = new Report(2460);
            r.subject = rider.getId();
            r.addDesc(rider);
            r.add(prd);
            r.addDesc(carrier);
            final int diceRoll = carrier.getCrew().rollPilotingSkill();
            r.add(diceRoll);
            if (diceRoll < prd.getValue()) {
                r.choose(false);
                falls = true;
            } else {
                r.choose(true);
            }
        }
        reports.add(r);
        if (falls) {
            if (carrier.getSwarmAttackerId() == rider.getId()) {
                rider.setDone(true);
                carrier.setSwarmAttackerId(Entity.NONE);
                rider.setSwarmTargetId(Entity.NONE);
            } else if (!unloadUnit(carrier, rider, curPos, curFacing, 0)) {
                LogManager.getLogger().error("Server was told to unload "
                        + rider.getDisplayName() + " from "
                        + carrier.getDisplayName() + " into "
                        + curPos.getBoardNum());
                return reports;
            }
            if (infDamage) {
                reports.addAll(doEntityFall(rider, curPos, 2, prd));
                if (rider.getEntityType() == Entity.ETYPE_INFANTRY) {
                    int extra = Compute.d6();
                    reports.addAll(damageEntity(rider, new HitData(Infantry.LOC_INFANTRY), extra));
                }
            }
            if (carrierDamage) {
                //Report the possibility of a critical hit.
                r = new Report(2470);
                r.subject = carrier.getId();
                r.addDesc(carrier);
                reports.addElement(r);
                int mod = 0;
                if (rider.getEntityType() == Entity.ETYPE_INFANTRY) {
                    mod = -2;
                }
                HitData hit = carrier.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                reports.addAll(criticalEntity(carrier, hit.getLocation(), false, mod, 0));
            }
        }
        return reports;
    }

    /**
     * Handles a pointblank shot for hidden units, which must request feedback
     * from the client of the player who owns the hidden unit.
     * @return Returns true if a point-blank shot was taken, otherwise false
     */
    private boolean processPointblankShotCFR(Entity hidden, Entity target) {
        sendPointBlankShotCFR(hidden, target);
        boolean firstPacket = true;
        // Keep processing until we get a response
        while (true) {
            synchronized (cfrPacketQueue) {
                try {
                    while (cfrPacketQueue.isEmpty()) {
                        cfrPacketQueue.wait();
                    }
                } catch (InterruptedException e) {
                    return false;
                }
                // Get the packet, if there's something to get
                Server.ReceivedPacket rp;
                if (!cfrPacketQueue.isEmpty()) {
                    rp = cfrPacketQueue.poll();
                    final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                    // Make sure we got the right type of response
                    if (!cfrType.isCFRHiddenPBS()) {
                        LogManager.getLogger().error("Expected a CFR_HIDDEN_PBS CFR packet, received: " + cfrType);
                        continue;
                    }
                    // Check packet came from right ID
                    if (rp.getConnectionId() != hidden.getOwnerId()) {
                        LogManager.getLogger().error(String.format(
                                "Expected a CFR_HIDDEN_PBS CFR packet from player %d, but instead it came from player %d",
                                hidden.getOwnerId(), rp.getConnectionId()));
                        continue;
                    }
                } else {
                    // If no packets, wait again
                    continue;
                }
                // First packet indicates whether the PBS is taken or declined
                if (firstPacket) {
                    // Check to see if the client declined the PBS
                    if (rp.getPacket().getObject(1) == null) {
                        return false;
                    } else {
                        firstPacket = false;
                        // Notify other clients, so they can display a message
                        for (Player p : game.getPlayersVector()) {
                            if (p.getId() == hidden.getOwnerId()) {
                                continue;
                            }
                            send(p.getId(), new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                                    PacketCommand.CFR_HIDDEN_PBS, Entity.NONE, Entity.NONE));
                        }
                        // Update all clients with the position of the PBS
                        entityUpdate(target.getId());
                        continue;
                    }
                }

                // The second packet contains the attacks to process
                Vector<EntityAction> attacks = (Vector<EntityAction>) rp.getPacket().getObject(1);
                // Mark the hidden unit as having taken a PBS
                hidden.setMadePointblankShot(true);
                // Process the Actions
                for (EntityAction ea : attacks) {
                    Entity entity = game.getEntity(ea.getEntityId());
                    if (ea instanceof TorsoTwistAction) {
                        TorsoTwistAction tta = (TorsoTwistAction) ea;
                        if (entity.canChangeSecondaryFacing()) {
                            entity.setSecondaryFacing(tta.getFacing());
                        }
                    } else if (ea instanceof FlipArmsAction) {
                        FlipArmsAction faa = (FlipArmsAction) ea;
                        entity.setArmsFlipped(faa.getIsFlipped());
                    } else if (ea instanceof SearchlightAttackAction) {
                        boolean hexesAdded = ((SearchlightAttackAction) ea).setHexesIlluminated(game);
                        // If we added new hexes, send them to all players.
                        // These are spotlights at night, you know they're there.
                        if (hexesAdded) {
                            send(createIlluminatedHexesPacket());
                        }
                        SearchlightAttackAction saa = (SearchlightAttackAction) ea;
                        addReport(saa.resolveAction(game));
                    } else if (ea instanceof WeaponAttackAction) {
                        WeaponAttackAction waa = (WeaponAttackAction) ea;
                        Entity ae = game.getEntity(waa.getEntityId());
                        Mounted m = ae.getEquipment(waa.getWeaponId());
                        Weapon w = (Weapon) m.getType();
                        // Track attacks original target, for things like swarm LRMs
                        waa.setOriginalTargetId(waa.getTargetId());
                        waa.setOriginalTargetType(waa.getTargetType());
                        AttackHandler ah = w.fire(waa, game, this);
                        if (ah != null) {
                            ah.setStrafing(waa.isStrafing());
                            ah.setStrafingFirstShot(waa.isStrafingFirstShot());
                            game.addAttack(ah);
                        }
                    }
                }
                // Now handle the attacks
                // Set to the firing phase, so the attacks handle
                GamePhase currentPhase = game.getPhase();
                game.setPhase(GamePhase.FIRING);
                // Handle attacks
                handleAttacks(true);
                // Restore Phase
                game.setPhase(currentPhase);
                return true;
            }
        }
    }

    public int processTeleguidedMissileCFR(int playerId, List<Integer> targetIds,
                                           List<Integer> toHitValues) {
        sendTeleguidedMissileCFR(playerId, targetIds, toHitValues);
        while (true) {
            synchronized (cfrPacketQueue) {
                try {
                    while (cfrPacketQueue.isEmpty()) {
                        cfrPacketQueue.wait();
                    }
                } catch (InterruptedException e) {
                    return 0;
                }

                // Get the packet, if there's something to get
                Server.ReceivedPacket rp = cfrPacketQueue.poll();
                final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                // Make sure we got the right type of response
                if (!cfrType.isCFRTeleguidedTarget()) {
                    LogManager.getLogger().error("Expected a CFR_TELEGUIDED_TARGET CFR packet, received: " + cfrType);
                    continue;
                }
                // Check packet came from right ID
                if (rp.getConnectionId() != playerId) {
                    LogManager.getLogger().error(String.format(
                            "Expected a CFR_TELEGUIDED_TARGET CFR packet from player %d, but instead it came from player %d",
                            playerId, rp.getConnectionId()));
                    continue;
                }
                return (int) rp.getPacket().getData()[1];
            }
        }
    }

    public int processTAGTargetCFR(int playerId, List<Integer> targetIds, List<Integer> targetTypes) {
        sendTAGTargetCFR(playerId, targetIds, targetTypes);
        while (true) {
            synchronized (cfrPacketQueue) {
                try {
                    while (cfrPacketQueue.isEmpty()) {
                        cfrPacketQueue.wait();
                    }
                } catch (InterruptedException e) {
                    return 0;
                }
                // Get the packet, if there's something to get
                Server.ReceivedPacket rp = cfrPacketQueue.poll();
                final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                // Make sure we got the right type of response
                if (!cfrType.isCFRTagTarget()) {
                    LogManager.getLogger().error("Expected a CFR_TAG_TARGET CFR packet, received: " + cfrType);
                    continue;
                }
                // Check packet came from right ID
                if (rp.getConnectionId() != playerId) {
                    LogManager.getLogger().error(String.format(
                            "Expected a CFR_TAG_TARGET CFR packet from player %d but instead it came from player %d",
                            playerId, rp.getConnectionId()));
                    continue;
                }
                return (int) rp.getPacket().getData()[1];
            }
        }
    }

    /**
     * If an aero unit takes off in the same turn that other units loaded, then
     * it risks damage to itself and those units
     *
     * @param a - The <code>Aero</code> taking off
     */
    private void checkForTakeoffDamage(IAero a) {
        boolean unsecured = false;
        for (Entity loaded : ((Entity) a).getLoadedUnits()) {
            if (loaded.wasLoadedThisTurn() && !(loaded instanceof Infantry)) {
                unsecured = true;
                // uh-oh, you forgot your seat belt
                Report r = new Report(6800);
                r.subject = loaded.getId();
                r.addDesc(loaded);
                addReport(r);
                int damage = 25;
                ToHitData toHit = new ToHitData();
                while (damage > 0) {
                    HitData hit = loaded.rollHitLocation(toHit.getHitTable(), ToHitData.SIDE_FRONT);
                    addReport(damageEntity(loaded, hit, 5, false,
                            DamageType.NONE, false, true, false));
                    damage -= 5;
                }
            }
        }

        if (unsecured) {
            // roll hit location to get a new critical
            HitData hit = ((Entity) a).rollHitLocation(ToHitData.HIT_ABOVE, ToHitData.SIDE_FRONT);
            addReport(applyCriticalHit((Entity) a, hit.getLocation(), new CriticalSlot(
                    0, ((Aero) a).getPotCrit()), true, 1, false));
        }

    }

    /**
     * Delivers a thunder-aug shot to the targeted hex area. Thunder-Augs are 7
     * hexes, though, so...
     *
     * @param damage
     *            The per-hex density of the incoming minefield; that is, the
     *            final value with any modifiers (such as halving and rounding
     *            just for <em>being</em> T-Aug) already applied.
     */
    public void deliverThunderAugMinefield(Coords coords, int playerId, int damage, int entityId) {
        Coords mfCoord;
        for (int dir = 0; dir < 7; dir++) {
            // May need to reset here for each new hex.
            int hexDamage = damage;
            if (dir == 6) {// The targeted hex.
                mfCoord = coords;
            } else {// The hex in the dir direction from the targeted hex.
                mfCoord = coords.translated(dir);
            }

            // Only if this is on the board...
            if (game.getBoard().contains(mfCoord)) {
                Minefield minefield = null;
                Enumeration<Minefield> minefields = game.getMinefields(mfCoord).elements();
                // Check if there already are Thunder minefields in the hex.
                while (minefields.hasMoreElements()) {
                    Minefield mf = minefields.nextElement();
                    if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                        minefield = mf;
                        break;
                    }
                }

                // Did we find a Thunder minefield in the hex?
                // N.B. damage Thunder minefields equals the number of
                // missiles, divided by two, rounded up.
                if (minefield == null) {
                    // Nope. Create a new Thunder minefield
                    minefield = Minefield.createMinefield(mfCoord, playerId,
                            Minefield.TYPE_CONVENTIONAL, hexDamage);
                    game.addMinefield(minefield);
                    checkForRevealMinefield(minefield, game.getEntity(entityId));
                } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
                    // Yup. Replace the old one.
                    removeMinefield(minefield);
                    hexDamage += minefield.getDensity();

                    // Damage from Thunder minefields are capped.
                    if (hexDamage > Minefield.MAX_DAMAGE) {
                        hexDamage = Minefield.MAX_DAMAGE;
                    }
                    minefield.setDensity(hexDamage);
                    game.addMinefield(minefield);
                    checkForRevealMinefield(minefield, game.getEntity(entityId));
                }
            }
        }
    }

    /**
     * Adds a Thunder minefield to the hex.
     *
     * @param coords   the minefield's coordinates
     * @param playerId the deploying player's id
     * @param damage   the amount of damage the minefield does
     * @param entityId an entity that might spot the minefield
     */
    public void deliverThunderMinefield(Coords coords, int playerId, int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords).elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_CONVENTIONAL, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = Math.min(damage, Minefield.MAX_DAMAGE);
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Adds a Thunder Inferno minefield to the hex.
     *
     * @param coords   the minefield's coordinates
     * @param playerId the deploying player's id
     * @param damage   the amount of damage the minefield does
     * @param entityId an entity that might spot the minefield
     */
    public void deliverThunderInfernoMinefield(Coords coords, int playerId, int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords).elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_INFERNO) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder Inferno minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_INFERNO, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = Math.min(damage, Minefield.MAX_DAMAGE);
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Delivers an artillery FASCAM shot to the targeted hex area.
     */
    public void deliverFASCAMMinefield(Coords coords, int playerId, int damage, int entityId) {
        // Only if this is on the board...
        if (game.getBoard().contains(coords)) {
            Minefield minefield = null;
            Enumeration<Minefield> minefields = game.getMinefields(coords).elements();
            // Check if there already are Thunder minefields in the hex.
            while (minefields.hasMoreElements()) {
                Minefield mf = minefields.nextElement();
                if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                    minefield = mf;
                    break;
                }
            }
            // Did we find a Thunder minefield in the hex?
            if (minefield == null) {
                minefield = Minefield.createMinefield(coords, playerId,
                        Minefield.TYPE_CONVENTIONAL, damage);
                game.addMinefield(minefield);
                checkForRevealMinefield(minefield, game.getEntity(entityId));
            } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
                // Add to the old one.
                removeMinefield(minefield);
                int oldDamage = minefield.getDensity();
                damage += oldDamage;
                damage = Math.min(damage, Minefield.MAX_DAMAGE);
                minefield.setDensity(damage);
                game.addMinefield(minefield);
                checkForRevealMinefield(minefield, game.getEntity(entityId));
            }
        }
    }

    /**
     * Adds a Thunder-Active minefield to the hex.
     * @param coords   the minefield's coordinates
     * @param playerId the deploying player's id
     * @param damage   the amount of damage the minefield does
     * @param entityId an entity that might spot the minefield
     */
    public void deliverThunderActiveMinefield(Coords coords, int playerId, int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords).elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_ACTIVE) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder-Active minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_ACTIVE, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = Math.min(damage, Minefield.MAX_DAMAGE);
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Adds a Thunder-Vibrabomb minefield to the hex.
     */
    public void deliverThunderVibraMinefield(Coords coords, int playerId,
                                             int damage, int sensitivity, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords).elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder-Vibra minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId,
                    Minefield.TYPE_VIBRABOMB, damage, sensitivity);
            game.addMinefield(minefield);
            game.addVibrabomb(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = Math.min(damage, Minefield.MAX_DAMAGE);
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            game.addVibrabomb(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Creates an artillery flare of the given radius above the target
     */
    public void deliverArtilleryFlare(Coords coords, int radius) {
        Flare flare = new Flare(coords, 5, radius, Flare.F_DRIFTING);
        game.addFlare(flare);
    }

    public void deliverMortarFlare(Coords coords, int duration) {
        Flare flare = new Flare(coords, duration, 1, Flare.F_IGNITED);
        game.addFlare(flare);
    }

    /**
     * deliver missile smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */
    public void deliverMissileSmoke(Coords coords, int smokeType, Vector<Report> vPhaseReport) {
        Report r;
        if (smokeType == SmokeCloud.SMOKE_GREEN) {
            r = new Report(5184, Report.PUBLIC);
        } else {
            r = new Report(5183, Report.PUBLIC);
            //Report either light or heavy smoke, as appropriate
            r.choose(smokeType == SmokeCloud.SMOKE_LIGHT);
            r.indent(2);
        }
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, smokeType, 3);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, smokeType));
        sendChangedHex(coords);
    }

    public void deliverSmokeGrenade(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5200, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_LIGHT, 3);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_LIGHT));
        sendChangedHex(coords);
    }

    public void deliverSmokeMortar(Coords coords, Vector<Report> vPhaseReport, int duration) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, duration);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
        sendChangedHex(coords);
    }

    public void deliverChaffGrenade(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5187, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_CHAFF_LIGHT, 1);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_CHAFF_LIGHT));
        sendChangedHex(coords);
    }

    /**
     * deliver artillery smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */
    public void deliverArtillerySmoke(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, 3);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
        sendChangedHex(coords);
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            r = new Report(5185, Report.PUBLIC);
            r.indent(2);
            r.add(tempcoords.getBoardNum());
            vPhaseReport.add(r);
            createSmoke(tempcoords, SmokeCloud.SMOKE_HEAVY, 3);
            hex = game.getBoard().getHex(tempcoords);
            hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
            sendChangedHex(tempcoords);
        }
    }

    /**
     * deliver LASER inhibiting smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */
    public void deliverLIsmoke(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5186, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_LI_HEAVY, 2);
        Hex hex = game.getBoard().getHex(coords);
        hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_LI_HEAVY));
        sendChangedHex(coords);
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            r = new Report(5186, Report.PUBLIC);
            r.indent(2);
            r.add(tempcoords.getBoardNum());
            vPhaseReport.add(r);
            createSmoke(tempcoords, SmokeCloud.SMOKE_LI_HEAVY, 2);
            hex = game.getBoard().getHex(tempcoords);
            hex.addTerrain(new Terrain(Terrains.SMOKE, SmokeCloud.SMOKE_LI_HEAVY));
            sendChangedHex(tempcoords);
        }
    }

    /**
     * deliver artillery inferno
     *
     * @param coords    the <code>Coords</code> where to deliver
     * @param ae        the attacking <code>entity</code>
     * @param subjectId the <code>int</code> id of the target
     */
    public void deliverArtilleryInferno(Coords coords, Entity ae,
                                        int subjectId, Vector<Report> vPhaseReport) {
        Hex h = game.getBoard().getHex(coords);
        Report r;
        // Unless there is a fire in the hex already, start one.
        if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_IV) {
            ignite(coords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);
        }
        // possibly melt ice and snow
        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {
            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));
        }
        for (Entity entity : game.getEntitiesVector(coords)) {
            // TacOps, p. 356 - treat as if hit by 5 inferno missiles
            r = new Report(6695);
            r.indent(3);
            r.add(entity.getDisplayName());
            r.subject = entity.getId();
            r.newlines = 0;
            vPhaseReport.add(r);
            if (entity instanceof Tank) {
                Report.addNewline(vPhaseReport);
            }
            Vector<Report> vDamageReport = deliverInfernoMissiles(ae, entity, 5, true);
            Report.indentAll(vDamageReport, 2);
            vPhaseReport.addAll(vDamageReport);
        }
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            h = game.getBoard().getHex(tempcoords);
            // Unless there is a fire in the hex already, start one.
            if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_IV) {
                ignite(tempcoords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);
            }
            // possibly melt ice and snow
            if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {
                vPhaseReport.addAll(meltIceAndSnow(tempcoords, subjectId));
            }
            for (Entity entity : game.getEntitiesVector(tempcoords)) {
                r = new Report(6695);
                r.indent(3);
                r.add(entity.getDisplayName());
                r.newlines = 0;
                r.subject = entity.getId();
                vPhaseReport.add(r);
                if (entity instanceof Tank) {
                    Report.addNewline(vPhaseReport);
                }
                Vector<Report> vDamageReport = deliverInfernoMissiles(ae,
                        entity, 5, true);
                Report.indentAll(vDamageReport, 2);
                vPhaseReport.addAll(vDamageReport);
            }
        }
    }

    public void deliverScreen(Coords coords, Vector<Report> vPhaseReport) {
        Hex h = game.getBoard().getHex(coords);
        Report r;
        Report.addNewline(vPhaseReport);
        r = new Report(9070, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        // use level to count the number of screens (since level does not matter
        // in space)
        int nscreens = h.terrainLevel(Terrains.SCREEN);
        if (nscreens > 0) {
            h.removeTerrain(Terrains.SCREEN);
            h.addTerrain(new Terrain(Terrains.SCREEN, nscreens + 1));
        } else {
            h.addTerrain(new Terrain(Terrains.SCREEN, 1));
        }
        sendChangedHex(coords);
    }

    /**
     * deploys a new telemissile entity onto the map
     */
    public void deployTeleMissile(Entity ae, WeaponType wtype, AmmoType atype, int wId,
                                  int capMisMod, int damage, int armor, Vector<Report> vPhaseReport) {
        Report r = new Report(9080);
        r.subject = ae.getId();
        r.addDesc(ae);
        r.indent(2);
        r.newlines = 0;
        r.add(wtype.getName());
        vPhaseReport.add(r);
        TeleMissile tele = new TeleMissile(ae, damage, armor,
                atype.getTonnage(ae), atype.getAmmoType(), capMisMod);
        tele.setDeployed(true);
        tele.setId(game.getNextEntityId());
        if (ae instanceof Aero) {
            Aero a = (Aero) ae;
            tele.setCurrentVelocity(a.getCurrentVelocity());
            tele.setNextVelocity(a.getNextVelocity());
            tele.setVectors(a.getVectors());
            tele.setFacing(a.getFacing());
        }
        // set velocity and heading the same as parent entity
        game.addEntity(tele);
        send(createAddEntityPacket(tele.getId()));
        // make him not get a move this turn
        tele.setDone(true);
        // place on board
        tele.setPosition(ae.getPosition());
        // Update the entity
        entityUpdate(tele.getId());
        // check to see if the launching of this missile removes control of any
        // prior missiles
        if (ae.getTMTracker().containsLauncher(wId)) {
            Entity priorMissile = game.getEntity(ae.getTMTracker().getMissile(wId));
            if (priorMissile instanceof TeleMissile) {
                ((TeleMissile) priorMissile).setOutContact(true);
                // remove this from the tracker for good measure
                ae.getTMTracker().removeMissile(wId);
            }
        }
        // track this missile on the entity
        ae.getTMTracker().addMissile(wId, tele.getId());
    }

    /**
     * deliver inferno missiles
     *
     * @param ae       the <code>Entity</code> that fired the missiles
     * @param t        the <code>Targetable</code> that is the target
     * @param missiles the <code>int</code> amount of missiles
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t, int missiles) {
        return deliverInfernoMissiles(ae, t, missiles, CalledShot.CALLED_NONE);
    }

    /**
     * deliver inferno missiles
     *
     * @param ae       the <code>Entity</code> that fired the missiles
     * @param t        the <code>Targetable</code> that is the target
     * @param missiles the <code>int</code> amount of missiles
     * @param areaEffect a <code>boolean</code> indicating whether the attack is from an
     *                   area effect weapon such as Arrow IV inferno, and partial cover should
     *                   be ignored.
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t, int missiles,
                                                 boolean areaEffect) {
        return deliverInfernoMissiles(ae, t, missiles, CalledShot.CALLED_NONE, areaEffect);
    }

    /**
     * deliver inferno missiles
     *
     * @param ae       the <code>Entity</code> that fired the missiles
     * @param t        the <code>Targetable</code> that is the target
     * @param missiles the <code>int</code> amount of missiles
     * @param called   an <code>int</code> indicated the aiming mode used to fire the
     *                 inferno missiles (for called shots)
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t, int missiles,
                                                 int called) {
        return deliverInfernoMissiles(ae, t, missiles, called, false);
    }

    /**
     * deliver inferno missiles
     *
     * @param ae         the <code>Entity</code> that fired the missiles
     * @param t          the <code>Targetable</code> that is the target
     * @param missiles   the <code>int</code> amount of missiles
     * @param called     an <code>int</code> indicated the aiming mode used to fire the
     *                   inferno missiles (for called shots)
     * @param areaEffect a <code>boolean</code> indicating whether the attack is from an
     *                   area effect weapon such as Arrow IV inferno, and partial cover should
     *                   be ignored.
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t, int missiles, int called,
                                                 boolean areaEffect) {
        Hex hex = game.getBoard().getHex(t.getPosition());
        Report r;
        Vector<Report> vPhaseReport = new Vector<>();
        int attId = Entity.NONE;
        if (null != ae) {
            attId = ae.getId();
        }
        switch (t.getTargetType()) {
            case Targetable.TYPE_HEX_ARTILLERY:
                // used for BA inferno explosion
                for (Entity e : game.getEntitiesVector(t.getPosition())) {
                    if (e.getElevation() > hex.terrainLevel(Terrains.BLDG_ELEV)) {
                        r = new Report(6685);
                        r.subject = e.getId();
                        r.addDesc(e);
                        vPhaseReport.add(r);
                        vPhaseReport.addAll(deliverInfernoMissiles(ae, e, missiles, called));
                    } else {
                        int roll = Compute.d6();
                        r = new Report(3570);
                        r.subject = e.getId();
                        r.addDesc(e);
                        r.add(roll);
                        vPhaseReport.add(r);
                        if (roll >= 5) {
                            vPhaseReport.addAll(deliverInfernoMissiles(ae, e, missiles, called));
                        }
                    }
                }
                if (game.getBoard().getBuildingAt(t.getPosition()) != null) {
                    Vector<Report> vBuildingReport = damageBuilding(game.getBoard().getBuildingAt(t.getPosition()),
                            2 * missiles, t.getPosition());
                    for (Report report : vBuildingReport) {
                        report.subject = attId;
                    }
                    vPhaseReport.addAll(vBuildingReport);
                }
                // fall through
            case Targetable.TYPE_HEX_CLEAR:
            case Targetable.TYPE_HEX_IGNITE:
                // Report that damage applied to terrain, if there's TF to damage
                Hex h = game.getBoard().getHex(t.getPosition());
                if ((h != null) && h.hasTerrainFactor()) {
                    r = new Report(3384);
                    r.indent(2);
                    r.subject = attId;
                    r.add(t.getPosition().getBoardNum());
                    r.add(missiles * 4);
                    vPhaseReport.addElement(r);
                }
                vPhaseReport.addAll(tryClearHex(t.getPosition(), missiles * 4, attId));
                tryIgniteHex(t.getPosition(), attId, false, true,
                        new TargetRoll(0, "inferno"), -1, vPhaseReport);
                break;
            case Targetable.TYPE_BLDG_IGNITE:
            case Targetable.TYPE_BUILDING:
                Vector<Report> vBuildingReport = damageBuilding(game.getBoard().getBuildingAt(t.getPosition()),
                        2 * missiles, t.getPosition());
                for (Report report : vBuildingReport) {
                    report.subject = attId;
                }
                vPhaseReport.addAll(vBuildingReport);

                // For each missile, check to see if it hits a unit in this hex
                for (Entity e : game.getEntitiesVector(t.getPosition())) {
                    if (e.getElevation() > hex.terrainLevel(Terrains.BLDG_ELEV)) {
                        continue;
                    }
                    for (int m = 0; m < missiles; m++) {
                        int roll = Compute.d6();
                        r = new Report(3570);
                        r.subject = e.getId();
                        r.indent(3);
                        r.addDesc(e);
                        r.add(roll);
                        vPhaseReport.add(r);
                        if (roll >= 5) {
                            Vector<Report> dmgReports = deliverInfernoMissiles(ae, e, 1, called);
                            for (Report rep : dmgReports) {
                                rep.indent(4);
                            }
                            vPhaseReport.addAll(dmgReports);
                        }
                    }
                }

                break;
            case Targetable.TYPE_ENTITY:
                Entity te = (Entity) t;
                if ((te instanceof Mech) && (!areaEffect)) {
                    // Bug #1585497: Check for partial cover
                    int m = missiles;
                    LosEffects le = LosEffects.calculateLOS(game, ae, t);
                    int cover = le.getTargetCover();
                    Vector<Report> coverDamageReports = new Vector<>();
                    int heatDamage = 0;
                    boolean heatReduced = false;
                    String reductionCause = "";
                    for (int i = 0; i < m; i++) {
                        int side = Compute.targetSideTable(ae, t, called);
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, side);
                        if (te.removePartialCoverHits(hit.getLocation(), cover, side)) {
                            missiles--;
                            // Determine if damageable cover is hit
                            int damageableCoverType;
                            Entity coverDropship;
                            Coords coverLoc;

                            // Determine if there is primary and secondary
                            // cover,
                            // and then determine which one gets hit
                            if (((cover == LosEffects.COVER_75RIGHT) || (cover == LosEffects.COVER_75LEFT))
                                    // 75% cover has a primary and secondary
                                    || ((cover == LosEffects.COVER_HORIZONTAL)
                                    && (le.getDamagableCoverTypeSecondary() != LosEffects.DAMAGABLE_COVER_NONE))) {
                                // Horizontal cover provided by two 25%'s,
                                // so primary and secondary
                                int hitLoc = hit.getLocation();
                                // Primary stores the left side, from the
                                // perspective of the attacker
                                if ((hitLoc == Mech.LOC_RLEG) || (hitLoc == Mech.LOC_RT)
                                        || (hitLoc == Mech.LOC_RARM)) {
                                    // Left side is primary
                                    damageableCoverType = le.getDamagableCoverTypePrimary();
                                    coverDropship = le.getCoverDropshipPrimary();
                                    coverLoc = le.getCoverLocPrimary();
                                } else {
                                    // If not left side, then right side,
                                    // which is secondary
                                    damageableCoverType = le.getDamagableCoverTypeSecondary();
                                    coverDropship = le.getCoverDropshipSecondary();
                                    coverLoc = le.getCoverLocSecondary();
                                }
                            } else { // Only primary cover exists
                                damageableCoverType = le.getDamagableCoverTypePrimary();
                                coverDropship = le.getCoverDropshipPrimary();
                                coverLoc = le.getCoverLocPrimary();
                            }

                            // Check if we need to damage the cover that
                            // absorbed
                            // the hit.
                            Vector<Report> coverDamageReport = new Vector<>();
                            if (damageableCoverType == LosEffects.DAMAGABLE_COVER_DROPSHIP) {
                                r = new Report(3465);
                                r.addDesc(coverDropship);
                                r.indent(1);
                                coverDamageReport = deliverInfernoMissiles(ae,
                                        coverDropship, 1, CalledShot.CALLED_NONE);
                                coverDamageReport.insertElementAt(r, 0);
                                for (Report report : coverDamageReport) {
                                    report.indent(1);
                                }
                            } else if (damageableCoverType == LosEffects.DAMAGABLE_COVER_BUILDING) {
                                BuildingTarget bldgTrgt = new BuildingTarget(coverLoc,
                                        game.getBoard(), false);
                                coverDamageReport = deliverInfernoMissiles(ae, bldgTrgt, 1,
                                        CalledShot.CALLED_NONE);
                            }
                            for (Report report : coverDamageReport) {
                                report.indent(1);
                            }
                            coverDamageReports.addAll(coverDamageReport);
                        } else { // No partial cover, missile hits
                            if ((te.getArmor(hit) > 0)
                                    && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAT_DISSIPATING)) {
                                heatDamage += 1;
                                heatReduced = true;
                                reductionCause = EquipmentType.armorNames[te
                                        .getArmorType(hit.getLocation())];
                            } else {
                                heatDamage += 2;
                            }
                        }
                    }
                    if (heatReduced) {
                        r = new Report(3406);
                        r.add(heatDamage);
                        r.subject = te.getId();
                        r.indent(2);
                        r.choose(true);
                        r.add(missiles * 2);
                        r.add(reductionCause);
                    } else {
                        r = new Report(3400);
                        r.add(heatDamage);
                        r.subject = te.getId();
                        r.indent(2);
                        r.choose(true);
                    }
                    vPhaseReport.add(r);
                    Report.addNewline(vPhaseReport);
                    te.heatFromExternal += heatDamage;

                    if (missiles != m) {
                        r = new Report(3403);
                        r.add(m - missiles);
                        r.indent(2);
                        r.subject = te.getId();
                        vPhaseReport.add(r);
                    }
                    vPhaseReport.addAll(coverDamageReports);
                    Report.addNewline(vPhaseReport);
                } else if (te.tracksHeat()) {
                    // ASFs and small craft
                    r = new Report(3400);
                    r.add(2 * missiles);
                    r.subject = te.getId();
                    r.indent(2);
                    r.choose(true);
                    vPhaseReport.add(r);
                    te.heatFromExternal += 2 * missiles;
                    Report.addNewline(vPhaseReport);
                } else if (te instanceof GunEmplacement) {
                    int direction = Compute.targetSideTable(ae, te, called);
                    while (missiles-- > 0) {
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, direction);
                        vPhaseReport.addAll(damageEntity(te, hit, 2));
                    }
                } else if ((te instanceof Tank) || te.isSupportVehicle()) {
                    int direction = Compute.targetSideTable(ae, te, called);
                    while (missiles-- > 0) {
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, direction);
                        int critRollMod = 0;
                        if (!te.isSupportVehicle() || (te.hasArmoredChassis()
                                && (te.getBARRating(hit.getLocation()) > 9))) {
                            critRollMod -= 2;
                        }
                        if ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED)
                                && (te.getArmor(hit.getLocation()) > 0)) {
                            critRollMod -= 2;
                        }
                        vPhaseReport.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),
                                critRollMod, 0, DamageType.INFERNO));
                    }
                } else if (te instanceof ConvFighter) {
                    // CFs take a point SI damage for every three missiles that hit.
                    // Use the heatFromExternal field to carry the remainder in case of multiple inferno hits.
                    te.heatFromExternal += missiles;
                    if (te.heatFromExternal >= 3) {
                        int siDamage = te.heatFromExternal / 3;
                        te.heatFromExternal %= 3;
                        final ConvFighter ftr = (ConvFighter) te;
                        int remaining = Math.max(0,  ftr.getSI() - siDamage);
                        r = new Report(9146);
                        r.subject = te.getId();
                        r.indent(2);
                        r.add(siDamage);
                        r.add(remaining);
                        vPhaseReport.add(r);
                        ftr.setSI(remaining);
                        te.damageThisPhase += siDamage;
                        if (remaining <= 0) {
                            // Lets auto-eject if we can!
                            if (ftr.isAutoEject()
                                    && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                    && ftr.isCondEjectSIDest()))) {
                                vPhaseReport.addAll(ejectEntity(te, true, false));
                            }
                            vPhaseReport.addAll(destroyEntity(te,"Structural Integrity Collapse"));
                            ftr.setSI(0);
                            if (null != ae) {
                                creditKill(te, ae);
                            }
                        }
                    }
                } else if (te.isLargeCraft()) {
                    // Large craft ignore infernos
                    r = new Report(1242);
                    r.subject = te.getId();
                    r.indent(2);
                    vPhaseReport.add(r);
                } else if (te instanceof Protomech) {
                    te.heatFromExternal += missiles;
                    while (te.heatFromExternal >= 3) {
                        te.heatFromExternal -= 3;
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                        if (hit.getLocation() == Protomech.LOC_NMISS) {
                            Protomech proto = (Protomech) te;
                            r = new Report(6035);
                            r.subject = te.getId();
                            r.indent(2);
                            if (proto.isGlider()) {
                                r.messageId = 6036;
                                proto.setWingHits(proto.getWingHits() + 1);
                            }
                            vPhaseReport.add(r);
                        } else {
                            r = new Report(6690);
                            r.subject = te.getId();
                            r.indent(2);
                            r.add(te.getLocationName(hit));
                            vPhaseReport.add(r);
                            te.destroyLocation(hit.getLocation());
                            // Handle ProtoMech pilot damage
                            // due to location destruction
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]
                                    - ((Protomech) te).getPilotDamageTaken(hit.getLocation());
                            if (hits > 0) {
                                vPhaseReport.addAll(damageCrew(te, hits));
                                ((Protomech) te).setPilotDamageTaken(hit.getLocation(),
                                        Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);
                            }
                            if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                                vPhaseReport.addAll(destroyEntity(te,
                                        "flaming inferno death", false, true));
                                Report.addNewline(vPhaseReport);
                            }
                        }
                    }
                } else if (te instanceof BattleArmor) {
                    if (((BattleArmor) te).isFireResistant()) {
                        r = new Report(3395);
                        r.indent(2);
                        r.subject = te.getId();
                        r.addDesc(te);
                        vPhaseReport.add(r);
                        return vPhaseReport;
                    }
                    te.heatFromExternal += missiles;
                    while (te.heatFromExternal >= 3) {
                        te.heatFromExternal -= 3;
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                        hit.setEffect(HitData.EFFECT_CRITICAL);
                        vPhaseReport.addAll(damageEntity(te, hit, 1));
                        Report.addNewline(vPhaseReport);
                    }
                } else if (te instanceof Infantry) {
                    HitData hit = new HitData(Infantry.LOC_INFANTRY);
                    if (te.getInternal(hit) > (3 * missiles)) {
                        // internal structure absorbs all damage
                        te.setInternal(te.getInternal(hit) - (3 * missiles), hit);
                        r = new Report(6065);
                        r.addDesc(te);
                        r.add(3 * missiles);
                        r.indent(2);
                        r.add(te.getLocationAbbr(hit));
                        r.newlines = 0;
                        r.subject = te.getId();
                        vPhaseReport.add(r);
                        Report.addNewline(vPhaseReport);
                        r = new Report(6095);
                        r.add(te.getInternal(hit));
                        r.subject = te.getId();
                        r.indent(3);
                        vPhaseReport.add(r);
                    } else {
                        vPhaseReport.addAll(destroyEntity(te, "damage", false));
                        creditKill(te, ae);
                        Report.addNewline(vPhaseReport);
                    }
                }
        }
        return vPhaseReport;
    }

    /**
     * Check for any detonations when an entity enters a minefield, except a
     * vibrabomb.
     *
     * @param entity
     *            - the <code>entity</code> who entered the minefield
     * @param c
     *            - the <code>Coords</code> of the minefield
     * @param curElev
     *            - an <code>int</code> for the elevation of the entity entering
     *            the minefield (used for underwater sea mines)
     * @param isOnGround
     *            - <code>true</code> if the entity is not in the middle of a
     *            jump
     * @param vMineReport
     *            - the {@link Report} <code>Vector</code> that reports will be added to
     * @return - <code>true</code> if the entity set off any mines
     */
    private boolean enterMinefield(Entity entity, Coords c, int curElev, boolean isOnGround,
                                   Vector<Report> vMineReport) {
        return enterMinefield(entity, c, curElev, isOnGround, vMineReport, -1);
    }

    /**
     * Check for any detonations when an entity enters a minefield, except a
     * vibrabomb.
     *
     * @param entity
     *            - the <code>entity</code> who entered the minefield
     * @param c
     *            - the <code>Coords</code> of the minefield
     * @param curElev
     *            - an <code>int</code> for the elevation of the entity entering
     *            the minefield (used for underwater sea mines)
     * @param isOnGround
     *            - <code>true</code> if the entity is not in the middle of a
     *            jump
     * @param vMineReport
     *            - the {@link Report} <code>Vector</code> that reports will be added to
     * @param target
     *            - the <code>int</code> target number for detonation. If this
     *            will be determined by density, it should be -1
     * @return - <code>true</code> if the entity set off any mines
     */
    private boolean enterMinefield(Entity entity, Coords c, int curElev, boolean isOnGround,
                                   Vector<Report> vMineReport, int target) {
        Report r;
        boolean trippedMine = false;
        // flying units cannot trip a mine
        if (curElev > 0) {
            return false;
        }

        // Check for Mine sweepers
        Mounted minesweeper = null;
        for (Mounted m : entity.getMisc()) {
            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) && m.isReady() && (m.getArmorValue() > 0)) {
                minesweeper = m;
                break; // Can only have one minesweeper
            }
        }

        Vector<Minefield> fieldsToRemove = new Vector<>();
        // loop through mines in this hex
        for (Minefield mf : game.getMinefields(c)) {
            // vibrabombs are handled differently
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                continue;
            }

            // if we are in the water, then the sea mine will only blow up if at
            // the right depth
            if (game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)) {
                if ((Math.abs(curElev) != mf.getDepth())
                        && (Math.abs(curElev + entity.getHeight()) != mf.getDepth())) {
                    continue;
                }
            }

            // Check for mine-sweeping. Vibramines handled elsewhere
            if ((minesweeper != null)
                    && ((mf.getType() == Minefield.TYPE_CONVENTIONAL)
                    || (mf.getType() == Minefield.TYPE_ACTIVE)
                    || (mf.getType() == Minefield.TYPE_INFERNO))) {
                // Check to see if the minesweeper clears
                int roll = Compute.d6(2);

                // Report minefield roll
                if (doBlind()) { // only report if DB, otherwise all players see
                    r = new Report(2152, Report.PLAYER);
                    r.player = mf.getPlayerId();
                    r.add(Minefield.getDisplayableName(mf.getType()));
                    r.add(mf.getCoords().getBoardNum());
                    r.add(roll);
                    r.newlines = 0;
                    vMineReport.add(r);
                }

                if (roll >= 6) {
                    // Report hit
                    if (doBlind()) {
                        r = new Report(5543, Report.PLAYER);
                        r.player = mf.getPlayerId();
                        vMineReport.add(r);
                    }

                    // Clear the minefield
                    r = new Report(2158);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(Minefield.getDisplayableName(mf.getType()), true);
                    r.add(mf.getCoords().getBoardNum(), true);
                    r.indent();
                    vMineReport.add(r);
                    fieldsToRemove.add(mf);

                    // Handle armor value damage
                    int remainingAV = minesweeper.getArmorValue() - 6;
                    minesweeper.setArmorValue(Math.max(remainingAV, 0));

                    r = new Report(2161);
                    r.indent(2);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(6);
                    r.add(Math.max(remainingAV, 0));
                    vMineReport.add(r);

                    if (remainingAV <= 0) {
                        minesweeper.setDestroyed(true);
                    }
                    // Check for damage transfer
                    if (remainingAV < 0) {
                        int damage = Math.abs(remainingAV);
                        r = new Report(2162);
                        r.indent(2);
                        r.subject = entity.getId();
                        r.add(damage, true);
                        vMineReport.add(r);

                        // Damage is dealt to the location of minesweeper
                        HitData hit = new HitData(minesweeper.getLocation());
                        Vector<Report> damageReports = damageEntity(entity, hit, damage);
                        for (Report r1 : damageReports) {
                            r1.indent(1);
                        }
                        vMineReport.addAll(damageReports);
                    }
                    Report.addNewline(vMineReport);
                    // If the minefield is cleared, we're done processing it
                    continue;
                } else {
                    // Report miss
                    if (doBlind()) {
                        r = new Report(5542, Report.PLAYER);
                        r.player = mf.getPlayerId();
                        vMineReport.add(r);
                    }
                }
            }

            // check whether we have an active mine
            if ((mf.getType() == Minefield.TYPE_ACTIVE) && isOnGround) {
                continue;
            } else if ((mf.getType() != Minefield.TYPE_ACTIVE) && !isOnGround) {
                continue;
            }

            // set the target number
            if (target == -1) {
                target = mf.getTrigger();
                if (mf.getType() == Minefield.TYPE_ACTIVE) {
                    target = 9;
                }
                if (entity instanceof Infantry) {
                    target += 1;
                }
                if (entity.hasAbility(OptionsConstants.MISC_EAGLE_EYES)) {
                    target += 2;
                }
                if ((entity.getMovementMode() == EntityMovementMode.HOVER)
                        || (entity.getMovementMode() == EntityMovementMode.WIGE)) {
                    target = Minefield.HOVER_WIGE_DETONATION_TARGET;
                }
            }

            int roll = Compute.d6(2);

            // Report minefield roll
            if (doBlind()) { // Only do if DB, otherwise all players will see
                r = new Report(2151, Report.PLAYER);
                r.player = mf.getPlayerId();
                r.add(Minefield.getDisplayableName(mf.getType()));
                r.add(mf.getCoords().getBoardNum());
                r.add(target);
                r.add(roll);
                r.newlines = 0;
                vMineReport.add(r);
            }

            if (roll < target) {
                // Report miss
                if (doBlind()) {
                    r = new Report(2217, Report.PLAYER);
                    r.player = mf.getPlayerId();
                    vMineReport.add(r);
                }
                continue;
            }

            // Report hit
            if (doBlind()) {
                r = new Report(2270, Report.PLAYER);
                r.player = mf.getPlayerId();
                vMineReport.add(r);
            }

            // apply damage
            trippedMine = true;
            // explodedMines.add(mf);
            mf.setDetonated(true);
            if (mf.getType() == Minefield.TYPE_INFERNO) {
                // report hitting an inferno mine
                r = new Report(2155);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                r.indent();
                vMineReport.add(r);
                vMineReport.addAll(deliverInfernoMissiles(entity, entity, mf.getDensity() / 2));
            } else {
                r = new Report(2150);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                r.indent();
                vMineReport.add(r);
                int damage = mf.getDensity();
                while (damage > 0) {
                    int cur_damage = Math.min(5, damage);
                    damage = damage - cur_damage;
                    HitData hit;
                    if (minesweeper == null) {
                        hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE,
                                Minefield.TO_HIT_SIDE);
                    } else { // Minesweepers cause mines to hit minesweeper loc
                        hit = new HitData(minesweeper.getLocation());
                    }
                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));
                }

                if (entity instanceof Tank) {
                    // Tanks check for motive system damage from minefields as
                    // from a side hit even though the damage proper hits the
                    // front above; exact side doesn't matter, though.
                    vMineReport.addAll(vehicleMotiveDamage((Tank) entity,
                            entity.getMotiveSideMod(ToHitData.SIDE_LEFT)));
                }
                Report.addNewline(vMineReport);
            }

            // check the direct reduction
            mf.checkReduction(0, true);
            revealMinefield(mf);
        }

        for (Minefield mf : fieldsToRemove) {
            removeMinefield(mf);
        }

        return trippedMine;
    }

    /**
     * cycle through all mines on the board, check to see whether they should do
     * collateral damage to other mines due to detonation, resets detonation to
     * false, and removes any mines whose density has been reduced to zero.
     */
    private void resetMines() {
        Enumeration<Coords> mineLoc = game.getMinedCoords();
        while (mineLoc.hasMoreElements()) {
            Coords c = mineLoc.nextElement();
            Enumeration<Minefield> minefields = game.getMinefields(c).elements();
            while (minefields.hasMoreElements()) {
                Minefield minefield = minefields.nextElement();
                if (minefield.hasDetonated()) {
                    minefield.setDetonated(false);
                    Enumeration<Minefield> otherMines = game.getMinefields(c).elements();
                    while (otherMines.hasMoreElements()) {
                        Minefield otherMine = otherMines.nextElement();
                        if (otherMine.equals(minefield)) {
                            continue;
                        }
                        int bonus = 0;
                        if (otherMine.getDensity() > minefield.getDensity()) {
                            bonus = 1;
                        }
                        if (otherMine.getDensity() < minefield.getDensity()) {
                            bonus = -1;
                        }
                        otherMine.checkReduction(bonus, false);
                    }
                }
            }
            // cycle through a second time to see if any mines at these coords
            // need to be removed
            List<Minefield> mfRemoved = new ArrayList<>();
            Enumeration<Minefield> mines = game.getMinefields(c).elements();
            while (mines.hasMoreElements()) {
                Minefield mine = mines.nextElement();
                if (mine.getDensity() < 5) {
                    mfRemoved.add(mine);
                }
            }
            // we have to do it this way to avoid a concurrent error problem
            for (Minefield mf : mfRemoved) {
                removeMinefield(mf);
            }
            // update the mines at these coords
            sendChangedMines(c);
        }
    }

    /**
     * attempt to clear a minefield
     *
     * @param mf     - a <code>Minefield</code> to clear
     * @param en     - <code>entity</code> doing the clearing
     * @param target - <code>int</code> needed to roll for a successful clearance
     * @return <code>true</code> if clearance successful
     */
    public boolean clearMinefield(Minefield mf, Entity en, int target,
                                  Vector<Report> vClearReport) {
        return clearMinefield(mf, en, target, -1, vClearReport, 2);
    }

    public boolean clearMinefield(Minefield mf, Entity en, int target,
                                  int botch, Vector<Report> vClearReport) {
        return clearMinefield(mf, en, target, botch, vClearReport, 1);
    }

    /**
     * attempt to clear a minefield We don't actually remove the minefield here,
     * because if this is called up from within a loop, that will cause problems
     *
     * @param mf
     *            - a <code>Minefield</code> to clear
     * @param en
     *            - <code>entity</code> doing the clearing
     * @param target
     *            - <code>int</code> needed to roll for a successful clearance
     * @param botch
     *            - <code>int</code> that indicates an accidental detonation
     * @param vClearReport
     *            - The report collection to report to
     * @param indent
     *            - The number of indents for the report
     * @return <code>true</code> if clearance successful
     */
    public boolean clearMinefield(Minefield mf, Entity en, int target,
                                  int botch, Vector<Report> vClearReport, int indent) {
        Report r;
        int roll = Compute.d6(2);
        if (roll >= target) {
            r = new Report(2250);
            r.subject = en.getId();
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            r.indent(indent);
            vClearReport.add(r);
            return true;
        } else if (roll <= botch) {
            // TODO : detonate the minefield
            r = new Report(2255);
            r.subject = en.getId();
            r.indent(indent);
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            vClearReport.add(r);
            // The detonation damages any units that were also attempting to
            // clear mines in the same hex
            for (Entity victim : game.getEntitiesVector(mf.getCoords())) {
                Report rVictim;
                if (victim.isClearingMinefield()) {
                    rVictim = new Report(2265);
                    rVictim.subject = victim.getId();
                    rVictim.add(victim.getShortName(), true);
                    rVictim.indent(indent + 1);
                    vClearReport.add(rVictim);
                    int damage = mf.getDensity();
                    while (damage > 0) {
                        int cur_damage = Math.min(5, damage);
                        damage = damage - cur_damage;
                        HitData hit = victim.rollHitLocation(
                                Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
                        vClearReport.addAll(damageEntity(victim, hit, cur_damage));
                    }
                }
            }
            // reduction works differently here
            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                mf.setDensity(Math.max(5, mf.getDensity() - 5));
            } else {
                // congratulations, you cleared the mine by blowing yourself up
                return true;
            }
        } else {
            // failure
            r = new Report(2260);
            r.subject = en.getId();
            r.indent(indent);
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            vClearReport.add(r);
        }
        return false;
    }

    /**
     * Clear any detonated mines at these coords
     */
    private void clearDetonatedMines(Coords c, int target) {
        Enumeration<Minefield> minefields = game.getMinefields(c).elements();
        List<Minefield> mfRemoved = new ArrayList<>();
        while (minefields.hasMoreElements()) {
            Minefield minefield = minefields.nextElement();
            if (minefield.hasDetonated() && (Compute.d6(2) >= target)) {
                mfRemoved.add(minefield);
            }
        }
        // we have to do it this way to avoid a concurrent error problem
        for (Minefield mf : mfRemoved) {
            removeMinefield(mf);
        }
    }

    /**
     * Checks to see if an entity sets off any vibrabombs.
     */
    private boolean checkVibrabombs(Entity entity, Coords coords, boolean displaced,
                                    Vector<Report> vMineReport) {
        return checkVibrabombs(entity, coords, displaced, null, null, vMineReport);
    }

    /**
     * Checks to see if an entity sets off any vibrabombs.
     */
    private boolean checkVibrabombs(Entity entity, Coords coords, boolean displaced, Coords lastPos,
                                    Coords curPos, Vector<Report> vMineReport) {
        int mass = (int) entity.getWeight();

        // Check for Mine sweepers
        Mounted minesweeper = null;
        for (Mounted m : entity.getMisc()) {
            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) && m.isReady() && (m.getArmorValue() > 0)) {
                minesweeper = m;
                break; // Can only have one minesweeper
            }
        }

        // Check for minesweepers sweeping VB minefields
        if (minesweeper != null) {
            Vector<Minefield> fieldsToRemove = new Vector<>();
            for (Minefield mf : game.getVibrabombs()) {
                // Ignore mines if they aren't in this position
                if (!mf.getCoords().equals(coords)) {
                    continue;
                }

                // Minesweepers on units within 9 tons of the vibrafield setting
                // automatically clear the minefield
                if (Math.abs(mass - mf.getSetting()) < 10) {
                    // Clear the minefield
                    Report r = new Report(2158);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(Minefield.getDisplayableName(mf.getType()), true);
                    r.add(mf.getCoords().getBoardNum(), true);
                    r.indent();
                    vMineReport.add(r);
                    fieldsToRemove.add(mf);

                    // Handle armor value damage
                    int remainingAV = minesweeper.getArmorValue() - 10;
                    minesweeper.setArmorValue(Math.max(remainingAV, 0));

                    r = new Report(2161);
                    r.indent(2);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(10);
                    r.add(Math.max(remainingAV, 0));
                    vMineReport.add(r);

                    if (remainingAV <= 0) {
                        minesweeper.setDestroyed(true);
                    }
                    // Check for damage transfer
                    if (remainingAV < 0) {
                        int damage = Math.abs(remainingAV);
                        r = new Report(2162);
                        r.indent(2);
                        r.subject = entity.getId();
                        r.add(damage, true);
                        vMineReport.add(r);

                        // Damage is dealt to the location of minesweeper
                        HitData hit = new HitData(minesweeper.getLocation());
                        Vector<Report> damageReports = damageEntity(entity, hit, damage);
                        for (Report r1 : damageReports) {
                            r1.indent(1);
                        }
                        vMineReport.addAll(damageReports);
                        entity.applyDamage();
                    }
                    Report.addNewline(vMineReport);
                }
            }
            for (Minefield mf : fieldsToRemove) {
                removeMinefield(mf);
            }
        }

        boolean boom = false;
        // Only mechs can set off vibrabombs. QuadVees should only be able to set off a
        // vibrabomb in Mech mode. Those that are converting to or from Mech mode should
        // are using leg movement and should be able to set them off.
        if (!(entity instanceof Mech) || (entity instanceof QuadVee
                && (entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)
                && !entity.isConvertingNow())) {
            return false;
        }

        Enumeration<Minefield> e = game.getVibrabombs().elements();

        while (e.hasMoreElements()) {
            Minefield mf = e.nextElement();

            // Bug 954272: Mines shouldn't work underwater, and BMRr says
            // Vibrabombs are mines
            if (game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)
                    && !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)
                    && !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {
                continue;
            }

            // Mech weighing 10 tons or less can't set off the bomb
            if (mass <= (mf.getSetting() - 10)) {
                continue;
            }

            int effectiveDistance = (mass - mf.getSetting()) / 10;
            int actualDistance = coords.distance(mf.getCoords());

            if (actualDistance <= effectiveDistance) {
                Report r = new Report(2156);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                vMineReport.add(r);

                // if the moving entity is not actually moving into the vibrabomb
                // hex, it won't get damaged
                Integer excludeEntityID = null;
                if (!coords.equals(mf.getCoords())) {
                    excludeEntityID = entity.getId();
                }

                explodeVibrabomb(mf, vMineReport, excludeEntityID);
            }

            // Hack; when moving, the Mech isn't in the hex during
            // the movement.
            if (!displaced && (actualDistance == 0)) {
                // report getting hit by vibrabomb
                Report r = new Report(2160);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vMineReport.add(r);
                int damage = mf.getDensity();
                while (damage > 0) {
                    int cur_damage = Math.min(5, damage);
                    damage = damage - cur_damage;
                    HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));
                }
                vMineReport.addAll(resolvePilotingRolls(entity, true, lastPos, curPos));
                // we need to apply Damage now, in case the entity lost a leg,
                // otherwise it won't get a leg missing mod if it hasn't yet
                // moved and lost a leg, see bug 1071434 for an example
                entity.applyDamage();
            }

            // don't check for reduction until the end or units in the same hex
            // through
            // movement will get the reduced damage
            if (mf.hasDetonated()) {
                boom = true;
                mf.checkReduction(0, true);
                revealMinefield(mf);
            }

        }
        return boom;
    }

    /**
     * Removes the minefield from the game.
     *
     * @param mf The <code>Minefield</code> to remove
     */
    public void removeMinefield(Minefield mf) {
        if (game.containsVibrabomb(mf)) {
            game.removeVibrabomb(mf);
        }
        game.removeMinefield(mf);

        Enumeration<Player> players = game.getPlayers();
        while (players.hasMoreElements()) {
            Player player = players.nextElement();
            removeMinefield(player, mf);
        }
    }

    /**
     * Removes the minefield from a player.
     *
     * @param player The <code>Player</code> whose minefield should be removed
     * @param mf     The <code>Minefield</code> to be removed
     */
    private void removeMinefield(Player player, Minefield mf) {
        if (player.containsMinefield(mf)) {
            player.removeMinefield(mf);
            send(player.getId(), new Packet(PacketCommand.REMOVE_MINEFIELD, mf));
        }
    }

    /**
     * Reveals a minefield for all players.
     *
     * @param mf The <code>Minefield</code> to be revealed
     */
    private void revealMinefield(Minefield mf) {
        game.getTeams().forEach(team -> revealMinefield(team, mf));
    }

    /**
     * Reveals a minefield for all players on a team.
     *
     * @param team The <code>team</code> whose minefield should be revealed
     * @param mf   The <code>Minefield</code> to be revealed
     */
    public void revealMinefield(Team team, Minefield mf) {
        for (Player player : team.players()) {
            if (!player.containsMinefield(mf)) {
                player.addMinefield(mf);
                send(player.getId(), new Packet(PacketCommand.REVEAL_MINEFIELD, mf));
            }
        }
    }

    /**
     * Reveals a minefield for a specific player
     * If on a team, does it for the whole team. Otherwise, just the player.
     */
    public void revealMinefield(Player player, Minefield mf) {
        Team team = game.getTeamForPlayer(player);

        if (team != null) {
            revealMinefield(team, mf);
        } else {
            if (!player.containsMinefield(mf)) {
                player.addMinefield(mf);
                send(player.getId(), new Packet(PacketCommand.REVEAL_MINEFIELD, mf));
            }
        }
    }

    /**
     * checks whether a newly set mine should be revealed to players based on
     * LOS. If so, then it reveals the mine
     */
    private void checkForRevealMinefield(Minefield mf, Entity layer) {
        // loop through each team and determine if they can see the mine, then
        // loop through players on team
        // and reveal the mine
        for (Team team : game.getTeams()) {
            boolean canSee = false;

            // the players own team can always see the mine
            if (team.equals(game.getTeamForPlayer(game.getPlayer(mf.getPlayerId())))) {
                canSee = true;
            } else {
                // need to loop through all entities on this team and find the
                // one with the best shot of seeing
                // the mine placement
                int target = Integer.MAX_VALUE;
                Iterator<Entity> entities = game.getEntities();
                while (entities.hasNext()) {
                    Entity en = entities.next();
                    // are we on the right team?
                    if (!team.equals(game.getTeamForPlayer(en.getOwner()))) {
                        continue;
                    }
                    if (LosEffects.calculateLOS(game, en,
                            new HexTarget(mf.getCoords(), Targetable.TYPE_HEX_CLEAR)).canSee()) {
                        target = 0;
                        break;
                    }
                    LosEffects los = LosEffects.calculateLOS(game, en, layer);
                    if (los.canSee()) {
                        // TODO : need to add mods
                        ToHitData current = new ToHitData(4, "base");
                        current.append(Compute.getAttackerMovementModifier(game, en.getId()));
                        current.append(Compute.getTargetMovementModifier(game, layer.getId()));
                        current.append(los.losModifiers(game));
                        if (current.getValue() < target) {
                            target = current.getValue();
                        }
                    }
                }

                if (Compute.d6(2) >= target) {
                    canSee = true;
                }
            }
            if (canSee) {
                revealMinefield(team, mf);
            }
        }
    }

    /**
     * Explodes a vibrabomb.
     *
     * @param mf The <code>Minefield</code> to explode
     */
    private void explodeVibrabomb(Minefield mf, Vector<Report> vBoomReport, Integer entityToExclude) {
        Iterator<Entity> targets = game.getEntities(mf.getCoords());
        Report r;

        while (targets.hasNext()) {
            Entity entity = targets.next();

            // Airborne entities wont get hit by the mines...
            if (entity.isAirborne()) {
                continue;
            }

            // check for the OptionsConstants.ADVGRNDMOV_NO_PREMOVE_VIBRA option
            // If it's set, and the target has not yet moved,
            // it doesn't get damaged.
            if (!entity.isDone()
                    && game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_NO_PREMOVE_VIBRA)) {
                r = new Report(2157);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vBoomReport.add(r);
                continue;
            }

            // the "currently moving entity" may not be in the same hex, so it needs to be excluded
            if ((entityToExclude != null) && (entity.getId() == entityToExclude)) {
                // report not hitting vibrabomb
                r = new Report(2157);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vBoomReport.add(r);
                continue;
            } else {
                // report hitting vibrabomb
                r = new Report(2160);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vBoomReport.add(r);
            }

            int damage = mf.getDensity();
            while (damage > 0) {
                int cur_damage = Math.min(5, damage);
                damage = damage - cur_damage;
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
                vBoomReport.addAll(damageEntity(entity, hit, cur_damage));
            }
            Report.addNewline(vBoomReport);

            if (entity instanceof Tank) {
                vBoomReport.addAll(vehicleMotiveDamage((Tank) entity,
                        entity.getMotiveSideMod(ToHitData.SIDE_LEFT)));
            }
            vBoomReport.addAll(resolvePilotingRolls(entity, true, entity.getPosition(),
                    entity.getPosition()));
            // we need to apply Damage now, in case the entity lost a leg,
            // otherwise it won't get a leg missing mod if it hasn't yet
            // moved and lost a leg, see bug 1071434 for an example
            game.resetPSRs(entity);
            entity.applyDamage();
            Report.addNewline(vBoomReport);
            entityUpdate(entity.getId());
        }

        // check the direct reduction of mine
        mf.checkReduction(0, true);
        mf.setDetonated(true);
    }

    /**
     * drowns any units swarming the entity
     *
     * @param entity The <code>Entity</code> that is being swarmed
     * @param pos    The <code>Coords</code> the entity is at
     */
    private void drownSwarmer(Entity entity, Coords pos) {
        // Any swarming infantry will be destroyed.
        final int swarmerId = entity.getSwarmAttackerId();
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            // Only *platoons* drown while swarming.
            if (!(swarmer instanceof BattleArmor)) {
                swarmer.setSwarmTargetId(Entity.NONE);
                entity.setSwarmAttackerId(Entity.NONE);
                swarmer.setPosition(pos);
                Report r = new Report(2165);
                r.subject = entity.getId();
                r.indent();
                r.add(entity.getShortName(), true);
                addReport(r);
                addReport(destroyEntity(swarmer, "a watery grave", false));
                entityUpdate(swarmerId);
            }
        }
    }

    /**
     * Checks to see if we may have just washed off infernos. Call after a step
     * which may have done this.
     *
     * @param entity The <code>Entity</code> that is being checked
     * @param coords The <code>Coords</code> the entity is at
     */
    void checkForWashedInfernos(Entity entity, Coords coords) {
        Hex hex = game.getBoard().getHex(coords);
        int waterLevel = hex.terrainLevel(Terrains.WATER);
        // Mech on fire with infernos can wash them off.
        if (!(entity instanceof Mech) || !entity.infernos.isStillBurning()) {
            return;
        }
        // Check if entering depth 2 water or prone in depth 1.
        if ((waterLevel > 0) && (entity.relHeight() < 0)) {
            washInferno(entity, coords);
        }
    }

    /**
     * Washes off an inferno from a mech and adds it to the (water) hex.
     *
     * @param entity The <code>Entity</code> that is taking a bath
     * @param coords The <code>Coords</code> the entity is at
     */
    void washInferno(Entity entity, Coords coords) {
        game.getBoard().addInfernoTo(coords, InfernoTracker.STANDARD_ROUND, 1);
        entity.infernos.clear();

        // Start a fire in the hex?
        Hex hex = game.getBoard().getHex(coords);
        Report r = new Report(2170);
        r.subject = entity.getId();
        r.addDesc(entity);
        if (!hex.containsTerrain(Terrains.FIRE)) {
            r.messageId = 2175;
            ignite(coords, Terrains.FIRE_LVL_INFERNO, null);
        }
        addReport(r);
    }

    /**
     * Add heat from the movement phase
     */
    public void addMovementHeat() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();

            if (entity.hasDamagedRHS()) {
                entity.heatBuildup += 1;
            }

            if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)
                    || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {
                // UMU heat
                entity.heatBuildup += 1;
                continue;
            }

            // build up heat from movement
            if (entity.isEvading() && !entity.isAero()) {
                entity.heatBuildup += entity.getRunHeat() + 2;
            } else if (entity.moved == EntityMovementType.MOVE_NONE) {
                entity.heatBuildup += entity.getStandingHeat();
            } else if ((entity.moved == EntityMovementType.MOVE_WALK)
                    || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                    || (entity.moved == EntityMovementType.MOVE_CAREFUL_STAND)) {
                entity.heatBuildup += entity.getWalkHeat();
            } else if ((entity.moved == EntityMovementType.MOVE_RUN)
                    || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                    || (entity.moved == EntityMovementType.MOVE_SKID)) {
                entity.heatBuildup += entity.getRunHeat();
            } else if (entity.moved == EntityMovementType.MOVE_JUMP) {
                entity.heatBuildup += entity.getJumpHeat(entity.delta_distance);
            } else if (entity.moved == EntityMovementType.MOVE_SPRINT
                    || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
                entity.heatBuildup += entity.getSprintHeat();
            }
        }
    }

    /**
     * Set the LocationsExposure of an entity
     *
     * @param entity
     *            The <code>Entity</code> who's exposure is being set
     * @param hex
     *            The <code>Hex</code> the entity is in
     * @param isJump
     *            a <code>boolean</code> value whether the entity is jumping
     * @param elevation
     *            the elevation the entity should be at.
     */
    public Vector<Report> doSetLocationsExposure(Entity entity, Hex hex,
                                                 boolean isJump, int elevation) {
        Vector<Report> vPhaseReport = new Vector<>();
        if (hex == null) {
            return vPhaseReport;
        }
        if ((hex.terrainLevel(Terrains.WATER) > 0) && !isJump
                && (elevation < 0)) {
            int partialWaterLevel = 1;
            if ((entity instanceof Mech) && entity.isSuperHeavy()) {
                partialWaterLevel = 2;
            }
            if ((entity instanceof Mech) && !entity.isProne()
                    && (hex.terrainLevel(Terrains.WATER) <= partialWaterLevel)) {
                for (int loop = 0; loop < entity.locations(); loop++) {
                    if (game.getPlanetaryConditions().isVacuum()
                            || ((entity.getEntityType() & Entity.ETYPE_AERO) == 0 && entity.isSpaceborne())) {
                        entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);
                    } else {
                        entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);
                    }
                }
                entity.setLocationStatus(Mech.LOC_RLEG, ILocationExposureStatus.WET);
                entity.setLocationStatus(Mech.LOC_LLEG, ILocationExposureStatus.WET);
                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_RLEG, hex));
                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_LLEG, hex));
                if (entity instanceof QuadMech) {
                    entity.setLocationStatus(Mech.LOC_RARM, ILocationExposureStatus.WET);
                    entity.setLocationStatus(Mech.LOC_LARM, ILocationExposureStatus.WET);
                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_RARM, hex));
                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_LARM, hex));
                }
                if (entity instanceof TripodMech) {
                    entity.setLocationStatus(Mech.LOC_CLEG, ILocationExposureStatus.WET);
                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_CLEG, hex));
                }
            } else {
                for (int loop = 0; loop < entity.locations(); loop++) {
                    entity.setLocationStatus(loop, ILocationExposureStatus.WET);
                    vPhaseReport.addAll(breachCheck(entity, loop, hex));
                }
            }
        } else {
            for (int loop = 0; loop < entity.locations(); loop++) {
                if (game.getPlanetaryConditions().isVacuum()
                        || ((entity.getEntityType() & Entity.ETYPE_AERO) == 0 && entity.isSpaceborne())) {
                    entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);
                } else {
                    entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * Do a roll to avoid pilot damage from g-forces
     *
     * @param entity       The <code>Entity</code> that should make the PSR
     * @param targetNumber The <code>int</code> to be used for this PSR.
     */
    private void resistGForce(Entity entity, int targetNumber) {
        // okay, print the info
        Report r = new Report(9330);
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9335);
        r.subject = entity.getId();
        r.add(Integer.toString(targetNumber));
        r.add(diceRoll);
        if (diceRoll < targetNumber) {
            r.choose(false);
            addReport(r);
            addReport(damageCrew(entity, 1));
        } else {
            r.choose(true);
            addReport(r);
        }
    }

    /**
     * Do a piloting skill check in space to avoid structural damage
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckInSpace(Entity entity, PilotingRollData roll) {
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9320);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9325);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            suc = false;
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check to take off vertically
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doVerticalTakeOffCheck(Entity entity, PilotingRollData roll) {

        if (!entity.isAero()) {
            return false;
        }

        IAero a = (IAero) entity;

        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9320);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9321);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        r.newlines = 0;
        addReport(r);
        boolean suc = false;
        if (diceRoll < roll.getValue()) {
            int mof = roll.getValue() - diceRoll;
            if (mof < 3) {
                r = new Report(9322);
                r.subject = entity.getId();
                addReport(r);
                suc = true;
            } else if (mof < 5) {
                PilotingRollData newRoll = entity.getBasePilotingRoll();
                if (Compute.d6(2) >= newRoll.getValue()) {
                    r = new Report(9322);
                    r.subject = entity.getId();
                    addReport(r);
                    suc = true;
                } else {
                    r = new Report(9323);
                    r.subject = entity.getId();
                    addReport(r);
                    int damage = 20;
                    while (damage > 0) {
                        addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                ToHitData.SIDE_REAR), Math.min(5, damage)));
                        damage -= 5;
                    }
                }
            } else if (mof < 6) {
                r = new Report(9323);
                r.subject = entity.getId();
                addReport(r);
                int damage = 50;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,
                            ToHitData.SIDE_REAR), Math.min(5, damage)));
                    damage -= 5;
                }
            } else {
                r = new Report(9323);
                r.subject = entity.getId();
                addReport(r);
                int damage = 100;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,
                            ToHitData.SIDE_REAR), Math.min(5, damage)));
                    damage -= 5;
                }
            }
            a.setGearHit(true);
            r = new Report(9125);
            r.subject = entity.getId();
            addReport(r);
        } else {
            r = new Report(9322);
            r.subject = entity.getId();
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check in space to do a successful maneuver Failure
     * means moving forward half velocity
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckManeuver(Entity entity, PilotingRollData roll) {
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9600);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9601);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            suc = false;
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check while standing still (during the movement
     * phase).
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckInPlace(Entity entity, PilotingRollData roll) {
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        if (entity.isProne()) {
            return true;
        }

        // okay, print the info
        Report r = new Report(2180);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = entity.getCrew().rollPilotingSkill();
        r = new Report(2185);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            if ((entity instanceof Mech)
                    && game.getOptions().booleanOption(
                    OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
                    && (entity.getCrew().getPiloting() < 6)
                    && !entity.isHullDown() && entity.canGoHullDown()) {
                if ((entity.getCrew().getPiloting() > 1) && ((roll.getValue() - diceRoll) < 2)) {
                    entity.setHullDown(true);
                } else if ((entity.getCrew().getPiloting() <= 1)
                        && ((roll.getValue() - diceRoll) < 3)) {
                    entity.setHullDown(true);
                }
            }
            if (!entity.isHullDown()
                    || (entity.isHullDown() && !entity.canGoHullDown())) {
                addReport(doEntityFall(entity, roll));
            } else {
                ServerHelper.sinkToBottom(entity);

                r = new Report(2317);
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                addReport(r);
            }

            suc = false;
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a Piloting Skill check to dislodge swarming infantry.
     *
     * @param entity The <code>Entity</code> that is doing the dislodging.
     * @param roll   The <code>PilotingRollData</code> for this PSR.
     * @param curPos The <code>Coords</code> the entity is at.
     * @return <code>true</code> if the dislodging is successful.
     */
    private boolean doDislodgeSwarmerSkillCheck(Entity entity, PilotingRollData roll, Coords curPos) {
        // okay, print the info
        Report r = new Report(2180);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(2190);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return false;
        }
        // Dislodged swarmers don't get turns.
        int swarmerId = entity.getSwarmAttackerId();
        final Entity swarmer = game.getEntity(swarmerId);
        if (!swarmer.isDone()) {
            game.removeTurnFor(swarmer);
            swarmer.setDone(true);
            send(createTurnVectorPacket());
        }

        // Update the report and cause a fall.
        r.choose(true);
        addReport(r);
        entity.setPosition(curPos);
        addReport(doEntityFallsInto(entity, curPos, roll, false));
        return true;
    }

    /**
     * Do a piloting skill check while moving.
     *
     * @param entity          - the <code>Entity</code> that must roll.
     * @param entityElevation The elevation of the supplied Entity above the surface of the
     *                        src hex. This is necessary as the state of the Entity may
     *                        represent the elevation of the entity about the surface of the
     *                        destination hex.
     * @param src             - the <code>Coords</code> the entity is moving from.
     * @param dest            - the <code>Coords</code> the entity is moving to. This value
     *                        can be the same as src for in-place checks.
     * @param roll            - the <code>PilotingRollData</code> that is causing this
     *                        check.
     * @param isFallRoll      - a <code>boolean</code> flag that indicates that failure will
     *                        result in a fall or not. Falls will be processed.
     * @return Margin of Failure if the pilot fails the skill check, 0 if they
     * pass.
     */
    private int doSkillCheckWhileMoving(Entity entity, int entityElevation,
                                        Coords src, Coords dest, PilotingRollData roll, boolean isFallRoll) {
        boolean fallsInPlace;

        // Start the info for this roll.
        Report r = new Report(1210);
        r.subject = entity.getId();
        r.addDesc(entity);

        // Will the entity fall in the source or destination hex?
        if (src.equals(dest)) {
            fallsInPlace = true;
            r.messageId = 2195;
            r.add(src.getBoardNum(), true);
        } else {
            fallsInPlace = false;
            r.messageId = 2200;
            r.add(src.getBoardNum(), true);
            r.add(dest.getBoardNum(), true);
        }

        // Finish the info.
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = entity.getCrew().rollPilotingSkill();
        r = new Report(2185);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        if (diceRoll < roll.getValue()) {
            // Does failing the PSR result in a fall.
            if (isFallRoll && entity.canFall()) {
                r.choose(false);
                addReport(r);
                addReport(doEntityFallsInto(entity, entityElevation,
                        fallsInPlace ? dest : src, fallsInPlace ? src : dest,
                        roll, true));
            } else {
                r.messageId = 2190;
                r.choose(false);
                addReport(r);
                entity.setPosition(fallsInPlace ? src : dest);
            }
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return roll.getValue() - diceRoll;
        }
        r.choose(true);
        r.newlines = 2;
        addReport(r);
        return 0;
    }

    /**
     * Process a fall when the source and destination hexes are the same.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller. Note: the elevation of the entity is used to
     * determine fall distance, so it is important to ensure the Entity's
     * elevation is correct.
     *
     * @param entity    The <code>Entity</code> that is falling.
     * @param src       The <code>Coords</code> of the source hex.
     * @param roll      The <code>PilotingRollData</code> to be used for PSRs induced
     *                  by the falling.
     * @param causeAffa The <code>boolean</code> value whether this fall should be able
     *                  to cause an accidental fall from above
     */
    private Vector<Report> doEntityFallsInto(Entity entity, Coords src,
                                             PilotingRollData roll, boolean causeAffa) {
        return doEntityFallsInto(entity, entity.getElevation(), src, src, roll, causeAffa);
    }

    /**
     * Process a fall when moving from the source hex to the destination hex.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller. Note: the elevation of the entity is used to
     * determine fall distance, so it is important to ensure the Entity's
     * elevation is correct.
     *
     * @param entity             The <code>Entity</code> that is falling.
     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
     *                           src hex. This is necessary as the state of the Entity may
     *                           represent the elevation of the entity about the surface of the
     *                           destination hex.
     * @param src                The <code>Coords</code> of the source hex.
     * @param dest               The <code>Coords</code> of the destination hex.
     * @param roll               The <code>PilotingRollData</code> to be used for PSRs induced
     *                           by the falling.
     * @param causeAffa          The <code>boolean</code> value whether this fall should be able
     *                           to cause an accidental fall from above
     */
    private Vector<Report> doEntityFallsInto(Entity entity, int entitySrcElevation, Coords src,
                                             Coords dest, PilotingRollData roll, boolean causeAffa) {
        return doEntityFallsInto(entity, entitySrcElevation, src, dest, roll, causeAffa, 0);
    }

    /**
     * Process a fall when moving from the source hex to the destination hex.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller.
     *
     * @param entity             The <code>Entity</code> that is falling.
     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
     *                           src hex. This is necessary as the state of the Entity may
     *                           represent the elevation of the entity about the surface of the
     *                           destination hex.
     * @param origSrc            The <code>Coords</code> of the original source hex.
     * @param origDest           The <code>Coords</code> of the original destination hex.
     * @param roll               The <code>PilotingRollData</code> to be used for PSRs induced
     *                           by the falling.
     * @param causeAffa          The <code>boolean</code> value whether this fall should be able
     *                           to cause an accidental fall from above
     * @param fallReduction      An integer value to reduce the fall distance by
     */
    private Vector<Report> doEntityFallsInto(Entity entity, int entitySrcElevation, Coords origSrc,
                                             Coords origDest, PilotingRollData roll,
                                             boolean causeAffa, int fallReduction) {
        Vector<Report> vPhaseReport = new Vector<>();
        Hex srcHex = game.getBoard().getHex(origSrc);
        Hex destHex = game.getBoard().getHex(origDest);
        Coords src, dest;
        // We need to fall into the lower of the two hexes, TW pg 68
        if (srcHex.getLevel() < destHex.getLevel()) {
            Hex swapHex = destHex;
            destHex = srcHex;
            srcHex = swapHex;
            src = origDest;
            dest = origSrc;
        } else {
            src = origSrc;
            dest = origDest;
        }
        final int srcHeightAboveFloor = entitySrcElevation + srcHex.depth(false);
        int fallElevation = Math.abs((srcHex.floor() + srcHeightAboveFloor)
                - (destHex.containsTerrain(Terrains.ICE) ? destHex.getLevel() : destHex.floor()))
                - fallReduction;
        if (destHex.containsTerrain(Terrains.BLDG_ELEV)) {
            fallElevation -= destHex.terrainLevel(Terrains.BLDG_ELEV);
        }
        if (destHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {
            if (entity.getElevation() == 0) { // floor 0 falling into basement
                fallElevation = destHex.depth(true);
            }
        }

        int direction;
        if (src.equals(dest)) {
            direction = Compute.d6() - 1;
        } else {
            direction = src.direction(dest);
        }
        Report r;
        // check entity in target hex
        Entity affaTarget = game.getAffaTarget(dest, entity);
        // falling mech falls
        r = new Report(2205);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(fallElevation);
        r.add(dest.getBoardNum(), true);
        r.newlines = 0;

        // if hex was empty, deal damage and we're done
        if (affaTarget == null) {
            r.newlines = 1;
            vPhaseReport.add(r);
            // If we rolled for the direction, we want to use that for the fall
            if (src.equals(dest)) {
                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation,
                        direction, roll, false, srcHex.hasCliffTopTowards(destHex)));
            } else {
                // Otherwise, we'll roll for the direction after the fall
                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation, roll));
            }

            return vPhaseReport;
        }
        vPhaseReport.add(r);

        // hmmm... somebody there... problems.
        if ((fallElevation >= 2) && causeAffa) {
            // accidental fall from above: havoc!
            r = new Report(2210);
            r.subject = entity.getId();
            r.addDesc(affaTarget);
            vPhaseReport.add(r);

            // determine to-hit number
            ToHitData toHit = new ToHitData(7, "base");
            if ((affaTarget instanceof Tank) || (affaTarget instanceof Dropship)) {
                toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, "Target is a Tank");
            } else {
                toHit.append(Compute.getTargetMovementModifier(game, affaTarget.getId()));
                toHit.append(Compute.getTargetTerrainModifier(game, affaTarget));
            }

            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL) {
                // collision roll
                final int diceRoll = Compute.d6(2);
                if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
                    r = new Report(2212);
                    r.add(toHit.getValue());
                } else {
                    r = new Report(2215);
                    r.subject = entity.getId();
                    r.add(toHit.getValue());
                    r.add(diceRoll);
                    r.newlines = 0;
                }
                r.indent();
                vPhaseReport.add(r);
                if (diceRoll >= toHit.getValue()) {
                    // deal damage to target
                    int damage = Compute.getAffaDamageFor(entity);
                    r = new Report(2220);
                    r.subject = affaTarget.getId();
                    r.addDesc(affaTarget);
                    r.add(damage);
                    vPhaseReport.add(r);
                    while (damage > 0) {
                        int cluster = Math.min(5, damage);
                        HitData hit = affaTarget.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);
                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                        vPhaseReport.addAll(damageEntity(affaTarget, hit, cluster));
                        damage -= cluster;
                    }

                    // attacker falls as normal, on his back
                    // only given a modifier, so flesh out into a full piloting
                    // roll
                    PilotingRollData pilotRoll = entity.getBasePilotingRoll();
                    pilotRoll.append(roll);
                    vPhaseReport.addAll(doEntityFall(entity, dest,
                            fallElevation, 3, pilotRoll, false, false));
                    vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(
                            entity, src, dest, entity.getElevation()));

                    // defender pushed away, or destroyed, if there is a
                    // stacking violation
                    Entity violation = Compute.stackingViolation(game, entity.getId(), dest);
                    if (violation != null) {
                        PilotingRollData prd = new PilotingRollData(violation.getId(), 2,
                                "fallen on");
                        if (violation instanceof Dropship) {
                            violation = entity;
                            prd = null;
                        }
                        Coords targetDest = Compute.getValidDisplacement(game, violation.getId(),
                                dest, direction);
                        if (targetDest != null) {
                            vPhaseReport.addAll(doEntityDisplacement(violation, dest, targetDest, prd));
                            // Update the violating entity's position on the
                            // client.
                            entityUpdate(violation.getId());
                        } else {
                            // ack! automatic death! Tanks
                            // suffer an ammo/power plant hit.
                            // TODO : a Mech suffers a Head Blown Off crit.
                            vPhaseReport.addAll(destroyEntity(violation, "impossible displacement",
                                    violation instanceof Mech, violation instanceof Mech));
                        }
                    }
                    return vPhaseReport;
                }
            } else {
                // automatic miss
                r = new Report(2213);
                r.add(toHit.getDesc());
                vPhaseReport.add(r);
            }
            // ok, we missed, let's fall into a valid other hex and not cause an
            // AFFA while doing so
            Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);
            if (targetDest != null) {
                vPhaseReport.addAll(doEntityFallsInto(entity, entitySrcElevation, src, targetDest,
                        new PilotingRollData(entity.getId(),
                                TargetRoll.IMPOSSIBLE,
                                "pushed off a cliff"),
                        false));
                // Update the entity's position on the client.
                entityUpdate(entity.getId());
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                vPhaseReport.addAll(destroyEntity(entity,
                        "impossible displacement", entity instanceof Mech, entity instanceof Mech));
            }
        } else {
            // damage as normal
            vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation, roll));
            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);
            if (violation != null) {
                PilotingRollData prd = new PilotingRollData(violation.getId(), 0, "domino effect");
                if (violation instanceof Dropship) {
                    violation = entity;
                    prd = null;
                }
                // target gets displaced, because of low elevation
                Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);
                vPhaseReport.addAll(doEntityDisplacement(violation, dest, targetDest, prd));
                // Update the violating entity's position on the client.
                if (!game.getOutOfGameEntitiesVector().contains(violation)) {
                    entityUpdate(violation.getId());
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * Displace a unit in the direction specified. The unit moves in that
     * direction, and the piloting skill roll is used to determine if it falls.
     * The roll may be unnecessary as certain situations indicate an automatic
     * fall. Rolls are added to the piloting roll list.
     */
    private Vector<Report> doEntityDisplacement(Entity entity, Coords src,
                                                Coords dest, PilotingRollData roll) {
        Vector<Report> vPhaseReport = new Vector<>();
        Report r;
        if (!game.getBoard().contains(dest)) {
            // set position anyway, for pushes moving through, stuff like that
            entity.setPosition(dest);
            if (!entity.isDoomed()) {
                // Make sure there aren't any specific entity turns for entity
                int turnsRemoved = game.removeSpecificEntityTurnsFor(entity);
                // May need to remove a turn for this Entity
                if (game.getPhase().isMovement() && !entity.isDone() && (turnsRemoved == 0)) {
                    game.removeTurnFor(entity);
                    send(createTurnVectorPacket());
                } else if (turnsRemoved > 0) {
                    send(createTurnVectorPacket());
                }
                game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED);
                send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED));
                // entity forced from the field
                r = new Report(2230);
                r.subject = entity.getId();
                r.addDesc(entity);
                vPhaseReport.add(r);
                // TODO : remove passengers and swarmers.
            }
            return vPhaseReport;
        }
        final Hex srcHex = game.getBoard().getHex(src);
        final Hex destHex = game.getBoard().getHex(dest);
        final int direction = src.direction(dest);

        // Handle null hexes.
        if ((srcHex == null) || (destHex == null)) {
            LogManager.getLogger().error("Can not displace " + entity.getShortName()
                    + " from " + src + " to " + dest + ".");
            return vPhaseReport;
        }
        int bldgElev = destHex.containsTerrain(Terrains.BLDG_ELEV)
                ? destHex.terrainLevel(Terrains.BLDG_ELEV) : 0;
        int fallElevation = srcHex.getLevel() + entity.getElevation()
                - (destHex.getLevel() + bldgElev);
        if (fallElevation > 1) {
            if (roll == null) {
                roll = entity.getBasePilotingRoll();
            }
            if (!(entity.isAirborneVTOLorWIGE())) {
                vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,
                        roll, true));
            } else {
                entity.setPosition(dest);
            }
            return vPhaseReport;
        }
        // unstick the entity if it was stuck in swamp
        boolean wasStuck = entity.isStuck();
        entity.setStuck(false);
        int oldElev = entity.getElevation();
        // move the entity into the new location gently
        entity.setPosition(dest);
        entity.setElevation(entity.calcElevation(srcHex, destHex));
        Building bldg = game.getBoard().getBuildingAt(dest);
        if (bldg != null) {
            if (destHex.terrainLevel(Terrains.BLDG_ELEV) > oldElev) {
                // whoops, into the building we go
                passBuildingWall(entity, game.getBoard().getBuildingAt(dest), src, dest, 1,
                        "displaced into",
                        Math.abs(entity.getFacing() - src.direction(dest)) == 3,
                        entity.moved, true);
            }
            checkBuildingCollapseWhileMoving(bldg, entity, dest);
        }

        ServerHelper.checkAndApplyMagmaCrust(destHex, entity.getElevation(), entity, dest, false, vPhaseReport, this);
        ServerHelper.checkEnteringMagma(destHex, entity.getElevation(), entity, this);

        Entity violation = Compute.stackingViolation(game, entity.getId(), dest);
        if (violation == null) {
            // move and roll normally
            r = new Report(2235);
            r.indent();
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(dest.getBoardNum(), true);
        } else {
            // domino effect: move & displace target
            r = new Report(2240);
            r.indent();
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(dest.getBoardNum(), true);
            r.addDesc(violation);
        }
        vPhaseReport.add(r);
        // trigger any special things for moving to the new hex
        vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(entity, src, dest, entity.getElevation()));
        vPhaseReport.addAll(doSetLocationsExposure(entity, destHex, false, entity.getElevation()));
        if (destHex.containsTerrain(Terrains.BLDG_ELEV)
                && (entity.getElevation() == 0)) {
            bldg = game.getBoard().getBuildingAt(dest);
            if (bldg.rollBasement(dest, game.getBoard(), vPhaseReport)) {
                sendChangedHex(dest);
                Vector<Building> buildings = new Vector<>();
                buildings.add(bldg);
                sendChangedBuildings(buildings);
            }
        }

        // mechs that were stuck will automatically fall in their new hex
        if (wasStuck && entity.canFall()) {
            if (roll == null) {
                roll = entity.getBasePilotingRoll();
            }
            vPhaseReport.addAll(doEntityFall(entity, dest, 0, roll));
        }
        // check bog-down conditions
        vPhaseReport.addAll(doEntityDisplacementBogDownCheck(entity, dest, entity.getElevation()));

        if (roll != null) {
            if (entity.canFall()) {
                game.addPSR(roll);
            } else if ((entity instanceof LandAirMech) && entity.isAirborneVTOLorWIGE()) {
                game.addControlRoll(roll);
            }
        }

        int waterDepth = destHex.terrainLevel(Terrains.WATER);

        if (destHex.containsTerrain(Terrains.ICE) && destHex.containsTerrain(Terrains.WATER)) {
            if (!(entity instanceof Infantry)) {
                int d6 = Compute.d6(1);
                r = new Report(2118);
                r.addDesc(entity);
                r.add(d6);
                r.subject = entity.getId();
                vPhaseReport.add(r);

                if (d6 == 6) {
                    vPhaseReport.addAll(resolveIceBroken(dest));
                }
            }
        }
        // Falling into water instantly destroys most non-mechs
        else if ((waterDepth > 0)
                && !(entity instanceof Mech)
                && !(entity instanceof Protomech)
                && !((entity.getRunMP() > 0) && (entity.getMovementMode() == EntityMovementMode.HOVER))
                && (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)
                && (entity.getMovementMode() != EntityMovementMode.NAVAL)
                && (entity.getMovementMode() != EntityMovementMode.SUBMARINE)
                && (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {
            vPhaseReport.addAll(destroyEntity(entity, "a watery grave", false));
        } else if ((waterDepth > 0)
                && !(entity.getMovementMode() == EntityMovementMode.HOVER)) {
            PilotingRollData waterRoll = entity.checkWaterMove(waterDepth, entity.moved);
            if (waterRoll.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, waterRoll);
            }
        }
        // Update the entity's position on the client.
        entityUpdate(entity.getId());

        if (violation != null) {
            // Can the violating unit move out of the way?
            // if the direction comes from a side, Entity didn't jump, and it
            // has MP left to use, it can try to move.
            MovePath stepForward = new MovePath(game, violation);
            MovePath stepBackwards = new MovePath(game, violation);
            stepForward.addStep(MovePath.MoveStepType.FORWARDS);
            stepBackwards.addStep(MovePath.MoveStepType.BACKWARDS);
            stepForward.compile(getGame(), violation, false);
            stepBackwards.compile(getGame(), violation, false);
            if ((direction != violation.getFacing())
                    && (direction != ((violation.getFacing() + 3) % 6))
                    && !entity.getIsJumpingNow()
                    && (stepForward.isMoveLegal() || stepBackwards.isMoveLegal())) {
                // First, we need to make a PSR to see if we can step out
                int result = Compute.d6(2);
                roll = entity.getBasePilotingRoll();

                r = new Report(2351);
                r.indent(2);
                r.subject = violation.getId();
                r.addDesc(violation);
                r.add(roll);
                r.add(result);
                vPhaseReport.add(r);
                if (result < roll.getValue()) {
                    r.choose(false);
                    Vector<Report> newReports = doEntityDisplacement(violation,
                            dest, dest.translated(direction),
                            new PilotingRollData(violation.getId(),
                                    TargetRoll.AUTOMATIC_FAIL,
                                    "failed to step out of a domino effect"));
                    for (Report newReport : newReports) {
                        newReport.indent(3);
                    }
                    vPhaseReport.addAll(newReports);
                } else {
                    r.choose(true);
                    sendDominoEffectCFR(violation);
                    synchronized (cfrPacketQueue) {
                        try {
                            cfrPacketQueue.wait();
                        } catch (Exception ignored) {

                        }

                        if (!cfrPacketQueue.isEmpty()) {
                            Server.ReceivedPacket rp = cfrPacketQueue.poll();
                            final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                            // Make sure we got the right type of response
                            if (!cfrType.isCFRDominoEffect()) {
                                LogManager.getLogger().error("Excepted a CFR_DOMINO_EFFECT CFR packet, received: " + cfrType);
                                throw new IllegalStateException();
                            }
                            MovePath mp = (MovePath) rp.getPacket().getData()[1];
                            // Move based on the feedback
                            if (mp != null) {
                                mp.setGame(getGame());
                                mp.setEntity(violation);
                                // Report
                                r = new Report(2352);
                                r.indent(3);
                                r.subject = violation.getId();
                                r.addDesc(violation);
                                r.choose(mp.getLastStep().getType() != MovePath.MoveStepType.FORWARDS);
                                r.add(mp.getLastStep().getPosition().getBoardNum());
                                vPhaseReport.add(r);
                                // Move unit
                                violation.setPosition(mp.getFinalCoords());
                                violation.mpUsed += mp.getMpUsed();
                                violation.moved = mp.getLastStepMovementType();
                            } else { // User decided to do nothing
                                r = new Report(2358);
                                r.indent(3);
                                r.subject = violation.getId();
                                r.addDesc(violation);
                                vPhaseReport.add(r);
                                vPhaseReport.addAll(doEntityDisplacement(violation, dest,
                                        dest.translated(direction), null));
                            }
                        } else { // If no responses, treat as no action
                            vPhaseReport.addAll(doEntityDisplacement(violation,
                                    dest, dest.translated(direction),
                                    new PilotingRollData(violation.getId(), 0,
                                            "domino effect")));
                        }
                    }
                }
            } else { // Nope
                r = new Report(2359);
                r.indent(2);
                r.subject = violation.getId();
                r.addDesc(violation);
                vPhaseReport.add(r);
                vPhaseReport.addAll(doEntityDisplacement(violation, dest, dest.translated(direction),
                        new PilotingRollData(violation.getId(), 0, "domino effect")));

            }
            // Update the violating entity's position on the client,
            // if it didn't get displaced off the board.
            if (!game.isOutOfGame(violation)) {
                entityUpdate(violation.getId());
            }
        }
        return vPhaseReport;
    }

    private void sendDominoEffectCFR(Entity e) {
        send(e.getOwnerId(), new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_DOMINO_EFFECT, e.getId()));
    }

    private void sendAMSAssignCFR(Entity e, Mounted ams, List<WeaponAttackAction> waas) {
        send(e.getOwnerId(), new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_AMS_ASSIGN, e.getId(), e.getEquipmentNum(ams), waas));
    }

    private void sendAPDSAssignCFR(Entity e, List<Integer> apdsDists, List<WeaponAttackAction> waas) {
        send(e.getOwnerId(), new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_APDS_ASSIGN, e.getId(), apdsDists, waas));
    }

    private void sendPointBlankShotCFR(Entity hidden, Entity target) {
        // Send attacker/target IDs to PBS Client
        send(hidden.getOwnerId(), new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_HIDDEN_PBS, hidden.getId(), target.getId()));
    }

    private void sendTeleguidedMissileCFR(int playerId, List<Integer> targetIds, List<Integer> toHitValues) {
        // Send target id numbers and to-hit values to Client
        send(playerId, new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_TELEGUIDED_TARGET, targetIds, toHitValues));
    }

    private void sendTAGTargetCFR(int playerId, List<Integer> targetIds, List<Integer> targetTypes) {
        // Send target id numbers and type identifiers to Client
        send(playerId, new Packet(PacketCommand.CLIENT_FEEDBACK_REQUEST,
                PacketCommand.CFR_TAG_TARGET, targetIds, targetTypes));
    }

    private Vector<Report> doEntityDisplacementMinefieldCheck(Entity entity, Coords src,
                                                              Coords dest, int elev) {
        Vector<Report> vPhaseReport = new Vector<>();
        boolean boom = checkVibrabombs(entity, dest, true, vPhaseReport);
        if (game.containsMinefield(dest)) {
            boom = enterMinefield(entity, dest, elev, true, vPhaseReport) || boom;
        }

        if (boom) {
            resetMines();
        }

        return vPhaseReport;
    }

    private Vector<Report> doEntityDisplacementBogDownCheck(Entity entity, Coords c, int elev) {
        Vector<Report> vReport = new Vector<>();
        Report r;
        Hex destHex = game.getBoard().getHex(c);
        int bgMod = destHex.getBogDownModifier(entity.getMovementMode(),
                entity instanceof LargeSupportTank);
        if ((bgMod != TargetRoll.AUTOMATIC_SUCCESS)
                && !entity.getMovementMode().isHoverOrWiGE()
                && (elev == 0)) {
            PilotingRollData roll = entity.getBasePilotingRoll();
            roll.append(new PilotingRollData(entity.getId(), bgMod, "avoid bogging down"));
            int stuckroll = Compute.d6(2);
            // A DFA-ing mech is "displaced" into the target hex. Since it
            // must be jumping, it will automatically be bogged down
            if (stuckroll < roll.getValue() || entity.isMakingDfa()) {
                entity.setStuck(true);
                r = new Report(2081);
                r.subject = entity.getId();
                r.add(entity.getDisplayName(), true);
                vReport.add(r);
                // check for quicksand
                vReport.addAll(checkQuickSand(c));
            }
        }
        return vReport;
    }

    /**
     * Receive a deployment packet. If valid, execute it and end the current turn.
     */
    private void receiveDeployment(Packet packet, int connId) {
        Entity entity = game.getEntity(packet.getIntValue(0));
        Coords coords = (Coords) packet.getObject(1);
        int nFacing = packet.getIntValue(2);
        int elevation = packet.getIntValue(3);

        // Handle units that deploy loaded with other units.
        int loadedCount = packet.getIntValue(4);
        Vector<Entity> loadVector = new Vector<>();
        for (int i = 0; i < loadedCount; i++) {
            int loadedId = packet.getIntValue(6 + i);
            loadVector.addElement(game.getEntity(loadedId));
        }

        // is this the right phase?
        if (!game.getPhase().isDeployment()) {
            LogManager.getLogger().error("Server got deployment packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        final boolean assaultDrop = packet.getBooleanValue(5);
        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null) || !turn.isValid(connId, entity, game)
                || !(game.getBoard().isLegalDeployment(coords, entity)
                || (assaultDrop && game.getOptions().booleanOption(OptionsConstants.ADVANCED_ASSAULT_DROP)
                && entity.canAssaultDrop()))) {
            String msg = "server got invalid deployment packet from "
                    + "connection " + connId;
            if (entity != null) {
                msg += ", Entity: " + entity.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            LogManager.getLogger().error(msg);
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket(turn.getPlayerNum()));
            return;
        }

        // looks like mostly everything's okay
        processDeployment(entity, coords, nFacing, elevation, loadVector, assaultDrop);

        //Update Aero sensors for a space or atmospheric game
        if (entity.isAero()) {
            IAero a = (IAero) entity;
            a.updateSensorOptions();
        }

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(null);
        }

        endCurrentTurn(entity);
    }

    /**
     * Used when an Entity that was loaded in another Entity in the Lounge is
     * unloaded during deployment.
     * @param packet the packet to be processed
     * @param connId the id for connection that received the packet.
     */
    private void receiveDeploymentUnload(Packet packet, int connId) {
        Entity loader = game.getEntity(packet.getIntValue(0));
        Entity loaded = game.getEntity(packet.getIntValue(1));

        if (!game.getPhase().isDeployment()) {
            String msg = "server received deployment unload packet "
                    + "outside of deployment phase from connection " + connId;
            if (loader != null) {
                msg += ", Entity: " + loader.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            LogManager.getLogger().error(msg);
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())) {
            turn = game.getTurnForPlayer(connId);
        }

        if ((turn == null) || !turn.isValid(connId, loader, game)) {
            String msg = "server got invalid deployment unload packet from connection " + connId;
            if (loader != null) {
                msg += ", Entity: " + loader.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            LogManager.getLogger().error(msg);
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket(connId));
            return;
        }

        // Unload and call entityUpdate
        unloadUnit(loader, loaded, null, 0, 0, false, true);

        // Need to update the loader
        entityUpdate(loader.getId());

        // Now need to add a turn for the unloaded unit, to be taken immediately
        // Turn forced to be immediate to avoid messy turn ordering issues
        // (aka, how do we add the turn with individual initiative?)
        game.insertTurnAfter(new GameTurn.SpecificEntityTurn(
                loaded.getOwnerId(), loaded.getId()), game.getTurnIndex() - 1);
        //game.insertNextTurn(new GameTurn.SpecificEntityTurn(
        //        loaded.getOwnerId(), loaded.getId()));
        send(createTurnVectorPacket());
    }


    /**
     * Process a deployment packet by... deploying the entity! We load any other
     * specified entities inside of it too. Also, check that the deployment is
     * valid.
     */
    private void processDeployment(Entity entity, Coords coords, int nFacing, int elevation, Vector<Entity> loadVector,
                                   boolean assaultDrop) {
        for (Entity loaded : loadVector) {
            if (loaded.getTransportId() != Entity.NONE) {
                // we probably already loaded this unit in the chat lounge
                continue;
            }
            if (loaded.getPosition() != null) {
                // Something is fishy in Denmark.
                LogManager.getLogger().error(entity + " can not load entity #" + loaded);
                break;
            }
            // Have the deployed unit load the indicated unit.
            loadUnit(entity, loaded, loaded.getTargetBay());
        }

        /*
         * deal with starting velocity for advanced movement. Probably not the
         * best place to do it, but what are you going to do
         */
        if (entity.isAero() && game.useVectorMove()) {
            IAero a = (IAero) entity;
            int[] v = {0, 0, 0, 0, 0, 0};

            // if this is the entity's first time deploying, we want to respect the "velocity" setting from the lobby
            if (entity.wasNeverDeployed()) {
                if (a.getCurrentVelocityActual() > 0) {
                    v[nFacing] = a.getCurrentVelocityActual();
                    entity.setVectors(v);
                }
                // this means the entity is coming back from off board, so we'll rotate the velocity vector by 180
                // and set it to 1/2 the magnitude
            } else {
                for (int x = 0; x < 6; x++) {
                    v[(x + 3) % 6] = entity.getVector(x) / 2;
                }

                entity.setVectors(v);
            }
        }

        entity.setPosition(coords);
        entity.setFacing(nFacing);
        entity.setSecondaryFacing(nFacing);
        Hex hex = game.getBoard().getHex(coords);
        if (assaultDrop) {
            entity.setAltitude(1);
            // from the sky!
            entity.setAssaultDropInProgress(true);
        } else if ((entity instanceof VTOL) && (entity.getExternalUnits().size() <= 0)) {
            // We should let players pick, but this simplifies a lot.
            // Only do it for VTOLs, though; assume everything else is on the
            // ground.
            entity.setElevation((hex.ceiling() - hex.getLevel()) + 1);
            while ((Compute.stackingViolation(game, entity, coords, null) != null)
                    && (entity.getElevation() <= 50)) {
                entity.setElevation(entity.getElevation() + 1);
            }
            if (entity.getElevation() > 50) {
                throw new IllegalStateException("Entity #" + entity.getId()
                        + " appears to be in an infinite loop trying to get a legal elevation.");
            }
        } else if (entity.isAero()) {
            // if the entity is airborne, then we don't want to set its
            // elevation below, because that will
            // default to 999
            if (entity.isAirborne()) {
                entity.setElevation(0);
                elevation = 0;
            }
            if (!game.getBoard().inSpace()) {
                // all spheroid craft should have velocity of zero in atmosphere
                // regardless of what was entered
                IAero a = (IAero) entity;
                if (a.isSpheroid() || game.getPlanetaryConditions().isVacuum()) {
                    a.setCurrentVelocity(0);
                    a.setNextVelocity(0);
                }
                // make sure that entity is above the level of the hex if in
                // atmosphere
                if (game.getBoard().inAtmosphere()
                        && (entity.getAltitude() <= hex.ceiling(true))) {
                    // you can't be grounded on low atmosphere map
                    entity.setAltitude(hex.ceiling(true) + 1);
                }
            }
        } else if (entity.getMovementMode() == EntityMovementMode.SUBMARINE) {
            // TODO : Submarines should have a selectable height.
            // TODO : For now, pretend they're regular naval.
            entity.setElevation(0);
        } else if ((entity.getMovementMode() == EntityMovementMode.HOVER)
                || (entity.getMovementMode() == EntityMovementMode.WIGE)
                || (entity.getMovementMode() == EntityMovementMode.NAVAL)
                || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)) {
            // For now, assume they're on the surface.
            // entity elevation is relative to hex surface
            entity.setElevation(0);
        } else if (hex.containsTerrain(Terrains.ICE)) {
            entity.setElevation(0);
        } else {
            Building bld = game.getBoard().getBuildingAt(entity.getPosition());
            if ((bld != null) && (bld.getType() == Building.WALL)) {
                entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
            }

        }
        // add the elevation that was passed into this method
        // TODO : currently only used for building placement, we should do this
        // TODO : more systematically with up/down buttons in the deployment display
        entity.setElevation(entity.getElevation() + elevation);
        boolean wigeFlyover = entity.getMovementMode() == EntityMovementMode.WIGE
                && hex.containsTerrain(Terrains.BLDG_ELEV)
                && entity.getElevation() > hex.terrainLevel(Terrains.BLDG_ELEV);


        // when first entering a building, we need to roll what type
        // of basement it has
        Building bldg = game.getBoard().getBuildingAt(entity.getPosition());
        if ((bldg != null)) {
            if (bldg.rollBasement(entity.getPosition(), game.getBoard(), vPhaseReport)) {
                sendChangedHex(entity.getPosition());
                Vector<Building> buildings = new Vector<>();
                buildings.add(bldg);
                sendChangedBuildings(buildings);
            }
            boolean collapse = checkBuildingCollapseWhileMoving(bldg, entity, entity.getPosition());
            if (collapse) {
                addAffectedBldg(bldg, true);
                if (wigeFlyover) {
                    // If the building is collapsed by a WiGE flying over it, the WiGE drops one level of elevation.
                    entity.setElevation(entity.getElevation() - 1);
                }
            }
        }

        entity.setDone(true);
        entity.setDeployed(true);
        entityUpdate(entity.getId());
        addReport(doSetLocationsExposure(entity, hex, false, entity.getElevation()));
    }

    /**
     * receive a packet that contains hexes that are automatically hit by
     * artillery
     *
     * @param packet the packet to be processed
     * @param connId the id for connection that received the packet.
     */
    @SuppressWarnings("unchecked")
    private void receiveArtyAutoHitHexes(Packet packet, int connId) {
        PlayerIDandList<Coords> artyAutoHitHexes = (PlayerIDandList<Coords>) packet
                .getObject(0);

        int playerId = artyAutoHitHexes.getPlayerID();

        // is this the right phase?
        if (!game.getPhase().isSetArtilleryAutohitHexes()) {
            LogManager.getLogger().error("Server got set artyautohithexespacket in wrong phase");
            return;
        }
        game.getPlayer(playerId).setArtyAutoHitHexes(artyAutoHitHexes);

        for (Coords coord : artyAutoHitHexes) {
            game.getBoard().addSpecialHexDisplay(coord,
                    new SpecialHexDisplay(
                            SpecialHexDisplay.Type.ARTILLERY_AUTOHIT,
                            SpecialHexDisplay.NO_ROUND, game.getPlayer(playerId),
                            "Artillery auto hit hex, for "
                                    + game.getPlayer(playerId).getName(),
                            SpecialHexDisplay.SHD_OBSCURED_TEAM));
        }
        endCurrentTurn(null);
    }

    /**
     * receive a packet that contains minefields
     *
     * @param packet the packet to be processed
     * @param connId the id for connection that received the packet.
     */
    @SuppressWarnings("unchecked")
    private void receiveDeployMinefields(Packet packet, int connId) {
        Vector<Minefield> minefields = (Vector<Minefield>) packet.getObject(0);

        // is this the right phase?
        if (!getGame().getPhase().isDeployMinefields()) {
            LogManager.getLogger().error("Server got deploy minefields packet in wrong phase");
            return;
        }

        // looks like mostly everything's okay
        processDeployMinefields(minefields);
        endCurrentTurn(null);
    }

    /**
     * process deployment of minefields
     *
     * @param minefields
     */
    private void processDeployMinefields(Vector<Minefield> minefields) {
        int playerId = Player.PLAYER_NONE;
        for (int i = 0; i < minefields.size(); i++) {
            Minefield mf = minefields.elementAt(i);
            playerId = mf.getPlayerId();

            game.addMinefield(mf);
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                game.addVibrabomb(mf);
            }
        }

        Player player = game.getPlayer(playerId);
        if (null != player) {
            int teamId = player.getTeam();

            if (teamId != Player.TEAM_NONE) {
                for (Team team : game.getTeams()) {
                    if (team.getId() == teamId) {
                        for (Player teamPlayer : team.players()) {
                            if (teamPlayer.getId() != player.getId()) {
                                send(teamPlayer.getId(), new Packet(PacketCommand.DEPLOY_MINEFIELDS,
                                        minefields));
                            }
                            teamPlayer.addMinefields(minefields);
                        }
                        break;
                    }
                }
            } else {
                player.addMinefields(minefields);
            }
        }
    }

    /**
     * Client has sent an update indicating that a ground unit is firing at
     * an airborne unit and is overriding the default select for the position
     * in the flight path.
     * @param packet the packet to be processed
     * @param connId the id for connection that received the packet.
     */
    private void receiveGroundToAirHexSelectPacket(Packet packet, int connId) {
        Integer targetId = (Integer) packet.getObject(0);
        Integer attackerId = (Integer) packet.getObject(1);
        Coords pos = (Coords) packet.getObject(2);
        game.getEntity(targetId).setPlayerPickedPassThrough(attackerId, pos);
    }

    /**
     * The end of a unit's Premovement or Prefiring
     */
    @SuppressWarnings("unchecked")
    private void receivePrephase(Packet packet, int connId) {
        Entity entity = game.getEntity(packet.getIntValue(0));

        // is this the right phase?
        if (!getGame().getPhase().isPrefiring() && !getGame().getPhase().isPremovement()) {
            LogManager.getLogger().error("Server got Prephase packet in wrong phase " + game.getPhase());
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null) || !turn.isValid(connId, entity, game)) {
            LogManager.getLogger().error(String.format(
                    "Server got invalid packet from Connection %s, Entity %s, %s Turn",
                    connId, ((entity == null) ? "null" : entity.getShortName()),
                    ((turn == null) ? "null" : "invalid")));
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket((turn == null) ? Player.PLAYER_NONE : turn.getPlayerNum()));
            return;
        }

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(null);
        }

        endCurrentTurn(entity);
        entityUpdate(entity.getId());
    }

    /**
     * Gets a bunch of entity attacks from the packet. If valid, processes them
     * and ends the current turn.
     */
    @SuppressWarnings("unchecked")
    private void receiveAttack(Packet packet, int connId) {
        Entity entity = game.getEntity(packet.getIntValue(0));
        Vector<EntityAction> vector = (Vector<EntityAction>) packet.getObject(1);

        // is this the right phase?
        if (!getGame().getPhase().isFiring() && !getGame().getPhase().isPhysical()
                && !getGame().getPhase().isTargeting() && !getGame().getPhase().isOffboard()) {
            LogManager.getLogger().error("Server got attack packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (getGame().getPhase().isSimultaneous(getGame())) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null) || !turn.isValid(connId, entity, game)) {
            LogManager.getLogger().error(String.format(
                    "Server got invalid attack packet from Connection %s, Entity %s, %s Turn",
                    connId, ((entity == null) ? "null" : entity.getShortName()),
                    ((turn == null) ? "null" : "invalid")));
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket((turn == null) ? Player.PLAYER_NONE : turn.getPlayerNum()));
            return;
        }

        // looks like mostly everything's okay
        processAttack(entity, vector);

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(null);
        }

        endCurrentTurn(entity);
    }

    /**
     * Process a batch of entity attack (or twist) actions by adding them to the
     * proper list to be processed later.
     */
    private void processAttack(Entity entity, Vector<EntityAction> vector) {
        // Convert any null vectors to empty vectors to avoid NPEs.
        if (vector == null) {
            vector = new Vector<>(0);
        }

        // Not **all** actions take up the entity's turn.
        boolean setDone = !((game.getTurn() instanceof GameTurn.TriggerAPPodTurn)
                || (game.getTurn() instanceof GameTurn.TriggerBPodTurn));
        for (EntityAction ea : vector) {
            // is this the right entity?
            if (ea.getEntityId() != entity.getId()) {
                LogManager.getLogger().error("Attack packet has wrong attacker");
                continue;
            }
            if (ea instanceof PushAttackAction) {
                // push attacks go the end of the displacement attacks
                PushAttackAction paa = (PushAttackAction) ea;
                entity.setDisplacementAttack(paa);
                game.addCharge(paa);
            } else if (ea instanceof DodgeAction) {
                entity.dodging = true;
            } else if (ea instanceof SpotAction) {
                entity.setSpotting(true);
                entity.setSpotTargetId(((SpotAction) ea).getTargetId());
            } else {
                // add to the normal attack list.
                game.addAction(ea);
            }

            // Anti-mech and pointblank attacks from
            // hiding may allow the target to respond.
            if (ea instanceof WeaponAttackAction) {
                final WeaponAttackAction waa = (WeaponAttackAction) ea;
                final String weaponName = entity.getEquipment(waa.getWeaponId()).getType()
                        .getInternalName();

                if (Infantry.SWARM_MEK.equals(weaponName) || Infantry.LEG_ATTACK.equals(weaponName)) {

                    // Does the target have any AP Pods available?
                    final Entity target = game.getEntity(waa.getTargetId());
                    for (Mounted equip : target.getMisc()) {
                        if (equip.getType().hasFlag(MiscType.F_AP_POD) && equip.canFire()) {

                            // Yup. Insert a game turn to handle AP pods.
                            // ASSUMPTION : AP pod declarations come
                            // immediately after the attack declaration.
                            game.insertNextTurn(new GameTurn.TriggerAPPodTurn(target.getOwnerId(),
                                    target.getId()));
                            send(createTurnVectorPacket());

                            // We can stop looking.
                            break;

                        } // end found-available-ap-pod

                    } // Check the next piece of equipment on the target.

                    for (Mounted weapon : target.getWeaponList()) {
                        if (weapon.getType().hasFlag(WeaponType.F_B_POD) && weapon.canFire()) {

                            // Yup. Insert a game turn to handle B pods.
                            // ASSUMPTION : B pod declarations come
                            // immediately after the attack declaration.
                            game.insertNextTurn(new GameTurn.TriggerBPodTurn(target.getOwnerId(),
                                    target.getId(), weaponName));
                            send(createTurnVectorPacket());

                            // We can stop looking.
                            break;

                        } // end found-available-b-pod
                    } // Check the next piece of equipment on the target.
                } // End check-for-available-ap-pod

                // Keep track of altitude loss for weapon attacks
                if (entity.isAero()) {
                    IAero aero = (IAero) entity;
                    if (waa.getAltitudeLoss(game) > aero.getAltLoss()) {
                        aero.setAltLoss(waa.getAltitudeLoss(game));
                    }
                }
            }

            // If attacker breaks grapple, defender may counter
            if (ea instanceof BreakGrappleAttackAction) {
                final BreakGrappleAttackAction bgaa = (BreakGrappleAttackAction) ea;
                final Entity att = (game.getEntity(bgaa.getEntityId()));
                if (att.isGrappleAttacker()) {
                    final Entity def = (game.getEntity(bgaa.getTargetId()));
                    // Remove existing break grapple by defender (if exists)
                    if (def.isDone()) {
                        game.removeActionsFor(def.getId());
                    } else {
                        game.removeTurnFor(def);
                        def.setDone(true);
                    }
                    // If defender is able, add a turn to declare counterattack
                    if (!def.isImmobile()) {
                        game.insertNextTurn(new GameTurn.CounterGrappleTurn(def.getOwnerId(), def.getId()));
                        send(createTurnVectorPacket());
                    }
                }
            }
            if (ea instanceof ArtilleryAttackAction) {
                boolean firingAtNewHex = false;
                final ArtilleryAttackAction aaa = (ArtilleryAttackAction) ea;
                final Entity firingEntity = game.getEntity(aaa.getEntityId());
                Targetable attackTarget = aaa.getTarget(game);

                for (Enumeration<AttackHandler> j = game.getAttacks(); !firingAtNewHex
                        && j.hasMoreElements(); ) {
                    WeaponHandler wh = (WeaponHandler) j.nextElement();
                    if (wh.waa instanceof ArtilleryAttackAction) {
                        ArtilleryAttackAction oaaa = (ArtilleryAttackAction) wh.waa;

                        if ((oaaa.getEntityId() == aaa.getEntityId())
                                && !Targetable.areAtSamePosition(oaaa.getTarget(game), attackTarget)) {
                            firingAtNewHex = true;
                        }
                    }
                }
                if (firingAtNewHex) {
                    clearArtillerySpotters(firingEntity.getId(), aaa.getWeaponId());
                }
                Iterator<Entity> spotters = game.getSelectedEntities(new EntitySelector() {
                    public int player = firingEntity.getOwnerId();
                    public Targetable target = aaa.getTarget(game);

                    @Override
                    public boolean accept(Entity entity) {
                        LosEffects los = LosEffects.calculateLOS(game, entity, target);
                        return ((player == entity.getOwnerId()) && !(los.isBlocked())
                                && entity.isActive());
                    }
                });
                Vector<Integer> spotterIds = new Vector<>();
                while (spotters.hasNext()) {
                    Integer id = spotters.next().getId();
                    spotterIds.addElement(id);
                }
                aaa.setSpotterIds(spotterIds);
            }

            // The equipment type of a club needs to be restored.
            if (ea instanceof ClubAttackAction) {
                ClubAttackAction caa = (ClubAttackAction) ea;
                Mounted club = caa.getClub();
                club.restore();
            }

            // Mark any AP Pod as used in this turn.
            if (ea instanceof TriggerAPPodAction) {
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;
                Mounted pod = entity.getEquipment(tapa.getPodId());
                pod.setUsedThisRound(true);
            }
            // Mark any B Pod as used in this turn.
            if (ea instanceof TriggerBPodAction) {
                TriggerBPodAction tba = (TriggerBPodAction) ea;
                Mounted pod = entity.getEquipment(tba.getPodId());
                pod.setUsedThisRound(true);
            }

            // Mark illuminated hexes, so they can be displayed
            if (ea instanceof SearchlightAttackAction) {
                boolean hexesAdded =
                        ((SearchlightAttackAction) ea).setHexesIlluminated(game);
                // If we added new hexes, send them to all players.
                // These are spotlights at night, you know they're there.
                if (hexesAdded) {
                    send(createIlluminatedHexesPacket());
                }
            }
        }

        // Apply altitude loss
        if (entity.isAero()) {
            IAero aero = (IAero) entity;
            if (aero.getAltLoss() > 0) {
                Report r = new Report(9095);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(aero.getAltLoss());
                addReport(r);
                entity.setAltitude(entity.getAltitude() - aero.getAltLoss());
                aero.setAltLossThisRound(aero.getAltLoss());
                aero.resetAltLoss();
                entityUpdate(entity.getId());
            }
        }

        // Unless otherwise stated,
        // this entity is done for the round.
        if (setDone) {
            entity.setDone(true);
        }
        entityUpdate(entity.getId());

        Packet p = createAttackPacket(vector, 0);
        if (getGame().getPhase().isSimultaneous(getGame())) {
            // Update attack only to player who declared it & observers
            for (Player player : game.getPlayersVector()) {
                if (player.canIgnoreDoubleBlind() || player.isObserver()
                        || (entity.getOwnerId() == player.getId())) {
                    send(player.getId(), p);
                }
            }
        } else {
            // update all players on the attacks. Don't worry about pushes being
            // a "charge" attack. It doesn't matter to the client.
            send(p);
        }
    }

    /**
     * Determine which telemissile attack actions could be affected by AMS, and assign AMS to those
     * attacks.
     */
    public void assignTeleMissileAMS(final TeleMissileAttackAction taa) {
        final Entity target = (taa.getTargetType() == Targetable.TYPE_ENTITY)
                ? (Entity) taa.getTarget(game) : null;

        // If a telemissile is still on the board and its original target is not, just return.
        if (target == null) {
            LogManager.getLogger().info("Telemissile has no target. AMS not assigned.");
            return;
        }

        target.assignTMAMS(taa);
    }

    /**
     * Determine which missile attack actions could be affected by AMS, and
     * assign AMS (and APDS) to those attacks.
     */
    public void assignAMS() {
        // Get all of the coords that would be protected by APDS
        Hashtable<Coords, List<Mounted>> apdsCoords = getAPDSProtectedCoords();
        // Map target to a list of missile attacks directed at it
        Hashtable<Entity, Vector<WeaponHandler>> htAttacks = new Hashtable<>();
        // Keep track of each APDS, and which attacks it could affect
        Hashtable<Mounted, Vector<WeaponHandler>> apdsTargets = new Hashtable<>();

        for (AttackHandler ah : game.getAttacksVector()) {
            WeaponHandler wh = (WeaponHandler) ah;
            WeaponAttackAction waa = wh.waa;

            // for artillery attacks, the attacking entity
            // might no longer be in the game.
            //TODO : Yeah, I know there's an exploit here, but better able to shoot some ArrowIVs than none, right?
            if (game.getEntity(waa.getEntityId()) == null) {
                LogManager.getLogger().info("Can't Assign AMS: Artillery firer is null!");
                continue;
            }

            Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());

            // Only entities can have AMS. Arrow IV doesn't target an entity until later, so we have to ignore them
            if (!(waa instanceof ArtilleryAttackAction) && (Targetable.TYPE_ENTITY != waa.getTargetType())) {
                continue;
            }

            // AMS is only used against attacks that hit (TW p129)
            if (wh.roll < wh.toHit.getValue()) {
                continue;
            }

            // Can only use AMS versus missiles. Artillery Bays might be firing Arrow IV homing missiles,
            // but lack the flag
            boolean isHomingMissile = false;
            if (wh instanceof ArtilleryWeaponIndirectHomingHandler
                    || wh instanceof ArtilleryBayWeaponIndirectHomingHandler) {
                Mounted ammoUsed = game.getEntity(waa.getEntityId()).getEquipment(waa.getAmmoId());
                AmmoType atype = ammoUsed == null ? null : (AmmoType) ammoUsed.getType();
                if (atype != null
                        && (atype.getAmmoType() == AmmoType.T_ARROW_IV || atype.getAmmoType() == BombType.B_HOMING)) {
                    isHomingMissile = true;
                }
            }
            if (!weapon.getType().hasFlag(WeaponType.F_MISSILE) && !isHomingMissile) {
                continue;
            }

            // For Bearings-only Capital Missiles, don't assign during the offboard phase
            if (wh instanceof CapitalMissileBearingsOnlyHandler) {
                ArtilleryAttackAction aaa = (ArtilleryAttackAction) waa;
                if ((aaa.getTurnsTilHit() > 0) || !getGame().getPhase().isFiring()) {
                    continue;
                }
            }

            // For Arrow IV homing artillery
            Entity target;
            if (waa instanceof ArtilleryAttackAction) {
                target = (waa.getTargetType() == Targetable.TYPE_ENTITY) ? (Entity) waa
                        .getTarget(game) : null;

                // In case our target really is null.
                if (target == null) {
                    continue;
                }
            } else {
                target = game.getEntity(waa.getTargetId());
            }
            Vector<WeaponHandler> v = htAttacks.computeIfAbsent(target, k -> new Vector<>());
            v.addElement(wh);
            // Keep track of what weapon attacks could be affected by APDS
            if (apdsCoords.containsKey(target.getPosition())) {
                for (Mounted apds : apdsCoords.get(target.getPosition())) {
                    // APDS only affects attacks against friendly units
                    if (target.isEnemyOf(apds.getEntity())) {
                        continue;
                    }
                    Vector<WeaponHandler> handlerList = apdsTargets.computeIfAbsent(apds, k -> new Vector<>());
                    handlerList.add(wh);
                }
            }
        }

        // Let each target assign its AMS
        for (Entity e : htAttacks.keySet()) {
            Vector<WeaponHandler> vAttacks = htAttacks.get(e);
            // Allow MM to automatically assign AMS targets
            if (game.getOptions().booleanOption(OptionsConstants.BASE_AUTO_AMS)) {
                e.assignAMS(vAttacks);
            } else { // Allow user to manually assign targets
                manuallyAssignAMSTarget(e, vAttacks);
            }
        }

        // Let each APDS assign itself to an attack
        Set<WeaponAttackAction> targetedAttacks = new HashSet<>();
        for (Mounted apds : apdsTargets.keySet()) {
            List<WeaponHandler> potentialTargets = apdsTargets.get(apds);
            // Ensure we only target each attack once
            List<WeaponHandler> targetsToRemove = new ArrayList<>();
            for (WeaponHandler wh : potentialTargets) {
                if (targetedAttacks.contains(wh.getWaa())) {
                    targetsToRemove.add(wh);
                }
            }
            potentialTargets.removeAll(targetsToRemove);
            WeaponAttackAction targetedWAA;
            // Assign APDS to an attack
            if (game.getOptions().booleanOption(OptionsConstants.BASE_AUTO_AMS)) {
                targetedWAA = apds.assignAPDS(potentialTargets);
            } else { // Allow user to manually assign targets
                targetedWAA = manuallyAssignAPDSTarget(apds, potentialTargets);
            }
            if (targetedWAA != null) {
                targetedAttacks.add(targetedWAA);
            }
        }

    }

    /**
     * Convenience method for determining which missile attack will be targeted
     * with AMS on the supplied Entity
     *
     * @param apds
     *            The Entity with AMS
     * @param vAttacks
     *            List of missile attacks directed at e
     */
    private WeaponAttackAction manuallyAssignAPDSTarget(Mounted apds,
                                                        List<WeaponHandler> vAttacks) {
        Entity e = apds.getEntity();
        if (e == null) {
            return null;
        }

        // Create a list of valid assignments for this APDS
        List<WeaponAttackAction> vAttacksInArc = new ArrayList<>(vAttacks.size());
        for (WeaponHandler wr : vAttacks) {
            boolean isInArc = Compute.isInArc(e.getGame(), e.getId(),
                    e.getEquipmentNum(apds),
                    game.getEntity(wr.waa.getEntityId()));
            boolean isInRange = e.getPosition().distance(
                    wr.getWaa().getTarget(game).getPosition()) <= 3;
            if (isInArc && isInRange) {
                vAttacksInArc.add(wr.waa);
            }
        }

        // If there are no valid attacks left, don't bother
        if (vAttacksInArc.size() < 1) {
            return null;
        }

        WeaponAttackAction targetedWAA = null;

        if (apds.curMode().equals("Automatic")) {
            targetedWAA = Compute.getHighestExpectedDamage(game,
                    vAttacksInArc, true);
        } else {
            // Send a client feedback request
            List<Integer> apdsDists = new ArrayList<>();
            for (WeaponAttackAction waa : vAttacksInArc) {
                apdsDists.add(waa.getTarget(game).getPosition()
                        .distance(e.getPosition()));
            }
            sendAPDSAssignCFR(e, apdsDists, vAttacksInArc);
            synchronized (cfrPacketQueue) {
                try {
                    cfrPacketQueue.wait();
                } catch (InterruptedException ignored) {
                    // Do nothing
                }

                if (!cfrPacketQueue.isEmpty()) {
                    Server.ReceivedPacket rp = cfrPacketQueue.poll();
                    final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                    // Make sure we got the right type of response
                    if (!cfrType.isCFRAPDSAssign()) {
                        LogManager.getLogger().error("Expected a CFR_APDS_ASSIGN CFR packet, received: " + cfrType);
                        throw new IllegalStateException();
                    }
                    Integer waaIndex = (Integer) rp.getPacket().getData()[1];
                    if (waaIndex != null) {
                        targetedWAA = vAttacksInArc.get(waaIndex);
                    }
                }
            }
        }

        if (targetedWAA != null) {
            targetedWAA.addCounterEquipment(apds);
            return targetedWAA;
        } else {
            return null;
        }
    }

    /**
     * Convenience method for determining which missile attack will be targeted
     * with AMS on the supplied Entity
     *
     * @param e
     *            The Entity with AMS
     * @param vAttacks
     *            List of missile attacks directed at e
     */
    private void manuallyAssignAMSTarget(Entity e,
                                         Vector<WeaponHandler> vAttacks) {
        //Fix for bug #1051 - don't send the targeting nag for a shutdown unit
        if (e.isShutDown()) {
            return;
        }
        // Current AMS targets: each attack can only be targeted once
        HashSet<WeaponAttackAction> amsTargets = new HashSet<>();
        // Pick assignment for each active AMS
        for (Mounted ams : e.getActiveAMS()) {
            // Skip APDS
            if (ams.isAPDS()) {
                continue;
            }
            // Create a list of valid assignments for this AMS
            List<WeaponAttackAction> vAttacksInArc = new ArrayList<>(vAttacks.size());
            for (WeaponHandler wr : vAttacks) {
                if (!amsTargets.contains(wr.waa)
                        && Compute.isInArc(game, e.getId(),
                        e.getEquipmentNum(ams),
                        game.getEntity(wr.waa.getEntityId()))) {
                    vAttacksInArc.add(wr.waa);
                }
            }

            // If there are no valid attacks left, don't bother
            if (vAttacksInArc.size() < 1) {
                continue;
            }

            WeaponAttackAction targetedWAA = null;

            if (ams.curMode().equals("Automatic")) {
                targetedWAA = Compute.getHighestExpectedDamage(game, vAttacksInArc, true);
            } else {
                // Send a client feedback request
                sendAMSAssignCFR(e, ams, vAttacksInArc);
                synchronized (cfrPacketQueue) {
                    try {
                        cfrPacketQueue.wait();
                    } catch (Exception ignored) {

                    }

                    if (!cfrPacketQueue.isEmpty()) {
                        Server.ReceivedPacket rp = cfrPacketQueue.poll();
                        final PacketCommand cfrType = (PacketCommand) rp.getPacket().getObject(0);
                        // Make sure we got the right type of response
                        if (!cfrType.isCFRAMSAssign()) {
                            LogManager.getLogger().error("Expected a CFR_AMS_ASSIGN CFR packet, received: " + cfrType);
                            throw new IllegalStateException();
                        }
                        Integer waaIndex = (Integer) rp.getPacket().getData()[1];
                        if (waaIndex != null) {
                            targetedWAA = vAttacksInArc.get(waaIndex);
                        }
                    }
                }
            }

            if (targetedWAA != null) {
                targetedWAA.addCounterEquipment(ams);
                amsTargets.add(targetedWAA);
            }
        }
    }

    /**
     * Convenience method for computing a mapping of which Coords are
     * "protected" by an APDS. Protection implies that the coords is within the
     * range/arc of an active APDS.
     *
     * @return
     */
    private Hashtable<Coords, List<Mounted>> getAPDSProtectedCoords() {
        // Get all of the coords that would be protected by APDS
        Hashtable<Coords, List<Mounted>> apdsCoords = new Hashtable<>();
        for (Entity e : game.getEntitiesVector()) {
            // Ignore Entities without positions
            if (e.getPosition() == null) {
                continue;
            }
            Coords origPos = e.getPosition();
            for (Mounted ams : e.getActiveAMS()) {
                // Ignore non-APDS AMS
                if (!ams.isAPDS()) {
                    continue;
                }
                // Add the current hex as a defended location
                List<Mounted> apdsList = apdsCoords.computeIfAbsent(origPos, k -> new ArrayList<>());
                apdsList.add(ams);
                // Add each coords that is within arc/range as protected
                int maxDist = 3;
                if (e instanceof BattleArmor) {
                    int numTroopers = ((BattleArmor) e)
                            .getNumberActiverTroopers();
                    switch (numTroopers) {
                        case 1:
                            maxDist = 1;
                            break;
                        case 2:
                        case 3:
                            maxDist = 2;
                            break;
                        // Anything above is the same as the default
                    }
                }
                for (int dist = 1; dist <= maxDist; dist++) {
                    List<Coords> coords = e.getPosition().allAtDistance(dist);
                    for (Coords pos : coords) {
                        // Check that we're in the right arc
                        if (Compute.isInArc(game, e.getId(), e.getEquipmentNum(ams),
                                new HexTarget(pos, HexTarget.TYPE_HEX_CLEAR))) {
                            apdsList = apdsCoords.computeIfAbsent(pos, k -> new ArrayList<>());
                            apdsList.add(ams);
                        }
                    }
                }

            }
        }
        return apdsCoords;
    }

    /**
     * Called at the start and end of movement. Determines if an entity
     * has been detected and/or had a firing solution calculated
     */
    private void detectSpacecraft() {
        // Don't bother if we're not in space or if the game option isn't on
        if (!game.getBoard().inSpace()
                || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {
            return;
        }

        //Now, run the detection rolls
        for (Entity detector : game.getEntitiesVector()) {
            //Don't process for invalid units
            //in the case of squadrons and transports, we want the 'host'
            //unit, not the component entities
            if (detector.getPosition() == null
                    || detector.isDestroyed()
                    || detector.isDoomed()
                    || detector.isOffBoard()
                    || detector.isPartOfFighterSquadron()
                    || detector.getTransportId() != Entity.NONE) {
                continue;
            }
            for (Entity target : game.getEntitiesVector()) {
                //Once a target is detected, we don't need to detect it again
                if (detector.hasSensorContactFor(target.getId())) {
                    continue;
                }
                //Don't process for invalid units
                //in the case of squadrons and transports, we want the 'host'
                //unit, not the component entities
                if (target.getPosition() == null
                        || target.isDestroyed()
                        || target.isDoomed()
                        || target.isOffBoard()
                        || target.isPartOfFighterSquadron()
                        || target.getTransportId() != Entity.NONE) {
                    continue;
                }
                // Only process for enemy units
                if (!detector.isEnemyOf(target)) {
                    continue;
                }
                //If we successfully detect the enemy, add it to the appropriate detector's sensor contacts list
                if (Compute.calcSensorContact(game, detector, target)) {
                    game.getEntity(detector.getId()).addSensorContact(target.getId());
                    //If detector is part of a C3 network, share the contact
                    if (detector.hasNavalC3()) {
                        for (Entity c3NetMate : game.getC3NetworkMembers(detector)) {
                            game.getEntity(c3NetMate.getId()).addSensorContact(target.getId());
                        }
                    }
                }
            }
        }
        //Now, run the firing solution calculations
        for (Entity detector : game.getEntitiesVector()) {
            //Don't process for invalid units
            //in the case of squadrons and transports, we want the 'host'
            //unit, not the component entities
            if (detector.getPosition() == null
                    || detector.isDestroyed()
                    || detector.isDoomed()
                    || detector.isOffBoard()
                    || detector.isPartOfFighterSquadron()
                    || detector.getTransportId() != Entity.NONE) {
                continue;
            }
            for (int targetId : detector.getSensorContacts()) {
                Entity target = game.getEntity(targetId);
                //if we already have a firing solution, no need to process a new one
                if (detector.hasFiringSolutionFor(targetId)) {
                    continue;
                }
                //Don't process for invalid units
                //in the case of squadrons and transports, we want the 'host'
                //unit, not the component entities
                if (target == null
                        || target.getPosition() == null
                        || target.isDestroyed()
                        || target.isDoomed()
                        || target.isOffBoard()
                        || target.isPartOfFighterSquadron()
                        || target.getTransportId() != Entity.NONE) {
                    continue;
                }
                // Only process for enemy units
                if (!detector.isEnemyOf(target)) {
                    continue;
                }
                //If we successfully lock up the enemy, add it to the appropriate detector's firing solutions list
                if (Compute.calcFiringSolution(game, detector, target)) {
                    game.getEntity(detector.getId()).addFiringSolution(targetId);
                }
            }
        }
    }

    /**
     * Called at the end of movement. Determines if an entity
     * has moved beyond sensor range
     */
    private void updateSpacecraftDetection() {
        // Don't bother if we're not in space or if the game option isn't on
        if (!game.getBoard().inSpace()
                || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {
            return;
        }
        //Run through our list of units and remove any entities from the plotting board that have moved out of range
        for (Entity detector : game.getEntitiesVector()) {
            Compute.updateFiringSolutions(game, detector);
            Compute.updateSensorContacts(game, detector);
        }
    }

    /**
     * Checks to see if any units can detected hidden units.
     */
    private void detectHiddenUnits() {
        // If hidden units aren't on, nothing to do
        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {
            return;
        }

        // See if any unit with a probe, detects any hidden units
        for (Entity detector : game.getEntitiesVector()) {
            ServerHelper.detectHiddenUnits(game, detector, detector.getPosition(), vPhaseReport, this);
        }
    }

    /**
     * Called to what players can see what units. This is used to determine who
     * can see what in double blind reports.
     */
    private void resolveWhatPlayersCanSeeWhatUnits() {
        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }
        Map<EntityTargetPair, LosEffects> losCache = new HashMap<>();
        for (Entity entity : game.getEntitiesVector()) {
            // We are hidden once again!
            entity.clearSeenBy();
            entity.clearDetectedBy();
            // Handle visual spotting
            for (Player p : whoCanSee(entity, false, losCache)) {
                entity.addBeenSeenBy(p);
            }
            // Handle detection by sensors
            for (Player p : whoCanDetect(entity, allECMInfo, losCache)) {
                entity.addBeenDetectedBy(p);
            }
        }
    }

    /**
     * Called during the weapons fire phase. Resolves anything other than
     * weapons fire that happens. Torso twists, for example.
     */
    private void resolveAllButWeaponAttacks() {
        Vector<EntityAction> triggerPodActions = new Vector<>();
        // loop through actions and handle everything we expect except attacks
        for (Enumeration<EntityAction> i = game.getActions(); i.hasMoreElements(); ) {
            EntityAction ea = i.nextElement();
            Entity entity = game.getEntity(ea.getEntityId());
            if (ea instanceof TorsoTwistAction) {
                TorsoTwistAction tta = (TorsoTwistAction) ea;
                if (entity.canChangeSecondaryFacing()) {
                    entity.setSecondaryFacing(tta.getFacing());
                    entity.postProcessFacingChange();
                }
            } else if (ea instanceof FlipArmsAction) {
                FlipArmsAction faa = (FlipArmsAction) ea;
                entity.setArmsFlipped(faa.getIsFlipped());
            } else if (ea instanceof FindClubAction) {
                resolveFindClub(entity);
            } else if (ea instanceof UnjamAction) {
                resolveUnjam(entity);
            } else if (ea instanceof ClearMinefieldAction) {
                resolveClearMinefield(entity, ((ClearMinefieldAction) ea).getMinefield());
            } else if (ea instanceof TriggerAPPodAction) {
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;

                // Don't trigger the same pod twice.
                if (!triggerPodActions.contains(tapa)) {
                    triggerAPPod(entity, tapa.getPodId());
                    triggerPodActions.addElement(tapa);
                } else {
                    LogManager.getLogger().error("AP Pod #" + tapa.getPodId() + " on "
                            + entity.getDisplayName() + " was already triggered this round!!");
                }
            } else if (ea instanceof TriggerBPodAction) {
                TriggerBPodAction tba = (TriggerBPodAction) ea;

                // Don't trigger the same pod twice.
                if (!triggerPodActions.contains(tba)) {
                    triggerBPod(entity, tba.getPodId(), game.getEntity(tba.getTargetId()));
                    triggerPodActions.addElement(tba);
                } else {
                    LogManager.getLogger().error("B Pod #" + tba.getPodId() + " on "
                            + entity.getDisplayName() + " was already triggered this round!!");
                }
            } else if (ea instanceof SearchlightAttackAction) {
                SearchlightAttackAction saa = (SearchlightAttackAction) ea;
                addReport(saa.resolveAction(game));
            } else if (ea instanceof UnjamTurretAction) {
                if (entity instanceof Tank) {
                    ((Tank) entity).unjamTurret(((Tank) entity).getLocTurret());
                    ((Tank) entity).unjamTurret(((Tank) entity).getLocTurret2());
                    Report r = new Report(3033);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                } else {
                    LogManager.getLogger().error("Non-Tank tried to unjam turret");
                }
            } else if (ea instanceof RepairWeaponMalfunctionAction) {
                if (entity instanceof Tank) {
                    Mounted m = entity.getEquipment(((RepairWeaponMalfunctionAction) ea).getWeaponId());
                    m.setJammed(false);
                    ((Tank) entity).getJammedWeapons().remove(m);
                    Report r = new Report(3034);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                } else {
                    LogManager.getLogger().error("Non-Tank tried to repair weapon malfunction");
                }
            } else if (ea instanceof DisengageAction) {
                MovePath path = new MovePath(game, entity);
                path.addStep(MovePath.MoveStepType.FLEE);
                addReport(processLeaveMap(path, false, -1));
            } else if (ea instanceof ActivateBloodStalkerAction) {
                ActivateBloodStalkerAction bloodStalkerAction = (ActivateBloodStalkerAction) ea;
                Entity target = game.getEntity(bloodStalkerAction.getTargetID());

                if ((entity != null) && (target != null)) {
                    game.getEntity(bloodStalkerAction.getEntityId())
                            .setBloodStalkerTarget(bloodStalkerAction.getTargetID());
                    Report r = new Report(10000);
                    r.subject = entity.getId();
                    r.add(entity.getDisplayName());
                    r.add(target.getDisplayName());
                    addReport(r);
                }
            }
        }
    }

    /*
     * Called during the weapons firing phase to initiate self destruction.
     */
    private void resolveSelfDestructions() {
        Vector<Report> vDesc = new Vector<>();
        Report r;
        for (Entity e : game.getEntitiesVector()) {
            if (e.getSelfDestructInitiated() && e.hasEngine()) {
                r = new Report(6166, Report.PUBLIC);
                int target = e.getCrew().getPiloting();
                int roll = e.getCrew().rollPilotingSkill();
                r.subject = e.getId();
                r.addDesc(e);
                r.indent();
                r.add(target);
                r.add(roll);
                r.choose(roll >= target);
                vDesc.add(r);

                // Blow it up...
                if (roll >= target) {
                    int engineRating = e.getEngine().getRating();
                    r = new Report(5400, Report.PUBLIC);
                    r.subject = e.getId();
                    r.indent(2);
                    vDesc.add(r);

                    if (e instanceof Mech) {
                        Mech mech = (Mech) e;
                        if (mech.isAutoEject()
                                && (!game.getOptions().booleanOption(
                                OptionsConstants.RPG_CONDITIONAL_EJECTION) || (game
                                .getOptions().booleanOption(
                                        OptionsConstants.RPG_CONDITIONAL_EJECTION) && mech
                                .isCondEjectEngine()))) {
                            vDesc.addAll(ejectEntity(e, true));
                        }
                    }
                    e.setSelfDestructedThisTurn(true);
                    doFusionEngineExplosion(engineRating, e.getPosition(),
                            vDesc, null);
                    Report.addNewline(vDesc);
                    r = new Report(5410, Report.PUBLIC);
                    r.subject = e.getId();
                    r.indent(2);
                    Report.addNewline(vDesc);
                    vDesc.add(r);
                }
                e.setSelfDestructInitiated(false);
            }
        }
        addReport(vDesc);
    }

    private void reportGhostTargetRolls() {
        // run through an enumeration of deployed game entities. If they have
        // ghost targets, then check the roll
        // and report it
        Report r;
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            if (ent.isDeployed() && ent.hasGhostTargets(false)) {
                r = new Report(3630);
                r.subject = ent.getId();
                r.addDesc(ent);
                // Ghost target mod is +3 per errata
                int target = ent.getCrew().getPiloting() + 3;
                if (ent.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
                    target = ent.getCrew().getGunnery() + 3;
                }
                int roll = ent.getGhostTargetRoll();
                r.add(target);
                r.add(roll);
                if (roll >= target) {
                    r.choose(true);
                } else {
                    r.choose(false);
                }
                addReport(r);
            }
        }
        addNewLines();
    }

    private void reportLargeCraftECCMRolls() {
        // run through an enumeration of deployed game entities. If they are
        // large craft in space, then check the roll
        // and report it
        if (!game.getBoard().inSpace()
                || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {
            return;
        }
        Report r;
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            if (ent.isDeployed() && ent.isLargeCraft()) {
                r = new Report(3635);
                r.subject = ent.getId();
                r.addDesc(ent);
                int target = ((Aero) ent).getECCMTarget();
                int roll = ((Aero) ent).getECCMRoll();
                r.add(roll);
                r.add(target);
                int mod = ((Aero) ent).getECCMBonus();
                r.add(mod);
                addReport(r);
            }
        }
    }

    private void resolveClearMinefield(Entity ent, Minefield mf) {

        if ((null == mf) || (null == ent) || ent.isDoomed()
                || ent.isDestroyed()) {
            return;
        }

        Coords pos = mf.getCoords();
        int clear = Minefield.CLEAR_NUMBER_INFANTRY;
        int boom = Minefield.CLEAR_NUMBER_INFANTRY_ACCIDENT;

        Report r = new Report(2245);
        // Does the entity has a minesweeper?
        if ((ent instanceof BattleArmor)) {
            BattleArmor ba = (BattleArmor) ent;
            String mcmName = BattleArmor.MANIPULATOR_TYPE_STRINGS
                    [BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE];
            if (ba.getLeftManipulatorName().equals(mcmName)) {
                clear = Minefield.CLEAR_NUMBER_BA_SWEEPER;
                boom = Minefield.CLEAR_NUMBER_BA_SWEEPER_ACCIDENT;
                r = new Report(2246);
            }
        } else if (ent instanceof Infantry) { // Check Minesweeping Engineers
            Infantry inf = (Infantry) ent;
            if (inf.hasSpecialization(Infantry.MINE_ENGINEERS)) {
                clear = Minefield.CLEAR_NUMBER_INF_ENG;
                boom = Minefield.CLEAR_NUMBER_INF_ENG_ACCIDENT;
                r = new Report(2247);
            }
        }
        // mine clearing roll
        r.subject = ent.getId();
        r.add(ent.getShortName(), true);
        r.add(Minefield.getDisplayableName(mf.getType()));
        r.add(pos.getBoardNum(), true);
        addReport(r);

        if (clearMinefield(mf, ent, clear, boom, vPhaseReport)) {
            removeMinefield(mf);
        }
        // some mines might have blown up
        resetMines();

        addNewLines();
    }

    /**
     * Called during the fire phase to resolve all (and only) weapon attacks
     */
    private void resolveOnlyWeaponAttacks() {
        // loop through received attack actions, getting attack handlers
        for (Enumeration<EntityAction> i = game.getActions(); i.hasMoreElements(); ) {
            EntityAction ea = i.nextElement();
            if (ea instanceof WeaponAttackAction) {
                WeaponAttackAction waa = (WeaponAttackAction) ea;
                Entity ae = game.getEntity(waa.getEntityId());
                Mounted m = ae.getEquipment(waa.getWeaponId());
                Weapon w = (Weapon) m.getType();
                // Track attacks original target, for things like swarm LRMs
                waa.setOriginalTargetId(waa.getTargetId());
                waa.setOriginalTargetType(waa.getTargetType());
                AttackHandler ah = w.fire(waa, game, this);
                if (ah != null) {
                    ah.setStrafing(waa.isStrafing());
                    ah.setStrafingFirstShot(waa.isStrafingFirstShot());
                    game.addAttack(ah);
                }
            }
        }
        // and clear the attacks Vector
        game.resetActions();
    }

    /**
     * Trigger the indicated AP Pod of the entity.
     *
     * @param entity the <code>Entity</code> triggering the AP Pod.
     * @param podId  the <code>int</code> ID of the AP Pod.
     */
    private void triggerAPPod(Entity entity, int podId) {
        // Get the mount for this pod.
        Mounted mount = entity.getEquipment(podId);

        // Confirm that this is, indeed, an AP Pod.
        if (null == mount) {
            LogManager.getLogger().error("Expecting to find an AP Pod at " + podId + " on the unit, " + entity.getDisplayName()
                    + " but found NO equipment at all!!!");
            return;
        }
        EquipmentType equip = mount.getType();
        if (!(equip instanceof MiscType) || !equip.hasFlag(MiscType.F_AP_POD)) {
            LogManager.getLogger().error("Expecting to find an AP Pod at " + podId + " on the unit, "+ entity.getDisplayName()
                    + " but found " + equip.getName() + " instead!!!");
            return;
        }

        // Now confirm that the entity can trigger the pod.
        // Ignore the "used this round" flag.
        boolean oldFired = mount.isUsedThisRound();
        mount.setUsedThisRound(false);
        boolean canFire = mount.canFire();
        mount.setUsedThisRound(oldFired);
        if (!canFire) {
            LogManager.getLogger().error("Can not trigger the AP Pod at " + podId + " on the unit, "
                    + entity.getDisplayName() + "!!!");
            return;
        }

        Report r;

        // Mark the pod as fired and log the action.
        mount.setFired(true);
        r = new Report(3010);
        r.newlines = 0;
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // Walk through ALL entities in the triggering entity's hex.
        for (Entity target : game.getEntitiesVector(entity.getPosition())) {
            // Is this an unarmored infantry platoon?
            if (target.isConventionalInfantry()) {
                // Roll d6-1 for damage.
                final int damage = Math.max(1, Compute.d6() - 1);

                // Damage the platoon.
                addReport(damageEntity(target, new HitData(Infantry.LOC_INFANTRY), damage));

                // Damage from AP Pods is applied immediately.
                target.applyDamage();
            } // End target-is-unarmored

            // Nope, the target is immune.
            // Don't make a log entry for the triggering entity.
            else if (!entity.equals(target)) {
                r = new Report(3020);
                r.indent(2);
                r.subject = target.getId();
                r.addDesc(target);
                addReport(r);
            }

        } // Check the next entity in the triggering entity's hex.
    }

    /**
     * Trigger the indicated B Pod of the entity.
     *
     * @param entity the <code>Entity</code> triggering the B Pod.
     * @param podId  the <code>int</code> ID of the B Pod.
     */
    private void triggerBPod(Entity entity, int podId, Entity target) {
        // Get the mount for this pod.
        Mounted mount = entity.getEquipment(podId);

        // Confirm that this is, indeed, an Anti-BA Pod.
        if (null == mount) {
            LogManager.getLogger().error("Expecting to find an B Pod at " + podId + " on the unit, "
                    + entity.getDisplayName() + " but found NO equipment at all!!!");
            return;
        }
        EquipmentType equip = mount.getType();
        if (!(equip instanceof WeaponType) || !equip.hasFlag(WeaponType.F_B_POD)) {
            LogManager.getLogger().error("Expecting to find an B Pod at " + podId + " on the unit, "
                    + entity.getDisplayName() + " but found " + equip.getName() + " instead!!!");
            return;
        }

        // Now confirm that the entity can trigger the pod.
        // Ignore the "used this round" flag.
        boolean oldFired = mount.isUsedThisRound();
        mount.setUsedThisRound(false);
        boolean canFire = mount.canFire();
        mount.setUsedThisRound(oldFired);
        if (!canFire) {
            LogManager.getLogger().error("Can not trigger the B Pod at " + podId + " on the unit, "
                    + entity.getDisplayName() + "!!!");
            return;
        }

        Report r;

        // Mark the pod as fired and log the action.
        mount.setFired(true);
        r = new Report(3011);
        r.newlines = 0;
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // Is this an unarmored infantry platoon?
        if (target.isConventionalInfantry()) {
            // Roll d6 for damage.
            final int damage = Compute.d6();

            // Damage the platoon.
            addReport(damageEntity(target, new HitData(Infantry.LOC_INFANTRY), damage));

            // Damage from AP Pods is applied immediately.
            target.applyDamage();
        } else if (target instanceof BattleArmor) {
            // 20 damage in 5 point clusters
            final int damage = 5;

            // Damage the squad.
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));

            // Damage from B Pods is applied immediately.
            target.applyDamage();
        } else if (!entity.equals(target)) {
            // Nope, the target is immune.
            // Don't make a log entry for the triggering entity.
            r = new Report(3020);
            r.indent(2);
            r.subject = target.getId();
            r.addDesc(target);
            addReport(r);
        }
    }

    /**
     * Resolve an Unjam Action object
     */
    private void resolveUnjam(Entity entity) {
        Report r;
        final int TN = entity.getCrew().getGunnery() + 3;
        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UNJAM_UAC)) {
            r = new Report(3026);
        } else {
            r = new Report(3025);
        }
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);
        for (Mounted mounted : entity.getTotalWeaponList()) {
            if (mounted.isJammed() && !mounted.isDestroyed()) {
                WeaponType wtype = (WeaponType) mounted.getType();
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {
                    int roll = Compute.d6(2);
                    r = new Report(3030);
                    r.indent();
                    r.subject = entity.getId();
                    r.add(wtype.getName());
                    r.add(TN);
                    r.add(roll);
                    if (roll >= TN) {
                        r.choose(true);
                        mounted.setJammed(false);
                    } else {
                        r.choose(false);
                    }
                    addReport(r);
                }
                // Unofficial option to unjam UACs, ACs, and LACs like Rotary
                // Autocannons
                if (((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)
                        || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)
                        || (wtype.getAmmoType() == AmmoType.T_AC)
                        || (wtype.getAmmoType() == AmmoType.T_AC_IMP)
                        || (wtype.getAmmoType() == AmmoType.T_PAC)
                        || (wtype.getAmmoType() == AmmoType.T_LAC))
                        && game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UNJAM_UAC)) {
                    int roll = Compute.d6(2);
                    r = new Report(3030);
                    r.indent();
                    r.subject = entity.getId();
                    r.add(wtype.getName());
                    r.add(TN);
                    r.add(roll);
                    if (roll >= TN) {
                        r.choose(true);
                        mounted.setJammed(false);
                    } else {
                        r.choose(false);
                    }
                    addReport(r);
                }
            }
        }
    }

    private void resolveFindClub(Entity entity) {
        EquipmentType clubType = null;

        entity.setFindingClub(true);

        // Get the entity's current hex.
        Coords coords = entity.getPosition();
        Hex curHex = game.getBoard().getHex(coords);

        Report r;

        // Is there a blown off arm in the hex?
        if (curHex.terrainLevel(Terrains.ARMS) > 0) {
            clubType = EquipmentType.get(EquipmentTypeLookup.LIMB_CLUB);
            curHex.addTerrain(new Terrain(Terrains.ARMS, curHex.terrainLevel(Terrains.ARMS) - 1));
            sendChangedHex(entity.getPosition());
            r = new Report(3035);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }
        // Is there a blown off leg in the hex?
        else if (curHex.terrainLevel(Terrains.LEGS) > 0) {
            clubType = EquipmentType.get(EquipmentTypeLookup.LIMB_CLUB);
            curHex.addTerrain(new Terrain(Terrains.LEGS, curHex.terrainLevel(Terrains.LEGS) - 1));
            sendChangedHex(entity.getPosition());
            r = new Report(3040);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }

        // Is there the rubble of a medium, heavy,
        // or hardened building in the hex?
        else if (Building.LIGHT < curHex.terrainLevel(Terrains.RUBBLE)) {

            // Finding a club is not guaranteed. The chances are
            // based on the type of building that produced the
            // rubble.
            boolean found = false;
            int roll = Compute.d6(2);
            switch (curHex.terrainLevel(Terrains.RUBBLE)) {
                case Building.MEDIUM:
                    if (roll >= 7) {
                        found = true;
                    }
                    break;
                case Building.HEAVY:
                    if (roll >= 6) {
                        found = true;
                    }
                    break;
                case Building.HARDENED:
                    if (roll >= 5) {
                        found = true;
                    }
                    break;
                case Building.WALL:
                    if (roll >= 13) {
                        found = true;
                    }
                    break;
                default:
                    // we must be in ultra
                    if (roll >= 4) {
                        found = true;
                    }
            }

            // Let the player know if they found a club.
            if (found) {
                clubType = EquipmentType.get(EquipmentTypeLookup.GIRDER_CLUB);
                r = new Report(3045);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
            } else {
                // Sorry, no club for you.
                r = new Report(3050);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
            }
        }

        // Are there woods in the hex?
        else if (curHex.containsTerrain(Terrains.WOODS)
                || curHex.containsTerrain(Terrains.JUNGLE)) {
            clubType = EquipmentType.get(EquipmentTypeLookup.TREE_CLUB);
            r = new Report(3055);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }

        // add the club
        try {
            if (clubType != null) {
                entity.addEquipment(clubType, Entity.LOC_NONE);
            }
        } catch (LocationFullException ex) {
            // unlikely...
            r = new Report(3060);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }
    }

    /**
     * Try to ignite the hex, taking into account existing fires and the
     * effects of Inferno rounds.
     *
     * @param c
     *            - the <code>Coords</code> of the hex being lit.
     * @param entityId
     *            - the <code>int</code> id of the entity involved.
     * @param bInferno
     *            - <code>true</code> if the weapon igniting the hex is an
     *            Inferno round. If some other weapon or ammo is causing the
     *            roll, this should be <code>false</code>.
     * @param bHotGun
     *            - <code>true</code> if the weapon is plasma/flamer/incendiary
     *            LRM/etc
     * @param nTargetRoll
     *            - the <code>TargetRoll</code> for the ignition roll.
     * @param bReportAttempt
     *            - <code>true</code> if the attempt roll should be added to the
     *            report.
     * @param accidentTarget
     *            - <code>int</code> the target number below which a roll has to
     *            be made in order to try igniting a hex accidentally. -1 for
     *            intentional
     */
    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun,
                                boolean bInferno, TargetRoll nTargetRoll, boolean bReportAttempt,
                                int accidentTarget, Vector<Report> vPhaseReport) {

        Hex hex = game.getBoard().getHex(c);
        Report r;

        // Ignore bad coordinates.
        if (hex == null) {
            return false;
        }

        // Ignore if fire is not enabled as a game option
        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_START_FIRE)) {
            return false;
        }

        // is the hex ignitable (how are infernos handled?)
        if (!hex.isIgnitable()) {
            return false;
        }

        // first for accidental ignitions, make the necessary roll
        if (accidentTarget > -1) {
            // if this hex is in snow, then accidental ignitions are not
            // possible
            if (hex.containsTerrain(Terrains.SNOW)) {
                return false;
            }
            nTargetRoll.addModifier(2, "accidental");
            int accidentRoll = Compute.d6(2);
            r = new Report(3066);
            r.subject = entityId;
            r.add(accidentTarget);
            r.add(accidentRoll);
            r.indent(2);
            if (accidentRoll > accidentTarget) {
                r.choose(false);
                vPhaseReport.add(r);
                return false;
            }
            r.choose(true);
            vPhaseReport.add(r);
        }

        int terrainMod = hex.getIgnitionModifier();
        if (terrainMod != 0) {
            nTargetRoll.addModifier(terrainMod, "terrain");
        }

        // building modifiers
        Building bldg = game.getBoard().getBuildingAt(c);
        if (null != bldg) {
            nTargetRoll.addModifier(bldg.getType() - 3, "building");
        }

        // add in any modifiers for planetary conditions
        int weatherMod = game.getPlanetaryConditions().getIgniteModifiers();
        if (weatherMod != 0) {
            nTargetRoll.addModifier(weatherMod, "conditions");
        }

        // if there is snow on the ground and this a hotgun or inferno, it may
        // melt the snow instead
        if ((hex.containsTerrain(Terrains.SNOW) || hex
                .containsTerrain(Terrains.ICE)) && (bHotGun || bInferno)) {
            boolean melted = false;
            int meltCheck = Compute.d6(2);
            if ((hex.terrainLevel(Terrains.SNOW) > 1) && (meltCheck == 12)) {
                melted = true;
            } else if (hex.containsTerrain(Terrains.ICE) && (meltCheck > 9)) {
                melted = true;
            } else if (hex.containsTerrain(Terrains.SNOW) && (meltCheck > 7)) {
                melted = true;
            }
            if (bInferno) {
                melted = true;
            }
            if (melted) {
                vPhaseReport.addAll(meltIceAndSnow(c, entityId));
                return false;
            }

        }

        // inferno always ignites
        // ERRATA not if targeting clear hexes for ignition is disabled.
        if (bInferno && !game.getOptions().booleanOption(OptionsConstants.ADVANCED_NO_IGNITE_CLEAR)) {
            nTargetRoll = new TargetRoll(0, "inferno");
        }

        // no lighting fires in tornadoes
        if (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_STORM) {
            nTargetRoll = new TargetRoll(TargetRoll.AUTOMATIC_FAIL, "tornado");
        }

        // The hex may already be on fire.
        if (hex.containsTerrain(Terrains.FIRE)) {
            if (bReportAttempt) {
                r = new Report(3065);
                r.indent(2);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
        } else if (checkIgnition(c, nTargetRoll, bInferno, entityId,
                vPhaseReport)) {
            return true;
        }
        return false;
    }

    /**
     * Try to ignite the hex, taking into account existing fires and the
     * effects of Inferno rounds. This version of the method will not report the
     * attempt roll.
     *
     * @param c
     *            - the <code>Coords</code> of the hex being lit.
     * @param entityId
     *            - the <code>int</code> id of the entity involved.
     * @param bInferno
     *            - <code>true</code> if the weapon igniting the hex is an
     *            Inferno round. If some other weapon or ammo is causing the
     *            roll, this should be <code>false</code>.
     * @param nTargetRoll
     *            - the <code>int</code> roll target for the attempt.
     */
    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun, boolean bInferno,
                                TargetRoll nTargetRoll, int accidentTarget,
                                Vector<Report> vPhaseReport) {
        return tryIgniteHex(c, entityId, bHotGun, bInferno, nTargetRoll, false,
                accidentTarget, vPhaseReport);
    }

    public Vector<Report> tryClearHex(Coords c, int nDamage, int entityId) {
        Vector<Report> vPhaseReport = new Vector<>();
        Hex h = game.getBoard().getHex(c);
        if (h == null) {
            return vPhaseReport;
        }
        Terrain woods = h.getTerrain(Terrains.WOODS);
        Terrain jungle = h.getTerrain(Terrains.JUNGLE);
        Terrain ice = h.getTerrain(Terrains.ICE);
        Terrain magma = h.getTerrain(Terrains.MAGMA);
        Report r;
        int reportType = Report.HIDDEN;
        if (entityId == Entity.NONE) {
            reportType = Report.PUBLIC;
        }
        if (woods != null) {
            int tf = woods.getTerrainFactor() - nDamage;
            int level = woods.getLevel();
            int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);
            if (tf <= 0) {
                h.removeTerrain(Terrains.WOODS);
                h.removeTerrain(Terrains.FOLIAGE_ELEV);
                h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                // light converted to rough
                r = new Report(3090, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 50) && (level > 1)) {
                h.removeTerrain(Terrains.WOODS);
                h.addTerrain(new Terrain(Terrains.WOODS, 1));
                if (folEl != 1) {
                    h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, 2));
                }
                woods = h.getTerrain(Terrains.WOODS);
                // heavy converted to light
                r = new Report(3085, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 90) && (level > 2)) {
                h.removeTerrain(Terrains.WOODS);
                h.addTerrain(new Terrain(Terrains.WOODS, 2));
                if (folEl != 1) {
                    h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, 2));
                }
                woods = h.getTerrain(Terrains.WOODS);
                // ultra heavy converted to heavy
                r = new Report(3082, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
            woods.setTerrainFactor(tf);
        }
        if (jungle != null) {
            int tf = jungle.getTerrainFactor() - nDamage;
            int level = jungle.getLevel();
            int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);
            if (tf < 0) {
                h.removeTerrain(Terrains.JUNGLE);
                h.removeTerrain(Terrains.FOLIAGE_ELEV);
                h.addTerrain(new Terrain(Terrains.ROUGH, 1));
                // light converted to rough
                r = new Report(3091, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 50) && (level > 1)) {
                h.removeTerrain(Terrains.JUNGLE);
                h.addTerrain(new Terrain(Terrains.JUNGLE, 1));
                if (folEl != 1) {
                    h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, 2));
                }
                jungle = h.getTerrain(Terrains.JUNGLE);
                // heavy converted to light
                r = new Report(3086, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 90) && (level > 2)) {
                h.removeTerrain(Terrains.JUNGLE);
                h.addTerrain(new Terrain(Terrains.JUNGLE, 2));
                if (folEl != 1) {
                    h.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, 2));
                }
                jungle = h.getTerrain(Terrains.JUNGLE);
                // ultra heavy converted to heavy
                r = new Report(3083, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
            jungle.setTerrainFactor(tf);
        }
        if (ice != null) {
            int tf = ice.getTerrainFactor() - nDamage;
            if (tf <= 0) {
                // ice melted
                r = new Report(3092, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
                vPhaseReport.addAll(resolveIceBroken(c));
            } else {
                ice.setTerrainFactor(tf);
            }
        }
        if ((magma != null) && (magma.getLevel() == 1)) {
            int tf = magma.getTerrainFactor() - nDamage;
            if (tf <= 0) {
                // magma crust destroyed
                r = new Report(3093, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
                h.removeTerrain(Terrains.MAGMA);
                h.addTerrain(new Terrain(Terrains.MAGMA, 2));
                for (Entity en : game.getEntitiesVector(c)) {
                    doMagmaDamage(en, false);
                }
            } else {
                magma.setTerrainFactor(tf);
            }
        }
        sendChangedHex(c);

        // any attempt to clear an heavy industrial hex may cause an explosion
        checkExplodeIndustrialZone(c, vPhaseReport);

        return vPhaseReport;
    }

    /**
     * Handle all physical attacks for the round
     */
    private void resolvePhysicalAttacks() {
        // Physical phase header
        addReport(new Report(4000, Report.PUBLIC));

        // add any pending charges
        for (Enumeration<AttackAction> i = game.getCharges(); i.hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetCharges();

        // add any pending rams
        for (Enumeration<AttackAction> i = game.getRams(); i.hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetRams();

        // add any pending Tele Missile Attacks
        for (Enumeration<AttackAction> i = game.getTeleMissileAttacks(); i.hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetTeleMissileAttacks();

        // remove any duplicate attack declarations
        cleanupPhysicalAttacks();

        // loop thru received attack actions
        for (Enumeration<EntityAction> i = game.getActions(); i.hasMoreElements(); ) {
            Object o = i.nextElement();
            // verify that the attacker is still active
            AttackAction aa = (AttackAction) o;
            if (!game.getEntity(aa.getEntityId()).isActive()
                    && !(o instanceof DfaAttackAction)) {
                continue;
            }
            AbstractAttackAction aaa = (AbstractAttackAction) o;
            // do searchlights immediately
            if (aaa instanceof SearchlightAttackAction) {
                SearchlightAttackAction saa = (SearchlightAttackAction) aaa;
                addReport(saa.resolveAction(game));
            } else {
                physicalResults.addElement(preTreatPhysicalAttack(aaa));
            }
        }
        int cen = Entity.NONE;
        for (PhysicalResult pr : physicalResults) {
            resolvePhysicalAttack(pr, cen);
            cen = pr.aaa.getEntityId();
        }
        physicalResults.removeAllElements();
    }

    /**
     * Cleans up the attack declarations for the physical phase by removing all
     * attacks past the first for any one mech. Also clears out attacks by dead
     * or disabled mechs.
     */
    private void cleanupPhysicalAttacks() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            removeDuplicateAttacks(entity.getId());
        }
        removeDeadAttacks();
    }

    /**
     * Removes any actions in the attack queue beyond the first by the specified
     * entity, unless that entity has melee master in which case it allows two
     * attacks.
     */
    private void removeDuplicateAttacks(int entityId) {
        int allowed = 1;
        Entity en = game.getEntity(entityId);
        if (null != en) {
            allowed = en.getAllowedPhysicalAttacks();
        }
        Vector<EntityAction> toKeep = new Vector<>();

        for (Enumeration<EntityAction> i = game.getActions(); i.hasMoreElements(); ) {
            EntityAction action = i.nextElement();
            if (action.getEntityId() != entityId) {
                toKeep.addElement(action);
            } else if (allowed > 0) {
                toKeep.addElement(action);
                if (!(action instanceof SearchlightAttackAction)) {
                    allowed--;
                }
            } else {
                LogManager.getLogger().error("Removing duplicate phys attack for id#" + entityId
                        + "\n\t\taction was " + action);
            }
        }

        // reset actions and re-add valid elements
        game.resetActions();
        for (EntityAction entityAction : toKeep) {
            game.addAction(entityAction);
        }
    }

    /**
     * Removes all attacks by any dead entities. It does this by going through
     * all the attacks and only keeping ones from active entities. DFAs are kept
     * even if the pilot is unconscious, so that he can fail.
     */
    private void removeDeadAttacks() {
        Vector<EntityAction> toKeep = new Vector<>(game.actionsSize());

        for (Enumeration<EntityAction> i = game.getActions(); i.hasMoreElements(); ) {
            EntityAction action = i.nextElement();
            Entity entity = game.getEntity(action.getEntityId());
            if ((entity != null) && !entity.isDestroyed()
                    && (entity.isActive() || (action instanceof DfaAttackAction))) {
                toKeep.addElement(action);
            }
        }

        // reset actions and re-add valid elements
        game.resetActions();
        for (EntityAction entityAction : toKeep) {
            game.addAction(entityAction);
        }
    }

    /**
     * Apply damage to mech for zweihandering (melee attack with both hands) as per pg. 82,
     * Campaign Operations 2nd Printing
     *
     * @param ae the attacking entity
     * @param missed did the attack miss? If so, a PSR is necessary.
     * @param criticalLocations the locations for possible criticals, should be one or both arms
     *                          depending on if it was an unarmed attack (both arms) or a weapon
     *                          attack (the arm with the weapon).
     */
    private void applyZweihanderSelfDamage(Entity ae, boolean missed, int... criticalLocations) {
        Report r = new Report(4022);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(ae);
        addReport(r);
        for (int location : criticalLocations) {
            addReport(criticalEntity(ae, location, false, 0, 1));
        }

        if (missed) {
            game.addPSR(new PilotingRollData(ae.getId(), 0, "Zweihander miss"));
        }
    }

    /**
     * Handle a punch attack
     */
    private void resolvePunchAttack(PhysicalResult pr, int lastEntityId) {
        final PunchAttackAction paa = (PunchAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        final Targetable target = game.getTarget(paa.getTargetType(), paa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        final String armName = (paa.getArm() == PunchAttackAction.LEFT) ? "Left Arm" : "Right Arm";
        final int armLoc = (paa.getArm() == PunchAttackAction.LEFT) ? Mech.LOC_LARM : Mech.LOC_RARM;

        // get damage, ToHitData and roll from the PhysicalResult
        int damage = paa.getArm() == PunchAttackAction.LEFT ? pr.damage : pr.damageRight;
        // LAMs in airmech mode do half damage if airborne.
        if (ae.isAirborneVTOLorWIGE()) {
            damage = (int) Math.ceil(damage * 0.5);
        }
        final ToHitData toHit = paa.getArm() == PunchAttackAction.LEFT ? pr.toHit : pr.toHitRight;
        int roll = paa.getArm() == PunchAttackAction.LEFT ? pr.roll : pr.rollRight;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        Report r;

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != paa.getEntityId()) {
            // report who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4010);
        r.subject = ae.getId();
        r.indent();
        r.add(armName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4015);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            if ((ae instanceof LandAirMech) && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed punch attack"));
            }
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4020);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // nope
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed punch attack"));
            }
            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }
            }

            if (paa.isZweihandering()) {
                applyZweihanderSelfDamage(ae, true, Mech.LOC_RARM, Mech.LOC_LARM);
            }

            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            if (paa.isZweihandering()) {
                applyZweihanderSelfDamage(ae, false,  Mech.LOC_RARM, Mech.LOC_LARM);
            }

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, toBldg, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO : this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.indent();
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            }

            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            damage = checkForSpikes(te, hit.getLocation(), damage, ae,
                    (paa.getArm() == PunchAttackAction.LEFT) ?  Mech.LOC_LARM : Mech.LOC_RARM);
            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                    false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM, VTOL.CRIT_ROTOR_DESTROYED),
                        false, 0, false));
            }
            // check for extending retractable blades
            if (paa.isBladeExtended(paa.getArm())) {
                addNewLines();
                r = new Report(4455);
                r.indent(2);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
                // conventional infantry don't take crits and battle armor need
                // to be handled differently
                if (!(target instanceof Infantry)) {
                    addNewLines();
                    addReport(criticalEntity(te, hit.getLocation(), hit.isRear(), 0,
                            true, false, damage));
                }

                if ((target instanceof BattleArmor) && (hit.getLocation() < te.locations())
                        && (te.getInternal(hit.getLocation()) > 0)) {
                    // TODO : we should really apply BA criticals through the critical
                    // TODO : hits methods. Right now they are applied in damageEntity
                    HitData baHit = new HitData(hit.getLocation(), false, HitData.EFFECT_CRITICAL);
                    addReport(damageEntity(te, baHit, 0));
                }
                // extend the blade
                // since retracting/extending is a freebie in the movement
                // phase, lets assume that the
                // blade retracts to its original mode
                // ae.extendBlade(paa.getArm());
                // check for breaking a nail
                if (Compute.d6(2) > 9) {
                    addNewLines();
                    r = new Report(4456);
                    r.indent(2);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);
                    ae.destroyRetractableBlade(armLoc);
                }
            }
        }

        addNewLines();

        if (paa.isZweihandering()) {
            applyZweihanderSelfDamage(ae, false,  Mech.LOC_RARM, Mech.LOC_LARM);
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a kick attack
     */
    private void resolveKickAttack(PhysicalResult pr, int lastEntityId) {
        KickAttackAction kaa = (KickAttackAction) pr.aaa;
        final Entity ae = game.getEntity(kaa.getEntityId());
        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        String legName = (kaa.getLeg() == KickAttackAction.LEFT)
                || (kaa.getLeg() == KickAttackAction.LEFTMULE) ? "Left " : "Right ";
        if ((kaa.getLeg() == KickAttackAction.LEFTMULE)
                || (kaa.getLeg() == KickAttackAction.RIGHTMULE)) {
            legName = legName.concat("rear ");
        } else if (ae instanceof QuadMech) {
            legName = legName.concat("front ");
        }
        legName = legName.concat("leg");
        Report r;

        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        // LAMs in airmech mode do half damage if airborne.
        if (ae.isAirborneVTOLorWIGE()) {
            damage = (int) Math.ceil(damage * 0.5);
        }
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4055);
        r.subject = ae.getId();
        r.indent();
        r.add(legName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4060);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            if ((ae instanceof LandAirMech) && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a kick"));
            } else {
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));
            }
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4065);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a kick"));
            } else {
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));
            }

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }
            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO : this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            }

            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            int leg;
            switch (kaa.getLeg()) {
                case KickAttackAction.LEFT:
                    leg = (ae instanceof QuadMech) ? Mech.LOC_LARM : Mech.LOC_LLEG;
                    break;
                case KickAttackAction.RIGHT:
                    leg = (ae instanceof QuadMech) ? Mech.LOC_RARM : Mech.LOC_RLEG;
                    break;
                case KickAttackAction.LEFTMULE:
                    leg = Mech.LOC_LLEG;
                    break;
                case KickAttackAction.RIGHTMULE:
                default:
                    leg = Mech.LOC_RLEG;
                    break;
            }
            damage = checkForSpikes(te, hit.getLocation(), damage, ae, leg);
            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                    false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM, VTOL.CRIT_ROTOR_DESTROYED),
                        false, 0, false));
            }

            if (te.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {
                addNewLines();
                addReport(criticalEntity(te, hit.getLocation(), hit.isRear(), 0, 0));
            }
        }

        if (te.canFall()) {
            PilotingRollData kickPRD = getKickPushPSR(te, ae, te, "was kicked");
            game.addPSR(kickPRD);
        }

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }

        addNewLines();
    }

    /**
     * Handle a kick attack
     */
    private void resolveJumpJetAttack(PhysicalResult pr, int lastEntityId) {
        JumpJetAttackAction kaa = (JumpJetAttackAction) pr.aaa;
        final Entity ae = game.getEntity(kaa.getEntityId());
        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        String legName;
        switch (kaa.getLeg()) {
            case JumpJetAttackAction.LEFT:
                legName = "Left leg";
                break;
            case JumpJetAttackAction.RIGHT:
                legName = "Right leg";
                break;
            default:
                legName = "Both legs";
                break;
        }

        Report r;

        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4290);
        r.subject = ae.getId();
        r.indent();
        r.add(legName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {
                damage += pr.damageRight;
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }
            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            damage += pr.damageRight;
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        r = new Report(4040);
        r.subject = ae.getId();
        r.newlines = 0;
        addReport(r);

        for (int leg = 0; leg < 2; leg++) {
            if (leg == 1) {
                damage = pr.damageRight;
                if (damage == 0) {
                    break;
                }
            }
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_ENERGY);

            // The building shields all units from a certain amount of damage.
            // The amount is based upon the building's CF at the phase's start.
            if (targetInBuilding && (bldg != null)) {
                int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
                int toBldg = Math.min(bldgAbsorbs, damage);
                damage -= toBldg;
                addNewLines();
                Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                for (Report report : buildingReport) {
                    report.subject = ae.getId();
                }
                addReport(buildingReport);

                // some buildings scale remaining damage that is not absorbed
                // TODO : this isn't quite right for castles brian
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
            }

            // A building may absorb the entire shot.
            if (damage == 0) {
                r = new Report(4050);
                r.subject = ae.getId();
                r.add(te.getShortName());
                r.add(te.getOwner().getName());
                r.newlines = 0;
                addReport(r);
            } else {
                if (glancing) {
                    // Round up glancing blows against conventional infantry
                    damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
                }
                if (directBlow) {
                    damage += toHit.getMoS() / 3;
                    hit.makeDirectBlow(toHit.getMoS() / 3);
                }
                addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                        false, false, throughFront));
            }
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a ProtoMech physical attack
     */
    private void resolveProtoAttack(PhysicalResult pr, int lastEntityId) {
        final ProtomechPhysicalAttackAction ppaa = (ProtomechPhysicalAttackAction) pr.aaa;
        final Entity ae = game.getEntity(ppaa.getEntityId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final Targetable target = game.getTarget(ppaa.getTargetType(), ppaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());
        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4070);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }
            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);

        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO : this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            }

            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }
            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                    false, false, throughFront));
            if (((Protomech) ae).isEDPCharged()) {
                r = new Report(3701);
                int taserRoll = Compute.d6(2) - 2;
                r.add(taserRoll);
                r.newlines = 0;
                vPhaseReport.add(r);

                if (te instanceof BattleArmor) {
                    r = new Report(3706);
                    r.addDesc(te);
                    // shut down for rest of scenario, so we actually kill it
                    // TODO : fix for salvage purposes
                    HitData targetTrooper = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    r.add(te.getLocationAbbr(targetTrooper));
                    vPhaseReport.add(r);
                    vPhaseReport.addAll(criticalEntity(ae, targetTrooper.getLocation(),
                            targetTrooper.isRear(), 0, false, false, 0));
                } else if (te instanceof Mech) {
                    if (((Mech) te).isIndustrial()) {
                        if (taserRoll >= 8) {
                            r = new Report(3705);
                            r.addDesc(te);
                            r.add(4);
                            te.taserShutdown(4, false);
                        } else {
                            // suffer +2 to piloting and gunnery for 4 rounds
                            r = new Report(3710);
                            r.addDesc(te);
                            r.add(2);
                            r.add(4);
                            te.setTaserInterference(2, 4, true);
                        }
                    } else {
                        if (taserRoll >= 11) {
                            r = new Report(3705);
                            r.addDesc(te);
                            r.add(3);
                            vPhaseReport.add(r);
                            te.taserShutdown(3, false);
                        } else {
                            r = new Report(3710);
                            r.addDesc(te);
                            r.add(2);
                            r.add(3);
                            vPhaseReport.add(r);
                            te.setTaserInterference(2, 3, true);
                        }
                    }
                } else if ((te instanceof Protomech) || (te instanceof Tank)
                        || (te instanceof Aero)) {
                    if (taserRoll >= 8) {
                        r = new Report(3705);
                        r.addDesc(te);
                        r.add(4);
                        vPhaseReport.add(r);
                        te.taserShutdown(4, false);
                    } else {
                        r = new Report(3710);
                        r.addDesc(te);
                        r.add(2);
                        r.add(4);
                        vPhaseReport.add(r);
                        te.setTaserInterference(2, 4, false);
                    }
                }

            }
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a brush off attack
     */
    private void resolveBrushOffAttack(PhysicalResult pr, int lastEntityId) {
        final BrushOffAttackAction baa = (BrushOffAttackAction) pr.aaa;
        final Entity ae = game.getEntity(baa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target
        // of a "brush off", but iNarc pods **are**.
        Targetable target = game.getTarget(baa.getTargetType(), baa.getTargetId());
        Entity te = null;
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT ? "Left Arm" : "Right Arm";
        Report r;

        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = game.getEntity(baa.getTargetId());
        }

        // get damage, ToHitData and roll from the PhysicalResult
        // ASSUMPTION: buildings can't absorb *this* damage.
        int damage = baa.getArm() == BrushOffAttackAction.LEFT ? pr.damage : pr.damageRight;
        final ToHitData toHit = baa.getArm() == BrushOffAttackAction.LEFT ? pr.toHit : pr.toHitRight;
        int roll = baa.getArm() == BrushOffAttackAction.LEFT ? pr.roll : pr.rollRight;

        if (lastEntityId != baa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4085);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.add(armName);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4090);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit);
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // Missed Brush Off attacks cause punch damage to the attacker.
            toHit.setHitTable(ToHitData.HIT_PUNCH);
            toHit.setSideTable(ToHitData.SIDE_FRONT);
            HitData hit = ae.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4095);
            r.subject = ae.getId();
            r.addDesc(ae);
            r.add(ae.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(ae, hit, damage));
            addNewLines();
            // if this is an industrial mech, it needs to check for crits
            // at the end of turn
            if ((ae instanceof Mech) && ((Mech) ae).isIndustrial()) {
                ((Mech) ae).setCheckForCrit(true);
            }
            return;
        }

        // Different target types get different handling.
        switch (target.getTargetType()) {
            case Targetable.TYPE_ENTITY:
                // Handle Entity targets.
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                r = new Report(4045);
                r.subject = ae.getId();
                r.add(toHit.getTableDesc());
                r.add(te.getLocationAbbr(hit));
                addReport(r);
                addReport(damageEntity(te, hit, damage));
                addNewLines();

                // Dislodge the swarming infantry.
                ae.setSwarmAttackerId(Entity.NONE);
                te.setSwarmTargetId(Entity.NONE);
                r = new Report(4100);
                r.subject = ae.getId();
                r.add(te.getDisplayName());
                addReport(r);
                break;
            case Targetable.TYPE_INARC_POD:
                // Handle iNarc pod targets.
                // TODO : check the return code and handle false appropriately.
                ae.removeINarcPod((INarcPod) target);
                // // TODO : confirm that we don't need to update the attacker.
                // //killme
                // entityUpdate( ae.getId() ); // killme
                r = new Report(4105);
                r.subject = ae.getId();
                r.add(target.getDisplayName());
                addReport(r);
                break;
            // TODO : add a default: case and handle it appropriately.
        }
    }

    /**
     * Handle a thrash attack
     */
    private void resolveThrashAttack(PhysicalResult pr, int lastEntityId) {
        final ThrashAttackAction taa = (ThrashAttackAction) pr.aaa;
        final Entity ae = game.getEntity(taa.getEntityId());

        // get damage, ToHitData and roll from the PhysicalResult
        int hits = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        // PLEASE NOTE: buildings are *never* the target of a "thrash".
        final Entity te = game.getEntity(taa.getTargetId());
        Report r;

        if (lastEntityId != taa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4110);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4115);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // Thrash attack may hit automatically
        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4120);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                return;
            }
            r = new Report(4125);
        }
        r.subject = ae.getId();
        r.newlines = 0;
        addReport(r);

        // Standard damage loop in 5 point clusters.
        if (glancing) {
            hits = (int) Math.floor(hits / 2.0);
        }

        if (directBlow) {
            hits += toHit.getMoS() / 3;
        }

        r = new Report(4130);
        r.subject = ae.getId();
        r.add(hits);
        r.newlines = 0;
        addReport(r);
        if (glancing) {
            r = new Report(3186);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        if (directBlow) {
            r = new Report(3189);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        while (hits > 0) {
            int damage = Math.min(5, hits);
            hits -= damage;
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4135);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(te, hit, damage));
        }

        addNewLines();

        // Thrash attacks cause PSRs. Failed PSRs cause falling damage.
        // This fall damage applies even though the Thrashing Mek is prone.
        PilotingRollData rollData = ae.getBasePilotingRoll();
        ae.addPilotingModifierForTerrain(rollData);
        rollData.addModifier(0, "thrashing at infantry");
        r = new Report(4140);
        r.subject = ae.getId();
        r.addDesc(ae);
        addReport(r);
        final int diceRoll = Compute.d6(2);
        r = new Report(2190);
        r.subject = ae.getId();
        r.add(rollData.getValueAsString());
        r.add(rollData.getDesc());
        r.add(diceRoll);
        if (diceRoll < rollData.getValue()) {
            r.choose(false);
            addReport(r);
            addReport(doEntityFall(ae, rollData));
        } else {
            r.choose(true);
            addReport(r);
        }
    }

    /**
     * Handle a thrash attack
     */
    private void resolveBAVibroClawAttack(PhysicalResult pr, int lastEntityId) {
        final BAVibroClawAttackAction bvaa = (BAVibroClawAttackAction) pr.aaa;
        final Entity ae = game.getEntity(bvaa.getEntityId());

        // get damage, ToHitData and roll from the PhysicalResult
        int hits = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        // PLEASE NOTE: buildings are *never* the target of a BA vibroclaw attack.
        final Entity te = game.getEntity(bvaa.getTargetId());
        Report r;

        if (lastEntityId != bvaa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4146);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4147);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // we may hit automatically
        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4120);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                return;
            }
        }

        // Standard damage loop
        if (glancing) {
            hits = (int) Math.floor(hits / 2.0);
        }

        if (directBlow) {
            hits += toHit.getMoS() / 3;
        }

        if (te.isConventionalInfantry()) {
            r = new Report(4149);
            r.subject = ae.getId();
            r.add(hits);
        } else {
            r = new Report(4148);
            r.subject = ae.getId();
            r.add(hits);
            r.add(ae.getVibroClaws());
        }
        r.newlines = 0;
        addReport(r);
        if (glancing) {
            r = new Report(3186);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        if (directBlow) {
            r = new Report(3189);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        while (hits > 0) {
            // BA get hit separately by each attacking BA trooper
            int damage = Math.min(ae.getVibroClaws(), hits);
            // conventional infantry get hit in one lump
            if (te.isConventionalInfantry()) {
                damage = hits;
            }
            hits -= damage;
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4135);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(te, hit, damage));
        }
        addNewLines();
    }

    /**
     * Handle a club attack
     */
    private void resolveClubAttack(PhysicalResult pr, int lastEntityId) {
        final ClubAttackAction caa = (ClubAttackAction) pr.aaa;
        final Entity ae = game.getEntity(caa.getEntityId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        // LAMs in airmech mode do half damage if airborne.
        if (ae.isAirborneVTOLorWIGE()) {
            damage = (int) Math.ceil(damage * 0.5);
        }
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        // Make sure the MoS is zero for *automatic* hits in case direct blows
        // are in force.
        toHit.setMoS((roll == Integer.MAX_VALUE) ? 0 : roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        // restore club attack
        caa.getClub().restore();

        // Shield bash causes 1 point of damage to the shield
        if (((MiscType) caa.getClub().getType()).isShield()) {
            ((Mech) ae).shieldAbsorptionDamage(1, caa.getClub().getLocation(), false);
        }

        if (lastEntityId != caa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4145);
        r.subject = ae.getId();
        r.indent();
        r.add(caa.getClub().getName());
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // Flail/Wrecking Ball auto misses on a 2 and hits themself.
        if ((caa.getClub().getType().hasSubType(MiscType.S_FLAIL)
                || caa.getClub().getType().hasSubType(MiscType.S_WRECKING_BALL)) && (roll == 2)) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            ToHitData newToHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, "hit with own flail/wrecking ball");
            pr.damage = ClubAttackAction.getDamageFor(ae, caa.getClub(), false, caa.isZweihandering());
            pr.damage = (pr.damage / 2) + (pr.damage % 2);
            newToHit.setHitTable(ToHitData.HIT_NORMAL);
            newToHit.setSideTable(ToHitData.SIDE_FRONT);
            pr.toHit = newToHit;
            pr.aaa.setTargetId(ae.getId());
            pr.aaa.setTargetType(Targetable.TYPE_ENTITY);
            pr.roll = Integer.MAX_VALUE;
            resolveClubAttack(pr, ae.getId());
            if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a flail/wrecking ball attack"));
            } else {
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a flail/wrecking ball attack"));
            }

            if (caa.isZweihandering()) {
                applyZweihanderSelfDamage(ae, true, caa.getClub().getLocation());
            }
            return;
        }

        // Need to compute 2d6 damage. and add +3 heat build up.
        if (caa.getClub().getType().hasSubType(MiscType.S_BUZZSAW)) {
            damage = Compute.d6(2);
            ae.heatBuildup += 3;

            // Buzzsaw's blade will shatter on a roll of 2.
            if (roll == 2) {
                Mounted club = caa.getClub();

                for (Mounted eq : ae.getWeaponList()) {
                    if ((eq.getLocation() == club.getLocation())
                            && (eq.getType() instanceof MiscType)
                            && eq.getType().hasFlag(MiscType.F_CLUB)
                            && eq.getType().hasSubType(MiscType.S_BUZZSAW)) {
                        eq.setHit(true);
                        break;
                    }
                }
                r = new Report(4037);
                r.subject = ae.getId();
                addReport(r);
                if (caa.isZweihandering()) {
                    applyZweihanderSelfDamage(ae, true, caa.getClub().getLocation());
                }
                return;
            }
        }

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            if (caa.getClub().getType().hasSubType(MiscType.S_MACE)) {
                if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                    game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));
                } else {
                    game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));
                }
            }

            if (caa.isZweihandering()) {
                if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {
                    applyZweihanderSelfDamage(ae, true, Mech.LOC_RARM, Mech.LOC_LARM);
                } else {
                    applyZweihanderSelfDamage(ae, true, caa.getClub().getLocation());
                }
            }
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            if (caa.getClub().getType().hasSubType(MiscType.S_MACE)) {
                if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                    game.addControlRoll(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));
                } else {
                    game.addPSR(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));
                }
            }

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }
            }

            if (caa.isZweihandering()) {
                if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {
                    applyZweihanderSelfDamage(ae, true, Mech.LOC_RARM, Mech.LOC_LARM);
                } else {
                    applyZweihanderSelfDamage(ae, true, caa.getClub().getLocation());
                }
            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            if (caa.isZweihandering()) {
                if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {
                    applyZweihanderSelfDamage(ae, false, Mech.LOC_RARM, Mech.LOC_LARM);

                    // the club breaks
                    r = new Report(4150);
                    r.subject = ae.getId();
                    r.add(caa.getClub().getName());
                    addReport(r);
                    ae.removeMisc(caa.getClub().getName());
                } else {
                    applyZweihanderSelfDamage(ae, false, caa.getClub().getLocation());
                }
            }

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO : this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            }

            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            damage = checkForSpikes(te, hit.getLocation(), damage, ae, Entity.LOC_NONE);

            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                    false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM, VTOL.CRIT_ROTOR_DESTROYED),
                        false, 0, false));
            }
        }

        // On a roll of 10+ a lance hitting a mech/Vehicle can cause 1 point of
        // internal damage
        if (caa.getClub().getType().hasSubType(MiscType.S_LANCE)
                && (te.getArmor(hit) > 0)
                && (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_HARDENED)
                && (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_FERRO_LAMELLOR)) {
            roll = Compute.d6(2);
            // Pierce checking report
            r = new Report(4021);
            r.indent(2);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.add(roll);
            addReport(r);
            if (roll >= 10) {
                hit.makeGlancingBlow();
                addReport(damageEntity(te, hit, 1, false, DamageType.NONE,
                        true, false, throughFront));
            }
        }

        // TODO : Verify this is correct according to latest rules
        if (caa.getClub().getType().hasSubType(MiscType.S_WRECKING_BALL)
                && (ae instanceof SupportTank) && (te instanceof Mech)) {
            // forces a PSR like a charge
            if (te instanceof LandAirMech && te.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(te.getId(), 2, "was hit by wrecking ball"));
            } else {
                game.addPSR(new PilotingRollData(te.getId(), 2, "was hit by wrecking ball"));
            }
        }

        // Chain whips can entangle 'Mech and ProtoMech limbs. This
        // implementation assumes that in order to do so the limb must still
        // have some structure left, so if the whip hits and destroys a
        // location in the same attack no special effects take place.
        if (caa.getClub().getType().hasSubType(MiscType.S_CHAIN_WHIP)
                && ((te instanceof Mech) || (te instanceof Protomech))) {
            addNewLines();

            int loc = hit.getLocation();

            boolean mightTrip = (te instanceof Mech)
                    && te.locationIsLeg(loc)
                    && !te.isLocationBad(loc)
                    && !te.isLocationDoomed(loc)
                    && !te.hasActiveShield(loc)
                    && !te.hasPassiveShield(loc);

            boolean mightGrapple = ((te instanceof Mech)
                    && ((loc == Mech.LOC_LARM) || (loc == Mech.LOC_RARM))
                    && !te.isLocationBad(loc)
                    && !te.isLocationDoomed(loc)
                    && !te.hasActiveShield(loc)
                    && !te.hasPassiveShield(loc)
                    && !te.hasNoDefenseShield(loc))
                    || ((te instanceof Protomech)
                    && ((loc == Protomech.LOC_LARM) || (loc == Protomech.LOC_RARM)
                    || (loc == Protomech.LOC_LEG))
                    // Only check location status after confirming we did
                    // hit a limb -- Protos have no actual near-miss
                    // "location" and will throw an exception if it's
                    // referenced here.
                    && !te.isLocationBad(loc)
                    && !te.isLocationDoomed(loc));

            if (mightTrip) {
                roll = Compute.d6(2);
                int toHitValue = toHit.getValue();
                String toHitDesc = toHit.getDesc();
                if ((ae instanceof Mech) && ((Mech) ae).hasActiveTSM(false)) {
                    toHitValue -= 2;
                    toHitDesc += " -2 (TSM Active Bonus)";
                }

                r = new Report(4450);
                r.subject = ae.getId();
                r.add(ae.getShortName());
                r.add(te.getShortName());
                r.addDataWithTooltip(String.valueOf(toHitValue), toHitDesc);
                r.add(roll);
                r.indent(2);
                r.newlines = 0;
                addReport(r);

                if (roll >= toHitValue) {
                    r = new Report(2270);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);

                    game.addPSR(new PilotingRollData(te.getId(), 3, "Snared by chain whip"));
                } else {
                    r = new Report(2357);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);
                }
            } else if (mightGrapple) {
                GrappleAttackAction gaa = new GrappleAttackAction(ae.getId(), te.getId());
                int grappleSide;
                if (caa.getClub().getLocation() == Mech.LOC_RARM) {
                    grappleSide = Entity.GRAPPLE_RIGHT;
                } else {
                    grappleSide = Entity.GRAPPLE_LEFT;
                }
                ToHitData grappleHit = GrappleAttackAction.toHit(game, ae.getId(), target,
                        grappleSide, true);
                PhysicalResult grappleResult = new PhysicalResult();
                grappleResult.aaa = gaa;
                grappleResult.toHit = grappleHit;
                grappleResult.roll = Compute.d6(2);
                resolveGrappleAttack(grappleResult, lastEntityId, grappleSide,
                        (hit.getLocation() == Mech.LOC_RARM) ? Entity.GRAPPLE_RIGHT : Entity.GRAPPLE_LEFT);
            }
        }

        addNewLines();

        if (caa.isZweihandering()) {
            if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {
                applyZweihanderSelfDamage(ae, false, Mech.LOC_RARM, Mech.LOC_LARM);
            } else {
                applyZweihanderSelfDamage(ae, false, caa.getClub().getLocation());
            }
        }

        // If the attacker is Zweihandering with an improvised club, it will break on the attack.
        // Otherwise, only a tree club will break on the attack
        if ((caa.isZweihandering() && caa.getClub().getType().hasSubType(MiscType.S_CLUB))
                || caa.getClub().getType().hasSubType(MiscType.S_TREE_CLUB)) {
            // the club breaks
            r = new Report(4150);
            r.subject = ae.getId();
            r.add(caa.getClub().getName());
            addReport(r);
            ae.removeMisc(caa.getClub().getName());
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a push attack
     */
    private void resolvePushAttack(PhysicalResult pr, int lastEntityId) {
        final PushAttackAction paa = (PushAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        // was this push resolved earlier?
        if (pr.pushBackResolved) {
            return;
        }
        // don't try this one again
        pr.pushBackResolved = true;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4155);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4160);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit);
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // check if our target has a push against us, too, and get it
        PhysicalResult targetPushResult = null;
        for (PhysicalResult tpr : physicalResults) {
            if ((tpr.aaa.getEntityId() == te.getId()) && (tpr.aaa instanceof PushAttackAction)
                    && (tpr.aaa.getTargetId() == ae.getId())) {
                targetPushResult = tpr;
            }
        }

        // if our target has a push against us, and we are hitting, we need to resolve both now
        if ((targetPushResult != null) && !targetPushResult.pushBackResolved
                && (roll >= toHit.getValue())) {
            targetPushResult.pushBackResolved = true;
            // do they hit?
            if (targetPushResult.roll >= targetPushResult.toHit.getValue()) {
                r = new Report(4165);
                r.subject = ae.getId();
                r.addDesc(te);
                r.addDesc(te);
                r.addDesc(ae);
                r.add(targetPushResult.toHit);
                r.add(targetPushResult.roll);
                r.addDesc(ae);
                addReport(r);
                if (ae.canFall()) {
                    PilotingRollData pushPRD = getKickPushPSR(ae, ae, te, "was pushed");
                    game.addPSR(pushPRD);
                } else if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                    game.addControlRoll(getKickPushPSR(ae, ae, te, "was pushed"));
                }

                if (te.canFall()) {
                    PilotingRollData targetPushPRD = getKickPushPSR(te, ae, te, "was pushed");
                    game.addPSR(targetPushPRD);
                } else if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                    game.addControlRoll(getKickPushPSR(te, ae, te, "was pushed"));
                }
                return;
            }
            // report the miss
            r = new Report(4166);
            r.subject = ae.getId();
            r.addDesc(te);
            r.addDesc(ae);
            r.add(targetPushResult.toHit);
            r.add(targetPushResult.roll);
            addReport(r);
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        int direction = ae.getFacing();

        Coords src = te.getPosition();
        Coords dest = src.translated(direction);

        PilotingRollData pushPRD = getKickPushPSR(te, ae, te, "was pushed");

        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {
            r = new Report(4170);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
            if (game.getBoard().contains(dest)) {
                r = new Report(4175);
                r.subject = ae.getId();
                r.add(dest.getBoardNum(), true);
            } else {
                // uh-oh, pushed off board
                r = new Report(4180);
                r.subject = ae.getId();
            }
            addReport(r);

            addReport(doEntityDisplacement(te, src, dest, pushPRD));

            // if push actually moved the target, attacker follows through
            if (!te.getPosition().equals(src)) {
                ae.setPosition(src);
            }
        } else {
            // target immovable
            r = new Report(4185);
            r.subject = ae.getId();
            addReport(r);
            if (te.canFall()) {
                game.addPSR(pushPRD);
            }
        }

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }

        checkForSpikes(te, ae.rollHitLocation(ToHitData.HIT_PUNCH, Compute.targetSideTable(ae, te)).getLocation(),
                0, ae, Mech.LOC_LARM, Mech.LOC_RARM);

        addNewLines();
    }

    /**
     * Handle a trip attack
     */
    private void resolveTripAttack(PhysicalResult pr, int lastEntityId) {
        final TripAttackAction paa = (TripAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "trip".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4280);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4285);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit);
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        if (te.canFall()) {
            PilotingRollData pushPRD = getKickPushPSR(te, ae, te, "was tripped");
            game.addPSR(pushPRD);
        }

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);
        addNewLines();
        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }
    }

    /**
     * Handle a grapple attack
     */
    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId) {
        resolveGrappleAttack(pr, lastEntityId, Entity.GRAPPLE_BOTH, Entity.GRAPPLE_BOTH);
    }

    /**
     * Resolves a grapple attack.
     *
     * @param pr            the result of a physical attack - this one specifically being a grapple
     * @param lastEntityId  the entity making the attack
     * @param aeGrappleSide
     *            The side that the attacker is grappling with. For normal
     *            grapples this will be both, for chain whip grapples this will
     *            be the arm with the chain whip in it.
     * @param teGrappleSide
     *            The that the target is grappling with. For normal grapples
     *            this will be both, for chain whip grapples this will be the
     *            arm that is being whipped.
     */
    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId, int aeGrappleSide,
                                      int teGrappleSide) {
        final GrappleAttackAction paa = (GrappleAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        // same method as push, for counterattacks
        if (pr.pushBackResolved) {
            return;
        }

        if ((te.getGrappled() != Entity.NONE) || (ae.getGrappled() != Entity.NONE)) {
            toHit.addModifier(TargetRoll.IMPOSSIBLE, "Already Grappled");
        }

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4295);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4300);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit);
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        ae.setGrappled(te.getId(), true);
        te.setGrappled(ae.getId(), false);
        ae.setGrappledThisRound(true);
        te.setGrappledThisRound(true);
        // For normal grapples, AE moves into targets hex.
        if (aeGrappleSide == Entity.GRAPPLE_BOTH) {
            Coords pos = te.getPosition();
            ae.setPosition(pos);
            ae.setElevation(te.getElevation());
            te.setFacing((ae.getFacing() + 3) % 6);
            addReport(doSetLocationsExposure(ae, game.getBoard().getHex(pos), false, ae.getElevation()));
        }

        ae.setGrappleSide(aeGrappleSide);
        te.setGrappleSide(teGrappleSide);

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);
        addNewLines();

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }
    }

    /**
     * Handle a break grapple attack
     */
    private void resolveBreakGrappleAttack(PhysicalResult pr, int lastEntityId) {
        final BreakGrappleAttackAction paa = (BreakGrappleAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4305);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4310);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a physical attack"));
            }
            return;
        }

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4320);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                if (ae instanceof LandAirMech && ae.isAirborneVTOLorWIGE()) {
                    game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed a physical attack"));
                }
                return;
            }

            // hit
            r = new Report(4040);
            r.subject = ae.getId();
        }
        addReport(r);

        // is there a counterattack?
        PhysicalResult targetGrappleResult = null;
        for (PhysicalResult tpr : physicalResults) {
            if ((tpr.aaa.getEntityId() == te.getId())
                    && (tpr.aaa instanceof GrappleAttackAction)
                    && (tpr.aaa.getTargetId() == ae.getId())) {
                targetGrappleResult = tpr;
                break;
            }
        }

        if (targetGrappleResult != null) {
            targetGrappleResult.pushBackResolved = true;
            // counterattack
            r = new Report(4315);
            r.subject = te.getId();
            r.newlines = 0;
            r.addDesc(te);
            addReport(r);

            // report the roll
            r = new Report(4025);
            r.subject = te.getId();
            r.add(targetGrappleResult.toHit);
            r.add(targetGrappleResult.roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
            } else {
                // hit
                r = new Report(4040);
                r.subject = ae.getId();
                addReport(r);

                // exchange attacker and defender
                ae.setGrappled(te.getId(), false);
                te.setGrappled(ae.getId(), true);

                return;
            }
        }

        // score the adjacent hexes
        Coords[] hexes = new Coords[6];
        int[] scores = new int[6];

        Hex curHex = game.getBoard().getHex(ae.getPosition());
        for (int i = 0; i < 6; i++) {
            hexes[i] = ae.getPosition().translated(i);
            scores[i] = 0;
            Hex hex = game.getBoard().getHex(hexes[i]);
            if (hex.containsTerrain(Terrains.MAGMA)) {
                scores[i] += 10;
            }

            if (hex.containsTerrain(Terrains.WATER)) {
                scores[i] += hex.terrainLevel(Terrains.WATER);
            }

            if ((curHex.getLevel() - hex.getLevel()) >= 2) {
                scores[i] += 2 * (curHex.getLevel() - hex.getLevel());
            }
        }

        int bestScore = 99999;
        int best = 0;
        int worstScore = -99999;
        int worst = 0;

        for (int i = 0; i < 6; i++) {
            if (bestScore > scores[i]) {
                best = i;
                bestScore = scores[i];
            }
            if (worstScore < scores[i]) {
                worst = i;
                worstScore = scores[i];
            }
        }

        // attacker doesn't fall, unless off a cliff
        if (ae.isGrappleAttacker()) {
            // move self to least dangerous hex
            PilotingRollData psr = ae.getBasePilotingRoll();
            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, "break grapple");
            addReport(doEntityDisplacement(ae, ae.getPosition(), hexes[best], psr));
            ae.setFacing(hexes[best].direction(te.getPosition()));
        } else {
            // move enemy to most dangerous hex
            PilotingRollData psr = te.getBasePilotingRoll();
            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, "break grapple");
            addReport(doEntityDisplacement(te, te.getPosition(), hexes[worst], psr));
            te.setFacing(hexes[worst].direction(ae.getPosition()));
        }

        // grapple is broken
        ae.setGrappled(Entity.NONE, false);
        te.setGrappled(Entity.NONE, false);

        addNewLines();
    }

    /**
     * Handle a charge attack
     */
    private void resolveChargeAttack(PhysicalResult pr, int lastEntityId) {
        final ChargeAttackAction caa = (ChargeAttackAction) pr.aaa;
        final Entity ae = game.getEntity(caa.getEntityId());
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;

        Entity te = null;
        if ((target != null) && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(caa.getTargetPos());

        // is the attacker dead? because that sure messes up the calculations
        if (ae == null) {
            return;
        }

        final int direction = ae.getFacing();

        // entity isn't charging any more
        ae.setDisplacementAttack(null);

        if (lastEntityId != caa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)
                && (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {
            r = new Report(4190);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            // doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(),
            // null);
            // Randall said that if a charge fails because of target
            // destruction,
            // the attacker stays in the hex he was in at the end of the
            // movement phase
            // See Bug 912094
            return;
        }

        // attacker fell down?
        if (ae.isProne()) {
            r = new Report(4195);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // attacker immobile?
        if (ae.isImmobile()) {
            r = new Report(4200);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // target fell down, only for attacking Mechs, though
        if ((te != null) && (te.isProne()) && (ae instanceof Mech)) {
            r = new Report(4205);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(4210);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // target still in the same position?
        if (!target.getPosition().equals(caa.getTargetPos())) {
            r = new Report(4215);
            r.subject = ae.getId();
            addReport(r);
            addReport(doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null));
            return;
        }

        // if the attacker's prone, fudge the roll
        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            roll = -12;
            r = new Report(4220);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4225);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            Coords src = ae.getPosition();
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);

            // TODO : handle movement into/out of/through a building. Do it here?

            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            // move attacker to side hex
            addReport(doEntityDisplacement(ae, src, dest, null));
        } else if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) { // Targeting
            // a building.
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // Apply damage to the attacker.
            int toAttacker = ChargeAttackAction.getDamageTakenBy(ae, bldg, target.getPosition());
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, ae.sideTable(target.getPosition()));
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(ae, hit, toAttacker, false, DamageType.NONE,
                    false, false, throughFront));
            addNewLines();
            entityUpdate(ae.getId());

            // TODO : Does the attacker enter the building?
            // TODO : What if the building collapses?
        } else {
            // Resolve the damage.
            resolveChargeDamage(ae, te, toHit, direction, glancing, throughFront, false);
        }
    }

    /**
     * Handle an Airmech ram attack
     */
    private void resolveAirmechRamAttack(PhysicalResult pr, int lastEntityId) {
        final AirmechRamAttackAction caa = (AirmechRamAttackAction) pr.aaa;
        final Entity ae = game.getEntity(caa.getEntityId());
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;

        Entity te = null;
        if ((target != null) && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean glancing = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
                && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(caa.getTargetPos());

        // is the attacker dead? because that sure messes up the calculations
        if (ae == null) {
            return;
        }

        final int direction = ae.getFacing();

        // entity isn't charging any more
        ae.setDisplacementAttack(null);

        if (lastEntityId != caa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)
                && (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {
            r = new Report(4192);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            game.addControlRoll(new PilotingRollData(
                    ae.getId(), 0, "missed a ramming attack"));
            return;
        }

        // attacker landed?
        if (!ae.isAirborneVTOLorWIGE()) {
            r = new Report(4197);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // attacker immobile?
        if (ae.isImmobile()) {
            r = new Report(4202);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(4212);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // if the attacker's prone, fudge the roll
        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            roll = -12;
            r = new Report(4222);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4227);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            // attacker must make a control roll
            game.addControlRoll(new PilotingRollData(ae.getId(), 0, "missed ramming attack"));
        } else if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) { // Targeting a building.
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // Apply damage to the attacker.
            int toAttacker = AirmechRamAttackAction.getDamageTakenBy(ae, target, ae.delta_distance);
            HitData hit = new HitData(Mech.LOC_CT);
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(ae, hit, toAttacker, false, DamageType.NONE,
                    false, false, throughFront));
            addNewLines();
            entityUpdate(ae.getId());

            // TODO : Does the attacker enter the building?
            // TODO : What if the building collapses?
        } else {
            // Resolve the damage.
            resolveChargeDamage(ae, te, toHit, direction, glancing, throughFront, true);
        }
    }

    /**
     * Handle a telemissile attack
     */
    private void resolveTeleMissileAttack(PhysicalResult pr, int lastEntityId) {
        final TeleMissileAttackAction taa = (TeleMissileAttackAction) pr.aaa;
        final Entity ae = game.getEntity(taa.getEntityId());
        if (!(ae instanceof TeleMissile)) {
            return;
        }
        TeleMissile tm = (TeleMissile) ae;
        final Targetable target = game.getTarget(taa.getTargetType(), taa.getTargetId());
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        int amsDamage = taa.CounterAVInt;
        Entity te = null;
        if ((target != null) && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }

        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }

        Report r;

        if (lastEntityId != taa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
                || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te.isDestroyed()
                || te.isDoomed() || te.getCrew().isDead()))) {
            r = new Report(4191);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(9031);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 1;
        addReport(r);

        // If point defenses engaged the missile, handle that damage
        if (amsDamage > 0) {
            //Report the attack
            r = new Report(3362);
            r.newlines = 1;
            r.subject = te.getId();
            vPhaseReport.add(r);

            // If the target's point defenses overheated, report that
            if (taa.getPDOverheated()) {
                r = new Report(3361);
                r.newlines = 1;
                r.subject = te.getId();
                vPhaseReport.add(r);
            }

            // Damage the missile
            HitData hit = tm.rollHitLocation(ToHitData.HIT_NORMAL,
                    tm.sideTable(te.getPosition(), true));
            addReport(damageEntity(ae, hit, amsDamage, false,
                    DamageType.NONE, false, false, false));

            // If point defense fire destroys the missile, don't process a hit
            if (ae.isDoomed()) {
                return;
            }
        }

        // add some stuff to the to hit value
        // need to add damage done modifier
        int damageTaken = (ae.getOArmor(TeleMissile.LOC_BODY) - ae.getArmor(TeleMissile.LOC_BODY));
        if (damageTaken > 10) {
            toHit.addModifier((int) (Math.floor(damageTaken / 10.0)), "damage taken");
        }

        // add modifiers for the originating unit missing CIC, FCS, or sensors
        Entity ride = game.getEntity(tm.getOriginalRideId());
        if (ride instanceof Aero) {
            Aero aride = (Aero) ride;
            int cic = aride.getCICHits();
            if (cic > 0) {
                toHit.addModifier(cic * 2, "CIC damage");
            }

            // sensor hits
            int sensors = aride.getSensorHits();
            if ((sensors > 0) && (sensors < 3)) {
                toHit.addModifier(sensors, "sensor damage");
            }

            if (sensors > 2) {
                toHit.addModifier(+5, "sensors destroyed");
            }

            // FCS hits
            int fcs = aride.getFCSHits();
            if (fcs > 0) {
                toHit.addModifier(fcs * 2, "fcs damage");
            }
        }

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4226);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
        } else {
            // report the roll
            r = new Report(9033);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(toHit.getDesc());
            r.add(roll);
            r.newlines = 0;
        }
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
        } else {
            // Resolve the damage.
            HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                    te.sideTable(ae.getPosition(), true));
            hit.setCapital(true);
            hit.setCapMisCritMod(tm.getCritMod());
            addReport(damageEntity(te, hit,
                    TeleMissileAttackAction.getDamageFor(ae), false,
                    DamageType.NONE, false, false, throughFront));
            destroyEntity(ae, "successful attack");
        }

    }

    /**
     * Handle a ramming attack
     */
    private void resolveRamAttack(PhysicalResult pr, int lastEntityId) {
        final RamAttackAction raa = (RamAttackAction) pr.aaa;
        final Entity ae = game.getEntity(raa.getEntityId());
        final Targetable target = game.getTarget(raa.getTargetType(), raa.getTargetId());
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        Entity te = null;
        if ((target != null) && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }

        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }

        Report r;

        boolean glancing = Compute.d6(1) == 6;

        // entity isn't ramming any more
        ae.setRamming(false);

        if (lastEntityId != raa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
                || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te.isDestroyed()
                || te.isDoomed() || te.getCrew().isDead()))) {
            r = new Report(4190);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // steel yourself for attack
        int steelRoll = Compute.d6(2);
        r = new Report(9020);
        r.subject = ae.getId();
        r.add(steelRoll);

        if (steelRoll >= 11) {
            r.choose(true);
            addReport(r);
        } else {
            r.choose(false);
            addReport(r);
            return;
        }

        // attacker immobile?
        if (ae.isImmobile()) {
            r = new Report(4200);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(9030);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4225);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
        }
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
        } else {
            // Resolve the damage.
            resolveRamDamage((IAero) ae, te, toHit, glancing, throughFront);
        }
    }

    /**
     * Handle a ramming attack's damage
     */
    private void resolveRamDamage(IAero aero, Entity te, ToHitData toHit, boolean glancing,
                                  boolean throughFront) {
        Entity ae = (Entity) aero;

        int damage = RamAttackAction.getDamageFor(aero, te);
        int damageTaken = RamAttackAction.getDamageTakenBy(aero, te);
        if (glancing) {
            // Round up glancing blows against conventional infantry
            damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        // are they capital scale?
        if (te.isCapitalScale()
                && !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
            damage = (int) Math.floor(damage / 10.0);
        }

        if (ae.isCapitalScale()
                && !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
            damageTaken = (int) Math.floor(damageTaken / 10.0);
        }

        Report r;

        if (glancing) {
            r = new Report(9015);
            r.subject = ae.getId();
            r.indent(1);
            addReport(r);
        }

        // damage to attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent();
        addReport(r);

        HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, ae.sideTable(te.getPosition(), true));
        // if the damage is greater than the initial armor then destroy the
        // entity
        if ((2 * ae.getOArmor(hit)) < damageTaken) {
            addReport(destroyEntity(ae, "by massive ramming damage", false));
        } else {
            addReport(damageEntity(ae, hit, damageTaken, false,
                    DamageType.NONE, false, false, throughFront));
        }

        r = new Report(4230);
        r.subject = ae.getId();
        r.add(damage);
        r.add(toHit.getTableDesc());
        r.indent();
        addReport(r);

        hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        if ((2 * te.getOArmor(hit)) < damage) {
            addReport(destroyEntity(te, "by massive ramming damage", false));
        } else {
            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                    false, false, throughFront));
        }
    }

    /**
     * Handle a charge's damage
     */
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {
        resolveChargeDamage(ae, te, toHit, direction, false, true, false);
    }

    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction,
                                     boolean glancing, boolean throughFront, boolean airmechRam) {
        // we hit...

        PilotingRollData chargePSR = null;
        // If we're upright, we may fall down.
        if (!ae.isProne() && !airmechRam) {
            chargePSR = new PilotingRollData(ae.getId(), 2, "charging");
        }

        // Damage To Target
        int damage;

        // Damage to Attacker
        int damageTaken;

        if (airmechRam) {
            damage = AirmechRamAttackAction.getDamageFor(ae);
            damageTaken = AirmechRamAttackAction.getDamageTakenBy(ae, te);
        } else {
            damage = ChargeAttackAction.getDamageFor(ae, te, game.getOptions()
                    .booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE), toHit.getMoS());
            damageTaken = ChargeAttackAction.getDamageTakenBy(ae, te, game
                    .getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE));
        }
        if (ae.hasWorkingMisc(MiscType.F_RAM_PLATE)) {
            damage = (int) Math.ceil(damage * 1.5);
            damageTaken = (int) Math.floor(damageTaken * 0.5);
        }
        if (glancing) {
            // Glancing Blow rule doesn't state whether damage to attacker on charge
            // or DFA is halved as well, assume yes. TODO : Check with PM
            damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }
        boolean bDirect = false;
        int directBlowCritMod = toHit.getMoS() / 3;
        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
                && ((toHit.getMoS() / 3) >= 1)) {
            damage += toHit.getMoS() / 3;
            bDirect = false;
        }

        // Is the target inside a building?
        final boolean targetInBuilding = Compute.isInBuilding(game, te);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(te.getPosition());

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        int bldgAbsorbs = 0;
        if (targetInBuilding && (bldg != null)) {
            bldgAbsorbs = bldg.getAbsorbtion(te.getPosition());
        }

        Report r;

        // damage to attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent();
        addReport(r);

        // Charging vehicles check for possible motive system hits.
        if (ae instanceof Tank) {
            r = new Report(4241);
            r.indent();
            addReport(r);
            int side = Compute.targetSideTable(te, ae);
            int mod = ae.getMotiveSideMod(side);
            addReport(vehicleMotiveDamage((Tank) ae, mod));
        }

        while (damageTaken > 0) {
            int cluster;
            HitData hit;
            // An airmech ramming attack does all damage to attacker's CT
            if (airmechRam) {
                cluster = damageTaken;
                hit = new HitData(Mech.LOC_CT);
            } else {
                cluster = Math.min(5, damageTaken);
                hit = ae.rollHitLocation(toHit.getHitTable(), ae.sideTable(te.getPosition()));
            }
            damageTaken -= cluster;
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            cluster = checkForSpikes(ae, hit.getLocation(), cluster, te, Mech.LOC_CT);
            addReport(damageEntity(ae, hit, cluster, false, DamageType.NONE,
                    false, false, throughFront));
        }

        // Damage to target
        if (ae instanceof Mech) {
            int spikeDamage = 0;
            for (int loc = 0; loc < ae.locations(); loc++) {
                if (((Mech) ae).locationIsTorso(loc) && ae.hasWorkingMisc(MiscType.F_SPIKES, -1, loc)) {
                    spikeDamage += 2;
                }
            }

            if (spikeDamage > 0) {
                r = new Report(4335);
                r.indent(2);
                r.subject = ae.getId();
                r.add(spikeDamage);
                addReport(r);
            }
            damage += spikeDamage;
        }
        r = new Report(4230);
        r.subject = ae.getId();
        r.add(damage);
        r.add(toHit.getTableDesc());
        r.indent();
        addReport(r);

        // Vehicles that have *been* charged check for motive system damage,
        // too...
        // ...though VTOLs don't use that table and should lose their rotor
        // instead,
        // which would be handled as part of the damage already.
        if ((te instanceof Tank) && !(te instanceof VTOL)) {
            r = new Report(4242);
            r.indent();
            addReport(r);

            int side = Compute.targetSideTable(ae, te);
            int mod = te.getMotiveSideMod(side);
            addReport(vehicleMotiveDamage((Tank) te, mod));
        }

        // track any additional damage to the attacker due to the target having spikes
        while (damage > 0) {
            int cluster = Math.min(5, damage);
            // Airmech ramming attacks do all damage to a single location
            if (airmechRam) {
                cluster = damage;
            }
            damage -= cluster;
            if (bldgAbsorbs > 0) {
                int toBldg = Math.min(bldgAbsorbs, cluster);
                cluster -= toBldg;
                addNewLines();
                Vector<Report> buildingReport = damageBuilding(bldg, damage, te.getPosition());
                for (Report report : buildingReport) {
                    report.subject = ae.getId();
                }
                addReport(buildingReport);

                // some buildings scale remaining damage that is not absorbed
                // TODO : this isn't quite right for castles brian
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
            }

            // A building may absorb the entire shot.
            if (cluster == 0) {
                r = new Report(4235);
                r.subject = ae.getId();
                r.addDesc(te);
                r.indent();
                addReport(r);
            } else {
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                if (bDirect) {
                    hit.makeDirectBlow(directBlowCritMod);
                }
                cluster = checkForSpikes(te, hit.getLocation(), cluster, ae, Mech.LOC_CT);
                addReport(damageEntity(te, hit, cluster, false,
                        DamageType.NONE, false, false, throughFront));
            }
        }

        if (airmechRam) {
            if (!ae.isDoomed()) {
                PilotingRollData controlRoll = ae.getBasePilotingRoll();
                Vector<Report> reports = new Vector<>();
                r = new Report(9320);
                r.subject = ae.getId();
                r.addDesc(ae);
                r.add("successful ramming attack");
                reports.add(r);
                int diceRoll = Compute.d6(2);
                // different reports depending on out-of-control status
                r = new Report(9606);
                r.subject = ae.getId();
                r.add(controlRoll.getValueAsString());
                r.add(controlRoll.getDesc());
                r.add(diceRoll);
                r.newlines = 1;
                if (diceRoll < controlRoll.getValue()) {
                    r.choose(false);
                    reports.add(r);
                    crashAirMech(ae, controlRoll, reports);
                } else {
                    r.choose(true);
                    reports.addElement(r);
                    if (ae instanceof LandAirMech) {
                        reports.addAll(landAirMech((LandAirMech) ae, ae.getPosition(), 1, ae.delta_distance));
                    }
                }
                addReport(reports);
            }
        } else {
            // move attacker and target, if possible
            Coords src = te.getPosition();
            Coords dest = src.translated(direction);

            if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {
                addNewLines();
                addReport(doEntityDisplacement(te, src, dest, new PilotingRollData(
                        te.getId(), 2, "was charged")));
                addReport(doEntityDisplacement(ae, ae.getPosition(), src, chargePSR));
            }

            addNewLines();
        }

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }
    }

    /**
     * Checks whether the location has spikes, and if so handles the damage to the
     * attack and returns the reduced damage. Locations without spikes return the
     * original damage amount.
     *
     * @param target            The target of a physical attack
     * @param targetLocation    The location that was hit
     * @param damage            The amount of damage dealt to the target
     * @param attacker          The attacker
     * @param attackerLocation  The location on the attacker that is damaged if the
     *                          target has spikes. Entity.LOC_NONE if the attacker
     *                          can't be damaged by spikes in this attack.
     * @return          The damage after applying any reduction due to spikes
     */
    private int checkForSpikes(Entity target, int targetLocation, int damage,
                               Entity attacker, int attackerLocation) {
        return checkForSpikes(target, targetLocation, damage, attacker, attackerLocation, Entity.LOC_NONE);
    }

    /**
     * Checks whether the location has spikes, and if so handles the damage to the
     * attack and returns the reduced damage. Locations without spikes return the
     * original damage amount.
     *
     * @param target            The target of a physical attack
     * @param targetLocation    The location that was hit
     * @param damage            The amount of damage dealt to the target
     * @param attacker          The attacker
     * @param attackerLocation  The location on the attacker that is damaged if the
     *                          target has spikes. Entity.LOC_NONE if the attacker
     *                          can't be damaged by spikes in this attack.
     * @param attackerLocation2 If not Entity.LOC_NONE, the damage to the attacker
     *                          will be split between two locations.
     * @return          The damage after applying any reduction due to spikes
     */
    private int checkForSpikes(Entity target, int targetLocation, int damage,
                               Entity attacker, int attackerLocation, int attackerLocation2) {
        if (target.hasWorkingMisc(MiscType.F_SPIKES, -1, targetLocation)) {
            Report r;
            if (damage == 0) {
                // Only show damage to attacker (push attack)
                r = new Report(4333);
            } else if (attackerLocation != Entity.LOC_NONE) {
                // Show damage reduction and damage to attacker
                r = new Report(4330);
            } else {
                // Only show damage reduction (club/physical weapon attack)
                r = new Report(4331);
            }
            r.indent(2);
            r.subject = target.getId();
            addReport(r);
            // An attack that deals zero damage can still damage the attacker in the case of a push
            if (attackerLocation != Entity.LOC_NONE) {
                // Spikes also protect from retaliatory spike damage
                if (attacker.hasWorkingMisc(MiscType.F_SPIKES, -1, attackerLocation)) {
                    r = new Report(4332);
                    r.indent(2);
                    r.subject = attacker.getId();
                    addReport(r);
                } else if (attackerLocation2 == Entity.LOC_NONE) {
                    addReport(damageEntity(attacker, new HitData(attackerLocation), 2, false,
                            DamageType.NONE, false, false, false));
                } else {
                    addReport(damageEntity(attacker, new HitData(attackerLocation), 1, false,
                            DamageType.NONE, false, false, false));
                    addReport(damageEntity(attacker, new HitData(attackerLocation2), 1, false,
                            DamageType.NONE, false, false, false));
                }
            }
            return Math.max(1, damage - 4);
        }
        return damage;
    }

    /**
     * End-phase checks for laid explosives; check whether explosives are
     * touched off, or if we should report laying explosives
     */
    private void checkLayExplosives() {
        // Report continuing explosive work
        for (Entity e : game.getEntitiesVector()) {
            if (!(e instanceof Infantry)) {
                continue;
            }
            Infantry inf = (Infantry) e;
            if (inf.turnsLayingExplosives > 0) {
                Report r = new Report(4271);
                r.subject = inf.getId();
                r.addDesc(inf);
                addReport(r);
            }
        }
        // Check for touched-off explosives
        Vector<Building> updatedBuildings = new Vector<>();
        for (Building.DemolitionCharge charge : explodingCharges) {
            Building bldg = game.getBoard().getBuildingAt(charge.pos);
            if (bldg == null) { // Shouldn't happen...
                continue;
            }
            bldg.removeDemolitionCharge(charge);
            updatedBuildings.add(bldg);
            Report r = new Report(4272, Report.PUBLIC);
            r.add(bldg.getName());
            addReport(r);
            Vector<Report> dmgReports = damageBuilding(bldg, charge.damage, " explodes for ", charge.pos);
            for (Report rep : dmgReports) {
                rep.indent();
                addReport(rep);
            }
        }
        explodingCharges.clear();
        sendChangedBuildings(updatedBuildings);
    }

    private void resolveLayExplosivesAttack(PhysicalResult pr) {
        final LayExplosivesAttackAction laa = (LayExplosivesAttackAction) pr.aaa;
        final Entity ae = game.getEntity(laa.getEntityId());
        if (ae instanceof Infantry) {
            Infantry inf = (Infantry) ae;
            if (inf.turnsLayingExplosives < 0) {
                inf.turnsLayingExplosives = 0;
                Report r = new Report(4270);
                r.subject = inf.getId();
                r.addDesc(inf);
                addReport(r);
            } else {
                Building building = game.getBoard().getBuildingAt(ae.getPosition());
                if (building != null) {
                    building.addDemolitionCharge(ae.getOwner().getId(), pr.damage, ae.getPosition());
                    Report r = new Report(4275);
                    r.subject = inf.getId();
                    r.addDesc(inf);
                    r.add(pr.damage);
                    addReport(r);
                    // Update clients with this info
                    Vector<Building> updatedBuildings = new Vector<>();
                    updatedBuildings.add(building);
                    sendChangedBuildings(updatedBuildings);
                }
                inf.turnsLayingExplosives = -1;
            }
        }
    }

    /**
     * Handle a death from above attack
     */
    private void resolveDfaAttack(PhysicalResult pr, int lastEntityId) {
        final DfaAttackAction daa = (DfaAttackAction) pr.aaa;
        final Entity ae = game.getEntity(daa.getEntityId());

        // is the attacker dead? because that sure messes up the calculations
        if (ae == null) {
            return;
        }

        final Hex aeHex = game.getBoard().getHex(ae.getPosition());
        final Hex teHex = game.getBoard().getHex(daa.getTargetPos());
        final Targetable target = game.getTarget(daa.getTargetType(), daa.getTargetId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        Entity te = null;
        if ((target != null)
                && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            // Lets re-write around that horrible hack that was here before.
            // So instead of asking if a specific location is wet and praying
            // that it won't cause an NPE...
            // We'll check 1) if the hex has water, and 2) if it's deep enough
            // to cover the unit in question at its current elevation.
            // It's especially important to make sure it's done this way,
            // because some units (Sylph, submarines) can be at ANY elevation
            // underwater, and VTOLs can be well above the surface.
            te = (Entity) target;
            Hex hex = game.getBoard().getHex(te.getPosition());
            if (hex.containsTerrain(Terrains.WATER)) {
                if (te.relHeight() < 0) {
                    damage = (int) Math.ceil(damage * 0.5f);
                }
            }
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean glancing = game.getOptions().booleanOption(
                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) && (roll == toHit.getValue());
        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) && ((toHit.getMoS() / 3) >= 1);

        Report r;

        final int direction = ae.getFacing();

        if (lastEntityId != daa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)
                && (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {
            r = new Report(4245);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
            if (ae.isProne()) {
                // attacker prone during weapons phase
                addReport(doEntityFall(ae, daa.getTargetPos(), 2, 3,
                        ae.getBasePilotingRoll(), false, false));

            } else {
                // same effect as successful DFA
                ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));
                addReport(doEntityDisplacement(ae, ae.getPosition(),
                        daa.getTargetPos(), new PilotingRollData(ae.getId(), 4,
                                "executed death from above")));
            }
            return;
        }

        r = new Report(4246);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // target still in the same position?
        if (!target.getPosition().equals(daa.getTargetPos())) {
            r = new Report(4215);
            r.subject = ae.getId();
            addReport(r);
            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
            addReport(doEntityFallsInto(ae, ae.getElevation(), ae.getPosition(), daa.getTargetPos(),
                    ae.getBasePilotingRoll(), true));
            return;
        }

        // hack: if the attacker's prone, or incapacitated, fudge the roll
        if (ae.isProne() || !ae.isActive()) {
            roll = -12;
            r = new Report(4250);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines--;
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            roll = -12;
            r = new Report(4255);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4260);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit);
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(3186);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

            if (directBlow) {
                r = new Report(3189);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            Coords dest = te.getPosition();
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            if (targetDest != null) {
                // move target to preferred hex
                addReport(doEntityDisplacement(te, dest, targetDest, null));
                // attacker falls into destination hex
                r = new Report(4265);
                r.subject = ae.getId();
                r.addDesc(ae);
                r.add(dest.getBoardNum(), true);
                r.indent();
                addReport(r);
                // entity isn't DFAing any more
                ae.setDisplacementAttack(null);
                addReport(doEntityFall(ae, dest, 2, 3, ae.getBasePilotingRoll(),
                        false, false), 1);
                Entity violation = Compute.stackingViolation(game, ae.getId(), dest);
                if (violation != null) {
                    // target gets displaced
                    targetDest = Compute.getValidDisplacement(game,
                            violation.getId(), dest, direction);
                    vPhaseReport.addAll(doEntityDisplacement(violation, dest,
                            targetDest, new PilotingRollData(violation.getId(),
                                    0, "domino effect")));
                    // Update the violating entity's position on the client.
                    if (!game.getOutOfGameEntitiesVector().contains(violation)) {
                        entityUpdate(violation.getId());
                    }
                }
            } else {
                // attacker destroyed
                // Tanks suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                addReport(destroyEntity(ae, "impossible displacement",
                        ae instanceof Mech, ae instanceof Mech));
            }
            return;
        }

        // we hit...

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);

        Coords dest = target.getPosition();

        // Can't DFA a target inside of a building.
        int damageTaken = DfaAttackAction.getDamageTakenBy(ae);

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // Which building takes the damage?
            Building bldg = game.getBoard().getBuildingAt(daa.getTargetPos());

            // The building takes the full brunt of the attack.
            Vector<Report> buildingReport = damageBuilding(bldg, damage, target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));
        } else { // Target isn't building.
            if (glancing && (te != null)) {
                damage = (int) (te.isConventionalInfantry() ? Math.ceil(damage / 2.0) : Math.floor(damage / 2.0));
            }

            if (directBlow) {
                damage += toHit.getMoS() / 3;
            }
            // damage target
            r = new Report(4230);
            r.subject = ae.getId();
            r.add(damage);
            r.add(toHit.getTableDesc());
            r.indent(2);
            addReport(r);

            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                if (directBlow) {
                    hit.makeDirectBlow(toHit.getMoS() / 3);
                }
                damage -= cluster;
                cluster = checkForSpikes(te, hit.getLocation(), cluster, ae, Mech.LOC_LLEG, Mech.LOC_RLEG);
                addReport(damageEntity(te, hit, cluster, false,
                        DamageType.NONE, false, false, throughFront));
            }

            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
            }
            // Target entities are pushed away or destroyed.
            Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);
            if (targetDest != null) {
                addReport(doEntityDisplacement(te, dest, targetDest,
                        new PilotingRollData(te.getId(), 2, "hit by death from above")));
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                addReport(destroyEntity(te, "impossible displacement",
                        te instanceof Mech, te instanceof Mech));
            }

        }

        if (glancing) {
            // Glancing Blow rule doesn't state whether damage to attacker on charge
            // or DFA is halved as well, assume yes. TODO : Check with PM
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        if (ae.hasQuirk(OptionsConstants.QUIRK_POS_REINFORCED_LEGS)) {
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        // damage attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent(2);
        addReport(r);
        while (damageTaken > 0) {
            int cluster = Math.min(5, damageTaken);
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(ae, hit, cluster));
            damageTaken -= cluster;
        }

        if (ae.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {
            addNewLines();
            addReport(criticalEntity(ae, Mech.LOC_LLEG, false, 0, 0));
            addNewLines();
            addReport(criticalEntity(ae, Mech.LOC_RLEG, false, 0, 0));
            if (ae instanceof QuadMech) {
                addNewLines();
                addReport(criticalEntity(ae, Mech.LOC_LARM, false, 0, 0));
                addNewLines();
                addReport(criticalEntity(ae, Mech.LOC_RARM, false, 0, 0));
            }
        }

        addNewLines();

        // That's it for target buildings.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            return;
        }
        ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));
        // HACK: to avoid automatic falls, displace from dest to dest
        addReport(doEntityDisplacement(ae, dest, dest, new PilotingRollData(
                ae.getId(), 4, "executed death from above")));

        // entity isn't DFAing any more
        ae.setDisplacementAttack(null);

        // if the target is an industrial mech, it needs to check for crits at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Get the Kick or Push PSR, modified by weight class
     *
     * @param psrEntity The <code>Entity</code> that should make a PSR
     * @param attacker  The attacking <code>Entity></code>
     * @param target    The target <code>Entity</code>
     * @return The <code>PilotingRollData</code>
     */
    private PilotingRollData getKickPushPSR(Entity psrEntity, Entity attacker,
                                            Entity target, String reason) {
        int mod = 0;
        PilotingRollData psr = new PilotingRollData(psrEntity.getId(), mod, reason);
        if (psrEntity.hasQuirk(OptionsConstants.QUIRK_POS_STABLE)) {
            psr.addModifier(-1, "stable", false);
        }
        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_PSR)) {

            switch (target.getWeightClass()) {
                case EntityWeightClass.WEIGHT_LIGHT:
                    mod = 1;
                    break;
                case EntityWeightClass.WEIGHT_MEDIUM:
                    mod = 0;
                    break;
                case EntityWeightClass.WEIGHT_HEAVY:
                    mod = -1;
                    break;
                case EntityWeightClass.WEIGHT_ASSAULT:
                    mod = -2;
                    break;
            }
            String reportStr;
            if (mod > 0) {
                reportStr = ("weight class modifier +") + mod;
            } else {
                reportStr = ("weight class modifier ") + mod;
            }
            psr.addModifier(mod, reportStr, false);
        }
        return psr;
    }

    /**
     * Each mech sinks the amount of heat appropriate to its current heat
     * capacity.
     */
    private void resolveHeat() {
        Report r;
        // Heat phase header
        addReport(new Report(5000, Report.PUBLIC));
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if ((null == entity.getPosition()) && !entity.isAero()) {
                continue;
            }
            Hex entityHex = game.getBoard().getHex(entity.getPosition());

            int hotDogMod = 0;
            if (entity.hasAbility(OptionsConstants.PILOT_HOT_DOG)) {
                hotDogMod = 1;
            }
            if (entity.getTaserInterferenceHeat()) {
                entity.heatBuildup += 5;
            }
            if (entity.hasDamagedRHS() && entity.weaponFired()) {
                entity.heatBuildup += 1;
            }
            if ((entity instanceof Mech) && ((Mech) entity).hasDamagedCoolantSystem() && entity.weaponFired()) {
                entity.heatBuildup += 1;
            }

            int radicalHSBonus = 0;
            Vector<Report> rhsReports = new Vector<>();
            if (entity.hasActivatedRadicalHS()) {
                if (entity instanceof Mech) {
                    radicalHSBonus = ((Mech) entity).getActiveSinks();
                } else if (entity instanceof Aero) {
                    radicalHSBonus = ((Aero) entity).getHeatSinks();
                } else {
                    LogManager.getLogger().error("Radical heat sinks mounted on non-mech, non-aero Entity!");
                }

                // RHS activation report
                r = new Report(5540);
                r.subject = entity.getId();
                r.indent();
                r.addDesc(entity);
                r.add(radicalHSBonus);
                rhsReports.add(r);

                int rhsRoll = Compute.d6(2);
                entity.setConsecutiveRHSUses(entity.getConsecutiveRHSUses() + 1);
                int targetNumber = ServerHelper.radicalHeatSinkSuccessTarget(entity.getConsecutiveRHSUses());
                boolean rhsFailure = rhsRoll < targetNumber;

                r = new Report(5541);
                r.indent(2);
                r.subject = entity.getId();
                r.add(targetNumber);
                r.add(rhsRoll);
                r.choose(rhsFailure);
                rhsReports.add(r);

                if (rhsFailure) {
                    entity.setHasDamagedRHS(true);
                    int loc = Entity.LOC_NONE;
                    for (Mounted m : entity.getEquipment()) {
                        if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {
                            loc = m.getLocation();
                            m.setDestroyed(true);
                            break;
                        }
                    }
                    if (loc == Entity.LOC_NONE) {
                        throw new IllegalStateException("Server.resolveHeat(): " +
                                "Could not find Radical Heat Sink mount on unit that used RHS!");
                    }
                    for (int s = 0; s < entity.getNumberOfCriticals(loc); s++) {
                        CriticalSlot slot = entity.getCritical(loc, s);
                        if ((slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                                && slot.getMount().getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {
                            slot.setHit(true);
                            break;
                        }
                    }
                }
            }

            // put in ASF heat build-up first because there are few differences
            if (entity instanceof Aero && !(entity instanceof ConvFighter)) {
                ServerHelper.resolveAeroHeat(game, entity, vPhaseReport, rhsReports, radicalHSBonus, hotDogMod, this);
                continue;
            }

            // heat doesn't matter for non-mechs
            if (!(entity instanceof Mech)) {
                entity.heat = 0;
                entity.heatBuildup = 0;
                entity.heatFromExternal = 0;
                entity.coolFromExternal = 0;

                if (entity.infernos.isStillBurning()) {
                    doFlamingDamage(entity, entity.getPosition());
                }
                if (entity.getTaserShutdownRounds() == 0) {
                    entity.setBATaserShutdown(false);
                    if (entity.isShutDown() && !entity.isManualShutdown()
                            && (entity.getTsempEffect() != MMConstants.TSEMP_EFFECT_SHUTDOWN)) {
                        entity.setShutDown(false);
                        r = new Report(5045);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                    }
                } else if (entity.isBATaserShutdown()) {
                    // if we're shutdown by a BA taser, we might activate again
                    int roll = Compute.d6(2);
                    if (roll >= 8) {
                        entity.setTaserShutdownRounds(0);
                        if (!(entity.isManualShutdown())) {
                            entity.setShutDown(false);
                        }
                        entity.setBATaserShutdown(false);
                    }
                }

                continue;
            }

            // Only Mechs after this point

            // Meks gain heat from inferno hits.
            if (entity.infernos.isStillBurning()) {
                int infernoHeat = entity.infernos.getHeat();
                entity.heatFromExternal += infernoHeat;
                r = new Report(5010);
                r.subject = entity.getId();
                r.add(infernoHeat);
                addReport(r);
            }

            // should we even bother for this mech?
            if (entity.isDestroyed() || entity.isDoomed() || entity.getCrew().isDoomed()
                    || entity.getCrew().isDead()) {
                continue;
            }

            // engine hits add a lot of heat, provided the engine is on
            entity.heatBuildup += entity.getEngineCritHeat();

            // If a Mek had an active Stealth suite, add 10 heat.
            if (entity.isStealthOn()) {
                entity.heatBuildup += 10;
                r = new Report(5015);
                r.subject = entity.getId();
                addReport(r);
            }

            // Greg: Nova CEWS If a Mek had an active Nova suite, add 2 heat.
            if (entity.hasActiveNovaCEWS()) {
                entity.heatBuildup += 2;
                r = new Report(5013);
                r.subject = entity.getId();
                addReport(r);
            }

            // void sig adds 10 heat
            if (entity.isVoidSigOn()) {
                entity.heatBuildup += 10;
                r = new Report(5016);
                r.subject = entity.getId();
                addReport(r);
            }

            // null sig adds 10 heat
            if (entity.isNullSigOn()) {
                entity.heatBuildup += 10;
                r = new Report(5017);
                r.subject = entity.getId();
                addReport(r);
            }

            // chameleon polarization field adds 6
            if (entity.isChameleonShieldOn()) {
                entity.heatBuildup += 6;
                r = new Report(5014);
                r.subject = entity.getId();
                addReport(r);
            }

            // If a Mek is in extreme Temperatures, add or subtract one
            // heat per 10 degrees (or fraction of 10 degrees) above or
            // below 50 or -30 degrees Celsius
            ServerHelper.adjustHeatExtremeTemp(game, entity, vPhaseReport);

            // Add +5 Heat if the hex you're in is on fire
            // and was on fire for the full round.
            if (entityHex != null) {
                if (entityHex.containsTerrain(Terrains.FIRE) && (entityHex.getFireTurn() > 0)
                        && (entity.getElevation() <= 1)) {
                    int heatToAdd = 5;
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heatToAdd /= 2;
                    }
                    entity.heatFromExternal += heatToAdd;
                    r = new Report(5030);
                    r.add(heatToAdd);
                    r.subject = entity.getId();
                    addReport(r);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
                int magma = entityHex.terrainLevel(Terrains.MAGMA);
                if ((magma > 0) && (entity.getElevation() == 0)) {
                    int heatToAdd = 5 * magma;
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heatToAdd /= 2;
                    }
                    entity.heatFromExternal += heatToAdd;
                    r = new Report(5032);
                    r.subject = entity.getId();
                    r.add(heatToAdd);
                    addReport(r);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
            }

            // Check the mech for vibroblades if so then check to see if any
            // are active and what heat they will produce.
            if (entity.hasVibroblades()) {
                int vibroHeat;

                vibroHeat = entity.getActiveVibrobladeHeat(Mech.LOC_RARM);
                vibroHeat += entity.getActiveVibrobladeHeat(Mech.LOC_LARM);

                if (vibroHeat > 0) {
                    r = new Report(5018);
                    r.subject = entity.getId();
                    r.add(vibroHeat);
                    addReport(r);
                    entity.heatBuildup += vibroHeat;
                }
            }

            int capHeat = 0;
            for (Mounted m : entity.getEquipment()) {
                if ((m.hasChargedOrChargingCapacitor() == 1) && !m.isUsedThisRound()) {
                    capHeat += 5;
                }
                if ((m.hasChargedOrChargingCapacitor() == 2) && !m.isUsedThisRound()) {
                    capHeat += 10;
                }
            }
            if (capHeat > 0) {
                r = new Report(5019);
                r.subject = entity.getId();
                r.add(capHeat);
                addReport(r);
                entity.heatBuildup += capHeat;
            }

            // Add heat from external sources to the heat buildup
            int max_ext_heat = game.getOptions().intOption(OptionsConstants.ADVCOMBAT_MAX_EXTERNAL_HEAT);
            // Check Game Options
            if (max_ext_heat < 0) {
                max_ext_heat = 15; // standard value specified in TW p.159
            }
            entity.heatBuildup += Math.min(max_ext_heat, entity.heatFromExternal);
            entity.heatFromExternal = 0;
            // remove heat we cooled down
            entity.heatBuildup -= Math.min(9, entity.coolFromExternal);
            entity.coolFromExternal = 0;

            // Combat computers help manage heat
            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {
                int reduce = Math.min(entity.heatBuildup, 4);
                r = new Report(5026);
                r.subject = entity.getId();
                r.add(reduce);
                addReport(r);
                entity.heatBuildup -= reduce;
            }

            if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)
                    && ((Mech) entity).isCoolingFlawActive()) {
                int flaw = 5;
                r = new Report(5021);
                r.subject = entity.getId();
                r.add(flaw);
                addReport(r);
                entity.heatBuildup += flaw;
            }
            // if heat build up is negative due to temperature, set it to 0
            // for prettier turn reports
            if (entity.heatBuildup < 0) {
                entity.heatBuildup = 0;
            }

            // add the heat we've built up so far.
            entity.heat += entity.heatBuildup;

            // how much heat can we sink?
            int toSink = entity.getHeatCapacityWithWater() + radicalHSBonus;

            if (entity.getCoolantFailureAmount() > 0) {
                int failureAmount = entity.getCoolantFailureAmount();
                r = new Report(5520);
                r.subject = entity.getId();
                r.add(failureAmount);
                toSink -= failureAmount;
            }

            // should we use a coolant pod?
            int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;
            int possibleSinkage = ((Mech) entity).getNumberOfSinks() - entity.getCoolantFailureAmount();
            for (Mounted m : entity.getEquipment()) {
                if (m.getType() instanceof AmmoType) {
                    AmmoType at = (AmmoType) m.getType();
                    if ((at.getAmmoType() == AmmoType.T_COOLANT_POD) && m.isAmmoUsable()) {
                        EquipmentMode mode = m.curMode();
                        if (mode.equals("dump")) {
                            r = new Report(5260);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            toSink += possibleSinkage;
                            break;
                        }
                        if (mode.equals("safe") && ((entity.heat - toSink) > safeHeat)) {
                            r = new Report(5265);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            toSink += possibleSinkage;
                            break;
                        }
                        if (mode.equals("efficient") && ((entity.heat - toSink) >= possibleSinkage)) {
                            r = new Report(5270);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            toSink += possibleSinkage;
                            break;
                        }
                    }
                }
            }

            toSink = Math.min(toSink, entity.heat);
            entity.heat -= toSink;
            r = new Report(5035);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(entity.heatBuildup);
            r.add(toSink);
            Color color = GUIPreferences.getInstance().getColorForHeat(entity.heat, Color.BLACK);
            r.add(r.bold(r.fgColor(color, String.valueOf(entity.heat))));
            addReport(r);
            entity.heatBuildup = 0;
            vPhaseReport.addAll(rhsReports);

            // Does the unit have inferno ammo?
            if (entity.hasInfernoAmmo()) {

                // Roll for possible inferno ammo explosion.
                if (entity.heat >= 10) {
                    int boom = (4 + (entity.heat >= 14 ? 2 : 0) + (entity.heat >= 19 ? 2 : 0)
                            + (entity.heat >= 23 ? 2 : 0) + (entity.heat >= 28 ? 2 : 0))
                            - hotDogMod;
                    int boomRoll = Compute.d6(2);
                    if (entity.getCrew().hasActiveTechOfficer()) {
                        boomRoll += 2;
                    }
                    r = new Report(5040);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(boom);
                    if (entity.getCrew().hasActiveTechOfficer()) {
                        r.add(boomRoll + "(" + (boomRoll - 2) + "+2)");
                    } else {
                        r.add(boomRoll);
                    }

                    if (boomRoll >= boom) {
                        // avoided
                        r.choose(true);
                        addReport(r);
                    } else {
                        r.choose(false);
                        addReport(r);
                        addReport(explodeInfernoAmmoFromHeat(entity));
                    }
                }
            } // End avoid-inferno-explosion
            int autoShutDownHeat;
            boolean mtHeat;

            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) {
                autoShutDownHeat = 50;
                mtHeat = true;
            } else {
                autoShutDownHeat = 30;
                mtHeat = false;
            }
            // heat effects: start up
            if ((entity.heat < autoShutDownHeat) && entity.isShutDown() && !entity.isStalled()) {
                if ((entity.getTaserShutdownRounds() == 0)
                        && (entity.getTsempEffect() != MMConstants.TSEMP_EFFECT_SHUTDOWN)) {
                    if ((entity.heat < 14) && !(entity.isManualShutdown())) {
                        // automatically starts up again
                        entity.setShutDown(false);
                        r = new Report(5045);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                    } else if (!(entity.isManualShutdown())) {
                        // If the pilot is KO and we need to roll, auto-fail.
                        if (!entity.getCrew().isActive()) {
                            r = new Report(5049);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                        } else {
                            // roll for startup
                            int startup = (4 + (((entity.heat - 14) / 4) * 2)) - hotDogMod;
                            if (mtHeat) {
                                startup -= 5;
                                switch (entity.getCrew().getPiloting()) {
                                    case 0:
                                    case 1:
                                        startup -= 2;
                                        break;
                                    case 2:
                                    case 3:
                                        startup -= 1;
                                        break;
                                    case 6:
                                    case 7:
                                        startup += 1;
                                }
                            }
                            int suRoll = Compute.d6(2);
                            r = new Report(5050);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(startup);
                            r.add(suRoll);
                            if (suRoll >= startup) {
                                // start 'er back up
                                entity.setShutDown(false);
                                r.choose(true);
                            } else {
                                r.choose(false);
                            }
                        }
                        addReport(r);
                    }
                } else {
                    // if we're shutdown by a BA taser, we might activate
                    // again
                    if (entity.isBATaserShutdown()) {
                        int roll = Compute.d6(2);
                        if (roll >= 7) {
                            entity.setTaserShutdownRounds(0);
                            if (!(entity.isManualShutdown())) {
                                entity.setShutDown(false);
                            }
                            entity.setBATaserShutdown(false);
                        }
                    }
                }
            }

            // heat effects: shutdown!
            // Don't shut down if you just restarted.
            else if ((entity.heat >= 14) && !entity.isShutDown()) {
                if (entity.heat >= autoShutDownHeat) {
                    r = new Report(5055);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    // add a piloting roll and resolve immediately
                    if (entity.canFall()) {
                        game.addPSR(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));
                        addReport(resolvePilotingRolls());
                    }
                    // okay, now mark shut down
                    entity.setShutDown(true);
                } else {
                    // Again, pilot KO means shutdown is automatic.
                    if (!entity.getCrew().isActive()) {
                        r = new Report(5056);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                        entity.setShutDown(true);
                    } else {
                        int shutdown = (4 + (((entity.heat - 14) / 4) * 2)) - hotDogMod;
                        if (mtHeat) {
                            shutdown -= 5;
                            switch (entity.getCrew().getPiloting()) {
                                case 0:
                                case 1:
                                    shutdown -= 2;
                                    break;
                                case 2:
                                case 3:
                                    shutdown -= 1;
                                    break;
                                case 6:
                                case 7:
                                    shutdown += 1;
                            }
                        }
                        int shutdownRoll = Compute.d6(2);
                        r = new Report(5060);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(shutdown);
                        if (entity.getCrew().hasActiveTechOfficer()) {
                            r.add((shutdownRoll + 2) + " (" + shutdownRoll + "+2)");
                            shutdownRoll += 2;
                        } else {
                            r.add(shutdownRoll);
                        }
                        if (shutdownRoll >= shutdown) {
                            // avoided
                            r.choose(true);
                            addReport(r);
                        } else {
                            // shutting down...
                            r.choose(false);
                            addReport(r);
                            // add a piloting roll and resolve immediately
                            if (entity.canFall()) {
                                game.addPSR(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));
                                addReport(resolvePilotingRolls());
                            }
                            // okay, now mark shut down
                            entity.setShutDown(true);
                        }
                    }
                }
            }

            // LAMs in fighter mode need to check for random movement due to heat
            checkRandomAeroMovement(entity, hotDogMod);

            // heat effects: ammo explosion!
            if (entity.heat >= 19) {
                int boom = (4 + (entity.heat >= 23 ? 2 : 0) + (entity.heat >= 28 ? 2 : 0))
                        - hotDogMod;
                if (mtHeat) {
                    boom += (entity.heat >= 35 ? 2 : 0)
                            + (entity.heat >= 40 ? 2 : 0)
                            + (entity.heat >= 45 ? 2 : 0);
                    // Last line is a crutch; 45 heat should be no roll
                    // but automatic explosion.
                }
                if (((Mech) entity).hasLaserHeatSinks()) {
                    boom--;
                }
                int boomRoll = Compute.d6(2);
                r = new Report(5065);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(boom);
                if (entity.getCrew().hasActiveTechOfficer()) {
                    r.add((boomRoll + 2) + " (" + boomRoll + "+2)");
                    boomRoll += 2;
                } else {
                    r.add(boomRoll);
                }
                if (boomRoll >= boom) {
                    // mech is ok
                    r.choose(true);
                    addReport(r);
                } else {
                    // boom!
                    r.choose(false);
                    addReport(r);
                    addReport(explodeAmmoFromHeat(entity));
                }
            }

            // heat effects: mechwarrior damage
            // N.B. The pilot may already be dead.
            int lifeSupportCritCount;
            boolean torsoMountedCockpit = ((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED;
            if (torsoMountedCockpit) {
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_RT);
                lifeSupportCritCount += entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_LT);
            } else {
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD);
            }
            int damageHeat = entity.heat;
            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_IMP_LIFE_SUPPORT)) {
                damageHeat -= 5;
            }
            if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_LIFE_SUPPORT)) {
                damageHeat += 5;
            }
            if ((lifeSupportCritCount > 0)
                    && ((damageHeat >= 15) || (torsoMountedCockpit && (damageHeat > 0)))
                    && !entity.getCrew().isDead() && !entity.getCrew().isDoomed()
                    && !entity.getCrew().isEjected()) {
                int heatLimitDesc = 1;
                int damageToCrew = 0;
                if ((damageHeat >= 47) && mtHeat) {
                    // mechwarrior takes 5 damage
                    heatLimitDesc = 47;
                    damageToCrew = 5;
                } else if ((damageHeat >= 39) && mtHeat) {
                    // mechwarrior takes 4 damage
                    heatLimitDesc = 39;
                    damageToCrew = 4;
                } else if ((damageHeat >= 32) && mtHeat) {
                    // mechwarrior takes 3 damage
                    heatLimitDesc = 32;
                    damageToCrew = 3;
                } else if (damageHeat >= 25) {
                    // mechwarrior takes 2 damage
                    heatLimitDesc = 25;
                    damageToCrew = 2;
                } else if (damageHeat >= 15) {
                    // mechwarrior takes 1 damage
                    heatLimitDesc = 15;
                    damageToCrew = 1;
                }
                if ((((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)
                        && !entity.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
                    damageToCrew += 1;
                }
                r = new Report(5070);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(heatLimitDesc);
                r.add(damageToCrew);
                addReport(r);
                addReport(damageCrew(entity, damageToCrew));
            } else if (mtHeat && (entity.heat >= 32) && !entity.getCrew().isDead()
                    && !entity.getCrew().isDoomed()
                    && !entity.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
                // Crew may take damage from heat if MaxTech option is set
                int heatRoll = Compute.d6(2);
                int avoidNumber;
                if (entity.heat >= 47) {
                    avoidNumber = 12;
                } else if (entity.heat >= 39) {
                    avoidNumber = 10;
                } else {
                    avoidNumber = 8;
                }
                avoidNumber -= hotDogMod;
                r = new Report(5075);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(avoidNumber);
                r.add(heatRoll);
                if (heatRoll >= avoidNumber) {
                    // damage avoided
                    r.choose(true);
                    addReport(r);
                } else {
                    r.choose(false);
                    addReport(r);
                    addReport(damageCrew(entity, 1));
                }
            }

            // The pilot may have just expired.
            if ((entity.getCrew().isDead() || entity.getCrew().isDoomed())
                    && !entity.getCrew().isEjected()) {
                r = new Report(5080);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity, "crew death", true));
            }

            // With MaxTech Heat Scale, there may occur critical damage
            if (mtHeat) {
                if (entity.heat >= 36) {
                    int damageRoll = Compute.d6(2);
                    int damageNumber;
                    if (entity.heat >= 44) {
                        damageNumber = 10;
                    } else {
                        damageNumber = 8;
                    }
                    damageNumber -= hotDogMod;
                    r = new Report(5085);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(damageNumber);
                    r.add(damageRoll);
                    r.newlines = 0;
                    if (damageRoll >= damageNumber) {
                        r.choose(true);
                    } else {
                        r.choose(false);
                        addReport(r);
                        addReport(oneCriticalEntity(entity, Compute.randomInt(8), false, 0));
                        // add an empty report, for line breaking
                        r = new Report(1210, Report.PUBLIC);
                    }
                    addReport(r);
                }
            }

            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_COOLANT_FAILURE)
                    && (entity.getHeatCapacity() > entity.getCoolantFailureAmount())
                    && (entity.heat >= 5)) {
                int roll = Compute.d6(2);
                int hitNumber = 10;

                hitNumber -= Math.max(0, (int) Math.ceil(entity.heat / 5.0) - 2);

                r = new Report(5525);
                r.subject = entity.getId();
                r.add(entity.getShortName());
                r.add(hitNumber);
                r.add(roll);
                r.newlines = 0;
                addReport(r);
                if (roll >= hitNumber) {
                    r = new Report(5052);
                    r.subject = entity.getId();
                    addReport(r);
                    r = new Report(5526);
                    r.subject = entity.getId();
                    r.add(entity.getShortNameRaw());
                    addReport(r);
                    entity.addCoolantFailureAmount(1);
                } else {
                    r = new Report(5041);
                    r.subject = entity.getId();
                    addReport(r);
                }
            }
        }

        if (vPhaseReport.size() == 1) {
            // I guess nothing happened...
            addReport(new Report(1205, Report.PUBLIC));
        }
    }

    void checkRandomAeroMovement(Entity entity, int hotDogMod) {
        if (!entity.isAero()) {
            return;
        }
        IAero a = (IAero) entity;
        // heat effects: control effects (must make it unless already random moving)
        if ((entity.heat >= 5) && !a.isRandomMove()) {
            int controlAvoid = (5 + (entity.heat >= 10 ? 1 : 0) + (entity.heat >= 15 ? 1 : 0)
                    + (entity.heat >= 20 ? 1 : 0) + (entity.heat >= 25 ? 2 : 0)) - hotDogMod;
            int controlRoll = Compute.d6(2);
            Report r = new Report(9210);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(controlAvoid);
            r.add(controlRoll);
            if (controlRoll >= controlAvoid) {
                // in control
                r.choose(true);
                addReport(r);
            } else {
                // out of control
                r.choose(false);
                addReport(r);
                // if not already out of control, this may lead to
                // elevation decline
                if (!a.isOutControl() && !a.isSpaceborne()
                        && a.isAirborne()) {
                    int loss = Compute.d6(1);
                    r = new Report(9366);
                    r.newlines = 0;
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(loss);
                    addReport(r);
                    entity.setAltitude(entity.getAltitude() - loss);
                    // check for crash
                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {
                        addReport(processCrash(entity, a.getCurrentVelocity(), entity.getPosition()));
                    }
                }
                // force unit out of control through heat
                a.setOutCtrlHeat(true);
                a.setRandomMove(true);
            }
        }
    }

    private void resolveEmergencyCoolantSystem() {
        for (Entity e : game.getEntitiesVector()) {
            if ((e instanceof Mech) && e.hasWorkingMisc(MiscType.F_EMERGENCY_COOLANT_SYSTEM)
                    && (e.heat > 13)) {
                Mech mech = (Mech) e;
                Vector<Report> vDesc = new Vector<>();
                HashMap<Integer, List<CriticalSlot>> crits = new HashMap<>();
                if (!(mech.doRISCEmergencyCoolantCheckFor(vDesc, crits))) {
                    mech.heat -= 6 + mech.getCoolantSystemMOS();
                    Report r = new Report(5027);
                    r.add(6+mech.getCoolantSystemMOS());
                    vDesc.add(r);
                }
                addReport(vDesc);
                for (Integer loc : crits.keySet()) {
                    List<CriticalSlot> lcs = crits.get(loc);
                    for (CriticalSlot cs : lcs) {
                        addReport(applyCriticalHit(mech, loc, cs, true, 0, false));
                    }
                }
            }
        }
    }

    /*
     * Resolve HarJel II/III repairs for Mechs so equipped.
     */
    private void resolveHarJelRepairs() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if (!(entity instanceof Mech)) {
                continue;
            }

            Mech me = (Mech) entity;
            for (int loc = 0; loc < me.locations(); ++loc) {
                boolean harJelII = me.hasHarJelIIIn(loc); // false implies HarJel III
                if ((harJelII || me.hasHarJelIIIIn(loc))
                        && me.isArmorDamagedThisTurn(loc)) {
                    if (me.hasRearArmor(loc)) {
                        // must have at least one remaining armor in location
                        if (!((me.getArmor(loc) > 0) || (me.getArmor(loc, true) > 0))) {
                            continue;
                        }

                        int toRepair = harJelII ? 2 : 4;
                        int frontRepair, rearRepair;
                        int desiredFrontRepair, desiredRearRepair;

                        Mounted harJel = null;
                        // find HarJel item
                        // don't need to check ready or worry about null,
                        // we already know there is one, it's ready,
                        // and there can be at most one in a given location
                        for (Mounted m: me.getMisc()) {
                            if ((m.getLocation() == loc)
                                    && (m.getType().hasFlag(MiscType.F_HARJEL_II)
                                    || m.getType().hasFlag(MiscType.F_HARJEL_III))) {
                                harJel = m;
                            }
                        }

                        if (harJelII) {
                            if (harJel.curMode().equals(MiscType.S_HARJEL_II_1F1R)) {
                                desiredFrontRepair = 1;
                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_II_2F0R)) {
                                desiredFrontRepair = 2;
                            } else { // 0F2R
                                desiredFrontRepair = 0;
                            }
                        } else { // HarJel III
                            if (harJel.curMode().equals(MiscType.S_HARJEL_III_2F2R)) {
                                desiredFrontRepair = 2;
                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_4F0R)) {
                                desiredFrontRepair = 4;
                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_3F1R)) {
                                desiredFrontRepair = 3;
                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_1F3R)) {
                                desiredFrontRepair = 1;
                            } else { // 0F4R
                                desiredFrontRepair = 0;
                            }
                        }
                        desiredRearRepair = toRepair - desiredFrontRepair;

                        int availableFrontRepair = me.getOArmor(loc) - me.getArmor(loc);
                        int availableRearRepair = me.getOArmor(loc, true) - me.getArmor(loc, true);
                        frontRepair = Math.min(availableFrontRepair, desiredFrontRepair);
                        rearRepair = Math.min(availableRearRepair, desiredRearRepair);
                        int surplus = desiredFrontRepair - frontRepair;
                        if (surplus > 0) { // we couldn't use all the points we wanted in front
                            rearRepair = Math.min(availableRearRepair, rearRepair + surplus);
                        } else {
                            surplus = desiredRearRepair - rearRepair;
                            // try to move any excess points from rear to front
                            frontRepair = Math.min(availableFrontRepair, frontRepair + surplus);
                        }

                        if (frontRepair > 0) {
                            me.setArmor(me.getArmor(loc) + frontRepair, loc);
                            r = new Report(harJelII ? 9850 : 9851);
                            r.subject = me.getId();
                            r.addDesc(entity);
                            r.add(frontRepair);
                            r.add(me.getLocationAbbr(loc));
                            addReport(r);
                        }
                        if (rearRepair > 0) {
                            me.setArmor(me.getArmor(loc, true) + rearRepair, loc, true);
                            r = new Report(harJelII ? 9850 : 9851);
                            r.subject = me.getId();
                            r.addDesc(entity);
                            r.add(rearRepair);
                            r.add(me.getLocationAbbr(loc) + " (R)");
                            addReport(r);
                        }
                    } else {
                        // must have at least one remaining armor in location
                        if (!(me.getArmor(loc) > 0)) {
                            continue;
                        }
                        int toRepair = harJelII ? 2 : 4;
                        toRepair = Math.min(toRepair, me.getOArmor(loc) - me.getArmor(loc));
                        me.setArmor(me.getArmor(loc) + toRepair, loc);
                        r = new Report(harJelII ? 9850 : 9851);
                        r.subject = me.getId();
                        r.addDesc(entity);
                        r.add(toRepair);
                        r.add(me.getLocationAbbr(loc));
                        addReport(r);
                    }
                }
            }
        }
    }

    /**
     * Resolve Flaming Damage for the given Entity Taharqa: This is now updated
     * to TacOps rules which is much more lenient So I have change the name to
     * Flaming Damage rather than flaming death
     *
     * @param entity The <code>Entity</code> that may experience flaming damage.
     * @param coordinates the coordinate location of the fire
     */
    private void doFlamingDamage(final Entity entity, final Coords coordinates) {
        Report r;
        int boomRoll = Compute.d6(2);

        if ((entity.getMovementMode() == EntityMovementMode.VTOL) && !entity.infernos.isStillBurning()) {
            // VTOLs don't check as long as they are flying higher than
            // the burning terrain. TODO : Check for rules conformity (ATPM?)
            // according to maxtech, elevation 0 or 1 should be affected,
            // this makes sense for level 2 as well
            if (entity.getElevation() > 1) {
                return;
            }
        }
        // Battle Armor squads equipped with fire protection
        // gear automatically avoid flaming damage
        // TODO : can conventional infantry mount fire-resistant armor?
        if ((entity instanceof BattleArmor) && ((BattleArmor) entity).isFireResistant()) {
            r = new Report(5095);
            r.subject = entity.getId();
            r.indent(1);
            r.addDesc(entity);
            addReport(r);
            return;
        }

        // mechs shouldn't be here, but just in case
        if (entity instanceof Mech) {
            return;
        }

        // fire has no effect on dropships
        if (entity instanceof Dropship) {
            return;
        }

        // Must roll 8+ to survive...
        r = new Report(5100);
        r.subject = entity.getId();
        r.newlines = 0;
        r.addDesc(entity);
        r.add(coordinates.getBoardNum());
        r.add(boomRoll);
        if (boomRoll >= 8) {
            // phew!
            r.choose(true);
            addReport(r);
            Report.addNewline(vPhaseReport);
        } else {
            // eek
            r.choose(false);
            r.newlines = 1;
            addReport(r);
            // gun emplacements have their own critical rules
            if (entity instanceof GunEmplacement) {
                Vector<GunEmplacement> gun = new Vector<>();
                gun.add((GunEmplacement) entity);

                Building building = getGame().getBoard().getBuildingAt(entity.getPosition());

                Report.addNewline(vPhaseReport);
                addReport(criticalGunEmplacement(gun, building, entity.getPosition()));
                // Taharqa: TacOps rules, protos and vees no longer die instantly
                // (hurray!)
            } else if (entity instanceof Tank) {
                int bonus = -2;
                if ((entity instanceof SupportTank) || (entity instanceof SupportVTOL)) {
                    bonus = 0;
                }
                // roll a critical hit
                Report.addNewline(vPhaseReport);
                addReport(criticalTank((Tank) entity, Tank.LOC_FRONT, bonus, 0, true));
            } else if (entity instanceof Protomech) {
                // this code is taken from inferno hits
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                if (hit.getLocation() == Protomech.LOC_NMISS) {
                    Protomech proto = (Protomech) entity;
                    r = new Report(6035);
                    r.subject = entity.getId();
                    r.indent(2);
                    if (proto.isGlider()) {
                        r.messageId = 6036;
                        proto.setWingHits(proto.getWingHits() + 1);
                    }
                    addReport(r);
                } else {
                    r = new Report(6690);
                    r.subject = entity.getId();
                    r.indent(1);
                    r.add(entity.getLocationName(hit));
                    addReport(r);
                    entity.destroyLocation(hit.getLocation());
                    // Handle ProtoMech pilot damage due to location destruction
                    int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]
                            - ((Protomech) entity).getPilotDamageTaken(hit.getLocation());
                    if (hits > 0) {
                        addReport(damageCrew(entity, hits));
                        ((Protomech) entity).setPilotDamageTaken(hit.getLocation(),
                                Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);
                    }
                    if (entity.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                        addReport(destroyEntity(entity, "flaming death", false, true));
                        Report.addNewline(vPhaseReport);
                    }
                }
            } else {
                // sucks to be you
                addReport(destroyEntity(entity, "fire", false, false));
                Report.addNewline(vPhaseReport);
            }
        }
    }

    private void clearFlawedCoolingFlags(Entity entity) {
        // If we're not using quirks, no need to do this check.
        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {
            return;
        }
        // Only applies to Mechs.
        if (!(entity instanceof Mech)) {
            return;
        }

        // Check for existence of flawed cooling quirk.
        if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {
            return;
        }
        entity.setFallen(false);
        entity.setStruck(false);
    }

    private void checkForFlawedCooling() {

        // If we're not using quirks, no need to do this check.
        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {
            return;
        }

        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();

            // Only applies to Mechs.
            if (!(entity instanceof Mech)) {
                continue;
            }

            // Check for existence of flawed cooling quirk.
            if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {
                continue;
            }

            // Check for active Cooling Flaw
            if (((Mech) entity).isCoolingFlawActive()) {
                continue;
            }

            // Perform the check.
            if (entity.damageThisPhase >= 20) {
                addReport(doFlawedCoolingCheck("20+ damage", entity));
            }
            if (entity.hasFallen()) {
                addReport(doFlawedCoolingCheck("fall", entity));
            }
            if (entity.wasStruck()) {
                addReport(doFlawedCoolingCheck("being struck", entity));
            }
            clearFlawedCoolingFlags(entity);
        }
    }

    /**
     * Checks to see if Flawed Cooling is triggered and generates a report of
     * the result.
     *
     * @param reason
     * @param entity
     * @return
     */
    private Vector<Report> doFlawedCoolingCheck(String reason, Entity entity) {
        Vector<Report> out = new Vector<>();
        Report r = new Report(9800);
        r.addDesc(entity);
        r.add(reason);
        int roll = Compute.d6(2);
        r.add(roll);
        out.add(r);
        if (roll >= 10) {
            Report s = new Report(9805);
            ((Mech) entity).setCoolingFlawActive(true);
            out.add(s);
        }

        return out;
    }

    /**
     * For chain whip grapples, a roll needs to be made at the end of the
     * physical phase to maintain the grapple.
     */
    private void checkForChainWhipGrappleChecks() {
        for (Entity ae : game.getEntitiesVector()) {
            if ((ae.getGrappled() != Entity.NONE) && ae.isChainWhipGrappled()
                    && ae.isGrappleAttacker() && !ae.isGrappledThisRound()) {
                Entity te = game.getEntity(ae.getGrappled());
                ToHitData grappleHit = GrappleAttackAction.toHit(game,
                        ae.getId(), te, ae.getGrappleSide(), true);
                int roll = Compute.d6(2);

                Report r = new Report(4317);
                r.subject = ae.getId();
                r.indent();
                r.addDesc(ae);
                r.addDesc(te);
                r.newlines = 0;
                addReport(r);

                if (grappleHit.getValue() == TargetRoll.IMPOSSIBLE) {
                    r = new Report(4300);
                    r.subject = ae.getId();
                    r.add(grappleHit.getDesc());
                    addReport(r);
                    return;
                }

                // report the roll
                r = new Report(4025);
                r.subject = ae.getId();
                r.add(grappleHit);
                r.add(roll);
                r.newlines = 0;
                addReport(r);

                // do we hit?
                if (roll >= grappleHit.getValue()) {
                    // hit
                    r = new Report(4040);
                    r.subject = ae.getId();
                    addReport(r);
                    // Nothing else to do
                    return;
                }

                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);

                // Need to break grapple
                ae.setGrappled(Entity.NONE, false);
                te.setGrappled(Entity.NONE, false);
            }
        }
    }

    /**
     * Checks to see if any entity takes enough damage that requires them to make a piloting roll
     */
    private void checkForPSRFromDamage() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if (entity.canFall()) {
                if (entity.isAirborne()) {
                    // You can't fall over when you are combat dropping because you are already
                    // falling!
                    continue;
                }
                // If this mek has 20+ damage, add another roll to the list.
                // Hulldown meks ignore this rule, TO Errata
                int psrThreshold = 20;
                if ((((Mech) entity).getCockpitType() == Mech.COCKPIT_DUAL)
                        && entity.getCrew().hasDedicatedPilot()) {
                    psrThreshold = 30;
                }
                if ((entity.damageThisPhase >= psrThreshold) && !entity.isHullDown()) {
                    if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_TAKING_DAMAGE)) {
                        PilotingRollData damPRD = new PilotingRollData(entity.getId());
                        int damMod = entity.damageThisPhase / psrThreshold;
                        damPRD.addModifier(damMod, (damMod * psrThreshold) + "+ damage");
                        int weightMod = 0;
                        if (getGame().getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_PSR)) {
                            switch (entity.getWeightClass()) {
                                case EntityWeightClass.WEIGHT_LIGHT:
                                    weightMod = 1;
                                    break;
                                case EntityWeightClass.WEIGHT_MEDIUM:
                                    weightMod = 0;
                                    break;
                                case EntityWeightClass.WEIGHT_HEAVY:
                                    weightMod = -1;
                                    break;
                                case EntityWeightClass.WEIGHT_ASSAULT:
                                    weightMod = -2;
                                    break;
                            }
                            if (entity.isSuperHeavy()) {
                                weightMod = -4;
                            }
                            // the weight class PSR modifier is not cumulative
                            damPRD.addModifier(weightMod, "weight class modifier", false);
                        }

                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                                && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        getGame().addPSR(damPRD);
                    } else {
                        PilotingRollData damPRD = new PilotingRollData(entity.getId(), 1,
                                psrThreshold + "+ damage");
                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                                && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        getGame().addPSR(damPRD);
                    }
                }
            }
            if (entity.isAero() && entity.isAirborne() && !game.getBoard().inSpace()) {
                // if this aero has any damage, add another roll to the list.
                if (entity.damageThisPhase > 0) {
                    if (!getGame().getOptions().booleanOption(OptionsConstants.ADVAERORULES_ATMOSPHERIC_CONTROL)) {
                        int damMod = entity.damageThisPhase / 20;
                        PilotingRollData damPRD = new PilotingRollData(entity.getId(), damMod,
                                entity.damageThisPhase + " damage +" + damMod);
                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                                && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        getGame().addControlRoll(damPRD);
                    } else {
                        // was the damage threshold exceeded this round?
                        if (((IAero) entity).wasCritThresh()) {
                            PilotingRollData damThresh = new PilotingRollData(entity.getId(), 0,
                                    "damage threshold exceeded");
                            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                                    && (entity.getCrew().getPiloting() > 3)) {
                                damThresh.addModifier(-1, "easy to pilot");
                            }
                            getGame().addControlRoll(damThresh);
                        }
                    }
                }
            }
            // Airborne AirMechs that take 20+ damage make a control roll instead of a PSR.
            if ((entity instanceof LandAirMech) && entity.isAirborneVTOLorWIGE()
                    && (entity.damageThisPhase >= 20)) {
                PilotingRollData damPRD = new PilotingRollData(entity.getId());
                int damMod = entity.damageThisPhase / 20;
                damPRD.addModifier(damMod, (damMod * 20) + "+ damage");
                getGame().addControlRoll(damPRD);
            }
        }
    }

    /**
     * Checks to see if any non-mech units are standing in fire. Called at the end of the movement
     * phase
     */
    public void checkForFlamingDamage() {
        for (Iterator<Entity> i = getGame().getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || (entity instanceof Mech)
                    || entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard()) {
                continue;
            }
            final Hex curHex = getGame().getBoard().getHex(entity.getPosition());
            final boolean underwater = curHex.containsTerrain(Terrains.WATER)
                    && (curHex.depth() > 0)
                    && (entity.getElevation() < curHex.getLevel());
            final int numFloors = curHex.terrainLevel(Terrains.BLDG_ELEV);
            if (curHex.containsTerrain(Terrains.FIRE) && !underwater
                    && ((entity.getElevation() <= 1)
                    || (entity.getElevation() <= numFloors))) {
                doFlamingDamage(entity, entity.getPosition());
            }
        }
    }

    /**
     * Checks to see if any telemissiles are in a hex with enemy units. If so,
     * then attack one.
     */
    private void checkForTeleMissileAttacks() {
        for (Iterator<Entity> i = getGame().getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if (entity instanceof TeleMissile) {
                // check for enemy units
                Vector<Integer> potTargets = new Vector<>();
                for (Entity te : getGame().getEntitiesVector(entity.getPosition())) {
                    //Telemissiles cannot target fighters or other telemissiles
                    //Fighters don't have a distinctive Etype flag, so we have to do
                    //this by exclusion.
                    if (!(te.hasETypeFlag(Entity.ETYPE_DROPSHIP)
                            || te.hasETypeFlag(Entity.ETYPE_SMALL_CRAFT)
                            || te.hasETypeFlag(Entity.ETYPE_JUMPSHIP)
                            || te.hasETypeFlag(Entity.ETYPE_WARSHIP)
                            || te.hasETypeFlag(Entity.ETYPE_SPACE_STATION))) {
                        continue;
                    }
                    if (te.isEnemyOf(entity)) {
                        // then add it to a vector of potential targets
                        potTargets.add(te.getId());
                    }
                }
                if (!potTargets.isEmpty()) {
                    // determine randomly
                    Entity target = getGame().getEntity(potTargets.get(Compute
                            .randomInt(potTargets.size())));
                    // report this and add a new TeleMissileAttackAction
                    Report r = new Report(9085);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.addDesc(target);
                    addReport(r);
                    getGame().addTeleMissileAttack(new TeleMissileAttackAction(entity, target));
                }
            }
        }
    }

    private void checkForBlueShieldDamage() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if (!(entity instanceof Aero) && entity.hasActiveBlueShield()
                    && (entity.getBlueShieldRounds() >= 6)) {
                int roll = Compute.d6(2);
                int target = (3 + entity.getBlueShieldRounds()) - 6;
                r = new Report(1240);
                r.addDesc(entity);
                r.add(target);
                r.add(roll);
                if (roll < target) {
                    for (Mounted m : entity.getMisc()) {
                        if (m.getType().hasFlag(MiscType.F_BLUE_SHIELD)) {
                            m.setBreached(true);
                        }
                    }
                    r.choose(true);
                } else {
                    r.choose(false);
                }
                vPhaseReport.add(r);
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in certain planetary conditions.
     */
    private void checkForConditionDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) && !entity.isOffBoard() || (entity.getTransportId() != Entity.NONE)) {
                // Ignore transported units, and units that don't have a position for some unknown reason
                continue;
            }
            String reason = game.getPlanetaryConditions().whyDoomed(entity, game);
            if (null != reason) {
                r = new Report(6015);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(reason);
                addReport(r);
                addReport(destroyEntity(entity, reason, true, true));
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in atmosphere.
     */
    private void checkForAtmosphereDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if (entity.doomedInAtmosphere() && (entity.getAltitude() == 0)) {
                r = new Report(6016);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity,
                        "being in atmosphere where it can't survive", true,
                        true));
            }
        }
    }

    /**
     * checks if IndustrialMechs should die because they moved into to-deep
     * water last round
     */
    private void checkForIndustrialWaterDeath() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if ((entity instanceof Mech) && ((Mech) entity).isIndustrial()
                    && ((Mech) entity).shouldDieAtEndOfTurnBecauseOfWater()) {
                addReport(destroyEntity(entity,
                        "being in water without environmental shielding", true,
                        true));
            }

        }
    }

    private void checkForIndustrialEndOfTurn() {
        checkForIndustrialWaterDeath();
        checkForIndustrialUnstall();
        checkForIndustrialCrit(); // This might hit an actuator or gyro, so...
        addReport(resolvePilotingRolls());
    }

    private void checkForIndustrialUnstall() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            entity.checkUnstall(vPhaseReport);
        }
    }

    /**
     * industrial mechs might need to check for critical damage
     */
    private void checkForIndustrialCrit() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((entity instanceof Mech) && ((Mech) entity).isIndustrial()) {
                Mech mech = (Mech) entity;
                // should we check for critical damage?
                if (mech.isCheckForCrit()) {
                    Report r = new Report(5530);
                    r.addDesc(mech);
                    r.subject = mech.getId();
                    r.newlines = 0;
                    vPhaseReport.add(r);
                    // for being hit by a physical weapon
                    if (mech.getLevelsFallen() == 0) {
                        r = new Report(5531);
                        r.subject = mech.getId();
                        // or for falling
                    } else {
                        r = new Report(5532);
                        r.subject = mech.getId();
                        r.add(mech.getLevelsFallen());
                    }
                    vPhaseReport.add(r);
                    HitData newHit = mech.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    vPhaseReport.addAll(criticalEntity(mech,
                            newHit.getLocation(), newHit.isRear(),
                            mech.getLevelsFallen(), 0));
                }
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in space.
     */
    private void checkForSpaceDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if (entity.doomedInSpace()) {
                r = new Report(6017);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity,
                        "being in space where it can't survive", true, true));
            }
        }
    }

    /**
     * Checks to see if any entities are underwater (or in vacuum) with damaged
     * life support. Called during the end phase.
     */
    private void checkForSuffocation() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                continue;
            }
            final Hex curHex = game.getBoard().getHex(entity.getPosition());
            if ((((entity.getElevation() < 0) && ((curHex
                    .terrainLevel(Terrains.WATER) > 1) || ((curHex
                    .terrainLevel(Terrains.WATER) == 1) && entity.isProne()))) || game
                    .getPlanetaryConditions().isVacuum())
                    && (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                    Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) > 0)) {
                Report r = new Report(6020);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(damageCrew(entity, 1));

            }
        }
    }

    /**
     * Iterates over all entities and gets rid of Narc pods attached to destroyed
     * or lost locations.
     */
    private void cleanupDestroyedNarcPods() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            i.next().clearDestroyedNarcPods();
        }
    }

    /**
     * Resolves all built up piloting skill rolls. Used at end of weapons,
     * physical phases.
     */
    private Vector<Report> resolvePilotingRolls() {
        Vector<Report> vPhaseReport = new Vector<>();
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vPhaseReport.addAll(resolvePilotingRolls(i.next()));
        }
        game.resetPSRs();
        return vPhaseReport;
    }

    /**
     * Resolves and reports all piloting skill rolls for a single mech.
     */
    private Vector<Report> resolvePilotingRolls(Entity entity) {
        return resolvePilotingRolls(entity, false, entity.getPosition(),
                entity.getPosition());
    }

    private Vector<Report> resolvePilotingRolls(Entity entity, boolean moving,
                                                Coords src, Coords dest) {
        Vector<Report> vPhaseReport = new Vector<>();
        // dead and undeployed and offboard units don't need to.
        if (entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard() || !entity.isDeployed()
                || (entity.getTransportId() != Entity.NONE)) {
            return vPhaseReport;
        }

        // airborne units don't make piloting rolls, they make control rolls
        if (entity.isAirborne()) {
            return vPhaseReport;
        }

        Report r;

        // first, do extreme gravity PSR, because non-mechs do these, too
        PilotingRollData rollTarget = null;
        for (Enumeration<PilotingRollData> i = game.getExtremeGravityPSRs(); i.hasMoreElements(); ) {
            final PilotingRollData roll = i.nextElement();
            if (roll.getEntityId() != entity.getId()) {
                continue;
            }
            // found a roll, use it (there can be only 1 per entity)
            rollTarget = roll;
            game.resetExtremeGravityPSRs(entity);
        }
        if ((rollTarget != null) && (rollTarget.getValue() != TargetRoll.CHECK_FALSE)) {
            // okay, print the info
            r = new Report(2180);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rollTarget.getLastPlainDesc());
            vPhaseReport.add(r);
            // roll
            final int diceRoll = Compute.d6(2);
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            if ((diceRoll < rollTarget.getValue())
                    || (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)
                    && (diceRoll == 2))) {
                r.choose(false);
                // Report the fumble
                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)
                        && (diceRoll == 2)) {
                    r.messageId = 2306;
                }
                vPhaseReport.add(r);
                // walking and running, 1 damage per MP used more than we would
                // have normally
                if ((entity.moved == EntityMovementType.MOVE_WALK)
                        || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                        || (entity.moved == EntityMovementType.MOVE_RUN)
                        || (entity.moved == EntityMovementType.MOVE_SPRINT)
                        || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                        || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)) {
                    if (entity instanceof Mech) {
                        int j = entity.mpUsed;
                        int damage = 0;
                        while (j > entity.getRunningGravityLimit()) {
                            j--;
                            damage++;
                        }
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                damage));
                    } else if (entity instanceof Tank) {
                        // if we got a pavement bonus, take care of it
                        int k = entity.gotPavementBonus ? 1 : 0;
                        if (!entity.gotPavementBonus) {
                            int j = entity.mpUsed;
                            int damage = 0;
                            while (j > (entity.getRunMP(false, false, false) + k)) {
                                j--;
                                damage++;
                            }
                            vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                    damage));
                        }
                    }
                }
                // jumping
                if ((entity.moved == EntityMovementType.MOVE_JUMP)
                        && (entity instanceof Mech)) {
                    // low g, 1 damage for each hex jumped further than
                    // possible normally
                    if (game.getPlanetaryConditions().getGravity() < 1) {
                        int j = entity.mpUsed;
                        int damage = 0;
                        while (j > entity.getJumpMP(false)) {
                            j--;
                            damage++;
                        }
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                damage));
                    }
                    // high g, 1 damage for each MP we have less than normally
                    else if (game.getPlanetaryConditions().getGravity() > 1) {
                        int damage = entity.getWalkMP(false, false)
                                - entity.getWalkMP();
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                damage));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
            } else {
                r.choose(true);
                vPhaseReport.add(r);
            }
        }

        // Glider ProtoMechs without sufficient movement to stay airborne make forced landings.
        if ((entity instanceof Protomech) && ((Protomech) entity).isGlider()
                && entity.isAirborneVTOLorWIGE() && (entity.getRunMP() < 4)) {
            vPhaseReport.addAll(landGliderPM((Protomech) entity, entity.getPosition(), entity.getElevation(),
                    entity.delta_distance));
        }

        // non mechs and prone mechs can now return
        if (!entity.canFall() || (entity.isHullDown() && entity.canGoHullDown())) {
            return vPhaseReport;
        }

        // Mechs with UMU float and don't have to roll???
        if (entity instanceof Mech) {
            Hex hex = game.getBoard().getHex(dest);
            int water = hex.terrainLevel(Terrains.WATER);
            if ((water > 0) && (entity.getElevation() != -hex.depth(true))
                    && ((entity.getElevation() < 0) || ((entity.getElevation() == 0)
                    && (hex.terrainLevel(Terrains.BRIDGE_ELEV) != 0) && !hex.containsTerrain(Terrains.ICE)))
                    && !entity.isMakingDfa() && !entity.isDropping()) {
                // mech is floating in water....
                if (entity.hasUMU()) {
                    return vPhaseReport;
                }
                // game.addPSR(new PilotingRollData(entity.getId(),
                // TargetRoll.AUTOMATIC_FAIL, "lost buoyancy"));
            }
        }
        // add all cumulative mods from other rolls to each PSR
        // holds all rolls to make
        Vector<PilotingRollData> rolls = new Vector<>();
        // holds the initial reason for each roll
        StringBuilder reasons = new StringBuilder();
        PilotingRollData base = entity.getBasePilotingRoll();
        entity.addPilotingModifierForTerrain(base);
        for (Enumeration<PilotingRollData> i = game.getPSRs(); i.hasMoreElements(); ) {
            PilotingRollData psr = i.nextElement();
            if (psr.getEntityId() != entity.getId()) {
                continue;
            }
            // found a roll
            if (reasons.length() > 0) {
                reasons.append("; ");
            }
            reasons.append(psr.getPlainDesc());
            PilotingRollData toUse = entity.getBasePilotingRoll();
            entity.addPilotingModifierForTerrain(toUse);
            toUse.append(psr);
            // now, append all other roll's cumulative mods, not the
            // non-cumulative
            // ones
            for (Enumeration<PilotingRollData> j = game.getPSRs(); j.hasMoreElements(); ) {
                final PilotingRollData other = j.nextElement();
                if ((other.getEntityId() != entity.getId()) || other.equals(psr)) {
                    continue;
                }
                toUse.append(other, false);
            }
            rolls.add(toUse);
        }
        // any rolls needed?
        if (rolls.isEmpty()) {
            return vPhaseReport;
        }
        // is our base roll impossible?
        if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL)
                || (base.getValue() == TargetRoll.IMPOSSIBLE)) {
            r = new Report(2275);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rolls.size());
            r.add(base.getDesc());
            vPhaseReport.add(r);
            if (moving) {
                vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,
                        base, true));
            } else if ((entity instanceof Mech) && game.getOptions().booleanOption(
                    OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
                    && (entity.getCrew().getPiloting() < 6)
                    && !entity.isHullDown() && entity.canGoHullDown()) {
                if (entity.isHullDown() && entity.canGoHullDown()) {
                    r = new Report(2317);
                    r.subject = entity.getId();
                    r.add(entity.getDisplayName());
                    vPhaseReport.add(r);
                } else {
                    vPhaseReport.addAll(doEntityFall(entity, base));
                }
            } else {
                vPhaseReport.addAll(doEntityFall(entity, base));
            }
            // failed a PSR, check for ICE engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return vPhaseReport;
        }
        // loop through rolls we do have to make...
        r = new Report(2280);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(rolls.size());
        r.add(reasons.toString());
        vPhaseReport.add(r);
        r = new Report(2285);
        r.subject = entity.getId();
        r.add(base.getValueAsString());
        r.add(base.getDesc());
        vPhaseReport.add(r);
        for (int i = 0; i < rolls.size(); i++) {
            PilotingRollData roll = rolls.elementAt(i);
            r = new Report(2290);
            r.subject = entity.getId();
            r.indent();
            r.newlines = 0;
            r.add(i + 1);
            r.add(roll.getDesc());
            vPhaseReport.add(r);
            if ((roll.getValue() == TargetRoll.AUTOMATIC_FAIL)
                    || (roll.getValue() == TargetRoll.IMPOSSIBLE)) {
                r = new Report(2295);
                r.subject = entity.getId();
                vPhaseReport.add(r);
                if (moving) {
                    vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,
                            roll, true));
                } else {
                    if ((entity instanceof Mech)
                            && game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
                            && (entity.getCrew().getPiloting() < 6)
                            && !entity.isHullDown() && entity.canGoHullDown()) {
                        if (entity.isHullDown() && entity.canGoHullDown()) {
                            r = new Report(2317);
                            r.subject = entity.getId();
                            r.add(entity.getDisplayName());
                            vPhaseReport.add(r);
                        } else {
                            vPhaseReport.addAll(doEntityFall(entity, roll));
                        }
                    } else {
                        vPhaseReport.addAll(doEntityFall(entity, roll));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
                return vPhaseReport;
            }
            int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2300);
            r.add(roll);
            r.add(diceRoll);
            r.subject = entity.getId();
            if ((diceRoll < roll.getValue())
                    || (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES) && (diceRoll == 2))) {
                r.choose(false);
                // Report the fumble
                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)
                        && (diceRoll == 2)) {
                    r.messageId = 2306;
                }
                vPhaseReport.add(r);
                if (moving) {
                    vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest, roll, true));
                } else {
                    if ((entity instanceof Mech)
                            && game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
                            && (entity.getCrew().getPiloting() < 6)
                            && !entity.isHullDown() && entity.canGoHullDown()) {
                        if ((entity.getCrew().getPiloting() > 1)
                                && ((roll.getValue() - diceRoll) < 2)) {
                            entity.setHullDown(true);
                        } else if ((entity.getCrew().getPiloting() <= 1)
                                && ((roll.getValue() - diceRoll) < 3)) {
                            entity.setHullDown(true);
                        }

                        if (entity.isHullDown() && entity.canGoHullDown()) {
                            ServerHelper.sinkToBottom(entity);

                            r = new Report(2317);
                            r.subject = entity.getId();
                            r.add(entity.getDisplayName());
                            vPhaseReport.add(r);
                        } else {
                            vPhaseReport.addAll(doEntityFall(entity, roll));
                        }
                    } else {
                        vPhaseReport.addAll(doEntityFall(entity, roll));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
                return vPhaseReport;
            }
            r.choose(true);
            vPhaseReport.add(r);
        }
        return vPhaseReport;
    }

    private Vector<Report> checkForTraitors() {
        Vector<Report> vFullReport = new Vector<>();
        // check for traitors
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if (entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard()
                    || !entity.isDeployed()) {
                continue;
            }
            if ((entity.getTraitorId() != -1) && (entity.getOwnerId() != entity.getTraitorId())) {
                final Player oldPlayer = game.getPlayer(entity.getOwnerId());
                final Player newPlayer = game.getPlayer(entity.getTraitorId());
                if (newPlayer != null) {
                    Report r = new Report(7305);
                    r.subject = entity.getId();
                    r.add(entity.getDisplayName());
                    r.add(newPlayer.getName());
                    entity.setOwner(newPlayer);
                    entityUpdate(entity.getId());
                    vFullReport.add(r);

                    // Move the initial count and BV to their new player
                    newPlayer.changeInitialEntityCount(1);
                    newPlayer.changeInitialBV(entity.calculateBattleValue());

                    // And remove it from their old player, if they exist
                    if (oldPlayer != null) {
                        oldPlayer.changeInitialEntityCount(-1);
                        // Note: I don't remove the full initial BV if I'm damaged, but that
                        // actually makes sense
                        oldPlayer.changeInitialBV(-1 * entity.calculateBattleValue());
                    }
                }
                entity.setTraitorId(-1);
            }
        }

        if (!vFullReport.isEmpty()) {
            vFullReport.add(0, new Report(7300));
        }

        return vFullReport;
    }

    /**
     * Resolves all built up control rolls. Used only during end phase
     */
    private Vector<Report> resolveControlRolls() {
        Vector<Report> vFullReport = new Vector<>();
        vFullReport.add(new Report(5001, Report.PUBLIC));
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vFullReport.addAll(resolveControl(i.next()));
        }
        game.resetControlRolls();
        return vFullReport;
    }

    /**
     * Resolves and reports all control skill rolls for a single aero or airborne LAM in airmech mode.
     */
    private Vector<Report> resolveControl(Entity e) {
        Vector<Report> vReport = new Vector<>();
        if (e.isDoomed() || e.isDestroyed() || e.isOffBoard() || !e.isDeployed()) {
            return vReport;
        }
        Report r;

        /*
         * See forum answers on OOC
         * http://forums.classicbattletech.com/index.php/topic,20424.0.html
         */

        IAero a = null;
        boolean canRecover = false;
        if (e.isAero() && (e.isAirborne() || e.isSpaceborne())) {
            a = (IAero) e;
            // they should get a shot at a recovery roll at the end of all this
            // if they are already out of control
            canRecover = a.isOutControl();
        } else if (!(e instanceof LandAirMech) || !e.isAirborneVTOLorWIGE()) {
            return vReport;
        }

        // if the unit already is moving randomly then it can't get any worse
        if (a == null || !a.isRandomMove()) {
            // find control rolls and make them
            Vector<PilotingRollData> rolls = new Vector<>();
            StringBuilder reasons = new StringBuilder();
            PilotingRollData target = e.getBasePilotingRoll();
            // maneuvering ace
            // TODO : pending rules query
            // http://www.classicbattletech.com/forums/index.php/topic,63552.new.html#new
            // for now I am assuming Man Ace applies to all out-of-control
            // rolls, but not other
            // uses of control rolls (thus it doesn't go in
            // Entity#addEntityBonuses) and
            // furthermore it doesn't apply to recovery rolls
            if (e.isUsingManAce()) {
                target.addModifier(-1, "maneuvering ace");
            }
            for (Enumeration<PilotingRollData> j = game.getControlRolls(); j.hasMoreElements(); ) {
                final PilotingRollData modifier = j.nextElement();
                if (modifier.getEntityId() != e.getId()) {
                    continue;
                }
                // found a roll, add it
                rolls.addElement(modifier);
                if (reasons.length() > 0) {
                    reasons.append("; ");
                }
                reasons.append(modifier.getCumulativePlainDesc());
                target.append(modifier);
            }
            // any rolls needed?
            if (!rolls.isEmpty()) {
                // loop through rolls we do have to make...
                r = new Report(9310);
                r.subject = e.getId();
                r.addDesc(e);
                r.add(rolls.size());
                r.add(reasons.toString());
                vReport.add(r);
                r = new Report(2285);
                r.subject = e.getId();
                r.add(target.getValueAsString());
                r.add(target.getDesc());
                vReport.add(r);
                for (int j = 0; j < rolls.size(); j++) {
                    PilotingRollData modifier = rolls.elementAt(j);
                    r = new Report(2290);
                    r.subject = e.getId();
                    r.indent();
                    r.newlines = 0;
                    r.add(j + 1);
                    r.add(modifier.getPlainDesc());
                    vReport.add(r);
                    int diceRoll = Compute.d6(2);
                    // different reports depending on out-of-control status
                    if (a != null && a.isOutControl()) {
                        r = new Report(9360);
                        r.subject = e.getId();
                        r.add(target);
                        r.add(diceRoll);
                        if (diceRoll < (target.getValue() - 5)) {
                            r.choose(false);
                            vReport.add(r);
                            a.setRandomMove(true);
                        } else {
                            r.choose(true);
                            vReport.add(r);
                        }
                    } else {
                        r = new Report(9315);
                        r.subject = e.getId();
                        r.add(target);
                        r.add(diceRoll);
                        r.newlines = 1;
                        if (diceRoll < target.getValue()) {
                            r.choose(false);
                            vReport.add(r);
                            if (a != null) {
                                a.setOutControl(true);
                                // do we have random movement?
                                if ((target.getValue() - diceRoll) > 5) {
                                    r = new Report(9365);
                                    r.newlines = 0;
                                    r.subject = e.getId();
                                    vReport.add(r);
                                    a.setRandomMove(true);
                                }
                                // if on the atmospheric map, then lose altitude
                                // and check
                                // for crash
                                if (!a.isSpaceborne() && a.isAirborne()) {
                                    int loss = Compute.d6(1);
                                    int origAltitude = e.getAltitude();
                                    e.setAltitude(e.getAltitude() - loss);
                                    // Reroll altitude loss with edge if the new altitude would result in a crash
                                    if (e.getAltitude() <= 0
                                            // Don't waste the edge if it won't help
                                            && origAltitude > 1
                                            && e.getCrew().hasEdgeRemaining()
                                            && e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_ALT_LOSS)) {
                                        loss = Compute.d6(1);
                                        // Report the edge use
                                        r = new Report(9367);
                                        r.newlines = 1;
                                        r.subject = e.getId();
                                        vReport.add(r);
                                        e.setAltitude(origAltitude - loss);
                                        // and spend the edge point
                                        e.getCrew().decreaseEdge();
                                    }
                                    //Report the altitude loss
                                    r = new Report(9366);
                                    r.newlines = 0;
                                    r.subject = e.getId();
                                    r.addDesc(e);
                                    r.add(loss);
                                    vReport.add(r);
                                    // check for crash
                                    if (checkCrash(e, e.getPosition(), e.getAltitude())) {
                                        vReport.addAll(processCrash(e, a.getCurrentVelocity(),
                                                e.getPosition()));
                                        break;
                                    }
                                }
                            } else if (e.isAirborneVTOLorWIGE()) {
                                int loss = target.getValue() - diceRoll;
                                r = new Report(9366);
                                r.subject = e.getId();
                                r.addDesc(e);
                                r.add(loss);
                                vReport.add(r);
                                Hex hex = game.getBoard().getHex(e.getPosition());
                                int elevation = Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));
                                if (e.getElevation() - loss <= elevation) {
                                    crashAirMech(e, target, vReport);
                                } else {
                                    e.setElevation(e.getElevation() - loss);
                                }
                            }
                        } else {
                            r.choose(true);
                            vReport.add(r);
                        }
                    }
                }
            }
        }

        // if they were out-of-control to start with, give them a chance to regain control
        if (canRecover) {
            PilotingRollData base = e.getBasePilotingRoll();
            // is our base roll impossible?
            if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL)
                    || (base.getValue() == TargetRoll.IMPOSSIBLE)) {
                // report something
                r = new Report(9340);
                r.subject = e.getId();
                r.addDesc(e);
                r.add(base.getDesc());
                vReport.add(r);
                return vReport;
            }
            r = new Report(9345);
            r.subject = e.getId();
            r.addDesc(e);
            r.add(base.getDesc());
            vReport.add(r);
            int diceRoll = Compute.d6(2);
            r = new Report(9350);
            r.subject = e.getId();
            r.add(base);
            r.add(diceRoll);
            if (diceRoll < base.getValue()) {
                r.choose(false);
                vReport.add(r);
            } else {
                r.choose(true);
                vReport.add(r);
                a.setOutControl(false);
                a.setOutCtrlHeat(false);
                a.setRandomMove(false);
            }
        }
        return vReport;
    }

    /**
     * Inflict damage on a pilot
     *
     * @param en     The <code>Entity</code> who's pilot gets damaged.
     * @param damage The <code>int</code> amount of damage.
     */
    public Vector<Report> damageCrew(Entity en, int damage) {
        return damageCrew(en, damage, -1);
    }

    /**
     * Inflict damage on a pilot
     *
     * @param en        The <code>Entity</code> who's pilot gets damaged.
     * @param damage    The <code>int</code> amount of damage.
     * @param crewPos   The <code>int</code>position of the crew member in a <code>MultiCrewCockpit</code>
     *                  that takes the damage. A value &lt; 0 applies the damage to all crew members.
     *                  The basic <code>Crew</code> ignores this value.
     */
    public Vector<Report> damageCrew(Entity en, int damage, int crewPos) {
        Vector<Report> vDesc = new Vector<>();
        Crew crew = en.getCrew();
        Report r;
        if (!crew.isDead() && !crew.isEjected() && !crew.isDoomed()) {
            for (int pos = 0; pos < en.getCrew().getSlotCount(); pos++) {
                if (crewPos >= 0
                        && (crewPos != pos || crew.isDead(crewPos))) {
                    continue;
                }
                boolean wasPilot = crew.getCurrentPilotIndex() == pos;
                boolean wasGunner = crew.getCurrentGunnerIndex() == pos;
                crew.setHits(crew.getHits(pos) + damage, pos);
                if (en.isLargeCraft()) {
                    r = new Report (6028);
                    r.subject = en.getId();
                    r.indent(2);
                    r.addDesc(en);
                    r.add(damage);
                    if (((Aero) en).isEjecting()) {
                        r.add("as crew depart the ship");
                    } else {
                        //Blank data
                        r.add("");
                    }
                    r.add(crew.getHits(pos));
                    vDesc.addElement(r);
                    if (Crew.DEATH > crew.getHits()) {
                        vDesc.addAll(resolveCrewDamage(en, damage, pos));
                    } else if (!crew.isDoomed()) {
                        crew.setDoomed(true);
                        //Safety. We might use this logic for large naval vessels later on
                        if (en instanceof Aero && ((Aero) en).isEjecting()) {
                            vDesc.addAll(destroyEntity(en, "ejection", true));
                            ((Aero) en).setEjecting(false);
                        } else {
                            vDesc.addAll(destroyEntity(en, "crew casualties", true));
                        }
                    }
                } else {
                    if (Crew.DEATH > crew.getHits(pos)) {
                        r = new Report(6025);
                    } else {
                        r = new Report(6026);
                    }
                    r.subject = en.getId();
                    r.indent(2);
                    r.add(crew.getCrewType().getRoleName(pos));
                    r.addDesc(en);
                    r.add(crew.getName(pos));
                    r.add(damage);
                    r.add(crew.getHits(pos));
                    vDesc.addElement(r);
                    if (crew.isDead(pos)) {
                        r = createCrewTakeoverReport(en, pos, wasPilot, wasGunner);
                        if (null != r) {
                            vDesc.addElement(r);
                        }
                    }
                    if (Crew.DEATH > crew.getHits()) {
                        vDesc.addAll(resolveCrewDamage(en, damage, pos));
                    } else if (!crew.isDoomed()) {
                        crew.setDoomed(true);
                        vDesc.addAll(destroyEntity(en, "pilot death", true));
                    }
                }
            }
        } else {
            boolean isPilot = (en instanceof Mech) || ((en instanceof Aero)
                    && !(en instanceof SmallCraft) && !(en instanceof Jumpship));
            if (crew.isDead() || crew.isDoomed()) {
                if (isPilot) {
                    r = new Report(6021);
                } else {
                    r = new Report(6022);
                }
            } else {
                if (isPilot) {
                    r = new Report(6023);
                } else {
                    r = new Report(6024);
                }
            }
            r.subject = en.getId();
            r.addDesc(en);
            r.add(crew.getName());
            r.indent(2);
            vDesc.add(r);
        }
        if (en.isAirborneVTOLorWIGE() && !en.getCrew().isActive()) {
            if (en instanceof LandAirMech) {
                crashAirMech(en, en.getBasePilotingRoll(), vDesc);
            } else if (en instanceof Protomech) {
                vDesc.addAll(landGliderPM((Protomech) en));
            }
        }
        return vDesc;
    }

    /**
     * Convenience method that fills in a report showing that a crew member of a multicrew cockpit
     * has taken over for another incapacitated crew member.
     *
     * @param e         The <code>Entity</code> for the crew.
     * @param slot      The slot index of the crew member that was incapacitated.
     * @param wasPilot  Whether the crew member was the pilot before becoming incapacitated.
     * @param wasGunner Whether the crew member was the gunner before becoming incapacitated.
     * @return          A completed <code>Report</code> if the position was assumed by another
     *                  crew members, otherwise null.
     */
    private Report createCrewTakeoverReport(Entity e, int slot, boolean wasPilot, boolean wasGunner) {
        if (wasPilot && e.getCrew().getCurrentPilotIndex() != slot) {
            Report r = new Report(5560);
            r.subject = e.getId();
            r.indent(4);
            r.add(e.getCrew().getNameAndRole(e.getCrew().getCurrentPilotIndex()));
            r.add(e.getCrew().getCrewType().getRoleName(e.getCrew().getCrewType().getPilotPos()));
            r.addDesc(e);
            return r;
        }
        if (wasGunner && e.getCrew().getCurrentGunnerIndex() != slot) {
            Report r = new Report(5560);
            r.subject = e.getId();
            r.indent(4);
            r.add(e.getCrew().getNameAndRole(e.getCrew().getCurrentGunnerIndex()));
            r.add(e.getCrew().getCrewType().getRoleName(e.getCrew().getCrewType().getGunnerPos()));
            r.addDesc(e);
            return r;
        }
        return null;
    }

    /**
     * resolves consciousness rolls for one entity
     *
     * @param e         The <code>Entity</code> that took damage
     * @param damage    The <code>int</code> damage taken by the pilot
     * @param crewPos   The <code>int</code> index of the crew member for multi crew cockpits, ignored by
     *                  basic <code>crew</code>
     */
    private Vector<Report> resolveCrewDamage(Entity e, int damage, int crewPos) {
        Vector<Report> vDesc = new Vector<>();
        final int totalHits = e.getCrew().getHits(crewPos);
        if ((e instanceof MechWarrior) || !e.isTargetable()
                || !e.getCrew().isActive(crewPos) || (damage == 0)) {
            return vDesc;
        }

        // no consciousness roll for pain-shunted warriors
        if (e.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
            return vDesc;
        }

        // no consciousness roll for capital fighter pilots or large craft crews
        if (e.isCapitalFighter() || e.isLargeCraft()) {
            return vDesc;
        }

        for (int hit = (totalHits - damage) + 1; hit <= totalHits; hit++) {
            int rollTarget = Compute.getConsciousnessNumber(hit);
            if (game.getOptions().booleanOption(OptionsConstants.RPG_TOUGHNESS)) {
                rollTarget -= e.getCrew().getToughness(crewPos);
            }
            boolean edgeUsed = false;
            do {
                if (edgeUsed) {
                    e.getCrew().decreaseEdge();
                }
                int roll = Compute.d6(2);
                if (e.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)) {
                    roll = Math.min(12, roll + 1);
                }
                Report r = new Report(6030);
                r.indent(2);
                r.subject = e.getId();
                r.add(e.getCrew().getCrewType().getRoleName(crewPos));
                r.addDesc(e);
                r.add(e.getCrew().getName(crewPos));
                r.add(rollTarget);
                r.add(roll);
                if (roll >= rollTarget) {
                    e.getCrew().setKoThisRound(false, crewPos);
                    r.choose(true);
                } else {
                    e.getCrew().setKoThisRound(true, crewPos);
                    r.choose(false);
                    if (e.getCrew().hasEdgeRemaining()
                            && (e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_KO)
                            || e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_KO))) {
                        edgeUsed = true;
                        vDesc.add(r);
                        r = new Report(6520);
                        r.subject = e.getId();
                        r.addDesc(e);
                        r.add(e.getCrew().getName(crewPos));
                        r.add(e.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                    } // if
                    // return true;
                } // else
                vDesc.add(r);
            } while (e.getCrew().hasEdgeRemaining()
                    && e.getCrew().isKoThisRound(crewPos)
                    && (e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_KO)
                    || e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_KO)));
            // end of do-while
            if (e.getCrew().isKoThisRound(crewPos)) {
                boolean wasPilot = e.getCrew().getCurrentPilotIndex() == crewPos;
                boolean wasGunner = e.getCrew().getCurrentGunnerIndex() == crewPos;
                e.getCrew().setUnconscious(true, crewPos);
                Report r = createCrewTakeoverReport(e, crewPos, wasPilot, wasGunner);
                if (null != r) {
                    vDesc.add(r);
                }
                return vDesc;
            }
        }
        return vDesc;
    }

    /**
     * Make the rolls indicating whether any unconscious crews wake up
     */
    private void resolveCrewWakeUp() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity e = i.next();

            // only unconscious pilots of mechs and protos, ASF and Small Craft
            // and MechWarriors can roll to wake up
            if (e.isTargetable()
                    && ((e instanceof Mech) || (e instanceof Protomech)
                    || (e instanceof MechWarrior) || ((e instanceof Aero) && !(e instanceof Jumpship)))) {
                for (int pos = 0; pos < e.getCrew().getSlotCount(); pos++) {
                    if (e.getCrew().isMissing(pos)) {
                        continue;
                    }
                    if (e.getCrew().isUnconscious(pos)
                            && !e.getCrew().isKoThisRound(pos)) {
                        int roll = Compute.d6(2);

                        if (e.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)) {
                            roll = Math.min(12, roll + 1);
                        }

                        int rollTarget = Compute.getConsciousnessNumber(e.getCrew()
                                .getHits(pos));
                        Report r = new Report(6029);
                        r.subject = e.getId();
                        r.add(e.getCrew().getCrewType().getRoleName(pos));
                        r.addDesc(e);
                        r.add(e.getCrew().getName(pos));
                        r.add(rollTarget);
                        r.add(roll);
                        if (roll >= rollTarget) {
                            r.choose(true);
                            e.getCrew().setUnconscious(false, pos);
                        } else {
                            r.choose(false);
                        }
                        addReport(r);
                    }
                }
            }
        }
    }

    /**
     * Check whether any <code>Entity</code> with a cockpit command console has been scheduled to swap
     * roles between the two crew members.
     */
    private void resolveConsoleCrewSwaps() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity e = i.next();
            if (e.getCrew().doConsoleRoleSwap()) {
                final Crew crew = e.getCrew();
                final int current = crew.getCurrentPilotIndex();
                Report r = new Report(5560);
                r.subject = e.getId();
                r.add(crew.getNameAndRole(current));
                r.add(crew.getCrewType().getRoleName(0));
                r.addDesc(e);
                addReport(r);
            }
        }
    }

    /*
     * Resolve any outstanding self destructions...
     */
    private void resolveSelfDestruct() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.getSelfDestructing()) {
                e.setSelfDestructing(false);
                e.setSelfDestructInitiated(true);
                Report r = new Report(5535, Report.PUBLIC);
                r.subject = e.getId();
                r.addDesc(e);
                addReport(r);
            }
        }
    }

    /*
     * Resolve any outstanding crashes from shutting down and being airborne
     * VTOL or WiGE...
     */
    private void resolveShutdownCrashes() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.isShutDown() && e.isAirborneVTOLorWIGE()
                    && !(e.isDestroyed() || e.isDoomed())) {
                Tank t = (Tank) e;
                t.immobilize();
                addReport(forceLandVTOLorWiGE(t));
            }
        }
    }

    /**
     * Resolve any potential fatal damage to Capital Fighter after each
     * individual attacker is finished
     */
    private Vector<Report> checkFatalThresholds(int nextAE, int prevAE) {
        Vector<Report> vDesc = new Vector<>();
        for (Iterator<Entity> e = game.getEntities(); e.hasNext();) {
            Entity en = e.next();
            if (!en.isCapitalFighter() || (nextAE == Entity.NONE)) {
                continue;
            }
            IAero ship = (IAero) en;
            int damage = ship.getCurrentDamage();
            double divisor = 2.0;
            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
                divisor = 20.0;
            }
            if (damage >= ship.getFatalThresh()) {
                int roll = Compute.d6(2)
                        + (int) Math.floor((damage - ship.getFatalThresh())
                        / divisor);
                if (roll > 9) {
                    // Lets auto-eject if we can!
                    if (ship instanceof LandAirMech) {
                        // LAMs eject if the CT destroyed switch is on
                        LandAirMech lam = (LandAirMech) ship;
                        if (lam.isAutoEject()
                                && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && lam.isCondEjectCTDest()))) {
                            addReport(ejectEntity(en, true, false));
                        }
                    } else {
                        // Aeros eject if the SI Destroyed switch is on
                        Aero aero = (Aero) ship;
                        if (aero.isAutoEject()
                                && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && aero.isCondEjectSIDest()))) {
                            addReport(ejectEntity(en, true, false));
                        }
                    }
                    vDesc.addAll(destroyEntity((Entity) ship, "fatal damage threshold"));
                    ship.doDisbandDamage();
                    if (prevAE != Entity.NONE) {
                        creditKill(en, game.getEntity(prevAE));
                    }
                }
            }
            ship.setCurrentDamage(0);
        }
        return vDesc;
    }

    /**
     * damage an Entity
     *
     * @param te            the <code>Entity</code> to be damaged
     * @param hit           the corresponding <code>HitData</code>
     * @param damage        the <code>int</code> amount of damage
     * @param ammoExplosion a <code>boolean</code> indicating if this is an ammo explosion
     * @return a <code>Vector<Report></code> containing the phase reports
     */
    private Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                        boolean ammoExplosion) {
        return damageEntity(te, hit, damage, ammoExplosion, DamageType.NONE,
                false, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te     the target entity
     * @param hit    the hit data for the location hit
     * @param damage the damage to apply
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage) {
        return damageEntity(te, hit, damage, false, DamageType.NONE, false,
                false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                       boolean areaSatArty) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                areaSatArty, true);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                       boolean areaSatArty, boolean throughFront) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                areaSatArty, throughFront, false, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @param underWater    Is the damage coming from an underwater attack
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                       boolean areaSatArty, boolean throughFront, boolean underWater) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                areaSatArty, throughFront, underWater, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param damageType         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @param underWater    Is the damage coming from an underwater attack?
     * @param nukeS2S       is this a ship-to-ship nuke?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType damageType, boolean damageIS,
                                       boolean areaSatArty, boolean throughFront, boolean underWater,
                                       boolean nukeS2S) {

        Vector<Report> vDesc = new Vector<>();
        Report r;
        int te_n = te.getId();

        // if this is a fighter squadron then pick an active fighter and pass on
        // the damage
        if (te instanceof FighterSquadron) {
            List<Entity> fighters = te.getActiveSubEntities();

            if (fighters.isEmpty()) {
                return vDesc;
            }
            Entity fighter = fighters.get(hit.getLocation());
            HitData new_hit = fighter.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
            new_hit.setBoxCars(hit.rolledBoxCars());
            new_hit.setGeneralDamageType(hit.getGeneralDamageType());
            new_hit.setCapital(hit.isCapital());
            new_hit.setCapMisCritMod(hit.getCapMisCritMod());
            new_hit.setSingleAV(hit.getSingleAV());
            new_hit.setAttackerId(hit.getAttackerId());
            return damageEntity(fighter, new_hit, damage, ammoExplosion, damageType,
                    damageIS, areaSatArty, throughFront, underWater, nukeS2S);
        }

        // Battle Armor takes full damage to each trooper from area-effect.
        if (areaSatArty && (te instanceof BattleArmor)) {
            r = new Report(6044);
            r.subject = te.getId();
            r.indent(2);
            vDesc.add(r);
            for (int i = 0; i < ((BattleArmor) te).getTroopers(); i++) {
                hit.setLocation(BattleArmor.LOC_TROOPER_1 + i);
                if (te.getInternal(hit) > 0) {
                    vDesc.addAll(damageEntity(te, hit, damage, ammoExplosion, damageType,
                            damageIS, false, throughFront, underWater, nukeS2S));
                }
            }
            return vDesc;
        }

        // This is good for shields if a shield absorps the hit it shouldn't
        // effect the pilot.
        // TC SRM's that hit the head do external and internal damage but its
        // one hit and shouldn't cause
        // 2 hits to the pilot.
        boolean isHeadHit = (te instanceof Mech)
                && (((Mech) te).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED)
                && (hit.getLocation() == Mech.LOC_HEAD)
                && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS);

        // booleans to indicate criticals for AT2
        boolean critSI = false;
        boolean critThresh = false;

        // get the relevant damage for damage thresholding
        int threshDamage = damage;
        // weapon groups only get the damage of one weapon
        if ((hit.getSingleAV() > -1)
                && !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
            threshDamage = hit.getSingleAV();
        }

        // is this capital-scale damage
        boolean isCapital = hit.isCapital();

        // check capital/standard damage
        if (isCapital
                && (!te.isCapitalScale() || game.getOptions().booleanOption(
                OptionsConstants.ADVAERORULES_AERO_SANITY))) {
            damage = 10 * damage;
            threshDamage = 10 * threshDamage;
        }
        if (!isCapital && te.isCapitalScale()
                && !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
            damage = (int) Math.round(damage / 10.0);
            threshDamage = (int) Math.round(threshDamage / 10.0);
        }

        int damage_orig = damage;

        // show Locations which have rerolled with Edge
        HitData undoneLocation = hit.getUndoneLocation();
        while (undoneLocation != null) {
            r = new Report(6500);
            r.subject = te_n;
            r.indent(2);
            r.addDesc(te);
            r.add(te.getLocationAbbr(undoneLocation));
            vDesc.addElement(r);
            undoneLocation = undoneLocation.getUndoneLocation();
        } // while
        // if edge was uses, give at end overview of remaining
        if (hit.getUndoneLocation() != null) {
            r = new Report(6510);
            r.subject = te_n;
            r.indent(2);
            r.addDesc(te);
            r.add(te.getCrew().getOptions().intOption(OptionsConstants.EDGE));
            vDesc.addElement(r);
        } // if

        boolean autoEject = false;
        if (ammoExplosion) {
            if (te instanceof Mech) {
                Mech mech = (Mech) te;
                if (mech.isAutoEject() && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        && mech.isCondEjectAmmo()))) {
                    autoEject = true;
                    vDesc.addAll(ejectEntity(te, true));
                }
            } else if (te instanceof Aero) {
                Aero aero = (Aero) te;
                if (aero.isAutoEject() && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        && aero.isCondEjectAmmo()))) {
                    autoEject = true;
                    vDesc.addAll(ejectEntity(te, true));
                }
            }
        }
        boolean isBattleArmor = te instanceof BattleArmor;
        boolean isPlatoon = !isBattleArmor && (te instanceof Infantry);
        boolean isFerroFibrousTarget = false;
        boolean wasDamageIS = false;
        boolean tookInternalDamage = damageIS;
        Hex te_hex = null;

        boolean hardenedArmor = ((te instanceof Mech) || (te instanceof Tank))
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED);
        boolean ferroLamellorArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_LAMELLOR);
        boolean reflectiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REFLECTIVE))
                || (isBattleArmor && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REFLECTIVE));
        boolean reactiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REACTIVE))
                || (isBattleArmor && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REACTIVE));
        boolean ballisticArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BALLISTIC_REINFORCED);
        boolean impactArmor = (te instanceof Mech)
                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_IMPACT_RESISTANT);
        boolean bar5 = te.getBARRating(hit.getLocation()) <= 5;

        // TACs from the hit location table
        int crits;
        if ((hit.getEffect() & HitData.EFFECT_CRITICAL) == HitData.EFFECT_CRITICAL) {
            crits = 1;
        } else {
            crits = 0;
        }

        // this is for special crits, like AP and tandem-charge
        int specCrits = 0;

        // the bonus to the crit roll if using the
        // "advanced determining critical hits rule"
        int critBonus = 0;
        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CRIT_ROLL)
                && (damage_orig > 0)
                && ((te instanceof Mech) || (te instanceof Protomech))) {
            critBonus = Math.min((damage_orig - 1) / 5, 4);
        }

        // Find out if Human TRO plays a part it crit bonus
        Entity ae = game.getEntity(hit.getAttackerId());
        if ((ae != null) && !areaSatArty) {
            if ((te instanceof Mech) && ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_MECH)) {
                critBonus += 1;
            } else if ((te instanceof Aero) && ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_AERO)) {
                critBonus += 1;
            } else if ((te instanceof Tank) && ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_VEE)) {
                critBonus += 1;
            } else if ((te instanceof BattleArmor) && ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_BA)) {
                critBonus += 1;
            }
        }

        HitData nextHit = null;

        // Some "hits" on a ProtoMech are actually misses.
        if ((te instanceof Protomech) && (hit.getLocation() == Protomech.LOC_NMISS)) {
            Protomech proto = (Protomech) te;
            r = new Report(6035);
            r.subject = te.getId();
            r.indent(2);
            if (proto.isGlider()) {
                r.messageId = 6036;
                proto.setWingHits(proto.getWingHits() + 1);
            }
            vDesc.add(r);
            return vDesc;
        }

        // check for critical hit/miss vs. a BA
        if ((crits > 0) && (te instanceof BattleArmor)) {
            // possible critical miss if the rerolled location isn't alive
            if ((hit.getLocation() >= te.locations()) || (te.getInternal(hit.getLocation()) <= 0)) {
                r = new Report(6037);
                r.add(hit.getLocation());
                r.subject = te_n;
                r.indent(2);
                vDesc.addElement(r);
                return vDesc;
            }
            // otherwise critical hit
            r = new Report(6225);
            r.add(te.getLocationAbbr(hit));
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);

            crits = 0;
            damage = Math.max(te.getInternal(hit.getLocation()) + te.getArmor(hit.getLocation()), damage);
        }

        if ((te.getArmor(hit) > 0) && ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_FIBROUS)
                || (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_LIGHT_FERRO)
                || (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAVY_FERRO))) {
            isFerroFibrousTarget = true;
        }

        // Infantry with TSM implants get 2d6 burst damage from ATSM munitions
        if (damageType.equals(DamageType.ANTI_TSM) && te.isConventionalInfantry() && te.antiTSMVulnerable()) {
            int burst = Compute.d6(2);
            r = new Report(6434);
            r.subject = te_n;
            r.add(burst);
            r.indent(2);
            vDesc.addElement(r);
            damage += burst;
        }

        // area effect against infantry is double damage
        if (isPlatoon && areaSatArty) {
            // PBI. Double damage.
            damage *= 2;
            r = new Report(6039);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
        }

        // Is the infantry in the open?
        if (ServerHelper.infantryInOpen(te, te_hex, game, isPlatoon, ammoExplosion, hit.isIgnoreInfantryDoubleDamage())) {
            // PBI. Damage is doubled.
            damage *= 2;
            r = new Report(6040);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
        }

        // Is the infantry in vacuum?
        if ((isPlatoon || isBattleArmor) && !te.isDestroyed() && !te.isDoomed()
                && game.getPlanetaryConditions().isVacuum()) {
            // PBI. Double damage.
            damage *= 2;
            r = new Report(6041);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
        }

        switch (damageType) {
            case FRAGMENTATION:
                // Fragmentation missiles deal full damage to conventional
                // infantry
                // (only) and no damage to other target types.
                if (!isPlatoon) {
                    damage = 0;
                    r = new Report(6050); // For some reason this report never
                    // actually shows up...
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                } else {
                    r = new Report(6045); // ...but this one displays just fine.
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case NONPENETRATING:
                if (!isPlatoon) {
                    damage = 0;
                    r = new Report(6051);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case FLECHETTE:
                // Flechette ammo deals full damage to conventional infantry and
                // half damage to other targets (including battle armor).
                if (!isPlatoon) {
                    damage /= 2;
                    r = new Report(6060);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                } else {
                    r = new Report(6055);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case ACID:
                if (isFerroFibrousTarget || reactiveArmor || reflectiveArmor
                        || ferroLamellorArmor || bar5) {
                    if (te.getArmor(hit) <= 0) {
                        break; // hitting IS, not acid-affected armor
                    }
                    damage = Math.min(te.getArmor(hit), 3);
                    r = new Report(6061);
                    r.subject = te_n;
                    r.indent(2);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (isPlatoon) {
                    damage = (int) Math.ceil(damage * 1.5);
                    r = new Report(6062);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case INCENDIARY:
                // Incendiary AC ammo does +2 damage to unarmoured infantry
                if (isPlatoon) {
                    damage += 2;
                    r = new Report(6064);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case NAIL_RIVET:
                // no damage against armor of BAR rating >=5
                if ((te.getBARRating(hit.getLocation()) >= 5)
                        && (te.getArmor(hit.getLocation()) > 0)) {
                    damage = 0;
                    r = new Report(6063);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.add(r);
                }
                break;
            default:
                // We can ignore this.
                break;
        }

        // adjust VTOL rotor damage
        if ((te instanceof VTOL) && (hit.getLocation() == VTOL.LOC_ROTOR)
                && (hit.getGeneralDamageType() != HitData.DAMAGE_PHYSICAL)
                && !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_FULL_ROTOR_HITS)) {
            damage = (damage + 9) / 10;
        }

        // save EI status, in case sensors crit destroys it
        final boolean eiStatus = te.hasActiveEiCockpit();
        // BA using EI implants receive +1 damage from attacks
        if (!(te instanceof Mech) && !(te instanceof Protomech) && eiStatus) {
            damage += 1;
        }

        // check for case on Aeros
        if (te instanceof Aero) {
            Aero a = (Aero) te;
            if (ammoExplosion && a.hasCase()) {
                // damage should be reduced by a factor of 2 for ammo explosions
                // according to p. 161, TW
                damage /= 2;
                r = new Report(9010);
                r.subject = te_n;
                r.add(damage);
                r.indent(3);
                vDesc.addElement(r);
            }
        }

        // infantry armor can reduce damage
        if (isPlatoon && (((Infantry) te).calcDamageDivisor() != 1.0)) {
            r = new Report(6074);
            r.subject = te_n;
            r.indent(2);
            r.add(damage);
            damage = (int) Math.ceil((damage) / ((Infantry) te).calcDamageDivisor());
            r.add(damage);
            vDesc.addElement(r);
        }

        // Allocate the damage
        while (damage > 0) {

            // first check for ammo explosions on aeros separately, because it
            // must be done before
            // standard to capital damage conversions
            if ((te instanceof Aero) && (hit.getLocation() == Aero.LOC_AFT)
                    && !damageIS) {
                for (Mounted mAmmo : te.getAmmo()) {
                    if (mAmmo.isDumping() && !mAmmo.isDestroyed() && !mAmmo.isHit()
                            && !(mAmmo.getType() instanceof BombType)) {
                        // doh. explode it
                        vDesc.addAll(explodeEquipment(te, mAmmo.getLocation(), mAmmo));
                        mAmmo.setHit(true);
                    }
                }
            }

            if (te.isAero()) {
                // chance of a critical if damage greater than threshold
                IAero a = (IAero) te;
                if ((threshDamage > a.getThresh(hit.getLocation()))) {
                    critThresh = true;
                    a.setCritThresh(true);
                }
            }

            // Capital fighters receive damage differently
            if (te.isCapitalFighter()) {
                IAero a = (IAero) te;
                a.setCurrentDamage(a.getCurrentDamage() + damage);
                a.setCapArmor(a.getCapArmor() - damage);
                r = new Report(9065);
                r.subject = te_n;
                r.indent(2);
                r.newlines = 0;
                r.addDesc(te);
                r.add(damage);
                vDesc.addElement(r);
                r = new Report(6085);
                r.subject = te_n;
                r.add(Math.max(a.getCapArmor(), 0));
                vDesc.addElement(r);
                // check to see if this destroyed the entity
                if (a.getCapArmor() <= 0) {
                    // Lets auto-eject if we can!
                    if (a instanceof LandAirMech) {
                        // LAMs eject if the CT destroyed switch is on
                        LandAirMech lam = (LandAirMech) a;
                        if (lam.isAutoEject()
                                && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && lam.isCondEjectCTDest()))) {
                            addReport(ejectEntity(te, true, false));
                        }
                    } else {
                        // Aeros eject if the SI Destroyed switch is on
                        Aero aero = (Aero) a;
                        if (aero.isAutoEject()
                                && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && aero.isCondEjectSIDest()))) {
                            addReport(ejectEntity(te, true, false));
                        }
                    }
                    vDesc.addAll(destroyEntity(te, "Structural Integrity Collapse"));
                    a.doDisbandDamage();
                    a.setCapArmor(0);
                    if (hit.getAttackerId() != Entity.NONE) {
                        creditKill(te, game.getEntity(hit.getAttackerId()));
                    }
                }
                // check for aero crits from natural 12 or threshold; LAMs take damage as mechs
                if (te instanceof Aero) {
                    checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh,
                            critSI, ammoExplosion, nukeS2S);
                }
                return vDesc;
            }

            if (!((te instanceof Aero) && ammoExplosion)) {
                // report something different for Aero ammo explosions
                r = new Report(6065);
                r.subject = te_n;
                r.indent(2);
                r.addDesc(te);
                r.add(damage);
                if (damageIS) {
                    r.messageId = 6070;
                }
                r.add(te.getLocationAbbr(hit));
                vDesc.addElement(r);
            }

            // was the section destroyed earlier this phase?
            if (te.getInternal(hit) == IArmorState.ARMOR_DOOMED) {
                // cannot transfer a through armor crit if so
                crits = 0;
            }

            // here goes the fun :)
            // Shields take damage first then cowls then armor whee
            // Shield does not protect from ammo explosions or falls.
            if (!ammoExplosion && !hit.isFallDamage() && !damageIS && te.hasShield()
                    && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                Mech me = (Mech) te;
                int damageNew = me.shieldAbsorptionDamage(damage, hit.getLocation(), hit.isRear());
                // if a shield absorbed the damage then lets tell the world
                // about it.
                if (damageNew != damage) {
                    int absorb = damage - damageNew;
                    te.damageThisPhase += absorb;
                    damage = damageNew;

                    r = new Report(3530);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(absorb);
                    vDesc.addElement(r);

                    if (damage <= 0) {
                        crits = 0;
                        specCrits = 0;
                        isHeadHit = false;
                    }
                }
            }

            // Armored Cowl may absorb some damage from hit
            if (te instanceof Mech) {
                Mech me = (Mech) te;
                if (me.hasCowl() && (hit.getLocation() == Mech.LOC_HEAD)
                        && !throughFront) {
                    int damageNew = me.damageCowl(damage);
                    int damageDiff = damage - damageNew;
                    me.damageThisPhase += damageDiff;
                    damage = damageNew;

                    r = new Report(3520);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damageDiff);
                    vDesc.addElement(r);
                }
            }

            // So might modular armor, if the location mounts any.
            if (!ammoExplosion && !damageIS
                    && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                int damageNew = te.getDamageReductionFromModularArmor(hit, damage, vDesc);
                int damageDiff = damage - damageNew;
                te.damageThisPhase += damageDiff;
                damage = damageNew;
            }

            // Destroy searchlights on 7+ (torso hits on mechs)
            if (te.hasSearchlight()) {
                boolean spotlightHittable = true;
                int loc = hit.getLocation();
                if (te instanceof Mech) {
                    if ((loc != Mech.LOC_CT) && (loc != Mech.LOC_LT) && (loc != Mech.LOC_RT)) {
                        spotlightHittable = false;
                    }
                } else if (te instanceof Tank) {
                    if (te instanceof SuperHeavyTank) {
                        if ((loc != Tank.LOC_FRONT)
                                && (loc != SuperHeavyTank.LOC_FRONTRIGHT)
                                && (loc != SuperHeavyTank.LOC_FRONTLEFT)
                                && (loc != SuperHeavyTank.LOC_REARRIGHT)
                                && (loc != SuperHeavyTank.LOC_REARLEFT)) {
                            spotlightHittable = false;
                        }
                    } else if (te instanceof LargeSupportTank) {
                        if ((loc != Tank.LOC_FRONT)
                                && (loc != LargeSupportTank.LOC_FRONTRIGHT)
                                && (loc != LargeSupportTank.LOC_FRONTLEFT)
                                && (loc != LargeSupportTank.LOC_REARRIGHT)
                                && (loc != LargeSupportTank.LOC_REARLEFT)) {
                            spotlightHittable = false;
                        }
                    } else {
                        if ((loc != Tank.LOC_FRONT) && (loc != Tank.LOC_RIGHT)
                                && (loc != Tank.LOC_LEFT)) {
                            spotlightHittable = false;
                        }
                    }

                }
                if (spotlightHittable) {
                    int spotroll = Compute.d6(2);
                    r = new Report(6072);
                    r.indent(2);
                    r.subject = te_n;
                    r.add("7+");
                    r.add("Searchlight");
                    r.add(spotroll);
                    vDesc.addElement(r);
                    if (spotroll >= 7) {
                        r = new Report(6071);
                        r.subject = te_n;
                        r.indent(2);
                        r.add("Searchlight");
                        vDesc.addElement(r);
                        te.destroyOneSearchlight();
                    }
                }
            }

            // Does an exterior passenger absorb some of the damage?
            if (!damageIS) {
                int nLoc = hit.getLocation();
                Entity passenger = te.getExteriorUnitAt(nLoc, hit.isRear());
                // Does an exterior passenger absorb some of the damage?
                if (!ammoExplosion && (null != passenger) && !passenger.isDoomed()
                        && (damageType != DamageType.IGNORE_PASSENGER)) {
                    damage = damageExternalPassenger(te, hit, damage, vDesc, passenger);
                }

                boolean bTorso = (nLoc == Mech.LOC_CT) || (nLoc == Mech.LOC_RT)
                        || (nLoc == Mech.LOC_LT);

                // Does a swarming unit absorb damage?
                int swarmer = te.getSwarmAttackerId();
                if ((!(te instanceof Mech) || bTorso) && (swarmer != Entity.NONE)
                        && ((hit.getEffect() & HitData.EFFECT_CRITICAL) == 0) && (Compute.d6() >= 5)
                        && (damageType != DamageType.IGNORE_PASSENGER) && !ammoExplosion) {
                    Entity swarm = game.getEntity(swarmer);
                    // Yup. Roll up some hit data for that passenger.
                    r = new Report(6076);
                    r.subject = swarmer;
                    r.indent(3);
                    r.addDesc(swarm);
                    vDesc.addElement(r);

                    HitData passHit = swarm.rollHitLocation(
                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);

                    // How much damage will the swarm absorb?
                    int absorb = 0;
                    HitData nextPassHit = passHit;
                    do {
                        if (0 < swarm.getArmor(nextPassHit)) {
                            absorb += swarm.getArmor(nextPassHit);
                        }
                        if (0 < swarm.getInternal(nextPassHit)) {
                            absorb += swarm.getInternal(nextPassHit);
                        }
                        nextPassHit = swarm.getTransferLocation(nextPassHit);
                    } while ((damage > absorb)
                            && (nextPassHit.getLocation() >= 0));

                    // Damage the swarm.
                    int absorbedDamage = Math.min(damage, absorb);
                    Vector<Report> newReports = damageEntity(swarm, passHit,
                            absorbedDamage);
                    for (Report newReport : newReports) {
                        newReport.indent(2);
                    }
                    vDesc.addAll(newReports);

                    // Did some damage pass on?
                    if (damage > absorb) {
                        // Yup. Remove the absorbed damage.
                        damage -= absorb;
                        r = new Report(6080);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        r.addDesc(te);
                        vDesc.addElement(r);
                    } else {
                        // Nope. Return our description.
                        return vDesc;
                    }
                }

                // is this a mech/tank dumping ammo being hit in the rear torso?
                if (((te instanceof Mech) && hit.isRear() && bTorso)
                        || ((te instanceof Tank) && (hit.getLocation() == (te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                        : Tank.LOC_REAR)))) {
                    for (Mounted mAmmo : te.getAmmo()) {
                        if (mAmmo.isDumping() && !mAmmo.isDestroyed()
                                && !mAmmo.isHit()) {
                            // doh. explode it
                            vDesc.addAll(explodeEquipment(te,
                                    mAmmo.getLocation(), mAmmo));
                            mAmmo.setHit(true);
                        }
                    }
                }
            }
            // is there armor in the location hit?
            if (!ammoExplosion && (te.getArmor(hit) > 0) && !damageIS) {
                int tmpDamageHold = -1;
                int origDamage = damage;

                if (isPlatoon) {
                    // infantry armour works differently
                    int armor = te.getArmor(hit);
                    int men = te.getInternal(hit);
                    tmpDamageHold = damage % 2;
                    damage /= 2;
                    if ((tmpDamageHold == 1) && (armor >= men)) {
                        // extra 1 point of damage to armor
                        tmpDamageHold = damage;
                        damage++;
                    } else {
                        // extra 0 or 1 point of damage to men
                        tmpDamageHold += damage;
                    }
                    // If the target has Ferro-Lamellor armor, we need to adjust
                    // damage. (4/5ths rounded down),
                    // Also check to eliminate crit chances for damage reduced
                    // to 0
                } else if (ferroLamellorArmor
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor((((double) damage) * 4) / 5);
                    if (damage <= 0) {
                        isHeadHit = false;
                        crits = 0;
                    }
                    r = new Report(6073);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (ballisticArmor
                        && ((hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                        || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING)
                        || (hit.getGeneralDamageType() == HitData.DAMAGE_BALLISTIC)
                        || (hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE))) {
                    tmpDamageHold = damage;
                    damage = Math.max(1, damage / 2);
                    r = new Report(6088);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (impactArmor
                        && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)) {
                    tmpDamageHold = damage;
                    damage -= (int) Math.ceil((double) damage / 3);
                    damage = Math.max(1, damage);
                    r = new Report(6089);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor
                        && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)
                        && !isBattleArmor) { // BA reflec does not receive extra physical damage
                    tmpDamageHold = damage;
                    int currArmor = te.getArmor(hit);
                    int dmgToDouble = Math.min(damage, currArmor / 2);
                    damage += dmgToDouble;
                    r = new Report(6066);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(currArmor);
                    r.add(tmpDamageHold);
                    r.add(dmgToDouble);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor && areaSatArty && !isBattleArmor) {
                    tmpDamageHold = damage; // BA reflec does not receive extra AE damage
                    int currArmor = te.getArmor(hit);
                    int dmgToDouble = Math.min(damage, currArmor / 2);
                    damage += dmgToDouble;
                    r = new Report(6087);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(currArmor);
                    r.add(tmpDamageHold);
                    r.add(dmgToDouble);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor
                        && (hit.getGeneralDamageType() == HitData.DAMAGE_ENERGY)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor(((double) damage) / 2);
                    if (tmpDamageHold == 1) {
                        damage = 1;
                    }
                    r = new Report(6067);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reactiveArmor
                        && ((hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE)
                        || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE) ||
                        areaSatArty)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor(((double) damage) / 2);
                    if (tmpDamageHold == 1) {
                        damage = 1;
                    }
                    r = new Report(6068);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                }

                // If we're using optional tank damage thresholds, setup our hit
                // effects now...
                if ((te instanceof Tank)
                        && game.getOptions()
                        .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)
                        && !((te instanceof VTOL) || (te instanceof GunEmplacement))) {
                    int thresh = (int) Math.ceil(
                            (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD_VARIABLE)
                                    ? te.getArmor(hit)
                                    : te.getOArmor(hit)) / (double) game.getOptions().intOption(
                                    OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD_DIVISOR));

                    // adjust for hardened armor
                    if (hardenedArmor
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                        thresh *= 2;
                    }

                    if ((damage > thresh) || (te.getArmor(hit) < damage)) {
                        hit.setEffect(((Tank) te).getPotCrit());
                        ((Tank) te).setOverThresh(true);
                        // TACs from the hit location table
                        crits = ((hit.getEffect() & HitData.EFFECT_CRITICAL)
                                == HitData.EFFECT_CRITICAL) ? 1 : 0;
                    } else {
                        ((Tank) te).setOverThresh(false);
                        crits = 0;
                    }
                }

                // if there's a mast mount in the rotor, it and all other
                // equipment
                // on it get destroyed
                if ((te instanceof VTOL)
                        && (hit.getLocation() == VTOL.LOC_ROTOR)
                        && te.hasWorkingMisc(MiscType.F_MAST_MOUNT, -1,
                        VTOL.LOC_ROTOR)) {
                    r = new Report(6081);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                    for (Mounted mount : te.getMisc()) {
                        if (mount.getLocation() == VTOL.LOC_ROTOR) {
                            mount.setHit(true);
                        }
                    }
                }
                // Need to account for the possibility of hardened armor here
                int armorThreshold = te.getArmor(hit);
                if (hardenedArmor
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                    armorThreshold *= 2;
                    armorThreshold -= (te.isHardenedArmorDamaged(hit)) ? 1 : 0;
                    vDesc.lastElement().newlines = 0;
                    r = new Report(6069);
                    r.subject = te_n;
                    r.indent(3);
                    int reportedDamage = damage / 2;
                    if ((damage % 2) > 0) {
                        r.add(reportedDamage + ".5");
                    } else {
                        r.add(reportedDamage);
                    }

                    vDesc.addElement(r);
                }
                if (armorThreshold >= damage) {

                    // armor absorbs all damage
                    // Hardened armor deals with damage in its own fashion...
                    if (hardenedArmor
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                        armorThreshold -= damage;
                        te.setHardenedArmorDamaged(hit, (armorThreshold % 2) > 0);
                        te.setArmor((armorThreshold / 2) + (armorThreshold % 2), hit);
                    } else {
                        te.setArmor(te.getArmor(hit) - damage, hit);
                    }

                    // set "armor damage" flag for HarJel II/III
                    // we only care about this if there is armor remaining,
                    // so don't worry about the case where damage exceeds
                    // armorThreshold
                    if ((te instanceof Mech) && (damage > 0)) {
                        ((Mech) te).setArmorDamagedThisTurn(hit.getLocation(), true);
                    }

                    // if the armor is hardened, any penetrating crits are
                    // rolled at -2
                    if (hardenedArmor) {
                        critBonus -= 2;
                    }

                    if (tmpDamageHold >= 0) {
                        te.damageThisPhase += tmpDamageHold;
                    } else {
                        te.damageThisPhase += damage;
                    }
                    damage = 0;
                    if (!te.isHardenedArmorDamaged(hit)) {
                        r = new Report(6085);
                    } else {
                        r = new Report(6086);
                    }

                    r.subject = te_n;
                    r.indent(3);
                    r.add(te.getArmor(hit));
                    vDesc.addElement(r);

                    // telemissiles are destroyed if they lose all armor
                    if ((te instanceof TeleMissile)
                            && (te.getArmor(hit) == damage)) {
                        vDesc.addAll(destroyEntity(te, "damage", false));
                    }

                } else {
                    // damage goes on to internal
                    int absorbed = Math.max(te.getArmor(hit), 0);
                    if (hardenedArmor
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {
                        absorbed = (absorbed * 2)
                                - ((te.isHardenedArmorDamaged(hit)) ? 1 : 0);
                    }
                    if (reflectiveArmor && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)
                            && !isBattleArmor) {
                        absorbed = (int) Math.ceil(absorbed / 2.0);
                        damage = tmpDamageHold;
                        tmpDamageHold = 0;
                    }
                    te.setArmor(IArmorState.ARMOR_DESTROYED, hit);
                    if (tmpDamageHold >= 0) {
                        te.damageThisPhase += 2 * absorbed;
                    } else {
                        te.damageThisPhase += absorbed;
                    }
                    damage -= absorbed;
                    r = new Report(6090);
                    r.subject = te_n;
                    r.indent(3);
                    vDesc.addElement(r);
                    if (te instanceof GunEmplacement) {
                        // gun emplacements have no internal,
                        // destroy the section
                        te.destroyLocation(hit.getLocation());
                        r = new Report(6115);
                        r.subject = te_n;
                        vDesc.addElement(r);

                        if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                            vDesc.addAll(destroyEntity(te, "damage", false));
                        }
                    }
                }

                // targets with BAR armor get crits, depending on damage and BAR
                // rating
                if (te.hasBARArmor(hit.getLocation())) {
                    if (origDamage > te.getBARRating(hit.getLocation())) {
                        if (te.hasArmoredChassis()) {
                            // crit roll with -1 mod
                            vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                    hit.isRear(), -1 + critBonus, damage_orig));
                        } else {
                            vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                    hit.isRear(), critBonus, damage_orig));
                        }
                    }
                }

                if ((tmpDamageHold > 0) && isPlatoon) {
                    damage = tmpDamageHold;
                }
            }

            // For optional tank damage thresholds, the overthresh flag won't
            // be set if IS is damaged, so set it here.
            if ((te instanceof Tank)
                    && ((te.getArmor(hit) < 1) || damageIS)
                    && game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)
                    && !((te instanceof VTOL)
                    || (te instanceof GunEmplacement))) {
                ((Tank) te).setOverThresh(true);
            }

            // is there damage remaining?
            if (damage > 0) {

                // if this is an Aero then I need to apply internal damage
                // to the SI after halving it. Return from here to prevent
                // further processing
                if (te instanceof Aero) {
                    Aero a = (Aero) te;

                    // check for large craft ammo explosions here: damage vented through armor, excess
                    // dissipating, much like Tank CASE.
                    if (ammoExplosion && te.isLargeCraft()) {
                        te.damageThisPhase += damage;
                        r = new Report(6128);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        int loc = hit.getLocation();
                        //Roll for broadside weapons so fore/aft side armor facing takes the damage
                        if (loc == Warship.LOC_LBS) {
                            int locRoll = Compute.d6();
                            if (locRoll < 4) {
                                loc = Jumpship.LOC_FLS;
                            } else {
                                loc = Jumpship.LOC_ALS;
                            }
                        }
                        if (loc == Warship.LOC_RBS) {
                            int locRoll = Compute.d6();
                            if (locRoll < 4) {
                                loc = Jumpship.LOC_FRS;
                            } else {
                                loc = Jumpship.LOC_ARS;
                            }
                        }
                        r.add(te.getLocationAbbr(loc));
                        vDesc.add(r);
                        if (damage > te.getArmor(loc)) {
                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc);
                            r = new Report(6090);
                        } else {
                            te.setArmor(te.getArmor(loc) - damage, loc);
                            r = new Report(6085);
                            r.add(te.getArmor(loc));
                        }
                        r.subject = te_n;
                        r.indent(3);
                        vDesc.add(r);
                        damage = 0;
                    }

                    // check for overpenetration
                    if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_OVER_PENETRATE)) {
                        int opRoll = Compute.d6(1);
                        if (((te instanceof Jumpship) && !(te instanceof Warship) && (opRoll > 3))
                                || ((te instanceof Dropship) && (opRoll > 4))
                                || ((te instanceof Warship) && (a.get0SI() <= 30) && (opRoll > 5))) {
                            // over-penetration happened
                            r = new Report(9090);
                            r.subject = te_n;
                            r.newlines = 0;
                            vDesc.addElement(r);
                            int new_loc = a.getOppositeLocation(hit.getLocation());
                            damage = Math.min(damage, te.getArmor(new_loc));
                            // We don't want to deal negative damage
                            damage = Math.max(damage, 0);
                            r = new Report(6065);
                            r.subject = te_n;
                            r.indent(2);
                            r.newlines = 0;
                            r.addDesc(te);
                            r.add(damage);
                            r.add(te.getLocationAbbr(new_loc));
                            vDesc.addElement(r);
                            te.setArmor(te.getArmor(new_loc) - damage, new_loc);
                            if ((te instanceof Warship) || (te instanceof Dropship)) {
                                damage = 2;
                            } else {
                                damage = 0;
                            }
                        }
                    }

                    // divide damage in half
                    // do not divide by half if it is an ammo explosion
                    if (!ammoExplosion && !nukeS2S
                            && !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {
                        damage /= 2;
                    }

                    // this should result in a crit
                    // but only if it really did damage after rounding down
                    if (damage > 0) {
                        critSI = true;
                    }

                    // Now apply damage to the structural integrity
                    a.setSI(a.getSI() - damage);
                    te.damageThisPhase += damage;
                    // send the report
                    r = new Report(1210);
                    r.subject = te_n;
                    r.newlines = 1;
                    if (!ammoExplosion) {
                        r.messageId = 9005;
                    }
                    //Only for fighters
                    if (ammoExplosion && !a.isLargeCraft()) {
                        r.messageId = 9006;
                    }
                    r.add(damage);
                    r.add(Math.max(a.getSI(), 0));
                    vDesc.addElement(r);
                    // check to see if this would destroy the ASF
                    if (a.getSI() <= 0) {
                        // Lets auto-eject if we can!
                        if (a.isAutoEject()
                                && (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && a.isCondEjectSIDest()))) {
                            vDesc.addAll(ejectEntity(te, true, false));
                        } else {
                            vDesc.addAll(destroyEntity(te,"Structural Integrity Collapse"));
                        }
                        a.setSI(0);
                        if (hit.getAttackerId() != Entity.NONE) {
                            creditKill(a, game.getEntity(hit.getAttackerId()));
                        }
                    }
                    checkAeroCrits(vDesc, a, hit, damage_orig, critThresh, critSI, ammoExplosion, nukeS2S);
                    return vDesc;
                }

                // Check for CASE II right away. if so reduce damage to 1
                // and let it hit the IS.
                // Also remove as much of the rear armor as allowed by the
                // damage. If arm/leg/head
                // Then they lose all their armor if its less then the
                // explosion damage.
                if (ammoExplosion && te.hasCASEII(hit.getLocation())) {
                    // 1 point of damage goes to IS
                    damage--;
                    // Remaining damage prevented by CASE II
                    r = new Report(6126);
                    r.subject = te_n;
                    r.add(damage);
                    r.indent(3);
                    vDesc.addElement(r);
                    int loc = hit.getLocation();
                    if ((te instanceof Mech) && ((loc == Mech.LOC_HEAD) || ((Mech) te).isArm(loc)
                            || te.locationIsLeg(loc))) {
                        int half = (int) Math.ceil(te.getOArmor(loc, false) / 2.0);
                        if (damage > half) {
                            damage = half;
                        }
                        if (damage >= te.getArmor(loc, false)) {
                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, false);
                        } else {
                            te.setArmor(te.getArmor(loc, false) - damage, loc, false);
                        }
                    } else {
                        if (damage >= te.getArmor(loc, true)) {
                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, true);
                        } else {
                            te.setArmor(te.getArmor(loc, true) - damage, loc, true);
                        }
                    }

                    if (te.getInternal(hit) > 0) {
                        // Mek takes 1 point of IS damage
                        damage = 1;
                    } else {
                        damage = 0;
                    }

                    te.damageThisPhase += damage;

                    int roll = Compute.d6(2);
                    r = new Report(6127);
                    r.subject = te.getId();
                    r.add(roll);
                    vDesc.add(r);
                    if (roll >= 8) {
                        hit.setEffect(HitData.EFFECT_NO_CRITICALS);
                    }
                }
                // check for tank CASE here: damage to rear armor, excess
                // dissipating, and a crew stunned crit
                if (ammoExplosion && (te instanceof Tank)
                        && te.locationHasCase(Tank.LOC_BODY)) {
                    te.damageThisPhase += damage;
                    r = new Report(6124);
                    r.subject = te_n;
                    r.indent(2);
                    r.add(damage);
                    vDesc.add(r);
                    int loc = (te instanceof SuperHeavyTank) ? SuperHeavyTank.LOC_REAR
                            : (te instanceof LargeSupportTank) ? LargeSupportTank.LOC_REAR : Tank.LOC_REAR;
                    if (damage > te.getArmor(loc)) {
                        te.setArmor(IArmorState.ARMOR_DESTROYED, loc);
                        r = new Report(6090);
                    } else {
                        te.setArmor(te.getArmor(loc) - damage, loc);
                        r = new Report(6085);
                        r.add(te.getArmor(loc));
                    }
                    r.subject = te_n;
                    r.indent(3);
                    vDesc.add(r);
                    damage = 0;
                    int critIndex;
                    if (((Tank) te).isCommanderHit()
                            && ((Tank) te).isDriverHit()) {
                        critIndex = Tank.CRIT_CREW_KILLED;
                    } else {
                        critIndex = Tank.CRIT_CREW_STUNNED;
                    }
                    vDesc.addAll(applyCriticalHit(te, Entity.NONE, new CriticalSlot(0, critIndex), true, 0, false));
                }

                // is there internal structure in the location hit?
                if (te.getInternal(hit) > 0) {

                    // Now we need to consider alternate structure types!
                    int tmpDamageHold = -1;
                    if ((te instanceof Mech)
                            && ((Mech) te).hasCompositeStructure()) {
                        tmpDamageHold = damage;
                        damage *= 2;
                        r = new Report(6091);
                        r.subject = te_n;
                        r.indent(3);
                        vDesc.add(r);
                    }
                    if ((te instanceof Mech)
                            && ((Mech) te).hasReinforcedStructure()) {
                        tmpDamageHold = damage;
                        damage /= 2;
                        damage += tmpDamageHold % 2;
                        r = new Report(6092);
                        r.subject = te_n;
                        r.indent(3);
                        vDesc.add(r);
                    }
                    if ((te.getInternal(hit) > damage) && (damage > 0)) {
                        // internal structure absorbs all damage
                        te.setInternal(te.getInternal(hit) - damage, hit);
                        // Triggers a critical hit on Vehicles and Mechs.
                        if (!isPlatoon && !isBattleArmor) {
                            crits++;
                        }
                        tookInternalDamage = true;
                        // Alternate structures don't affect our damage total
                        // for later PSR purposes, so use the previously stored
                        // value here as necessary.
                        te.damageThisPhase += (tmpDamageHold > -1) ?
                                tmpDamageHold : damage;
                        damage = 0;
                        r = new Report(6100);
                        r.subject = te_n;
                        r.indent(3);
                        // Infantry platoons have men not "Internals".
                        if (isPlatoon) {
                            r.messageId = 6095;
                        }
                        r.add(te.getInternal(hit));
                        vDesc.addElement(r);
                    } else if (damage > 0) {
                        // Triggers a critical hit on Vehicles and Mechs.
                        if (!isPlatoon && !isBattleArmor) {
                            crits++;
                        }
                        // damage transfers, maybe
                        int absorbed = Math.max(te.getInternal(hit), 0);

                        // Handle ProtoMech pilot damage
                        // due to location destruction
                        if (te instanceof Protomech) {
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]
                                    - ((Protomech) te).getPilotDamageTaken(hit.getLocation());
                            if (hits > 0) {
                                vDesc.addAll(damageCrew(te, hits));
                                ((Protomech) te).setPilotDamageTaken(hit.getLocation(),
                                        Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);
                            }
                        }

                        // Platoon, Trooper, or Section destroyed message
                        r = new Report(1210);
                        r.subject = te_n;
                        if (isPlatoon) {
                            // Infantry have only one section, and
                            // are therefore destroyed.
                            if (((Infantry) te).isSquad()) {
                                r.messageId = 6106; // Squad Killed
                            } else {
                                r.messageId = 6105; // Platoon Killed
                            }
                        } else if (isBattleArmor) {
                            r.messageId = 6110;
                        } else {
                            r.messageId = 6115;
                        }
                        r.indent(3);
                        vDesc.addElement(r);

                        // If a sidetorso got destroyed, and the
                        // corresponding arm is not yet destroyed, add
                        // it as a club to that hex (p.35 BMRr)
                        if ((te instanceof Mech)
                                && (((hit.getLocation() == Mech.LOC_RT)
                                && (te.getInternal(Mech.LOC_RARM) > 0))
                                || ((hit.getLocation() == Mech.LOC_LT)
                                && (te.getInternal(Mech.LOC_LARM) > 0)))) {
                            int blownOffLocation;
                            if (hit.getLocation() == Mech.LOC_RT) {
                                blownOffLocation = Mech.LOC_RARM;
                            } else {
                                blownOffLocation = Mech.LOC_LARM;
                            }
                            te.destroyLocation(blownOffLocation, true);
                            r = new Report(6120);
                            r.subject = te_n;
                            r.add(te.getLocationName(blownOffLocation));
                            vDesc.addElement(r);
                            Hex h = game.getBoard().getHex(te.getPosition());
                            if (null != h) {
                                if (te instanceof BipedMech) {
                                    if (!h.containsTerrain(Terrains.ARMS)) {
                                        h.addTerrain(new Terrain(Terrains.ARMS, 1));
                                    } else {
                                        h.addTerrain(new Terrain(Terrains.ARMS, h.terrainLevel(Terrains.ARMS) + 1));
                                    }
                                } else if (!h.containsTerrain(Terrains.LEGS)) {
                                    h.addTerrain(new Terrain(Terrains.LEGS, 1));
                                } else {
                                    h.addTerrain(new Terrain(Terrains.LEGS, h.terrainLevel(Terrains.LEGS) + 1));
                                }
                                sendChangedHex(te.getPosition());
                            }
                        }

                        // Troopers riding on a location
                        // all die when the location is destroyed.
                        if ((te instanceof Mech) || (te instanceof Tank)) {
                            Entity passenger = te.getExteriorUnitAt(
                                    hit.getLocation(), hit.isRear());
                            if ((null != passenger) && !passenger.isDoomed()) {
                                HitData passHit = passenger
                                        .getTrooperAtLocation(hit, te);
                                // ensures a kill
                                passHit.setEffect(HitData.EFFECT_CRITICAL);
                                if (passenger.getInternal(passHit) > 0) {
                                    vDesc.addAll(damageEntity(passenger,
                                            passHit, damage));
                                }
                                passHit = new HitData(hit.getLocation(),
                                        !hit.isRear());
                                passHit = passenger.getTrooperAtLocation(
                                        passHit, te);
                                // ensures a kill
                                passHit.setEffect(HitData.EFFECT_CRITICAL);
                                if (passenger.getInternal(passHit) > 0) {
                                    vDesc.addAll(damageEntity(passenger,
                                            passHit, damage));
                                }
                            }
                        }

                        // BA inferno explosions
                        if (te instanceof BattleArmor) {
                            int infernos = 0;
                            for (Mounted m : te.getEquipment()) {
                                if (m.getType() instanceof AmmoType) {
                                    AmmoType at = (AmmoType) m.getType();
                                    if (((at.getAmmoType() == AmmoType.T_SRM) || (at.getAmmoType() == AmmoType.T_MML))
                                            && (at.getMunitionType() == AmmoType.M_INFERNO)) {
                                        infernos += at.getRackSize() * m.getHittableShotsLeft();
                                    }
                                } else if (m.getType().hasFlag(MiscType.F_FIRE_RESISTANT)) {
                                    // immune to inferno explosion
                                    infernos = 0;
                                    break;
                                }
                            }
                            if (infernos > 0) {
                                int roll = Compute.d6(2);
                                r = new Report(6680);
                                r.add(roll);
                                vDesc.add(r);
                                if (roll >= 8) {
                                    Coords c = te.getPosition();
                                    if (c == null) {
                                        Entity transport = game.getEntity(te.getTransportId());
                                        if (transport != null) {
                                            c = transport.getPosition();
                                        }
                                        vPhaseReport.addAll(deliverInfernoMissiles(te, te, infernos));
                                    }
                                    if (c != null) {
                                        vPhaseReport.addAll(deliverInfernoMissiles(te,
                                                new HexTarget(c, Targetable.TYPE_HEX_ARTILLERY),
                                                infernos));
                                    }
                                }
                            }
                        }

                        // Mark off the internal structure here, but *don't*
                        // destroy the location just yet -- there are checks
                        // still to run!
                        te.setInternal(0, hit);
                        te.damageThisPhase += absorbed;
                        damage -= absorbed;

                        // Now we need to consider alternate structure types!
                        if (tmpDamageHold > 0) {
                            if (((Mech) te).hasCompositeStructure()) {
                                // If there's a remainder, we can actually
                                // ignore it.
                                damage /= 2;
                            } else if (((Mech) te).hasReinforcedStructure()) {
                                damage *= 2;
                                damage -= tmpDamageHold % 2;
                            }
                        }
                    }
                }
                if (te.getInternal(hit) <= 0) {
                    // internal structure is gone, what are the transfer
                    // potentials?
                    nextHit = te.getTransferLocation(hit);
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {
                        if (te instanceof Mech) {
                            // Start with the number of engine crits in this
                            // location, if any...
                            te.engineHitsThisPhase += te.getNumberOfCriticals(
                                    CriticalSlot.TYPE_SYSTEM,
                                    Mech.SYSTEM_ENGINE, hit.getLocation());
                            // ...then deduct the ones destroyed previously or
                            // critically
                            // hit this round already. That leaves the ones
                            // actually
                            // destroyed with the location.
                            te.engineHitsThisPhase -= te.getHitCriticals(
                                    CriticalSlot.TYPE_SYSTEM,
                                    Mech.SYSTEM_ENGINE, hit.getLocation());
                        }

                        boolean engineExploded = checkEngineExplosion(te,
                                vDesc, te.engineHitsThisPhase);

                        if (!engineExploded) {
                            // Entity destroyed. Ammo explosions are
                            // neither survivable nor salvageable.
                            // Only ammo explosions in the CT are devastating.
                            vDesc.addAll(destroyEntity(te, "damage", !ammoExplosion,
                                    !((ammoExplosion || areaSatArty) && ((te instanceof Tank)
                                            || ((te instanceof Mech) && (hit.getLocation() == Mech.LOC_CT))))));
                            // If the head is destroyed, kill the crew.

                            if ((te instanceof Mech) && (hit.getLocation() == Mech.LOC_HEAD)
                                    && !te.getCrew().isDead() && !te.getCrew().isDoomed()
                                    && game.getOptions().booleanOption(
                                    OptionsConstants.ADVANCED_TACOPS_SKIN_OF_THE_TEETH_EJECTION)) {
                                Mech mech = (Mech) te;
                                if (mech.isAutoEject()
                                        && (!game.getOptions().booleanOption(
                                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                        || (game.getOptions().booleanOption(
                                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                        && mech.isCondEjectHeadshot()))) {
                                    autoEject = true;
                                    vDesc.addAll(ejectEntity(te, true, true));
                                }
                            }

                            if ((te instanceof Mech) && (hit.getLocation() == Mech.LOC_CT)
                                    && !te.getCrew().isDead() && !te.getCrew().isDoomed()) {
                                Mech mech = (Mech) te;
                                if (mech.isAutoEject()
                                        && game.getOptions().booleanOption(
                                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                        && mech.isCondEjectCTDest()) {
                                    if (mech.getCrew().getHits() < 5) {
                                        Report.addNewline(vDesc);
                                        mech.setDoomed(false);
                                        mech.setDoomed(true);
                                    }
                                    autoEject = true;
                                    vDesc.addAll(ejectEntity(te, true));
                                }
                            }

                            if ((hit.getLocation() == Mech.LOC_HEAD)
                                    || ((hit.getLocation() == Mech.LOC_CT)
                                    && ((ammoExplosion && !autoEject) || areaSatArty))) {
                                te.getCrew().setDoomed(true);
                            }
                            if (game.getOptions().booleanOption(
                                    OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
                                vDesc.addAll(abandonEntity(te));
                            }
                        }

                        // nowhere for further damage to go
                        damage = 0;
                    } else if (nextHit.getLocation() == Entity.LOC_NONE) {
                        // Rest of the damage is wasted.
                        damage = 0;
                    } else if (ammoExplosion
                            && te.locationHasCase(hit.getLocation())) {
                        // Remaining damage prevented by CASE
                        r = new Report(6125);
                        r.subject = te_n;
                        r.add(damage);
                        r.indent(3);
                        vDesc.addElement(r);

                        // The target takes no more damage from the explosion.
                        damage = 0;
                    } else if (damage > 0) {
                        // remaining damage transfers
                        r = new Report(6130);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        r.add(te.getLocationAbbr(nextHit));
                        vDesc.addElement(r);

                        // If there are split weapons in this location, mark it
                        // as hit, even if it took no criticals.
                        for (Mounted m : te.getWeaponList()) {
                            if (m.isSplit()) {
                                if ((m.getLocation() == hit.getLocation())
                                        || (m.getLocation() == nextHit
                                        .getLocation())) {
                                    te.setWeaponHit(m);
                                }
                            }
                        }
                        // if this is damage from a nail/rivet gun, and we
                        // transfer
                        // to a location that has armor, and BAR >=5, no damage
                        if ((damageType == DamageType.NAIL_RIVET)
                                && (te.getArmor(nextHit.getLocation()) > 0)
                                && (te.getBARRating(nextHit.getLocation()) >= 5)) {
                            damage = 0;
                            r = new Report(6065);
                            r.subject = te_n;
                            r.indent(2);
                            vDesc.add(r);
                        }
                    }
                }
            } else if (hit.getSpecCrit()) {
                // ok, we dealt damage but didn't go on to internal
                // we get a chance of a crit, using Armor Piercing.
                // but only if we don't have hardened, Ferro-Lamellor, or reactive armor
                if (!hardenedArmor && !ferroLamellorArmor && !reactiveArmor) {
                    specCrits++;
                }
            }
            // check for breaching
            vDesc.addAll(breachCheck(te, hit.getLocation(), null, underWater));

            // resolve special results
            if ((hit.getEffect() & HitData.EFFECT_VEHICLE_MOVE_DAMAGED) == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {
                vDesc.addAll(vehicleMotiveDamage((Tank) te, hit.getMotiveMod()));
            }
            // Damage from any source can break spikes
            if (te.hasWorkingMisc(MiscType.F_SPIKES, -1, hit.getLocation())) {
                vDesc.add(checkBreakSpikes(te, hit.getLocation()));
            }

            // roll all critical hits against this location
            // unless the section destroyed in a previous phase?
            // Cause a crit.
            if ((te.getInternal(hit) != IArmorState.ARMOR_DESTROYED)
                    && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                for (int i = 0; i < crits; i++) {
                    vDesc.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),
                            hit.glancingMod() + critBonus, damage_orig, damageType));
                }
                crits = 0;

                for (int i = 0; i < specCrits; i++) {
                    // against BAR or reflective armor, we get a +2 mod
                    int critMod = te.hasBARArmor(hit.getLocation()) ? 2 : 0;
                    critMod += (reflectiveArmor && !isBattleArmor) ? 2 : 0; // BA
                    // against impact armor, we get a +1 mod
                    critMod += impactArmor ? 1 : 0;
                    // hardened armour has no crit penalty
                    if (!hardenedArmor) {
                        // non-hardened armor gets modifiers
                        // the -2 for hardened is handled in the critBonus
                        // variable
                        critMod += hit.getSpecCritMod();
                        critMod += hit.glancingMod();
                    }
                    vDesc.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),
                            critMod + critBonus, damage_orig));
                }
                specCrits = 0;
            }

            // resolve Aero crits
            if (te instanceof Aero) {
                checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh, critSI,
                        ammoExplosion, nukeS2S);
            }

            if (isHeadHit
                    && !te.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {
                Report.addNewline(vDesc);
                vDesc.addAll(damageCrew(te, 1));
            }

            // If the location has run out of internal structure, finally
            // actually
            // destroy it here. *EXCEPTION:* Aero units have 0 internal
            // structure
            // in every location by default and are handled elsewhere, so they
            // get a bye.
            if (!(te instanceof Aero) && (te.getInternal(hit) <= 0)) {
                te.destroyLocation(hit.getLocation());

                // Check for possible engine destruction here
                if ((te instanceof Mech)
                        && ((hit.getLocation() == Mech.LOC_RT) || (hit.getLocation() == Mech.LOC_LT))) {

                    int numEngineHits = te.getEngineHits();
                    boolean engineExploded = checkEngineExplosion(te, vDesc, numEngineHits);

                    int hitsToDestroy = 3;
                    if ((te instanceof Mech) && te.isSuperHeavy() && te.hasEngine()
                            && (te.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                        hitsToDestroy = 2;
                    }

                    if (!engineExploded && (numEngineHits >= hitsToDestroy)) {
                        // third engine hit
                        vDesc.addAll(destroyEntity(te, "engine destruction"));
                        if (game.getOptions()
                                .booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
                            vDesc.addAll(abandonEntity(te));
                        }
                        te.setSelfDestructing(false);
                        te.setSelfDestructInitiated(false);
                    }

                    // Torso destruction in airborne LAM causes immediate crash.
                    if ((te instanceof LandAirMech) && !te.isDestroyed() && !te.isDoomed()) {
                        r = new Report(9710);
                        r.subject = te.getId();
                        r.addDesc(te);
                        if (te.isAirborneVTOLorWIGE()) {
                            vDesc.add(r);
                            crashAirMech(te, new PilotingRollData(te.getId(), TargetRoll.AUTOMATIC_FAIL,
                                    "side torso destroyed"), vDesc);
                        } else if (te.isAirborne() && te.isAero()) {
                            vDesc.add(r);
                            vDesc.addAll(processCrash(te, ((IAero) te).getCurrentVelocity(), te.getPosition()));
                        }
                    }
                }

            }

            // If damage remains, loop to next location; if not, be sure to stop
            // here because we may need to refer back to the last *damaged*
            // location again later. (This is safe because at damage <= 0 the
            // loop terminates anyway.)
            if (damage > 0) {
                hit = nextHit;
                // Need to update armor status for the new location
                hardenedArmor = ((te instanceof Mech) || (te instanceof Tank))
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED);
                ferroLamellorArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_LAMELLOR);
                reflectiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REFLECTIVE))
                        || (isBattleArmor
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REFLECTIVE));
                reactiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REACTIVE))
                        || (isBattleArmor && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REACTIVE));
                ballisticArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BALLISTIC_REINFORCED);
                impactArmor = (te instanceof Mech)
                        && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_IMPACT_RESISTANT);
            }
            if (damageIS) {
                wasDamageIS = true;
                damageIS = false;
            }
        }
        // Mechs using EI implants take pilot damage each time a hit
        // inflicts IS damage
        if (tookInternalDamage
                && ((te instanceof Mech) || (te instanceof Protomech))
                && te.hasActiveEiCockpit()) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(5075);
            r.subject = te.getId();
            r.addDesc(te);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 7);
            r.indent(2);
            vDesc.add(r);
            if (roll < 7) {
                vDesc.addAll(damageCrew(te, 1));
            }
        }

        // if using VDNI (but not buffered), check for damage on an internal hit
        if (tookInternalDamage
                && te.hasAbility(OptionsConstants.MD_VDNI)
                && !te.hasAbility(OptionsConstants.MD_BVDNI)
                && !te.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(3580);
            r.subject = te.getId();
            r.addDesc(te);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 8);
            r.indent(2);
            vDesc.add(r);
            if (roll >= 8) {
                vDesc.addAll(damageCrew(te, 1));
            }
        }

        // TacOps p.78 Ammo booms can hurt other units in same and adjacent hexes
        // But, this does not apply to CASE'd units and it only applies if the
        // ammo explosion
        // destroyed the unit
        if (ammoExplosion && game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_AMMUNITION)
                // For 'Mechs we care whether there was CASE specifically in the
                // location that went boom...
                && !(te.locationHasCase(hit.getLocation()) || te.hasCASEII(hit.getLocation()))
                // ...but vehicles and ASFs just have one CASE item for the
                // whole unit, so we need to look whether there's CASE anywhere
                // at all.
                && !(((te instanceof Tank) || (te instanceof Aero)) && te
                .hasCase()) && (te.isDestroyed() || te.isDoomed())
                && (damage_orig > 0) && ((damage_orig / 10) > 0)) {
            Report.addNewline(vDesc);
            r = new Report(5068, Report.PUBLIC);
            r.subject = te.getId();
            r.addDesc(te);
            r.indent(2);
            vDesc.add(r);
            Report.addNewline(vDesc);
            r = new Report(5400, Report.PUBLIC);
            r.subject = te.getId();
            r.indent(2);
            vDesc.add(r);
            int[] damages = {(int) Math.floor(damage_orig / 10.0),
                    (int) Math.floor(damage_orig / 20.0)};
            doExplosion(damages, false, te.getPosition(), true, vDesc, null, 5,
                    te.getId(), false);
            Report.addNewline(vDesc);
            r = new Report(5410, Report.PUBLIC);
            r.subject = te.getId();
            r.indent(2);
            vDesc.add(r);
        }

        // This flag indicates the hit was directly to IS
        if (wasDamageIS) {
            Report.addNewline(vDesc);
        }
        return vDesc;
    }

    /**
     * Apply damage to an Entity carrying external Battle Armor or ProtoMech
     * when a location with a trooper present is hit.
     *
     * @param te             The carrying Entity
     * @param hit            The hit to resolve
     * @param damage         The amount of damage to be allocated
     * @param vDesc          The {@link Report} <code>Vector</code>
     * @param passenger      The BA squad
     * @return               The amount of damage remaining
     */
    private int damageExternalPassenger(Entity te, HitData hit, int damage, Vector<Report> vDesc,
                                        Entity passenger) {
        Report r;
        int passengerDamage = damage;
        int avoidRoll = Compute.d6();
        HitData passHit = passenger.getTrooperAtLocation(hit, te);
        if (passenger.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
            passengerDamage -= damage / 2;
            passHit = passenger.rollHitLocation(ToHitData.HIT_SPECIAL_PROTO, ToHitData.SIDE_FRONT);
        } else if (avoidRoll < 5) {
            passengerDamage = 0;
        }
        passHit.setGeneralDamageType(hit.getGeneralDamageType());

        if (passengerDamage > 0) {
            // Yup. Roll up some hit data for that passenger.
            r = new Report(6075);
            r.subject = passenger.getId();
            r.indent(3);
            r.addDesc(passenger);
            vDesc.addElement(r);

            // How much damage will the passenger absorb?
            int absorb = 0;
            HitData nextPassHit = passHit;
            do {
                int armorType = passenger.getArmorType(nextPassHit.getLocation());
                boolean armorDamageReduction = false;
                if (((armorType == EquipmentType.T_ARMOR_BA_REACTIVE)
                        && ((hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE)))
                        || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {
                    armorDamageReduction = true;
                }
                // Check for reflective armor
                if ((armorType == EquipmentType.T_ARMOR_BA_REFLECTIVE)
                        && (hit.getGeneralDamageType() == HitData.DAMAGE_ENERGY)) {
                    armorDamageReduction = true;
                }
                if (0 < passenger.getArmor(nextPassHit)) {
                    absorb += passenger.getArmor(nextPassHit);
                    if (armorDamageReduction) {
                        absorb *= 2;
                    }
                }
                if (0 < passenger.getInternal(nextPassHit)) {
                    absorb += passenger.getInternal(nextPassHit);
                    // Armor damage reduction, like for reflective or
                    // reactive armor will divide the whole damage
                    // total by 2 and round down. If we have an odd
                    // damage total, need to add 1 to make this
                    // evenly divisible by 2
                    if (((absorb % 2) != 0) && armorDamageReduction) {
                        absorb++;
                    }
                }
                nextPassHit = passenger.getTransferLocation(nextPassHit);
            } while ((damage > absorb) && (nextPassHit.getLocation() >= 0));

            // Damage the passenger.
            absorb = Math.min(passengerDamage, absorb);
            Vector<Report> newReports = damageEntity(passenger, passHit, absorb);
            for (Report newReport : newReports) {
                newReport.indent(2);
            }
            vDesc.addAll(newReports);

            // Did some damage pass on?
            if (damage > absorb) {
                // Yup. Remove the absorbed damage.
                damage -= absorb;
                r = new Report(6080);
                r.subject = te.getId();
                r.indent(2);
                r.add(damage);
                r.addDesc(te);
                vDesc.addElement(r);
            } else {
                // Nope. Return our description.
                return 0;
            }

        } else {
            // Report that a passenger that could've been missed
            // narrowly avoids damage
            r = new Report(6084);
            r.subject = passenger.getId();
            r.indent(3);
            r.addDesc(passenger);
            vDesc.addElement(r);
        } // End nLoc-has-exterior-passenger
        if (passenger.hasETypeFlag(Entity.ETYPE_PROTOMECH)
                && (passengerDamage > 0) && !passenger.isDoomed() && !passenger.isDestroyed()) {
            r = new Report(3850);
            r.subject = passenger.getId();
            r.indent(3);
            r.addDesc(passenger);
            vDesc.addElement(r);
            int facing = te.getFacing();
            // We're going to assume that it's mounted facing the mech
            Coords position = te.getPosition();
            if (!hit.isRear()) {
                facing = (facing + 3) % 6;
            }
            unloadUnit(te, passenger, position, facing, te.getElevation(), false, false);
            Entity violation = Compute.stackingViolation(game,
                    passenger.getId(), position);
            if (violation != null) {
                Coords targetDest = Compute.getValidDisplacement(game, passenger.getId(), position,
                        Compute.d6() - 1);
                addReport(doEntityDisplacement(violation, position, targetDest, null));
                // Update the violating entity's position on the client.
                entityUpdate(violation.getId());
            }
        }
        return damage;
    }

    /**
     * Check to see if the entity's engine explodes. Rules for ICE explosions
     * are different to fusion engines.
     *
     * @param en    - the <code>Entity</code> in question. This value must not be
     *              <code>null</code>.
     * @param vDesc - the <code>Vector</code> that this function should add its
     *              <code>Report<code>s to.  It may be empty, but not
     *              <code>null</code>.
     * @param hits  - the number of criticals on the engine
     * @return <code>true</code> if the unit's engine exploded,
     * <code>false</code> if not.
     */
    private boolean checkEngineExplosion(Entity en, Vector<Report> vDesc, int hits) {
        if (!(en instanceof Mech) && !(en instanceof Aero) && !(en instanceof Tank)) {
            return false;
        }
        // If this method gets called for an entity that's already destroyed or
        // that hasn't taken any actual engine hits this phase yet, do nothing.
        if (en.isDestroyed() || (en.engineHitsThisPhase <= 0)
                || en.getSelfDestructedThisTurn() || !en.hasEngine()) {
            return false;
        }
        int explosionBTH = 10;
        int hitsPerRound = 4;
        Engine engine = en.getEngine();

        if (en instanceof Tank) {
            explosionBTH = 12;
            hitsPerRound = 1;
        } else if (!(en instanceof Mech)) {
            explosionBTH = 12;
            hitsPerRound = 1;
        }

        // Non mechs and mechs that already rolled are safe
        if (en.rolledForEngineExplosion || !(en instanceof Mech)) {
            return false;
        }
        // ICE can always explode and roll every time hit
        if (engine.isFusion()
                && (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_ENGINE_EXPLOSIONS)
                || (en.engineHitsThisPhase < hitsPerRound))) {
            return false;
        }
        if (!engine.isFusion()) {
            switch (hits) {
                case 0:
                    return false;
                case 1:
                    explosionBTH = 10;
                    break;
                case 2:
                    explosionBTH = 7;
                    break;
                case 3:
                default:
                    explosionBTH = 4;
                    break;
            }
        }
        int explosionRoll = Compute.d6(2);
        boolean didExplode = explosionRoll >= explosionBTH;

        Report r;
        r = new Report(6150);
        r.subject = en.getId();
        r.indent(2);
        r.addDesc(en);
        r.add(en.engineHitsThisPhase);
        vDesc.addElement(r);
        r = new Report(6155);
        r.subject = en.getId();
        r.indent(2);
        r.add(explosionBTH);
        r.add(explosionRoll);
        vDesc.addElement(r);

        if (!didExplode) {
            // whew!
            if (engine.isFusion()) {
                en.rolledForEngineExplosion = true;
            }
            // fusion engines only roll 1/phase but ICE roll every time damaged
            r = new Report(6160);
            r.subject = en.getId();
            r.indent(2);
            vDesc.addElement(r);
        } else {
            en.rolledForEngineExplosion = true;
            r = new Report(6165, Report.PUBLIC);
            r.subject = en.getId();
            r.indent(2);
            vDesc.addElement(r);
            vDesc.addAll(destroyEntity(en, "engine explosion", false, false));
            // kill the crew
            en.getCrew().setDoomed(true);

            // This is a hack so MM.NET marks the mech as not salvageable
            en.destroyLocation(Mech.LOC_CT);

            // ICE explosions don't hurt anyone else, but fusion do
            if (engine.isFusion()) {
                int engineRating = en.getEngine().getRating();
                Report.addNewline(vDesc);
                r = new Report(5400, Report.PUBLIC);
                r.subject = en.getId();
                r.indent(2);
                vDesc.add(r);

                Mech mech = (Mech) en;
                if (mech.isAutoEject() && (!game.getOptions().booleanOption(
                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        || (game.getOptions().booleanOption(
                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
                        && mech.isCondEjectEngine()))) {
                    vDesc.addAll(ejectEntity(en, true));
                }

                doFusionEngineExplosion(engineRating, en.getPosition(), vDesc, null);
                Report.addNewline(vDesc);
                r = new Report(5410, Report.PUBLIC);
                r.subject = en.getId();
                r.indent(2);
                vDesc.add(r);

            }
        }

        return didExplode;
    }

    /**
     * Extract explosion functionality for generalized explosions in areas.
     */
    public void doFusionEngineExplosion(int engineRating, Coords position, Vector<Report> vDesc,
                                        Vector<Integer> vUnits) {
        int[] myDamages = { engineRating, (engineRating / 10), (engineRating / 20),
                (engineRating / 40) };
        doExplosion(myDamages, true, position, false, vDesc, vUnits, 5, -1, true);
    }

    /**
     * General function to cause explosions in areas.
     */
    public void doExplosion(int damage, int degradation, boolean autoDestroyInSameHex,
                            Coords position, boolean allowShelter, Vector<Report> vDesc,
                            Vector<Integer> vUnits, int excludedUnitId) {
        if (degradation < 1) {
            return;
        }

        int[] myDamages = new int[damage / degradation];

        if (myDamages.length < 1) {
            return;
        }

        myDamages[0] = damage;
        for (int x = 1; x < myDamages.length; x++) {
            myDamages[x] = myDamages[x - 1] - degradation;
        }
        doExplosion(myDamages, autoDestroyInSameHex, position, allowShelter, vDesc, vUnits,
                5, excludedUnitId, false);
    }

    /**
     * General function to cause explosions in areas.
     */
    public void doExplosion(int[] damages, boolean autoDestroyInSameHex, Coords position,
                            boolean allowShelter, Vector<Report> vDesc, Vector<Integer> vUnits,
                            int clusterAmt, int excludedUnitId, boolean engineExplosion) {
        if (vDesc == null) {
            vDesc = new Vector<>();
        }

        if (vUnits == null) {
            vUnits = new Vector<>();
        }

        Report r;
        HashSet<Entity> entitiesHit = new HashSet<>();

        // We need to damage buildings.
        Enumeration<Building> buildings = game.getBoard().getBuildings();
        while (buildings.hasMoreElements()) {
            final Building bldg = buildings.nextElement();

            // Lets find the closest hex from the building.
            Enumeration<Coords> hexes = bldg.getCoords();

            while (hexes.hasMoreElements()) {
                final Coords coords = hexes.nextElement();
                int dist = position.distance(coords);
                if (dist < damages.length) {
                    Vector<Report> buildingReport = damageBuilding(bldg, damages[dist], coords);
                    for (Report report : buildingReport) {
                        report.type = Report.PUBLIC;
                    }
                    vDesc.addAll(buildingReport);
                }
            }
        }

        // We need to damage terrain
        int maxDist = damages.length;
        Hex hex = game.getBoard().getHex(position);
        // Center hex starts on fire for engine explosions
        if (engineExplosion && (hex != null) && !hex.containsTerrain(Terrains.FIRE)) {
            r = new Report(5136);
            r.indent(2);
            r.type = Report.PUBLIC;
            r.add(position.getBoardNum());
            vDesc.add(r);
            Vector<Report> reports = new Vector<>();
            ignite(position, Terrains.FIRE_LVL_NORMAL, reports);
            for (Report report : reports) {
                report.indent();
            }
            vDesc.addAll(reports);
        }
        if ((hex != null) && hex.hasTerrainFactor()) {
            r = new Report(3384);
            r.indent(2);
            r.type = Report.PUBLIC;
            r.add(position.getBoardNum());
            r.add(damages[0]);
            vDesc.add(r);
        }
        Vector<Report> reports = tryClearHex(position, damages[0], Entity.NONE);
        for (Report report : reports) {
            report.indent(3);
        }
        vDesc.addAll(reports);

        // Handle surrounding coords
        for (int dist = 1; dist < maxDist; dist++) {
            List<Coords> coords = position.allAtDistance(dist);
            for (Coords c : coords) {
                hex = game.getBoard().getHex(c);
                if ((hex != null) && hex.hasTerrainFactor()) {
                    r = new Report(3384);
                    r.indent(2);
                    r.type = Report.PUBLIC;
                    r.add(c.getBoardNum());
                    r.add(damages[dist]);
                    vDesc.add(r);
                }
                reports = tryClearHex(c, damages[dist], Entity.NONE);
                for (Report report : reports) {
                    report.indent(3);
                }
                vDesc.addAll(reports);
            }
        }

        // Now we damage people near the explosion.
        List<Entity> loaded = new ArrayList<>();
        for (Iterator<Entity> ents = game.getEntities(); ents.hasNext();) {
            Entity entity = ents.next();

            if (entitiesHit.contains(entity)) {
                continue;
            }

            if (entity.getId() == excludedUnitId) {
                continue;
            }

            if (entity.isDestroyed() || !entity.isDeployed()) {
                // FIXME
                // IS this the behavior we want?
                // This means, incidentally, that salvage is never affected by
                // explosions
                // as long as it was destroyed before the explosion.
                continue;
            }

            // We are going to assume that explosions are on the ground here so
            // flying entities should be unaffected
            if (entity.isAirborne()) {
                continue;
            }

            if ((entity instanceof MechWarrior) && !((MechWarrior) entity).hasLanded()) {
                // MechWarrior is still up in the air ejecting hence safe
                // from this explosion.
                continue;
            }

            Coords entityPos = entity.getPosition();
            if (entityPos == null) {
                // maybe its loaded?
                Entity transport = game.getEntity(entity.getTransportId());
                if ((transport != null) && !transport.isAirborne()) {
                    loaded.add(entity);
                }
                continue;
            }
            int range = position.distance(entityPos);

            if (range >= damages.length) {
                // Yeah, this is fine. It's outside the blast radius.
                continue;
            }

            // We might need to nuke everyone in the explosion hex. If so...
            if ((range == 0) && autoDestroyInSameHex) {
                // Add the reports
                vDesc.addAll(destroyEntity(entity, "explosion proximity", false, false));
                // Add it to the "blasted units" list
                vUnits.add(entity.getId());
                // Kill the crew
                entity.getCrew().setDoomed(true);

                entitiesHit.add(entity);
                continue;
            }

            int damage = damages[range];

            if (allowShelter && canShelter(entityPos, position, entity.relHeight())) {
                if (isSheltered()) {
                    r = new Report(6545);
                    r.addDesc(entity);
                    r.subject = entity.getId();
                    vDesc.addElement(r);
                    continue;
                }
                // If shelter is allowed but didn't work, report that.
                r = new Report(6546);
                r.subject = entity.getId();
                r.addDesc(entity);
                vDesc.addElement(r);
            }

            // Since it's taking damage, add it to the list of units hit.
            vUnits.add(entity.getId());

            AreaEffectHelper.applyExplosionClusterDamageToEntity(entity, damage, clusterAmt, position, vDesc, this);

            Report.addNewline(vDesc);
        }

        // now deal with loaded units...
        for (Entity e : loaded) {
            // This can be null, if the transport died from damage
            final Entity transporter = game.getEntity(e.getTransportId());
            if ((transporter == null) || transporter.getExternalUnits().contains(e)) {
                // Its external or transport was destroyed - hit it.
                final Coords entityPos = (transporter == null ? e.getPosition()
                        : transporter.getPosition());
                final int range = position.distance(entityPos);

                if (range >= damages.length) {
                    // Yeah, this is fine. It's outside the blast radius.
                    continue;
                }

                int damage = damages[range];
                if (allowShelter) {
                    final int absHeight = (transporter == null ? e.relHeight()
                            : transporter.relHeight());
                    if (canShelter(entityPos, position, absHeight)) {
                        if (isSheltered()) {
                            r = new Report(6545);
                            r.addDesc(e);
                            r.subject = e.getId();
                            vDesc.addElement(r);
                            continue;
                        }
                        // If shelter is allowed but didn't work, report that.
                        r = new Report(6546);
                        r.subject = e.getId();
                        r.addDesc(e);
                        vDesc.addElement(r);
                    }
                }
                // No shelter
                // Since it's taking damage, add it to the list of units hit.
                vUnits.add(e.getId());

                r = new Report(6175);
                r.subject = e.getId();
                r.indent(2);
                r.addDesc(e);
                r.add(damage);
                vDesc.addElement(r);

                while (damage > 0) {
                    int cluster = Math.min(5, damage);
                    int table = ToHitData.HIT_NORMAL;
                    if (e instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    }
                    HitData hit = e.rollHitLocation(table, ToHitData.SIDE_FRONT);
                    vDesc.addAll(damageEntity(e, hit, cluster, false,
                            DamageType.IGNORE_PASSENGER, false, true));
                    damage -= cluster;
                }
                Report.addNewline(vDesc);
            }
        }
    }

    /**
     * Check if an Entity of the passed height can find shelter from a nuke blast
     *
     * @param entityPosition  the <code>Coords</code> the Entity is at
     * @param position        the <code>Coords</code> of the explosion
     * @param entityAbsHeight the <code>int</code> height of the entity
     * @return a <code>boolean</code> value indicating if the entity of the
     * given height can find shelter
     */
    public boolean canShelter(Coords entityPosition, Coords position, int entityAbsHeight) {
        // What is the next hex in the direction of the blast?
        Coords shelteringCoords = Coords.nextHex(entityPosition, position);
        Hex shelteringHex = game.getBoard().getHex(shelteringCoords);

        // This is an error condition. It really shouldn't ever happen.
        if (shelteringHex == null) {
            return false;
        }

        // Now figure out the height to which that hex will provide shelter.
        // It's worth noting, this assumes that any building in the hex has
        // already survived the bomb blast. In the case where a building
        // won't survive the blast but hasn't actually taken the damage
        // yet, this will be wrong.
        int shelterLevel = shelteringHex.floor();
        if (shelteringHex.containsTerrain(Terrains.BUILDING)) {
            shelterLevel = shelteringHex.ceiling();
        }

        // Get the absolute height of the unit relative to level 0.
        entityAbsHeight += game.getBoard().getHex(entityPosition).getLevel();

        // Now find the height that needs to be sheltered, and compare.
        return entityAbsHeight < shelterLevel;
    }

    /**
     * @return true if the unit succeeds a shelter roll
     */
    private boolean isSheltered() {
        return Compute.d6(2) >= 9;
    }

    /**
     * add a nuke to be exploded in the next weapons attack phase
     *
     * @param nuke this is an int[] with i=0 and i=1 being X and Y coordinates respectively,
     *             If the input array is length 3, then i=2 is NukeType (from HS:3070)
     *             If the input array is length 6, then i=2 is the base damage dealt,
     *             i=3 is the degradation, i=4 is the secondary radius, and i=5 is the crater depth
     */
    public void addScheduledNuke(int[] nuke) {
        scheduledNukes.add(nuke);
    }

    /**
     * explode any scheduled nukes
     */
    private void resolveScheduledNukes() {
        for (int[] nuke : scheduledNukes) {
            if (nuke.length == 3) {
                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1), nuke[2],
                        vPhaseReport);
            }
            if (nuke.length == 6) {
                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1), nuke[2], nuke[3],
                        nuke[4], nuke[5], vPhaseReport);
            }
        }
        scheduledNukes.clear();
    }

    /**
     * do a nuclear explosion
     *
     * @param position the position that will be hit by the nuke
     * @param nukeType the type of nuke
     * @param vDesc    a vector that contains the output report
     */
    public void doNuclearExplosion(Coords position, int nukeType, Vector<Report> vDesc) {
        AreaEffectHelper.NukeStats nukeStats = AreaEffectHelper.getNukeStats(nukeType);

        if (nukeStats == null) {
            LogManager.getLogger().error("Illegal nuke not listed in HS:3070");
        }

        doNuclearExplosion(position, nukeStats.baseDamage, nukeStats.degradation, nukeStats.secondaryRadius,
                nukeStats.craterDepth, vDesc);
    }

    /**
     * explode a nuke
     *
     * @param position          the position that will be hit by the nuke
     * @param baseDamage        the base damage from the blast
     * @param degradation       how fast the blast's power degrades
     * @param secondaryRadius   the secondary blast radius
     * @param craterDepth       the depth of the crater created by the blast
     * @param vDesc             a vector that contains the output report
     */
    public void doNuclearExplosion(Coords position, int baseDamage, int degradation,
                                   int secondaryRadius, int craterDepth, Vector<Report> vDesc) {
        // Just in case.
        if (vDesc == null) {
            vDesc = new Vector<>();
        }

        // First, crater the terrain.
        // All terrain, units, buildings... EVERYTHING in here is just gone.
        // Gotta love nukes.
        Report r = new Report(1215, Report.PUBLIC);

        r.indent();
        r.add(position.getBoardNum(), true);
        vDesc.add(r);

        int curDepth = craterDepth;
        int range = 0;
        while (range < (2 * craterDepth)) {
            // Get the set of hexes at this range.
            List<Coords> hexSet = position.allAtDistance(range);

            // Iterate through the hexes.
            for (Coords myHexCoords: hexSet) {
                // ignore out of bounds coordinates
                if (!game.getBoard().contains(myHexCoords)) {
                    continue;
                }

                Hex myHex = game.getBoard().getHex(myHexCoords);
                // In each hex, first, sink the terrain if necessary.
                myHex.setLevel((myHex.getLevel() - curDepth));

                // Then, remove ANY terrains here.
                // I mean ALL of them; they're all just gone.
                // No ruins, no water, no rough, no nothing.
                if (myHex.containsTerrain(Terrains.WATER)) {
                    myHex.setLevel(myHex.floor());
                }
                myHex.removeAllTerrains();
                myHex.clearExits();

                sendChangedHex(myHexCoords);
            }

            // Lastly, if the next distance is a multiple of 2...
            // The crater depth goes down one.
            if ((range > 0) && ((range % 2) == 0)) {
                curDepth--;
            }

            // Now that the hexes are dealt with, increment the distance.
            range++;
        }

        // This is technically part of cratering, but...
        // Now we destroy all the units inside the cratering range.
        for (Entity entity : game.getEntitiesVector()) {
            // loaded units and off board units don't have a position,
            // so we don't count 'em here
            if ((entity.getTransportId() != Entity.NONE) || (entity.getPosition() == null)) {
                continue;
            }

            // If it's too far away for this...
            if (position.distance(entity.getPosition()) >= range) {
                continue;
            }

            // If it's already destroyed...
            if (entity.isDestroyed()) {
                continue;
            }

            vDesc.addAll(destroyEntity(entity, "nuclear explosion proximity",
                    false, false));
            // Kill the crew
            entity.getCrew().setDoomed(true);
        }

        // Then, do actual blast damage.
        // Use the standard blast function for this.
        Vector<Report> tmpV = new Vector<>();
        Vector<Integer> blastedUnitsVec = new Vector<>();
        doExplosion(baseDamage, degradation, true, position, true, tmpV,
                blastedUnitsVec, -1);
        Report.indentAll(tmpV, 2);
        vDesc.addAll(tmpV);

        // Everything that was blasted by the explosion has to make a piloting
        // check at +6.
        for (int i : blastedUnitsVec) {
            Entity o = game.getEntity(i);
            if (o.canFall()) {
                // Needs a piloting check at +6 to avoid falling over.
                game.addPSR(new PilotingRollData(o.getId(), 6,
                        "hit by nuclear blast"));
            } else if (o instanceof VTOL) {
                // Needs a piloting check at +6 to avoid crashing.
                // Wheeeeee!
                VTOL vt = (VTOL) o;

                // Check only applies if it's in the air.
                // FIXME: is this actually correct? What about
                // buildings/bridges?
                if (vt.getElevation() > 0) {
                    game.addPSR(new PilotingRollData(vt.getId(), 6,
                            "hit by nuclear blast"));
                }
            } else if (o instanceof Tank) {
                // As per official answer on the rules questions board...
                // Needs a piloting check at +6 to avoid a 1-level fall...
                // But ONLY if a hover-tank.
                // TODO : Fix me
            }
        }

        // This ISN'T part of the blast, but if there's ANYTHING in the ground
        // zero hex, destroy it.
        Building tmpB = game.getBoard().getBuildingAt(position);
        if (tmpB != null) {
            r = new Report(2415);
            r.add(tmpB.getName());
            addReport(r);
            tmpB.setCurrentCF(0, position);
        }
        Hex gzHex = game.getBoard().getHex(position);
        if (gzHex.containsTerrain(Terrains.WATER)) {
            gzHex.setLevel(gzHex.floor());
        }
        gzHex.removeAllTerrains();

        // Next, for whatever's left, do terrain effects
        // such as clearing, roughing, and boiling off water.
        boolean damageFlag = true;
        int damageAtRange = baseDamage - (degradation * range);
        if (damageAtRange > 0) {
            for (int x = range; damageFlag; x++) {
                // Damage terrain as necessary.
                // Get all the hexes, and then iterate through them.
                List<Coords> hexSet = position.allAtDistance(x);

                // Iterate through the hexes.
                for (Coords myHexCoords : hexSet) {
                    // ignore out of bounds coordinates
                    if (!game.getBoard().contains(myHexCoords)) {
                        continue;
                    }

                    Hex myHex = game.getBoard().getHex(myHexCoords);

                    // For each 3000 damage, water level is reduced by 1.
                    if ((damageAtRange >= 3000) && (myHex.containsTerrain(Terrains.WATER))) {
                        int numCleared = damageAtRange / 3000;
                        int oldLevel = myHex.terrainLevel(Terrains.WATER);
                        myHex.removeTerrain(Terrains.WATER);
                        if (oldLevel > numCleared) {
                            myHex.setLevel(myHex.getLevel() - numCleared);
                            myHex.addTerrain(new Terrain(Terrains.WATER, oldLevel - numCleared));
                        } else {
                            myHex.setLevel(myHex.getLevel() - oldLevel);
                        }
                    }

                    // ANY non-water hex that takes 200 becomes rough.
                    if ((damageAtRange >= 200) && (!myHex.containsTerrain(Terrains.WATER))) {
                        myHex.removeAllTerrains();
                        myHex.clearExits();
                        myHex.addTerrain(new Terrain(Terrains.ROUGH, 1));
                    } else if ((damageAtRange >= 20)
                            && ((myHex.containsTerrain(Terrains.WOODS))
                            || (myHex.containsTerrain(Terrains.JUNGLE)))) {
                        // Each 20 clears woods by 1 level.
                        int numCleared = damageAtRange / 20;
                        int terrainType = (myHex.containsTerrain(Terrains.WOODS)
                                ? Terrains.WOODS : Terrains.JUNGLE);
                        int oldLevel = myHex.terrainLevel(terrainType);
                        int oldEl = myHex.terrainLevel(Terrains.FOLIAGE_ELEV);
                        myHex.removeTerrain(terrainType);
                        if (oldLevel > numCleared) {
                            myHex.addTerrain(new Terrain(terrainType, oldLevel - numCleared));
                            if (oldEl != 1) {
                                myHex.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV,
                                        oldLevel - numCleared == 3 ? 3 : 2));
                            }
                        } else {
                            myHex.removeTerrain(Terrains.FOLIAGE_ELEV);
                        }
                    }

                    sendChangedHex(myHexCoords);
                }

                // Initialize for the next iteration.
                damageAtRange = baseDamage - ((degradation * x) + 1);

                // If the damage is less than 20, it has no terrain effect.
                if (damageAtRange < 20) {
                    damageFlag = false;
                }
            }
        }

        // Lastly, do secondary effects.
        for (Entity entity : game.getEntitiesVector()) {
            // loaded units and off board units don't have a position,
            // so we don't count 'em here
            if ((entity.getTransportId() != Entity.NONE) || (entity.getPosition() == null)) {
                continue;
            }

            // If it's already destroyed...
            if ((entity.isDoomed()) || (entity.isDestroyed())) {
                continue;
            }

            // If it's too far away for this...
            if (position.distance(entity.getPosition()) > secondaryRadius) {
                continue;
            }

            // Actually do secondary effects against it.
            // Since the effects are unit-dependant, we'll just define it in the
            // entity.
            applySecondaryNuclearEffects(entity, position, vDesc);
        }

        // All right. We're done.
        r = new Report(1216, Report.PUBLIC);
        r.indent();
        r.newlines = 2;
        vDesc.add(r);
    }

    /**
     * Handles secondary effects from nuclear blasts against all units in range.
     *
     * @param entity   The entity to affect.
     * @param position The coordinates of the nuclear blast, for to-hit directions.
     * @param vDesc    a description vector to use for reports.
     */
    public void applySecondaryNuclearEffects(Entity entity, Coords position, Vector<Report> vDesc) {
        // If it's already destroyed, give up. We really don't care.
        if (entity.isDestroyed()) {
            return;
        }

        // Check to see if the infantry is in a protective structure.
        boolean inHardenedBuilding = (Compute.isInBuilding(game, entity)
                && (game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.BUILDING) == 4));

        // Roll 2d6.
        int roll = Compute.d6(2);

        Report r = new Report(6555);
        r.subject = entity.getId();
        r.add(entity.getDisplayName());
        r.add(roll);

        // If they are in protective structure, add 2 to the roll.
        if (inHardenedBuilding) {
            roll += 2;
            r.add(" + 2 (unit is in hardened building)");
        } else {
            r.add("");
        }

        // Also, if the entity is "hardened" against EMI, it gets a +2.
        // For these purposes, I'm going to hand this off to the Entity itself
        // to tell us.
        // Right now, it IS based purely on class, but I won't rule out the idea
        // of
        // "nuclear hardening" as equipment for a support vehicle, for example.
        if (entity.isNuclearHardened()) {
            roll += 2;
            r.add(" + 2 (unit is hardened against EMI)");
        } else {
            r.add("");
        }

        r.indent(2);
        vDesc.add(r);

        // Now, compare it to the table, and apply the effects.
        if (roll <= 4) {
            // The unit is destroyed.
            // Sucks, doesn't it?
            // This applies to all units.
            // Yup, just sucks.
            vDesc.addAll(destroyEntity(entity,
                    "nuclear explosion secondary effects", false, false));
            // Kill the crew
            entity.getCrew().setDoomed(true);
        } else if (roll <= 6) {
            if (entity instanceof BattleArmor) {
                // It takes 50% casualties, rounded up.
                BattleArmor myBA = (BattleArmor) entity;
                int numDeaths = (int) (Math.ceil((myBA.getNumberActiverTroopers())) / 2.0);
                for (int x = 0; x < numDeaths; x++) {
                    vDesc.addAll(applyCriticalHit(entity, 0, null, false,
                            0, false));
                }
            } else if (entity instanceof Infantry) {
                // Standard infantry are auto-killed in this band, unless
                // they're in a building.
                if (game.getBoard().getHex(entity.getPosition()).containsTerrain(Terrains.BUILDING)) {
                    // 50% casualties, rounded up.
                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 2.0));
                    vDesc.addAll(damageEntity(entity, new HitData(
                            Infantry.LOC_INFANTRY), damage, true));
                } else {
                    vDesc.addAll(destroyEntity(entity,
                            "nuclear explosion secondary effects", false, false));
                    entity.getCrew().setDoomed(true);
                }
            } else if (entity instanceof Tank) {
                // All vehicles suffer two critical hits...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));
                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));

                // ...and a Crew Killed hit.
                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,
                        Tank.CRIT_CREW_KILLED), false, 0, false));
            } else if ((entity instanceof Mech) || (entity instanceof Protomech)) {
                // 'Mechs suffer two critical hits...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));
                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));

                // and four pilot hits.
                vDesc.addAll(damageCrew(entity, 4));
            }
            // Buildings and gun emplacements and such are only affected by the EMI.
            // No auto-crits or anything.
        } else if (roll <= 10) {
            if (entity instanceof BattleArmor) {
                // It takes 25% casualties, rounded up.
                BattleArmor myBA = (BattleArmor) entity;
                int numDeaths = (int) (Math.ceil(((myBA.getNumberActiverTroopers())) / 4.0));
                for (int x = 0; x < numDeaths; x++) {
                    vDesc.addAll(applyCriticalHit(entity, 0, null, false, 0, false));
                }
            } else if (entity instanceof Infantry) {
                if (game.getBoard().getHex(entity.getPosition()).containsTerrain(Terrains.BUILDING)) {
                    // 25% casualties, rounded up.
                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 4.0));
                    vDesc.addAll(damageEntity(entity, new HitData(Infantry.LOC_INFANTRY), damage, true));
                } else {
                    // 50% casualties, rounded up.
                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 2.0));
                    vDesc.addAll(damageEntity(entity, new HitData(Infantry.LOC_INFANTRY), damage, true));
                }
            } else if (entity instanceof Tank) {
                // It takes one crit...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));

                // Plus a Crew Stunned critical.
                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,
                        Tank.CRIT_CREW_STUNNED), false, 0, false));
            } else if ((entity instanceof Mech) || (entity instanceof Protomech)) {
                // 'Mechs suffer a critical hit...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));

                // and two pilot hits.
                vDesc.addAll(damageCrew(entity, 2));
            }
            // Buildings and gun emplacements and such are only affected by
            // the EMI.
            // No auto-crits or anything.
        }
        // If it's 11+, there are no secondary effects beyond EMI.
        // Lucky bastards.

        // And lastly, the unit is now affected by electromagnetic interference.
        entity.setEMI(true);
    }

    /**
     * Apply a single critical hit. The following private member of Server are
     * accessed from this function, preventing it from being factored out of the
     * Server class: destroyEntity() destroyLocation() checkEngineExplosion()
     * damageCrew() explodeEquipment() game
     *
     * @param en               the <code>Entity</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit. This value may
     *                         be <code>Entity.NONE</code> for hits to <code>Tank</code>s and
     *                         for hits to a <code>Protomech</code> torso weapon.
     * @param cs               the <code>CriticalSlot</code> being damaged. This value may
     *                         not be <code>null</code>. For critical hits on a
     *                         <code>Tank</code>, the index of the slot should be the index
     *                         of the critical hit table.
     * @param secondaryEffects the <code>boolean</code> flag that indicates whether to allow
     *                         critical hits to cause secondary effects (such as triggering
     *                         an ammo explosion, sending hovercraft to watery graves, or
     *                         damaging ProtoMech torso weapons). This value is normally
     *                         <code>true</code>, but it will be <code>false</code> when the
     *                         hit is being applied from a saved game or scenario.
     * @param damageCaused     the amount of damage causing this critical.
     * @param isCapital        whether it was capital scale damage that caused critical
     */
    public Vector<Report> applyCriticalHit(Entity en, int loc, CriticalSlot cs,
                                           boolean secondaryEffects, int damageCaused,
                                           boolean isCapital) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        if (en instanceof Tank) {
            vDesc.addAll(applyTankCritical((Tank) en, loc, cs, damageCaused));
        } else if (en instanceof Aero) {
            vDesc.addAll(applyAeroCritical((Aero) en, loc, cs, damageCaused, isCapital));
        } else if (en instanceof BattleArmor) {
            // We might as well handle this here.
            // However, we're considering a crit against BA as a "crew kill".
            BattleArmor ba = (BattleArmor) en;
            r = new Report(6111);
            int randomTrooper = ba.getRandomTrooper();
            ba.destroyLocation(randomTrooper);
            r.add(randomTrooper);
            r.newlines = 1;
            vDesc.add(r);
        } else if (CriticalSlot.TYPE_SYSTEM == cs.getType()) {
            // Handle critical hits on system slots.
            cs.setHit(true);
            if (en instanceof Protomech) {
                vDesc.addAll(applyProtomechCritical((Protomech) en, loc, cs, secondaryEffects, damageCaused, isCapital));
            } else {
                vDesc.addAll(applyMechSystemCritical(en, loc, cs));
            }
        } else if (CriticalSlot.TYPE_EQUIPMENT == cs.getType()) {
            vDesc.addAll(applyEquipmentCritical(en, loc, cs, secondaryEffects));
        } // End crit-on-equipment-slot

        // if using buffered VDNI then a possible pilot hit
        if (en.hasAbility(OptionsConstants.MD_BVDNI) && !en.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(3580);
            r.subject = en.getId();
            r.addDesc(en);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 8);
            r.indent(2);
            vDesc.add(r);
            if (roll >= 8) {
                vDesc.addAll(damageCrew(en, 1));
            }
        }

        // Return the results of the damage.
        return vDesc;
    }

    /**
     * Apply a single critical hit to an equipment slot.
     *
     * @param en               the <code>Entity</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit.
     * @param cs               the <code>CriticalSlot</code> being damaged.
     * @param secondaryEffects the <code>boolean</code> flag that indicates whether to allow
     *                         critical hits to cause secondary effects (such as triggering
     *                         an ammo explosion, sending hovercraft to watery graves, or
     *                         damaging ProtoMech torso weapons). This value is normally
     *                         <code>true</code>, but it will be <code>false</code> when the
     *                         hit is being applied from a saved game or scenario.
     */
    private Vector<Report> applyEquipmentCritical(Entity en, int loc, CriticalSlot cs,
                                                  boolean secondaryEffects) {
        Vector<Report> reports = new Vector<>();
        Report r;
        cs.setHit(true);
        Mounted mounted = cs.getMount();
        EquipmentType eqType = mounted.getType();
        boolean hitBefore = mounted.isHit();

        r = new Report(6225);
        r.subject = en.getId();
        r.indent(3);
        r.add(mounted.getDesc());
        reports.addElement(r);

        // Shield objects are not useless when they take one crit.
        if ((eqType instanceof MiscType) && ((MiscType) eqType).isShield()) {
            mounted.setHit(false);
        } else if (mounted.is(EquipmentTypeLookup.SCM)) {
            // Super-Cooled Myomer remains functional until all its slots have been hit
            if (en.damagedSCMCritCount() >= 6) {
                mounted.setHit(true);
            }
        } else {
            mounted.setHit(true);
        }

        if ((eqType instanceof MiscType) && eqType.hasFlag(MiscType.F_EMERGENCY_COOLANT_SYSTEM)) {
            ((Mech) en).setHasDamagedCoolantSystem(true);
        }

        if ((eqType instanceof MiscType) && eqType.hasFlag(MiscType.F_HARJEL)) {
            reports.addAll(breachLocation(en, loc, null, true));
        }

        // HarJel II/III hits trigger another possible critical hit on
        // the same location
        // it's like an ammunition explosion---a secondary effect
        if (secondaryEffects && (eqType instanceof MiscType)
                && (eqType.hasFlag(MiscType.F_HARJEL_II) || eqType.hasFlag(MiscType.F_HARJEL_III))
                && !hitBefore) {
            r = new Report(9852);
            r.subject = en.getId();
            r.indent(2);
            reports.addElement(r);
            reports.addAll(criticalEntity(en, loc, false, 0, 0));
        }

        // If the item is the ECM suite of a Mek Stealth system
        // then it's destruction turns off the stealth.
        if (!hitBefore && (eqType instanceof MiscType)
                && eqType.hasFlag(MiscType.F_ECM)
                && (mounted.getLinkedBy() != null)) {
            Mounted stealth = mounted.getLinkedBy();
            r = new Report(6255);
            r.subject = en.getId();
            r.indent(2);
            r.add(stealth.getType().getName());
            reports.addElement(r);
            stealth.setMode("Off");
        }

        // Handle equipment explosions.
        // Equipment explosions are secondary effects and
        // do not occur when loading from a scenario.
        if (((secondaryEffects && eqType.isExplosive(mounted))
                || mounted.isHotLoaded() || (mounted.hasChargedCapacitor() != 0))
                && !hitBefore) {
            reports.addAll(explodeEquipment(en, loc, mounted));
        }

        // Make sure that ammo in this slot is exhausted.
        if (mounted.getBaseShotsLeft() > 0) {
            mounted.setShotsLeft(0);
        }

        // LAMs that are part of a fighter squadron will need to have the squadron recalculate
        // the bomb load out on a bomb bay critical.
        if (en.isPartOfFighterSquadron() && (mounted.getType() instanceof MiscType)
                && mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {
            Entity squadron = game.getEntity(en.getTransportId());
            if (squadron instanceof FighterSquadron) {
                ((FighterSquadron) squadron).computeSquadronBombLoadout();
            }
        }
        return reports;
    }

    /**
     * Apply a single critical hit to a Mech system.
     *
     * @param en   the <code>Entity</code> that is being damaged. This value may
     *             not be <code>null</code>.
     * @param loc  the <code>int</code> location of critical hit.
     * @param cs   the <code>CriticalSlot</code> being damaged. This value may
     *             not be <code>null</code>.
     */
    private Vector<Report> applyMechSystemCritical(Entity en, int loc, CriticalSlot cs) {
        Vector<Report> reports = new Vector<>();
        Report r;
        r = new Report(6225);
        r.subject = en.getId();
        r.indent(3);
        r.add(((Mech) en).getSystemName(cs.getIndex()));
        reports.addElement(r);
        switch (cs.getIndex()) {
            case Mech.SYSTEM_COCKPIT:
                //First check whether this hit takes out the whole crew; for multi-crew cockpits
                //we need to check the other critical positions (if any).
                boolean allDead = true;
                int crewSlot = ((Mech) en).getCrewForCockpitSlot(loc, cs);
                if (crewSlot >= 0) {
                    for (int i = 0; i < en.getCrew().getSlotCount(); i++) {
                        if (i != crewSlot && !en.getCrew().isDead(i) && !en.getCrew().isMissing(i)) {
                            allDead = false;
                        }
                    }
                }
                if (allDead) {
                    // Don't kill a pilot multiple times.
                    if (Crew.DEATH > en.getCrew().getHits()) {
                        // Single pilot or tripod cockpit; all crew are killed.
                        en.getCrew().setDoomed(true);
                        Report.addNewline(reports);
                        reports.addAll(destroyEntity(en, "pilot death", true));
                    }
                } else if (!en.getCrew().isMissing(crewSlot)) {
                    boolean wasPilot = en.getCrew().getCurrentPilotIndex() == crewSlot;
                    boolean wasGunner = en.getCrew().getCurrentGunnerIndex() == crewSlot;
                    en.getCrew().setDead(true, crewSlot);
                    r = new Report(6027);
                    r.subject = en.getId();
                    r.indent(2);
                    r.add(en.getCrew().getCrewType().getRoleName(crewSlot));
                    r.addDesc(en);
                    r.add(en.getCrew().getName(crewSlot));
                    reports.addElement(r);
                    r = createCrewTakeoverReport(en, crewSlot, wasPilot, wasGunner);
                    if (null != r) {
                        reports.add(r);
                    }
                }

                break;
            case Mech.SYSTEM_ENGINE:
                // if the slot is missing, the location was previously
                // destroyed and the engine hit was then counted already
                if (!cs.isMissing()) {
                    en.engineHitsThisPhase++;
                }
                int numEngineHits = en.getEngineHits();
                boolean engineExploded = checkEngineExplosion(en, reports, numEngineHits);
                int hitsToDestroy = 3;
                if (en.isSuperHeavy() && en.hasEngine()
                        && (en.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                    hitsToDestroy = 2;
                }

                if (!engineExploded && (numEngineHits >= hitsToDestroy)) {
                    // third engine hit
                    reports.addAll(destroyEntity(en, "engine destruction"));
                    if (game.getOptions()
                            .booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
                        reports.addAll(abandonEntity(en));
                    }
                    en.setSelfDestructing(false);
                    en.setSelfDestructInitiated(false);
                }
                break;
            case Mech.SYSTEM_GYRO:
                int gyroHits = en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc);
                if (en.getGyroType() != Mech.GYRO_HEAVY_DUTY) {
                    gyroHits++;
                }
                // Automatically falls in AirMech mode, which it seems would indicate a crash if airborne.
                if (gyroHits == 3 && en instanceof LandAirMech && en.isAirborneVTOLorWIGE()) {
                    crashAirMech(en, new PilotingRollData(en.getId(),
                            TargetRoll.AUTOMATIC_FAIL, 1, "gyro destroyed"), reports);
                    break;
                }
                //No PSR for Mechs in non-leg mode
                if (!en.canFall(true)) {
                    break;
                }
                switch (gyroHits) {
                    case 3:
                        // HD 3 hits, standard 2 hits
                        game.addPSR(new PilotingRollData(en.getId(), TargetRoll.AUTOMATIC_FAIL,
                                1, "gyro destroyed"));
                        // Gyro destroyed entities may not be hull down
                        en.setHullDown(false);
                        break;
                    case 2:
                        // HD 2 hits, standard 1 hit
                        game.addPSR(new PilotingRollData(en.getId(), 3, "gyro hit"));
                        break;
                    case 1:
                        // HD 1 hit
                        game.addPSR(new PilotingRollData(en.getId(), 2, "gyro hit"));
                        break;
                    default:
                        // ignore if >4 hits (don't over do it, the auto fail
                        // already happened.)
                }
                break;
            case Mech.ACTUATOR_UPPER_LEG:
            case Mech.ACTUATOR_LOWER_LEG:
            case Mech.ACTUATOR_FOOT:
                if (en.canFall(true)) {
                    // leg/foot actuator piloting roll
                    game.addPSR(new PilotingRollData(en.getId(), 1, "leg/foot actuator hit"));
                }
                break;
            case Mech.ACTUATOR_HIP:
                if (en.canFall(true)) {
                    // hip piloting roll
                    game.addPSR(new PilotingRollData(en.getId(), 2, "hip actuator hit"));
                }
                break;
            case LandAirMech.LAM_AVIONICS:
                if (en.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER) {
                    if (en.isPartOfFighterSquadron()) {
                        game.addControlRoll(new PilotingRollData(
                                en.getTransportId(), 1, "avionics hit"));
                    } else if (en.isCapitalFighter()) {
                        game.addControlRoll(new PilotingRollData(en.getId(), 1,
                                "avionics hit"));
                    } else {
                        game.addControlRoll(new PilotingRollData(en.getId(), 0,
                                "avionics hit"));
                    }
                }
                break;
        }
        return reports;
    }

    /**
     * Apply a single critical hit to a ProtoMech.
     *
     * @param pm               the <code>Protomech</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit. This value may
     *                         be <code>Entity.NONE</code> for hits to a <code>Protomech</code>
     *                         torso weapon.
     * @param cs               the <code>CriticalSlot</code> being damaged. This value may
     *                         not be <code>null</code>.
     * @param secondaryEffects the <code>boolean</code> flag that indicates whether to allow
     *                         critical hits to cause secondary effects (such as damaging
     *                         ProtoMech torso weapons). This value is normally
     *                         <code>true</code>, but it will be <code>false</code> when the
     *                         hit is being applied from a saved game or scenario.
     * @param damageCaused     the amount of damage causing this critical.
     * @param isCapital        whether it was capital scale damage that caused critical
     */
    private Vector<Report> applyProtomechCritical(Protomech pm, int loc, CriticalSlot cs,
                                                  boolean secondaryEffects, int damageCaused,
                                                  boolean isCapital) {
        Vector<Report> reports = new Vector<>();
        Report r;
        int numHit = pm.getCritsHit(loc);
        if ((cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_A)
                && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_B)
                && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_C)
                && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_D)
                && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_E)
                && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_F)) {
            r = new Report(6225);
            r.subject = pm.getId();
            r.indent(3);
            r.add(Protomech.systemNames[cs.getIndex()]);
            reports.addElement(r);
        }
        switch (cs.getIndex()) {
            case Protomech.SYSTEM_HEADCRIT:
                if (2 == numHit) {
                    r = new Report(6230);
                    r.subject = pm.getId();
                    reports.addElement(r);
                    pm.destroyLocation(loc);
                }
                break;
            case Protomech.SYSTEM_ARMCRIT:
                if (2 == numHit) {
                    r = new Report(6235);
                    r.subject = pm.getId();
                    reports.addElement(r);
                    pm.destroyLocation(loc);
                }
                break;
            case Protomech.SYSTEM_LEGCRIT:
                if (3 == numHit) {
                    r = new Report(6240);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                    pm.destroyLocation(loc);
                }
                break;
            case Protomech.SYSTEM_TORSOCRIT:
                if (3 == numHit) {
                    reports.addAll(destroyEntity(pm, "torso destruction"));
                }
                // Torso weapon hits are secondary effects and
                // do not occur when loading from a scenario.
                else if (secondaryEffects) {
                    int tweapRoll = Compute.d6(1);
                    CriticalSlot newSlot;

                    switch (tweapRoll) {
                        case 1:
                            if (pm.isQuad()) {
                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_A);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                        case 2:
                            if (pm.isQuad()) {
                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_B);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                            newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                    Protomech.SYSTEM_TORSO_WEAPON_A);
                            reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                    secondaryEffects, damageCaused, isCapital));
                            break;
                        case 3:
                            if (pm.isQuad()) {
                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_C);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                        case 4:
                            if (pm.isQuad()) {
                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_D);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                            newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                    Protomech.SYSTEM_TORSO_WEAPON_B);
                            reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                    secondaryEffects, damageCaused, isCapital));
                            break;
                        case 5:
                            if (pm.getWeight() > 9) {
                                if (pm.isQuad()) {
                                    newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                            Protomech.SYSTEM_TORSO_WEAPON_E);
                                    reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                            secondaryEffects, damageCaused, isCapital));
                                    break;
                                }
                                newSlot = new CriticalSlot(
                                        CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_C);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                        case 6:
                            if (pm.getWeight() > 9) {
                                if (pm.isQuad()) {
                                    newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                            Protomech.SYSTEM_TORSO_WEAPON_F);
                                    reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                            secondaryEffects, damageCaused, isCapital));
                                    break;
                                }
                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                        Protomech.SYSTEM_TORSO_WEAPON_C);
                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,
                                        secondaryEffects, damageCaused, isCapital));
                                break;
                            }
                    }
                    // A magnetic clamp system is destroyed by any torso critical.
                    Mounted magClamp = pm.getMisc().stream().filter(m -> m.getType()
                            .hasFlag(MiscType.F_MAGNETIC_CLAMP)).findFirst().orElse(null);
                    if ((magClamp != null) && !magClamp.isHit()) {
                        magClamp.setHit(true);
                        r = new Report(6252);
                        r.subject = pm.getId();
                        reports.addElement(r);
                    }
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_A:
                Mounted weaponA = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponA) {
                    weaponA.setHit(true);
                    r = new Report(6245);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_B:
                Mounted weaponB = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponB) {
                    weaponB.setHit(true);
                    r = new Report(6246);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_C:
                Mounted weaponC = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponC) {
                    weaponC.setHit(true);
                    r = new Report(6247);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_D:
                Mounted weaponD = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponD) {
                    weaponD.setHit(true);
                    r = new Report(6248);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_E:
                Mounted weaponE = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponE) {
                    weaponE.setHit(true);
                    r = new Report(6249);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
            case Protomech.SYSTEM_TORSO_WEAPON_F:
                Mounted weaponF = pm.getTorsoWeapon(cs.getIndex());
                if (null != weaponF) {
                    weaponF.setHit(true);
                    r = new Report(6250);
                    r.subject = pm.getId();
                    r.newlines = 0;
                    reports.addElement(r);
                }
                break;
        }

        // Shaded hits cause pilot damage.
        if (pm.shaded(loc, numHit)) {
            // Destroyed ProtoMech sections have
            // already damaged the pilot.
            int pHits = Protomech.POSSIBLE_PILOT_DAMAGE[loc]
                    - pm.getPilotDamageTaken(loc);
            if (Math.min(1, pHits) > 0) {
                Report.addNewline(reports);
                reports.addAll(damageCrew(pm, 1));
                pHits = 1 + pm.getPilotDamageTaken(loc);
                pm.setPilotDamageTaken(loc, pHits);
            }
        }
        return reports;
    }

    /**
     * Apply a single critical hit to an aerospace unit.
     *
     * @param aero             the <code>Aero</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit.
     * @param cs               the <code>CriticalSlot</code> being damaged. This value may
     *                         not be <code>null</code>.
     * @param damageCaused     the amount of damage causing this critical.
     * @param isCapital        whether it was capital scale damage that caused critical
     */
    private Vector<Report> applyAeroCritical(Aero aero, int loc, CriticalSlot cs, int damageCaused, boolean isCapital) {
        Vector<Report> reports = new Vector<>();
        Report r;
        Jumpship js = null;
        if (aero instanceof Jumpship) {
            js = (Jumpship) aero;
        }

        switch (cs.getIndex()) {
            case Aero.CRIT_NONE:
                // no effect
                r = new Report(6005);
                r.subject = aero.getId();
                reports.add(r);
                break;
            case Aero.CRIT_FCS:
                // Fire control system
                r = new Report(9105);
                r.subject = aero.getId();
                reports.add(r);
                aero.setFCSHits(aero.getFCSHits() + 1);
                break;
            case Aero.CRIT_SENSOR:
                // sensors
                r = new Report(6620);
                r.subject = aero.getId();
                reports.add(r);
                aero.setSensorHits(aero.getSensorHits() + 1);
                break;
            case Aero.CRIT_AVIONICS:
                // avionics
                r = new Report(9110);
                r.subject = aero.getId();
                reports.add(r);
                aero.setAvionicsHits(aero.getAvionicsHits() + 1);
                if (aero.isPartOfFighterSquadron()) {
                    game.addControlRoll(new PilotingRollData(
                            aero.getTransportId(), 1, "avionics hit"));
                } else if (aero.isCapitalFighter()) {
                    game.addControlRoll(new PilotingRollData(aero.getId(), 1,
                            "avionics hit"));
                } else {
                    game.addControlRoll(new PilotingRollData(aero.getId(), 0,
                            "avionics hit"));
                }
                break;
            case Aero.CRIT_CONTROL:
                // force control roll
                r = new Report(9115);
                r.subject = aero.getId();
                reports.add(r);
                if (aero.isPartOfFighterSquadron()) {
                    game.addControlRoll(new PilotingRollData(
                            aero.getTransportId(), 1, "critical hit"));
                } else if (aero.isCapitalFighter()) {
                    game.addControlRoll(new PilotingRollData(aero.getId(), 1,
                            "critical hit"));
                } else {
                    game.addControlRoll(new PilotingRollData(aero.getId(), 0,
                            "critical hit"));
                }
                break;
            case Aero.CRIT_FUEL_TANK:
                // fuel tank
                int boomTarget = 10;
                if (aero.hasQuirk(OptionsConstants.QUIRK_NEG_FRAGILE_FUEL)) {
                    boomTarget = 8;
                }
                if (aero.isLargeCraft() && aero.isClan()
                        && game.getOptions().booleanOption(
                        OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)) {
                    boomTarget = 12;
                }
                // check for possible explosion
                int fuelroll = Compute.d6(2);
                r = new Report(9120);
                r.subject = aero.getId();
                if (fuelroll >= boomTarget) {
                    // A chance to reroll the explosion with edge
                    if (aero.getCrew().hasEdgeRemaining()
                            && aero.getCrew().getOptions().booleanOption(
                            OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)) {
                        // Reporting this is funky because 9120 only has room for 2 choices. Replace it.
                        r = new Report(9123);
                        r.subject = aero.getId();
                        r.newlines = 0;
                        reports.add(r);
                        aero.getCrew().decreaseEdge();
                        fuelroll = Compute.d6(2);
                        // To explode, or not to explode
                        if (fuelroll >= boomTarget) {
                            r = new Report(9124);
                            r.subject = aero.getId();
                        } else {
                            r = new Report(9122);
                            r.subject = aero.getId();
                            reports.add(r);
                            break;
                        }
                    }
                    r.choose(true);
                    reports.add(r);
                    // Lets auto-eject if we can!
                    if (aero.isFighter()) {
                        if (aero.isAutoEject()
                                && (!game.getOptions().booleanOption(
                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                || (game.getOptions().booleanOption(
                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
                                && aero.isCondEjectFuel()))) {
                            reports.addAll(ejectEntity(aero, true, false));
                        }
                    }
                    reports.addAll(destroyEntity(aero, "fuel explosion", false, false));
                } else {
                    r.choose(false);
                    reports.add(r);
                }

                aero.setFuelTankHit(true);
                break;
            case Aero.CRIT_CREW:
                // pilot hit
                r = new Report(6650);
                if (aero.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {
                    r = new Report(6651);
                    r.subject = aero.getId();
                    reports.add(r);
                    break;
                } else if (aero.hasAbility(OptionsConstants.MD_TSM_IMPLANT)) {
                    r = new Report(6652);
                    r.subject = aero.getId();
                    reports.add(r);
                    break;
                }
                if ((aero instanceof SmallCraft) || (aero instanceof Jumpship)) {
                    r = new Report(9197);
                }
                if (aero.isLargeCraft() && aero.isClan()
                        && game.getOptions().booleanOption(
                        OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)
                        && (aero.getIgnoredCrewHits() < 2)) {
                    aero.setIgnoredCrewHits(aero.getIgnoredCrewHits() + 1);
                    r = new Report(9198);
                    r.subject = aero.getId();
                    reports.add(r);
                    break;
                }
                r.subject = aero.getId();
                reports.add(r);
                reports.addAll(damageCrew(aero, 1));
                // The pilot may have just expired.
                if ((aero.getCrew().isDead() || aero.getCrew().isDoomed())
                        && !aero.getCrew().isEjected()) {
                    reports.addAll(destroyEntity(aero, "pilot death", true, true));
                }
                break;
            case Aero.CRIT_GEAR:
                // landing gear
                r = new Report(9125);
                r.subject = aero.getId();
                reports.add(r);
                aero.setGearHit(true);
                break;
            case Aero.CRIT_BOMB:
                // bomb destroyed
                // go through bomb list and choose one
                List<Mounted> bombs = new ArrayList<>();
                for (Mounted bomb : aero.getBombs()) {
                    if (bomb.getType().isHittable() && (bomb.getHittableShotsLeft() > 0)) {
                        bombs.add(bomb);
                    }
                }
                if (!bombs.isEmpty()) {
                    Mounted hitbomb = bombs.get(Compute.randomInt(bombs.size()));
                    hitbomb.setShotsLeft(0);
                    hitbomb.setDestroyed(true);
                    r = new Report(9130);
                    r.subject = aero.getId();
                    r.add(hitbomb.getDesc());
                    reports.add(r);
                    // If we are part of a squadron, we should recalculate
                    // the bomb salvo for the squadron
                    if (aero.getTransportId() != Entity.NONE) {
                        Entity e = game.getEntity(aero.getTransportId());
                        if (e instanceof FighterSquadron) {
                            ((FighterSquadron) e).computeSquadronBombLoadout();
                        }
                    }
                } else {
                    r = new Report(9131);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                break;
            case Aero.CRIT_HEATSINK:
                // heat sink hit
                int sinksLost = 1;
                if (isCapital) {
                    sinksLost = 10;
                }
                r = new Report(9135);
                r.subject = aero.getId();
                r.add(sinksLost);
                reports.add(r);
                aero.setHeatSinks(Math.max(0, aero.getHeatSinks() - sinksLost));
                break;
            case Aero.CRIT_WEAPON_BROAD:
                if (aero instanceof Warship) {
                    if ((loc == Jumpship.LOC_ALS) || (loc == Jumpship.LOC_FLS)) {
                        loc = Warship.LOC_LBS;
                    } else if ((loc == Jumpship.LOC_ARS)
                            || (loc == Jumpship.LOC_FRS)) {
                        loc = Warship.LOC_RBS;
                    }
                }
            case Aero.CRIT_WEAPON:
                if (aero.isCapitalFighter()) {
                    boolean destroyAll = false;
                    // CRIT_WEAPON damages the capital fighter/squadron's weapon groups
                    // Go ahead and map damage for the fighter's weapon criticals for MHQ
                    // resolution.
                    aero.damageCapFighterWeapons(loc);
                    if ((loc == Aero.LOC_NOSE) || (loc == Aero.LOC_AFT)) {
                        destroyAll = true;
                    }

                    // Convert L/R wing location to wings, else wing weapons never get hit
                    if (loc == Aero.LOC_LWING || loc == Aero.LOC_RWING) {
                        loc = Aero.LOC_WINGS;
                    }

                    if (loc == Aero.LOC_WINGS) {
                        if (aero.areWingsHit()) {
                            destroyAll = true;
                        } else {
                            aero.setWingsHit(true);
                        }
                    }
                    for (Mounted weapon : aero.getWeaponList()) {
                        if (weapon.getLocation() == loc) {
                            if (destroyAll) {
                                weapon.setHit(true);
                            } else {
                                weapon.setNWeapons(weapon.getNWeapons() / 2);
                            }
                        }
                    }
                    // also destroy any ECM or BAP in the location hit
                    for (Mounted misc : aero.getMisc()) {
                        if ((misc.getType().hasFlag(MiscType.F_ECM)
                                || misc.getType().hasFlag(MiscType.F_ANGEL_ECM)
                                || misc.getType().hasFlag(MiscType.F_BAP))
                                && misc.getLocation() == loc) {
                            misc.setHit(true);
                            //Taharqa: We should also damage the critical slot, or
                            //MM and MHQ won't remember that this weapon is damaged on the MUL
                            //file
                            for (int i = 0; i < aero.getNumberOfCriticals(loc); i++) {
                                CriticalSlot slot1 = aero.getCritical(loc, i);
                                if ((slot1 == null) ||
                                        (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                                    continue;
                                }
                                Mounted mounted = slot1.getMount();
                                if (mounted.equals(misc)) {
                                    aero.hitAllCriticals(loc, i);
                                    break;
                                }
                            }
                        }
                    }
                    r = new Report(9152);
                    r.subject = aero.getId();
                    r.add(aero.getLocationName(loc));
                    reports.add(r);
                    break;
                }
                r = new Report(9150);
                r.subject = aero.getId();
                List<Mounted> weapons = new ArrayList<>();
                for (Mounted weapon : aero.getWeaponList()) {
                    if ((weapon.getLocation() == loc) && !weapon.isDestroyed()
                            && weapon.getType().isHittable()) {
                        weapons.add(weapon);
                    }
                }
                // add in in hittable misc equipment
                for (Mounted misc : aero.getMisc()) {
                    if (misc.getType().isHittable()
                            && (misc.getLocation() == loc)
                            && !misc.isDestroyed()) {
                        weapons.add(misc);
                    }
                }

                if (!weapons.isEmpty()) {
                    Mounted weapon = weapons.get(Compute.randomInt(weapons.size()));
                    // possibly check for an ammo explosion
                    // don't allow ammo explosions on fighter squadrons
                    if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_AMMO_EXPLOSIONS)
                            && !(aero instanceof FighterSquadron)
                            && (weapon.getType() instanceof WeaponType)) {
                        //Bay Weapons
                        if (aero.usesWeaponBays()) {
                            //Finish reporting(9150) a hit on the bay
                            r.add(weapon.getName());
                            reports.add(r);
                            //Pick a random weapon in the bay and get the stats
                            int wId = weapon.getBayWeapons().get(Compute.randomInt(weapon.getBayWeapons().size()));
                            Mounted bayW = aero.getEquipment(wId);
                            Mounted bayWAmmo = bayW.getLinked();
                            if (bayWAmmo != null && bayWAmmo.getType().isExplosive(bayWAmmo)) {
                                r = new Report(9156);
                                r.subject = aero.getId();
                                r.newlines = 1;
                                r.indent(2);
                                //On a roll of 10+, the ammo bin explodes
                                int ammoRoll = Compute.d6(2);
                                boomTarget = 10;
                                r.choose(ammoRoll >= boomTarget);
                                // A chance to reroll an explosion with edge
                                if (aero.getCrew().hasEdgeRemaining()
                                        && aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)
                                        && ammoRoll >= boomTarget) {
                                    // Report 9156 doesn't offer the right choices. Replace it.
                                    r = new Report(9158);
                                    r.subject = aero.getId();
                                    r.newlines = 0;
                                    r.indent(2);
                                    reports.add(r);
                                    aero.getCrew().decreaseEdge();
                                    ammoRoll = Compute.d6(2);
                                    // To explode, or not to explode
                                    if (ammoRoll >= boomTarget) {
                                        reports.addAll(explodeEquipment(aero, loc, bayWAmmo));
                                    } else {
                                        r = new Report(9157);
                                        r.subject = aero.getId();
                                        reports.add(r);
                                    }
                                } else {
                                    // Finish handling report 9156
                                    reports.add(r);
                                    if (ammoRoll >= boomTarget) {
                                        reports.addAll(explodeEquipment(aero, loc, bayWAmmo));
                                    }
                                }
                            }
                            // Hit the weapon then also hit all the other weapons in the bay
                            weapon.setHit(true);
                            for (int next : weapon.getBayWeapons()) {
                                Mounted bayWeap = aero.getEquipment(next);
                                if (null != bayWeap) {
                                    bayWeap.setHit(true);
                                    // Taharqa : We should also damage the critical slot, or MM and
                                    // MHQ won't remember that this weapon is damaged on the MUL file
                                    for (int i = 0; i < aero.getNumberOfCriticals(loc); i++) {
                                        CriticalSlot slot1 = aero.getCritical(loc, i);
                                        if ((slot1 == null) ||
                                                (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                                            continue;
                                        }
                                        Mounted mounted = slot1.getMount();
                                        if (mounted.equals(bayWeap)) {
                                            aero.hitAllCriticals(loc, i);
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        }
                        // does it use Ammo?
                        WeaponType wtype = (WeaponType) weapon.getType();
                        if (wtype.getAmmoType() != AmmoType.T_NA) {
                            Mounted m = weapon.getLinked();
                            int ammoroll = Compute.d6(2);
                            if (ammoroll >= 10) {
                                // A chance to reroll an explosion with edge
                                if (aero.getCrew().hasEdgeRemaining()
                                        && aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)) {
                                    aero.getCrew().decreaseEdge();
                                    r = new Report(6530);
                                    r.subject = aero.getId();
                                    r.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                                    reports.add(r);
                                    ammoroll = Compute.d6(2);
                                    if (ammoroll >= 10) {
                                        reports.addAll(explodeEquipment(aero, loc, m));
                                        break;
                                    } else {
                                        // Crisis averted, set report 9150 back up
                                        r = new Report(9150);
                                        r.subject = aero.getId();
                                    }
                                } else {
                                    r = new Report(9151);
                                    r.subject = aero.getId();
                                    r.add(m.getName());
                                    r.newlines = 0;
                                    reports.add(r);
                                    reports.addAll(explodeEquipment(aero, loc, m));
                                    break;
                                }
                            }
                        }
                    }
                    // If the weapon is explosive, use edge to roll up a new one
                    if (aero.getCrew().hasEdgeRemaining()
                            && aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)
                            && (weapon.getType().isExplosive(weapon) && !weapon.isHit()
                            && !weapon.isDestroyed())) {
                        aero.getCrew().decreaseEdge();
                        // Try something new for an interrupting report. r is still 9150.
                        Report r1 = new Report(6530);
                        r1.subject = aero.getId();
                        r1.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                        reports.add(r1);
                        weapon = weapons.get(Compute.randomInt(weapons.size()));
                    }
                    r.add(weapon.getName());
                    reports.add(r);
                    // explosive weapons e.g. gauss now explode
                    if (weapon.getType().isExplosive(weapon) && !weapon.isHit()
                            && !weapon.isDestroyed()) {
                        reports.addAll(explodeEquipment(aero, loc, weapon));
                    }
                    weapon.setHit(true);
                    // Taharqa : We should also damage the critical slot, or MM and MHQ won't
                    // remember that this weapon is damaged on the MUL file
                    for (int i = 0; i < aero.getNumberOfCriticals(loc); i++) {
                        CriticalSlot slot1 = aero.getCritical(loc, i);
                        if ((slot1 == null) || (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                            continue;
                        }
                        Mounted mounted = slot1.getMount();
                        if (mounted.equals(weapon)) {
                            aero.hitAllCriticals(loc, i);
                            break;
                        }
                    }
                    // if this is a weapons bay then also hit all the other weapons
                    for (int wId : weapon.getBayWeapons()) {
                        Mounted bayWeap = aero.getEquipment(wId);
                        if (null != bayWeap) {
                            bayWeap.setHit(true);
                            // Taharqa : We should also damage the critical slot, or MM and MHQ
                            // won't remember that this weapon is damaged on the MUL file
                            for (int i = 0; i < aero.getNumberOfCriticals(loc); i++) {
                                CriticalSlot slot1 = aero.getCritical(loc, i);
                                if ((slot1 == null)
                                        || (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                                    continue;
                                }
                                Mounted mounted = slot1.getMount();
                                if (mounted.equals(bayWeap)) {
                                    aero.hitAllCriticals(loc, i);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    r = new Report(9155);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                break;
            case Aero.CRIT_ENGINE:
                // engine hit
                r = new Report(9140);
                r.subject = aero.getId();
                reports.add(r);
                aero.engineHitsThisPhase++;
                boolean engineExploded = checkEngineExplosion(aero, reports, 1);
                aero.setEngineHits(aero.getEngineHits() + 1);
                if ((aero.getEngineHits() >= aero.getMaxEngineHits())
                        || engineExploded) {
                    // this engine hit puts the ASF out of commission
                    reports.addAll(destroyEntity(aero, "engine destruction", true, true));
                    aero.setSelfDestructing(false);
                    aero.setSelfDestructInitiated(false);
                }
                break;
            case Aero.CRIT_LEFT_THRUSTER:
                // thruster hit
                r = new Report(9160);
                r.subject = aero.getId();
                reports.add(r);
                aero.setLeftThrustHits(aero.getLeftThrustHits() + 1);
                break;
            case Aero.CRIT_RIGHT_THRUSTER:
                // thruster hit
                r = new Report(9160);
                r.subject = aero.getId();
                reports.add(r);
                aero.setRightThrustHits(aero.getRightThrustHits() + 1);
                break;
            case Aero.CRIT_CARGO:
                applyCargoCritical(aero, damageCaused, reports);
                break;
            case Aero.CRIT_DOOR:
                // door hit
                // choose a random bay
                String bayType = aero.damageBayDoor();
                if (!bayType.equals("none")) {
                    r = new Report(9170);
                    r.subject = aero.getId();
                    r.add(bayType);
                    reports.add(r);
                } else {
                    r = new Report(9171);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                break;
            case Aero.CRIT_DOCK_COLLAR:
                // docking collar hit
                // different effect for DropShips and JumpShips
                if (aero instanceof Dropship) {
                    ((Dropship) aero).setDamageDockCollar(true);
                    r = new Report(9175);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                if (aero instanceof Jumpship) {
                    // damage a random docking collar
                    if (aero.damageDockCollar()) {
                        r = new Report(9176);
                        r.subject = aero.getId();
                        reports.add(r);
                    } else {
                        r = new Report(9177);
                        r.subject = aero.getId();
                        reports.add(r);
                    }
                }
                break;
            case Aero.CRIT_KF_BOOM:
                // KF boom hit
                // no real effect yet
                if (aero instanceof Dropship) {
                    ((Dropship) aero).setDamageKFBoom(true);
                    r = new Report(9180);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                break;
            case Aero.CRIT_CIC:
                if (js == null) {
                    break;
                }
                // CIC hit
                r = new Report(9185);
                r.subject = aero.getId();
                reports.add(r);
                js.setCICHits(js.getCICHits() + 1);
                break;
            case Aero.CRIT_KF_DRIVE:
                //Per SO construction rules, stations have no KF drive, therefore they can't take a hit to it...
                if (js == null || js instanceof SpaceStation) {
                    break;
                }
                // KF Drive hit - damage the drive integrity
                js.setKFIntegrity(Math.max(0, (js.getKFIntegrity() - 1)));
                if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_EXPANDED_KF_DRIVE_DAMAGE)) {
                    // Randomize the component struck - probabilities taken from the old BattleSpace record sheets
                    switch (Compute.d6(2)) {
                        case 2:
                            // Drive Coil Hit
                            r = new Report(9186);
                            r.subject = aero.getId();
                            reports.add(r);
                            js.setKFDriveCoilHit(true);
                            break;
                        case 3:
                        case 11:
                            // Charging System Hit
                            r = new Report(9187);
                            r.subject = aero.getId();
                            reports.add(r);
                            js.setKFChargingSystemHit(true);
                            break;
                        case 5:
                            // Field Initiator Hit
                            r = new Report(9190);
                            r.subject = aero.getId();
                            reports.add(r);
                            js.setKFFieldInitiatorHit(true);
                            break;
                        case 4:
                        case 6:
                        case 7:
                        case 8:
                            // Helium Tank Hit
                            r = new Report(9189);
                            r.subject = aero.getId();
                            reports.add(r);
                            js.setKFHeliumTankHit(true);
                            break;
                        case 9:
                            // Drive Controller Hit
                            r = new Report(9191);
                            r.subject = aero.getId();
                            reports.add(r);
                            js.setKFDriveControllerHit(true);
                            break;
                        case 10:
                        case 12:
                            // LF Battery Hit - if you don't have one, treat as helium tank
                            if (js.hasLF()) {
                                r = new Report(9188);
                                r.subject = aero.getId();
                                reports.add(r);
                                js.setLFBatteryHit(true);
                            } else {
                                r = new Report(9189);
                                r.subject = aero.getId();
                                reports.add(r);
                                js.setKFHeliumTankHit(true);
                            }
                            break;
                    }
                } else {
                    // Just report the standard KF hit, per SO rules
                    r = new Report(9194);
                    r.subject = aero.getId();
                    reports.add(r);
                }
                break;
            case Aero.CRIT_GRAV_DECK:
                if (js == null) {
                    break;
                } else if (js.getTotalGravDeck() <= 0) {
                    LogManager.getLogger().error("Cannot handle a grav deck crit for a JumpShip with no grav decks");
                    break;
                }
                int choice = Compute.randomInt(js.getTotalGravDeck());
                // Grav Deck hit
                r = new Report(9195);
                r.subject = aero.getId();
                reports.add(r);
                js.setGravDeckDamageFlag(choice, 1);
                break;
            case Aero.CRIT_LIFE_SUPPORT:
                // Life Support hit
                aero.setLifeSupport(false);
                r = new Report(9196);
                r.subject = aero.getId();
                reports.add(r);
                break;
        }
        return reports;
    }

    /**
     * Selects random undestroyed bay and applies damage, destroying loaded units where applicable.
     *
     * @param aero         The unit that received the cargo critical.
     * @param damageCaused The amount of damage applied by the hit that resulted in the cargo critical.
     * @param reports      Used to return any report generated while applying the critical.
     */
    private void applyCargoCritical(Aero aero, int damageCaused, Vector<Report> reports) {
        Report r;
        // cargo hit
        // First what percentage of the cargo did the hit destroy?
        double percentDestroyed = 0.0;
        double mult = 2.0;
        if (aero.isLargeCraft() && aero.isClan()
                && game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)) {
            mult = 4.0;
        }
        if (damageCaused > 0) {
            percentDestroyed = Math.min(
                    damageCaused / (mult * aero.getSI()), 1.0);
        }
        List<Bay> bays;
        double destroyed = 0;
        // did it hit cargo or units
        int roll = Compute.d6(1);
        // A hit on a bay filled with transported units is devastating
        // allow a reroll with edge
        if (aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_UNIT_CARGO_LOST)
                && aero.getCrew().hasEdgeRemaining() && roll > 3) {
            aero.getCrew().decreaseEdge();
            r = new Report(9172);
            r.subject = aero.getId();
            r.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));
            reports.add(r);
            // Reroll. Maybe we'll hit cargo.
            roll = Compute.d6(1);
        }
        if (roll < 4) {
            bays = aero.getTransportBays().stream().filter(Bay::isCargo).collect(Collectors.toList());
        } else {
            bays = aero.getTransportBays().stream()
                    .filter(b -> !b.isCargo() && !b.isQuarters()).collect(Collectors.toList());
        }
        Bay hitBay = null;
        while ((null == hitBay) && !bays.isEmpty()) {
            hitBay = bays.remove(Compute.randomInt(bays.size()));
            if (hitBay.getBayDamage() < hitBay.getCapacity()) {
                if (hitBay.isCargo()) {
                    destroyed = (hitBay.getCapacity() * percentDestroyed * 2.0) / 2.0;
                } else {
                    destroyed = Math.ceil(hitBay.getCapacity() * percentDestroyed);
                }
            } else {
                hitBay = null;
            }
        }
        if (null != hitBay) {
            destroyed = Math.min(destroyed, hitBay.getCapacity() - hitBay.getBayDamage());
            if (hitBay.isCargo()) {
                r = new Report(9165);
            } else {
                r = new Report(9166);
            }
            r.subject = aero.getId();
            r.add(hitBay.getBayNumber());
            if (destroyed == (int) destroyed) {
                r.add((int) destroyed);
            } else {
                r.add(String.valueOf(Math.ceil(destroyed * 2.0) / 2.0));
            }
            reports.add(r);
            if (!hitBay.isCargo()) {
                List<Entity> units = new ArrayList<>(hitBay.getLoadedUnits());
                List<Entity> toRemove = new ArrayList<>();
                // We're letting destroyed units stay in the bay now, but take them off the targets list
                for (Entity en : units) {
                    if (en.isDestroyed() || en.isDoomed()) {
                        toRemove.add(en);
                    }
                }
                units.removeAll(toRemove);
                while ((destroyed > 0) && !units.isEmpty()) {
                    Entity target = units.remove(Compute.randomInt(units.size()));
                    reports.addAll(destroyEntity(target, "cargo damage",
                            false, true));
                    destroyed--;
                }
            }
        } else {
            r = new Report(9167);
            r.subject = aero.getId();
            r.choose(roll < 4); // cargo or transport
            reports.add(r);
        }
    }

    /**
     * Apply a single critical hit to a vehicle.
     *
     * @param tank             the <code>Tank</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit. This value may
     *                         be <code>Entity.NONE</code> for hits to <code>Tank</code>s and
     *                         for hits to a <code>Protomech</code> torso weapon.
     * @param cs               the <code>CriticalSlot</code> being damaged. This value may
     *                         not be <code>null</code>. The index of the slot should be the index
     *                         of the critical hit table.
     * @param damageCaused     the amount of damage causing this critical.
     */
    private Vector<Report> applyTankCritical(Tank tank, int loc, CriticalSlot cs, int damageCaused) {
        Vector<Report> reports = new Vector<>();
        Report r;
        HitData hit;
        switch (cs.getIndex()) {
            case Tank.CRIT_NONE:
                // no effect
                r = new Report(6005);
                r.subject = tank.getId();
                reports.add(r);
                break;
            case Tank.CRIT_AMMO:
                // ammo explosion
                r = new Report(6610);
                r.subject = tank.getId();
                reports.add(r);
                int damage = 0;
                for (Mounted m : tank.getAmmo()) {
                    // Don't include ammo of one-shot weapons.
                    if (m.getLocation() == Entity.LOC_NONE) {
                        continue;
                    }
                    m.setHit(true);
                    int tmp = m.getHittableShotsLeft()
                            * ((AmmoType) m.getType()).getDamagePerShot()
                            * ((AmmoType) m.getType()).getRackSize();
                    m.setShotsLeft(0);
                    // non-explosive ammo can't explode
                    if (!m.getType().isExplosive(m)) {
                        continue;
                    }
                    damage += tmp;
                    r = new Report(6390);
                    r.subject = tank.getId();
                    r.add(m.getName());
                    r.add(tmp);
                    reports.add(r);
                }
                hit = new HitData(loc);
                reports.addAll(damageEntity(tank, hit, damage, true));
                break;
            case Tank.CRIT_CARGO:
                // Cargo/infantry damage
                r = new Report(6615);
                r.subject = tank.getId();
                reports.add(r);
                List<Entity> passengers = tank.getLoadedUnits();
                if (!passengers.isEmpty()) {
                    Entity target = passengers.get(Compute.randomInt(passengers.size()));
                    hit = target.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    reports.addAll(damageEntity(target, hit, damageCaused));
                }
                break;
            case Tank.CRIT_COMMANDER:
                if (tank.hasAbility(OptionsConstants.MD_VDNI)
                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {
                    r = new Report(6191);
                    r.subject = tank.getId();
                    reports.add(r);
                    reports.addAll(damageCrew(tank, 1));
                } else {
                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)
                            && !tank.isCommanderHitPS()) {
                        r = new Report(6606);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setCommanderHitPS(true);
                    } else if (tank.hasWorkingMisc(MiscType.F_COMMAND_CONSOLE)
                            && !tank.isUsingConsoleCommander()) {
                        r = new Report(6607);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setUsingConsoleCommander(true);
                    } else {
                        r = new Report(6605);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setCommanderHit(true);
                    }
                }
                // fall through here, because effects of crew stunned also
                // apply
            case Tank.CRIT_CREW_STUNNED:
                if (tank.hasAbility(OptionsConstants.MD_VDNI)
                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {
                    r = new Report(6191);
                    r.subject = tank.getId();
                    reports.add(r);
                    reports.addAll(damageCrew(tank, 1));
                } else {
                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)
                            || tank.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {
                        r = new Report(6186);
                    } else {
                        tank.stunCrew();
                        r = new Report(6185);
                        r.add(tank.getStunnedTurns() - 1);
                    }
                    r.subject = tank.getId();
                    reports.add(r);
                }
                break;
            case Tank.CRIT_DRIVER:
                if (tank.hasAbility(OptionsConstants.MD_VDNI)
                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {
                    r = new Report(6191);
                    r.subject = tank.getId();
                    reports.add(r);
                    reports.addAll(damageCrew(tank, 1));
                } else {
                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)
                            && !tank.isDriverHitPS()) {
                        r = new Report(6601);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setDriverHitPS(true);
                    } else {
                        r = new Report(6600);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setDriverHit(true);
                    }
                }
                break;
            case Tank.CRIT_CREW_KILLED:
                if (tank.hasAbility(OptionsConstants.MD_VDNI)
                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {
                    r = new Report(6191);
                    r.subject = tank.getId();
                    reports.add(r);
                    reports.addAll(damageCrew(tank, 1));
                } else {
                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT) && !tank.isCrewHitPS()) {
                        r = new Report(6191);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.setCrewHitPS(true);
                    } else {
                        r = new Report(6190);
                        r.subject = tank.getId();
                        reports.add(r);
                        tank.getCrew().setDoomed(true);
                        if (tank.isAirborneVTOLorWIGE()) {
                            reports.addAll(crashVTOLorWiGE(tank));
                        }
                    }
                }
                break;
            case Tank.CRIT_ENGINE:
                r = new Report(6210);
                r.subject = tank.getId();
                reports.add(r);
                tank.engineHit();
                tank.engineHitsThisPhase++;
                boolean engineExploded = checkEngineExplosion(tank, reports, 1);
                if (engineExploded) {
                    reports.addAll(destroyEntity(tank, "engine destruction", true, true));
                    tank.setSelfDestructing(false);
                    tank.setSelfDestructInitiated(false);
                }
                if (tank.isAirborneVTOLorWIGE()
                        && !(tank.isDestroyed() || tank.isDoomed())) {
                    tank.immobilize();
                    reports.addAll(forceLandVTOLorWiGE(tank));
                }
                break;
            case Tank.CRIT_FUEL_TANK:
                r = new Report(6215);
                r.subject = tank.getId();
                reports.add(r);
                reports.addAll(destroyEntity(tank, "fuel explosion", false, false));
                break;
            case Tank.CRIT_SENSOR:
                r = new Report(6620);
                r.subject = tank.getId();
                reports.add(r);
                tank.setSensorHits(tank.getSensorHits() + 1);
                break;
            case Tank.CRIT_STABILIZER:
                r = new Report(6625);
                r.subject = tank.getId();
                reports.add(r);
                tank.setStabiliserHit(loc);
                break;
            case Tank.CRIT_TURRET_DESTROYED:
                r = new Report(6630);
                r.subject = tank.getId();
                reports.add(r);
                tank.destroyLocation(tank.getLocTurret());
                reports.addAll(destroyEntity(tank, "turret blown off", true, true));
                break;
            case Tank.CRIT_TURRET_JAM:
                if (tank.isTurretEverJammed(loc)) {
                    r = new Report(6640);
                    r.subject = tank.getId();
                    reports.add(r);
                    tank.lockTurret(loc);
                    break;
                }
                r = new Report(6635);
                r.subject = tank.getId();
                reports.add(r);
                tank.jamTurret(loc);
                break;
            case Tank.CRIT_TURRET_LOCK:
                r = new Report(6640);
                r.subject = tank.getId();
                reports.add(r);
                tank.lockTurret(loc);
                break;
            case Tank.CRIT_WEAPON_DESTROYED: {
                r = new Report(6305);
                r.subject = tank.getId();
                List<Mounted> weapons = new ArrayList<>();
                for (Mounted weapon : tank.getWeaponList()) {
                    if ((weapon.getLocation() == loc) && !weapon.isHit() && !weapon.isDestroyed()) {
                        weapons.add(weapon);
                    }
                }
                // sort weapons by BV
                weapons.sort(new WeaponComparatorBV());
                int roll = Compute.d6();
                Mounted weapon;
                if (roll < 4) {
                    // defender should choose, we'll just use the lowest BV
                    // weapon
                    weapon = weapons.get(weapons.size() - 1);
                } else {
                    // attacker chooses, we'll use the highest BV weapon
                    weapon = weapons.get(0);
                }
                r.add(weapon.getName());
                reports.add(r);
                // explosive weapons e.g. gauss now explode
                if (weapon.getType().isExplosive(weapon) && !weapon.isHit()
                        && !weapon.isDestroyed()) {
                    reports.addAll(explodeEquipment(tank, loc, weapon));
                }
                weapon.setHit(true);
                //Taharqa: We should also damage the critical slot, or
                //MM and MHQ won't remember that this weapon is damaged on the MUL
                //file
                for (int i = 0; i < tank.getNumberOfCriticals(loc); i++) {
                    CriticalSlot slot1 = tank.getCritical(loc, i);
                    if ((slot1 == null) || (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                        continue;
                    }
                    Mounted mounted = slot1.getMount();
                    if (mounted.equals(weapon)) {
                        tank.hitAllCriticals(loc, i);
                        break;
                    }
                }
                break;
            }
            case Tank.CRIT_WEAPON_JAM: {
                r = new Report(6645);
                r.subject = tank.getId();
                ArrayList<Mounted> weapons = new ArrayList<>();
                for (Mounted weapon : tank.getWeaponList()) {
                    if ((weapon.getLocation() == loc) && !weapon.isJammed()
                            && !weapon.jammedThisPhase() && !weapon.isHit()
                            && !weapon.isDestroyed()) {
                        weapons.add(weapon);
                    }
                }

                if (!weapons.isEmpty()) {
                    Mounted weapon = weapons.get(Compute.randomInt(weapons.size()));
                    weapon.setJammed(true);
                    tank.addJammedWeapon(weapon);
                    r.add(weapon.getName());
                    reports.add(r);
                }
                break;
            }
            case VTOL.CRIT_PILOT:
                r = new Report(6650);
                r.subject = tank.getId();
                reports.add(r);
                tank.setDriverHit(true);
                PilotingRollData psr = tank.getBasePilotingRoll();
                psr.addModifier(0, "pilot injury");
                if (!doSkillCheckInPlace(tank, psr)) {
                    r = new Report(6675);
                    r.subject = tank.getId();
                    r.addDesc(tank);
                    reports.add(r);
                    boolean crash = true;
                    if (tank.canGoDown()) {
                        tank.setElevation(tank.getElevation() - 1);
                        crash = !tank.canGoDown();
                    }
                    if (crash) {
                        reports.addAll(crashVTOLorWiGE(tank));
                    }
                }
                break;
            case VTOL.CRIT_COPILOT:
                r = new Report(6655);
                r.subject = tank.getId();
                reports.add(r);
                tank.setCommanderHit(true);
                break;
            case VTOL.CRIT_ROTOR_DAMAGE: {
                // Only resolve rotor crits if the rotor was actually still
                // there.
                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {
                    r = new Report(6660);
                    r.subject = tank.getId();
                    reports.add(r);
                    tank.setMotiveDamage(tank.getMotiveDamage() + 1);
                    if (tank.getMotiveDamage() >= tank.getOriginalWalkMP()) {
                        tank.immobilize();
                        if (tank.isAirborneVTOLorWIGE()
                                // Don't bother with forcing a landing if
                                // we're already otherwise destroyed.
                                && !(tank.isDestroyed() || tank.isDoomed())) {
                            reports.addAll(forceLandVTOLorWiGE(tank));
                        }
                    }
                }
                break;
            }
            case VTOL.CRIT_ROTOR_DESTROYED:
                // Only resolve rotor crits if the rotor was actually still
                // there. Note that despite the name this critical hit does
                // not in itself physically destroy the rotor *location*
                // (which would simply kill the VTOL).
                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {
                    r = new Report(6670);
                    r.subject = tank.getId();
                    reports.add(r);
                    tank.immobilize();
                    reports.addAll(crashVTOLorWiGE(tank, true));
                }
                break;
            case VTOL.CRIT_FLIGHT_STABILIZER:
                // Only resolve rotor crits if the rotor was actually still
                // there.
                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {
                    r = new Report(6665);
                    r.subject = tank.getId();
                    reports.add(r);
                    tank.setStabiliserHit(VTOL.LOC_ROTOR);
                }
                break;
        }
        return reports;
    }

    /**
     * Rolls and resolves critical hits with a die roll modifier.
     */

    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear, int critMod, int damage) {
        return criticalEntity(en, loc, isRear, critMod, true, false, damage);
    }

    /**
     * Rolls and resolves critical hits with a die roll modifier.
     */

    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear, int critMod, int damage,
                                         DamageType damageType) {
        return criticalEntity(en, loc, isRear, critMod, true, false, damage, damageType);
    }

    /**
     * Rolls one critical hit
     */
    public Vector<Report> oneCriticalEntity(Entity en, int loc, boolean isRear, int damage) {
        return criticalEntity(en, loc, isRear, 0, false, false, damage);
    }

    /**
     * Makes any roll required when an AirMech lands and resolve any damage or
     * skidding resulting from a failed roll. Updates final position and elevation.
     *
     * @param lam       the landing LAM
     * @param pos       the <code>Coords</code> of the landing hex
     * @param elevation the elevation from which the landing is attempted (usually 1, but may be higher
     *                          if the unit is forced to land due to insufficient movement
     * @param distance  the distance the unit moved in the turn prior to landing
     */
    private Vector<Report> landAirMech(LandAirMech lam, Coords pos, int elevation, int distance) {
        Vector<Report> vDesc = new Vector<>();

        lam.setPosition(pos);
        Hex hex = game.getBoard().getHex(pos);
        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {
            lam.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
        } else {
            lam.setElevation(0);
        }
        PilotingRollData psr = lam.checkAirMechLanding();
        if (psr.getValue() != TargetRoll.CHECK_FALSE
                && (0 > doSkillCheckWhileMoving(lam, elevation, pos, pos, psr, false))) {
            crashAirMech(lam, pos, elevation, distance, psr, vDesc);
        }
        return vDesc;
    }

    private boolean crashAirMech(Entity en, PilotingRollData psr, Vector<Report> vDesc) {
        return crashAirMech(en, en.getPosition(), en.getElevation(), en.delta_distance, psr, vDesc);
    }

    private boolean crashAirMech(Entity en, Coords pos, int elevation, int distance,
                                 PilotingRollData psr, Vector<Report> vDesc) {
        MoveStep step = new MoveStep(null, MovePath.MoveStepType.DOWN);
        step.setFromEntity(en, game);
        return crashAirMech(en, pos, elevation, distance, psr, step, vDesc);
    }

    private boolean crashAirMech(Entity en, Coords pos, int elevation, int distance,
                                 PilotingRollData psr, MoveStep lastStep, Vector<Report> vDesc) {
        vDesc.addAll(doEntityFallsInto(en, elevation, pos, pos, psr, true, 0));
        return en.isDoomed()
                || processSkid(en, pos, 0, 0, distance, lastStep, en.moved, false);
    }

    /**
     * Makes the landing roll required for a glider ProtoMech and resolves any damage
     * resulting from a failed roll. Updates final position and elevation.
     *
     * @param en    the landing glider ProtoMech
     */
    private Vector<Report> landGliderPM(Protomech en) {
        return landGliderPM(en, en.getPosition(), en.getElevation(), en.delta_distance);
    }

    /**
     * Makes the landing roll required for a glider ProtoMech and resolves any damage
     * resulting from a failed roll. Updates final position and elevation.
     *
     * @param en    the landing glider ProtoMech
     * @param pos   the <code>Coords</code> of the landing hex
     * @param startElevation    the elevation from which the landing is attempted (usually 1, but may be higher
     *                          if the unit is forced to land due to insufficient movement
     * @param distance  the distance the unit moved in the turn prior to landing
     */
    private Vector<Report> landGliderPM(Protomech en, Coords pos, int startElevation,
                                        int distance) {
        Vector<Report> vDesc = new Vector<>();

        en.setPosition(pos);
        Hex hex = game.getBoard().getHex(pos);
        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {
            en.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
        } else {
            en.setElevation(0);
        }
        PilotingRollData psr = en.checkGliderLanding();
        if ((psr.getValue() != TargetRoll.CHECK_FALSE)
                && (0 > doSkillCheckWhileMoving(en, startElevation, pos, pos, psr, false))) {
            for (int i = 0; i < en.getNumberOfCriticals(Protomech.LOC_LEG); i++) {
                en.getCritical(Protomech.LOC_LEG, i).setHit(true);
            }
            HitData hit = new HitData(Protomech.LOC_LEG);
            vDesc.addAll(damageEntity(en, hit, 2 * startElevation));
        }
        return vDesc;
    }

    /**
     * Resolves the forced landing of one airborne {@code VTOL} or {@code WiGE}
     * in its current hex. As this method is only for internal use and not part
     * of the exported public API, it simply relies on its client code to only
     * ever hand it a valid airborne vehicle and does not run any further checks
     * of its own.
     *
     * @param en The {@code VTOL} or {@code WiGE} in question.
     * @return The resulting {@code Vector} of {@code Report}s.
     */
    private Vector<Report> forceLandVTOLorWiGE(Tank en) {
        Vector<Report> vDesc = new Vector<>();
        PilotingRollData psr = en.getBasePilotingRoll();
        Hex hex = game.getBoard().getHex(en.getPosition());
        if (en instanceof VTOL) {
            psr.addModifier(4, "VTOL making forced landing");
        } else {
            psr.addModifier(0, "WiGE making forced landing");
        }
        int elevation = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),
                hex.terrainLevel(Terrains.BRIDGE_ELEV));
        elevation = Math.max(elevation, 0);
        elevation = Math.min(elevation, en.getElevation());
        if (en.getElevation() > elevation) {
            if (!hex.containsTerrain(Terrains.FUEL_TANK)
                    && !hex.containsTerrain(Terrains.JUNGLE)
                    && !hex.containsTerrain(Terrains.MAGMA)
                    && !hex.containsTerrain(Terrains.MUD)
                    && !hex.containsTerrain(Terrains.RUBBLE)
                    && !hex.containsTerrain(Terrains.WATER)
                    && !hex.containsTerrain(Terrains.WOODS)) {
                Report r = new Report(2180);
                r.subject = en.getId();
                r.addDesc(en);
                r.add(psr.getLastPlainDesc(), true);
                vDesc.add(r);

                // roll
                final int diceRoll = Compute.d6(2);
                r = new Report(2185);
                r.subject = en.getId();
                r.add(psr.getValueAsString());
                r.add(psr.getDesc());
                r.add(diceRoll);
                if (diceRoll < psr.getValue()) {
                    r.choose(false);
                    vDesc.add(r);
                    vDesc.addAll(crashVTOLorWiGE(en, true));
                } else {
                    r.choose(true);
                    vDesc.add(r);
                    en.setElevation(elevation);
                }
            } else {
                vDesc.addAll(crashVTOLorWiGE(en, true));
            }
        }
        return vDesc;
    }

    /**
     * Crash a VTOL
     *
     * @param en the <code>VTOL</code> to be crashed
     * @return the <code>Vector<Report></code> containing phase reports
     */
    private Vector<Report> crashVTOLorWiGE(Tank en) {
        return crashVTOLorWiGE(en, false, false, 0, en.getPosition(),
                en.getElevation(), 0);
    }

    /**
     * Crash a VTOL or WiGE.
     *
     * @param en              The {@code VTOL} or {@code WiGE} to crash.
     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
     *                        typically after a "rotor destroyed" critical hit.
     * @return The {@code Vector<Report>} of resulting reports.
     */
    private Vector<Report> crashVTOLorWiGE(Tank en, boolean rerollRotorHits) {
        return crashVTOLorWiGE(en, rerollRotorHits, false, 0, en.getPosition(),
                en.getElevation(), 0);
    }

    /**
     * Crash a VTOL or WiGE.
     *
     * @param en              The {@code VTOL} or {@code WiGE} to crash.
     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
     *                        typically after a "rotor destroyed" critical hit.
     * @param sideSlipCrash   A <code>boolean</code> value indicating whether this is a
     *                        sideslip crash or not.
     * @param hexesMoved      The <code>int</code> number of hexes moved.
     * @param crashPos        The <code>Coords</code> of the crash
     * @param crashElevation  The <code>int</code> elevation of the VTOL
     * @param impactSide      The <code>int</code> describing the side on which the VTOL
     *                        falls
     * @return a <code>Vector<Report></code> of Reports.
     */

    private Vector<Report> crashVTOLorWiGE(Tank en, boolean rerollRotorHits,
                                           boolean sideSlipCrash, int hexesMoved, Coords crashPos,
                                           int crashElevation, int impactSide) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // we might be off the board after a DFA, so return then
        if (!game.getBoard().contains(crashPos)) {
            return vDesc;
        }

        if (!sideSlipCrash) {
            // report lost movement and crashing
            r = new Report(6260);
            r.subject = en.getId();
            r.newlines = 0;
            r.addDesc(en);
            vDesc.addElement(r);
            int newElevation = 0;
            Hex fallHex = game.getBoard().getHex(crashPos);

            // May land on roof of building or bridge
            if (fallHex.containsTerrain(Terrains.BLDG_ELEV)) {
                newElevation = fallHex.terrainLevel(Terrains.BLDG_ELEV);
            } else if (fallHex.containsTerrain(Terrains.BRIDGE_ELEV)) {
                newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
                if (newElevation > crashElevation) {
                    newElevation = 0; // vtol was under bridge already
                }
            }

            int fall = crashElevation - newElevation;
            if (fall == 0) {
                // already on ground, no harm done
                r = new Report(6265);
                r.subject = en.getId();
                vDesc.addElement(r);
                return vDesc;
            }
            // set elevation 1st to avoid multiple crashes
            en.setElevation(newElevation);

            // plummets to ground
            r = new Report(6270);
            r.subject = en.getId();
            r.add(fall);
            vDesc.addElement(r);

            // facing after fall
            String side;
            int table;
            int facing = Compute.d6() - 1;
            switch (facing) {
                case 1:
                case 2:
                    side = "right side";
                    table = ToHitData.SIDE_RIGHT;
                    break;
                case 3:
                    side = "rear";
                    table = ToHitData.SIDE_REAR;
                    break;
                case 4:
                case 5:
                    side = "left side";
                    table = ToHitData.SIDE_LEFT;
                    break;
                case 0:
                default:
                    side = "front";
                    table = ToHitData.SIDE_FRONT;
            }

            if (newElevation <= 0) {
                boolean waterFall = fallHex.containsTerrain(Terrains.WATER);
                if (waterFall && fallHex.containsTerrain(Terrains.ICE)) {
                    int roll = Compute.d6(1);
                    r = new Report(2119);
                    r.subject = en.getId();
                    r.addDesc(en);
                    r.add(roll);
                    r.subject = en.getId();
                    vDesc.add(r);
                    if (roll > 3) {
                        vDesc.addAll(resolveIceBroken(crashPos));
                    } else {
                        waterFall = false; // saved by ice
                    }
                }
                if (waterFall) {
                    // falls into water and is destroyed
                    r = new Report(6275);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                    vDesc.addAll(destroyEntity(en, "Fell into water", false, false));
                    // not sure, is this salvageable?
                }
            }

            // calculate damage for hitting the surface
            int damage = (int) Math.round(en.getWeight() / 10.0) * (fall + 1);

            // adjust damage for gravity
            damage = Math.round(damage * game.getPlanetaryConditions().getGravity());
            // report falling
            r = new Report(6280);
            r.subject = en.getId();
            r.indent();
            r.addDesc(en);
            r.add(side);
            r.add(damage);
            //r.newlines = 0;
            vDesc.addElement(r);

            en.setFacing((en.getFacing() + (facing)) % 6);

            boolean exploded = false;

            // standard damage loop
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, table);
                if ((en instanceof VTOL) && (hit.getLocation() == VTOL.LOC_ROTOR) && rerollRotorHits) {
                    continue;
                }
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                int[] isBefore = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),
                        en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};
                vDesc.addAll(damageEntity(en, hit, cluster));
                int[] isAfter = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),
                        en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};
                for (int x = 0; x <= 3; x++) {
                    if (isBefore[x] != isAfter[x]) {
                        exploded = true;
                        break;
                    }
                }
                damage -= cluster;
            }
            if (exploded) {
                r = new Report(6285);
                r.subject = en.getId();
                r.addDesc(en);
                vDesc.addElement(r);
                vDesc.addAll(explodeVTOLorWiGE(en));
            }

            // check for location exposure
            vDesc.addAll(doSetLocationsExposure(en, fallHex, false, newElevation));

        } else {
            en.setElevation(0);// considered landed in the hex.
            // crashes into ground thanks to sideslip
            r = new Report(6290);
            r.subject = en.getId();
            r.addDesc(en);
            vDesc.addElement(r);
            int damage = (int) Math.round(en.getWeight() / 10.0) * (hexesMoved + 1);
            boolean exploded = false;

            // standard damage loop
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, impactSide);
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                int[] isBefore = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),
                        en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};
                vDesc.addAll(damageEntity(en, hit, cluster));
                int[] isAfter = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),
                        en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};
                for (int x = 0; x <= 3; x++) {
                    if (isBefore[x] != isAfter[x]) {
                        exploded = true;
                        break;
                    }
                }
                damage -= cluster;
            }
            if (exploded) {
                r = new Report(6295);
                r.subject = en.getId();
                r.addDesc(en);
                vDesc.addElement(r);
                vDesc.addAll(explodeVTOLorWiGE(en));
            }

        }

        if (game.containsMinefield(crashPos)) {
            // may set off any minefields in the hex
            enterMinefield(en, crashPos, 0, true, vDesc, 7);
            // it may also clear any minefields that it detonated
            clearDetonatedMines(crashPos, 5);
            resetMines();
        }

        return vDesc;

    }

    /**
     * Explode a VTOL
     *
     * @param en The <code>VTOL</code> to explode.
     * @return a <code>Vector</code> of reports
     */
    private Vector<Report> explodeVTOLorWiGE(Tank en) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        if (en.hasEngine() && en.getEngine().isFusion()) {
            // fusion engine, no effect
            r = new Report(6300);
            r.subject = en.getId();
            vDesc.addElement(r);
        } else {
            Coords pos = en.getPosition();
            Hex hex = game.getBoard().getHex(pos);
            if (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {
                ignite(pos, Terrains.FIRE_LVL_NORMAL, vDesc);
            } else {
                ignite(pos, Terrains.FIRE_LVL_INFERNO, vDesc);
            }
            vDesc.addAll(destroyEntity(en, "crashed and burned", false, false));
        }

        return vDesc;
    }

    /**
     * rolls and resolves one tank critical hit
     *
     * @param t       the <code>Tank</code> to be critted
     * @param loc     the <code>int</code> location of the Tank to be critted
     * @param critMod the <code>int</code> modifier to the crit roll
     * @return a <code>Vector<Report></code> containing the phase reports
     */
    private Vector<Report> criticalTank(Tank t, int loc, int critMod, int damage, boolean damagedByFire) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // roll the critical
        r = new Report(6305);
        r.subject = t.getId();
        r.indent(3);
        r.add(t.getLocationAbbr(loc));
        r.newlines = 0;
        vDesc.add(r);
        int roll = Compute.d6(2);
        r = new Report(6310);
        r.subject = t.getId();
        String rollString = "";
        if (critMod != 0) {
            rollString = "(" + roll;
            if (critMod > 0) {
                rollString += "+";
            }
            rollString += critMod + ") = ";
            roll += critMod;
        }
        rollString += roll;
        r.add(rollString);
        r.newlines = 0;
        vDesc.add(r);

        // now look up on vehicle crits table
        int critType = t.getCriticalEffect(roll, loc, damagedByFire);
        if ((critType == Tank.CRIT_NONE)
                && game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)
                && !((t instanceof VTOL) || (t instanceof GunEmplacement))
                && !t.getOverThresh()) {
            r = new Report(6006);
            r.subject = t.getId();
            r.newlines = 0;
            vDesc.add(r);
        }
        vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0, critType),
                true, damage, false));
        if ((critType != Tank.CRIT_NONE) && t.hasEngine() && !t.getEngine().isFusion()
                && t.hasQuirk(OptionsConstants.QUIRK_NEG_FRAGILE_FUEL) && (Compute.d6(2) > 9)) {
            // BOOM!!
            vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0,
                    Tank.CRIT_FUEL_TANK), true, damage, false));
        }
        return vDesc;
    }

    /**
     * Checks for aero criticals
     *
     * @param vDesc         - {@link Report} <code>Vector</code>
     * @param a             - the entity being critted
     * @param hit           - the hitdata for the attack
     * @param damage_orig   - the original damage of the attack
     * @param critThresh    - did the attack go over the damage threshold
     * @param critSI        - did the attack damage SI
     * @param ammoExplosion - was the damage from an ammo explosion
     * @param nukeS2S       - was this a ship 2 ship nuke attack
     */
    private void checkAeroCrits(Vector<Report> vDesc, Aero a, HitData hit,
                                int damage_orig, boolean critThresh, boolean critSI,
                                boolean ammoExplosion, boolean nukeS2S) {

        Report r;

        boolean isCapital = hit.isCapital();
        // get any capital missile critical mods
        int capitalMissile = hit.getCapMisCritMod();

        // check for nuclear critical
        if (nukeS2S) {
            // add a control roll
            PilotingRollData nukePSR = new PilotingRollData(a.getId(), 4,
                    "Nuclear attack", false);
            game.addControlRoll(nukePSR);

            Report.addNewline(vDesc);
            // need some kind of report
            int nukeroll = Compute.d6(2);
            r = new Report(9145);
            r.subject = a.getId();
            r.indent(3);
            r.add(capitalMissile);
            r.add(nukeroll);
            vDesc.add(r);
            if (nukeroll >= capitalMissile) {
                // Allow a reroll with edge
                if (a.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_NUKE_CRIT)
                        && a.getCrew().hasEdgeRemaining()) {
                    a.getCrew().decreaseEdge();
                    r = new Report(9148);
                    r.subject = a.getId();
                    r.indent(3);
                    r.add(a.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                    vDesc.add(r);
                    // Reroll
                    nukeroll = Compute.d6(2);
                    // and report the new results
                    r = new Report(9149);
                    r.subject = a.getId();
                    r.indent(3);
                    r.add(capitalMissile);
                    r.add(nukeroll);
                    r.choose(nukeroll >= capitalMissile);
                    vDesc.add(r);
                    if (nukeroll < capitalMissile) {
                        // We might be vaporized by the damage itself, but no additional effect
                        return;
                    }
                }
                a.setSI(a.getSI() - (damage_orig * 10));
                a.damageThisPhase += (damage_orig * 10);
                r = new Report(9146);
                r.subject = a.getId();
                r.add((damage_orig * 10));
                r.indent(4);
                r.add(Math.max(a.getSI(), 0));
                vDesc.addElement(r);
                if (a.getSI() <= 0) {
                    //No auto-ejection chance here. Nuke would vaporize the pilot.
                    vDesc.addAll(destroyEntity(a, "Structural Integrity Collapse"));
                    a.setSI(0);
                    if (hit.getAttackerId() != Entity.NONE) {
                        creditKill(a, game.getEntity(hit.getAttackerId()));
                    }
                } else if (!critSI) {
                    critSI = true;
                }
            } else {
                r = new Report(9147);
                r.subject = a.getId();
                r.indent(4);
                vDesc.addElement(r);
            }
        }

        // apply crits
        if (hit.rolledBoxCars()) {
            if (hit.isFirstHit()) {
                // Allow edge use to ignore the critical roll
                if (a.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_LUCKY_CRIT)
                        && a.getCrew().hasEdgeRemaining()) {
                    a.getCrew().decreaseEdge();
                    r = new Report(9103);
                    r.subject = a.getId();
                    r.indent(3);
                    r.add(a.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                    vDesc.addElement(r);
                    // Skip the critical roll
                    return;
                }
                vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(), "12 to hit",
                        8, damage_orig, isCapital));
            } else { // Let the user know why the lucky crit doesn't apply
                r = new Report(9102);
                r.subject = a.getId();
                r.indent(3);
                vDesc.addElement(r);
            }
        }
        // ammo explosions shouldn't affect threshold because they
        // go right to SI
        if (critThresh && !ammoExplosion) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "Damage threshold exceeded", 8, damage_orig, isCapital));
        }
        if (critSI && !ammoExplosion) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "SI damaged", 8, damage_orig, isCapital));
        }
        if ((capitalMissile > 0) && !nukeS2S) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "Capital Missile", capitalMissile, damage_orig, isCapital));
        }
    }

    private Vector<Report> criticalAero(Aero a, int loc, int critMod,
                                        String reason, int target, int damage, boolean isCapital) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        //Telemissiles don't take critical hits
        if (a instanceof TeleMissile) {
            return vDesc;
        }

        // roll the critical
        r = new Report(9100);
        r.subject = a.getId();
        r.add(reason);
        r.indent(3);
        r.newlines = 0;
        vDesc.add(r);
        int roll = Compute.d6(2);
        r = new Report(9101);
        r.subject = a.getId();
        r.add(target);
        String rollString = "";
        if (critMod != 0) {
            rollString = "(" + roll;
            if (critMod > 0) {
                rollString += "+";
            }
            rollString += critMod + ") = ";
            roll += critMod;
        }
        rollString += roll;
        r.add(rollString);
        r.newlines = 0;
        vDesc.add(r);

        // now look up on vehicle crits table
        int critType = a.getCriticalEffect(roll, target);
        vDesc.addAll(applyCriticalHit(a, loc, new CriticalSlot(0, critType),
                true, damage, isCapital));
        return vDesc;
    }

    /**
     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
     */
    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
                                         int critMod, boolean rollNumber, boolean isCapital, int damage) {
        return criticalEntity(en, loc, isRear, critMod, rollNumber, isCapital,
                damage, DamageType.NONE);
    }

    /**
     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
     */
    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
                                         int critMod, boolean rollNumber, boolean isCapital, int damage,
                                         DamageType damageType) {

        if (en.hasQuirk("poor_work")) {
            critMod += 1;
        }
        if (en.hasQuirk(OptionsConstants.QUIRK_NEG_PROTOTYPE)) {
            critMod += 2;
        }

        // Apply modifiers for Anti-penetrative ablation armor
        if ((en.getArmor(loc, isRear) > 0)
                && (en.getArmorType(loc) == EquipmentType.T_ARMOR_ANTI_PENETRATIVE_ABLATION)) {
            critMod -= 2;
        }

        if (en instanceof Tank) {
            return criticalTank((Tank) en, loc, critMod, damage, damageType.equals(DamageType.INFERNO));
        }

        if (en instanceof Aero) {
            return criticalAero((Aero) en, loc, critMod, "unknown", 8, damage,
                    isCapital);
        }
        CriticalSlot slot;
        Vector<Report> vDesc = new Vector<>();
        Report r;
        Coords coords = en.getPosition();
        Hex hex = null;
        int hits;
        if (rollNumber) {
            if (null != coords) {
                hex = game.getBoard().getHex(coords);
            }
            r = new Report(6305);
            r.subject = en.getId();
            r.indent(3);
            r.add(en.getLocationAbbr(loc));
            r.newlines = 0;
            vDesc.addElement(r);
            hits = 0;
            int roll = Compute.d6(2);
            r = new Report(6310);
            r.subject = en.getId();
            String rollString = "";
            // industrials get a +2 bonus on the roll
            if ((en instanceof Mech) && ((Mech) en).isIndustrial()) {
                critMod += 2;
            }
            // reinforced structure gets a -1 mod
            if ((en instanceof Mech) && ((Mech) en).hasReinforcedStructure()) {
                critMod -= 1;
            }
            if (critMod != 0) {
                rollString = "(" + roll;
                if (critMod > 0) {
                    rollString += "+";
                }
                rollString += critMod + ") = ";
                roll += critMod;
            }
            rollString += roll;
            r.add(rollString);
            r.newlines = 0;
            vDesc.addElement(r);
            boolean advancedCrit = game.getOptions().booleanOption(
                    OptionsConstants.ADVCOMBAT_TACOPS_CRIT_ROLL);
            if ((!advancedCrit && (roll <= 7)) || (advancedCrit && (roll <= 8))) {
                // no effect
                r = new Report(6005);
                r.subject = en.getId();
                vDesc.addElement(r);
                return vDesc;
            } else if ((!advancedCrit && (roll >= 8) && (roll <= 9))
                    || (advancedCrit && (roll >= 9) && (roll <= 10))) {
                hits = 1;
                r = new Report(6315);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if ((!advancedCrit && (roll >= 10) && (roll <= 11))
                    || (advancedCrit && (roll >= 11) && (roll <= 12))) {
                hits = 2;
                r = new Report(6320);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if (advancedCrit && (roll >= 13) && (roll <= 14)) {
                hits = 3;
                r = new Report(6325);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if ((!advancedCrit && (roll >= 12)) || (advancedCrit && (roll >= 15))) {
                if (en instanceof Protomech) {
                    hits = 3;
                    r = new Report(6325);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                } else if (en.locationIsLeg(loc)) {
                    CriticalSlot cs = en.getCritical(loc, 0);
                    if ((cs != null) && cs.isArmored()) {
                        r = new Report(6700);
                        r.subject = en.getId();
                        r.add(en.getLocationName(loc));
                        r.newlines = 0;
                        vDesc.addElement(r);
                        cs.setArmored(false);
                        return vDesc;
                    }
                    // limb blown off
                    r = new Report(6120);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    if (en.getInternal(loc) > 0) {
                        en.destroyLocation(loc, true);
                    }
                    if (null != hex) {
                        if (!hex.containsTerrain(Terrains.LEGS)) {
                            hex.addTerrain(new Terrain(Terrains.LEGS, 1));
                        } else {
                            hex.addTerrain(new Terrain(Terrains.LEGS, hex.terrainLevel(Terrains.LEGS) + 1));
                        }
                    }
                    sendChangedHex(en.getPosition());
                    return vDesc;
                } else if ((loc == Mech.LOC_RARM) || (loc == Mech.LOC_LARM)) {
                    CriticalSlot cs = en.getCritical(loc, 0);
                    if ((cs != null) && cs.isArmored()) {
                        r = new Report(6700);
                        r.subject = en.getId();
                        r.add(en.getLocationName(loc));
                        r.newlines = 0;
                        vDesc.addElement(r);
                        cs.setArmored(false);
                        return vDesc;
                    }

                    // limb blown off
                    r = new Report(6120);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    en.destroyLocation(loc, true);
                    if (null != hex) {
                        if (!hex.containsTerrain(Terrains.ARMS)) {
                            hex.addTerrain(new Terrain(Terrains.ARMS, 1));
                        } else {
                            hex.addTerrain(new Terrain(Terrains.ARMS, hex.terrainLevel(Terrains.ARMS) + 1));
                        }
                    }
                    sendChangedHex(en.getPosition());
                    return vDesc;
                } else if (loc == Mech.LOC_HEAD) {
                    // head blown off
                    r = new Report(6330);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    en.destroyLocation(loc, true);
                    if (((Mech) en).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED) {
                        // Don't kill a pilot multiple times.
                        if (Crew.DEATH > en.getCrew().getHits()) {
                            en.getCrew().setDoomed(true);
                            Report.addNewline(vDesc);
                            vDesc.addAll(destroyEntity(en, "pilot death", true));
                        }
                    }
                    return vDesc;
                } else {
                    // torso hit
                    hits = 3;
                    // industrials get 4 crits on a modified result of 14
                    if ((roll >= 14) && (en instanceof Mech) && ((Mech) en).isIndustrial()) {
                        hits = 4;
                    }
                    r = new Report(6325);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                }
            }
            if (damageType.equals(DamageType.ANTI_TSM) && (en instanceof Mech)
                    && en.antiTSMVulnerable()) {
                r = new Report(6430);
                r.subject = en.getId();
                r.indent(2);
                r.addDesc(en);
                vDesc.addElement(r);
                hits++;
            }
        } else {
            hits = 1;
        }

        // Check if there is the potential for a reactive armor crit
        // Because reactive armor isn't hittable, the transfer check doesn't
        // consider it
        boolean possibleReactiveCrit = (en.getArmor(loc) > 0)
                && (en.getArmorType(loc) == EquipmentType.T_ARMOR_REACTIVE);
        boolean locContainsReactiveArmor = false;
        for (int i = 0; (i < en.getNumberOfCriticals(loc)) && possibleReactiveCrit; i++) {
            CriticalSlot crit = en.getCritical(loc, i);
            if ((crit != null) && (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)
                    && (crit.getMount() != null)
                    && crit.getMount().getType().hasFlag(MiscType.F_REACTIVE)) {
                locContainsReactiveArmor = true;
                break;
            }
        }
        possibleReactiveCrit &= locContainsReactiveArmor;

        // transfer criticals, if needed
        while ((en.canTransferCriticals(loc) && !possibleReactiveCrit)
                && (en.getTransferLocation(loc) != Entity.LOC_DESTROYED)
                && (en.getTransferLocation(loc) != Entity.LOC_NONE)) {
            loc = en.getTransferLocation(loc);
            r = new Report(6335);
            r.subject = en.getId();
            r.indent(3);
            r.add(en.getLocationAbbr(loc));
            vDesc.addElement(r);
        }

        // Roll critical hits in this location.
        while (hits > 0) {

            // Have we hit all available slots in this location?
            if (en.getHittableCriticals(loc) <= 0) {
                r = new Report(6340);
                r.subject = en.getId();
                r.indent(3);
                vDesc.addElement(r);
                break;
            }

            // Randomly pick a slot to be hit.
            int slotIndex = Compute.randomInt(en.getNumberOfCriticals(loc));
            slot = en.getCritical(loc, slotIndex);

            // There are certain special cases, like reactive armor
            // some crits aren't normally hittable, except in certain cases
            boolean reactiveArmorCrit = false;
            if ((slot != null) && (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                    && (slot.getMount() != null)) {
                Mounted eq = slot.getMount();
                if (eq.getType().hasFlag(MiscType.F_REACTIVE) && (en.getArmor(loc) > 0)) {
                    reactiveArmorCrit = true;
                }
            }

            // Ignore empty or unhitable slots (this
            // includes all previously hit slots).
            if ((slot != null) && (slot.isHittable() || reactiveArmorCrit)) {

                if (slot.isArmored()) {
                    r = new Report(6710);
                    r.subject = en.getId();
                    if (slot.getType() == CriticalSlot.TYPE_SYSTEM) {
                        // Pretty sure that only 'mechs have system crits,
                        // but just in case....
                        if (en instanceof Mech) {
                            r.add(((Mech) en).getSystemName(slot.getIndex()));
                        }
                    } else {
                        // Shouldn't be null, but we'll be careful...
                        if (slot.getMount() != null) {
                            r.add(slot.getMount().getName());
                        }
                    }
                    vDesc.addElement(r);
                    slot.setArmored(false);
                    hits--;
                    continue;
                }
                // if explosive use edge
                if ((en instanceof Mech)
                        && (en.getCrew().hasEdgeRemaining() && en.getCrew().getOptions()
                        .booleanOption(OptionsConstants.EDGE_WHEN_EXPLOSION))
                        && (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                        && slot.getMount().getType().isExplosive(slot.getMount())) {
                    en.getCrew().decreaseEdge();
                    r = new Report(6530);
                    r.subject = en.getId();
                    r.indent(3);
                    r.add(en.getCrew().getOptions().intOption(OptionsConstants.EDGE));
                    vDesc.addElement(r);
                    continue;
                }

                // check for reactive armor exploding
                if (reactiveArmorCrit) {
                    Mounted mount = slot.getMount();
                    if ((mount != null) && mount.getType().hasFlag(MiscType.F_REACTIVE)) {
                        int roll = Compute.d6(2);
                        r = new Report(6082);
                        r.subject = en.getId();
                        r.indent(3);
                        r.add(roll);
                        vDesc.addElement(r);
                        // big budda boom
                        if (roll == 2) {
                            r = new Report(6083);
                            r.subject = en.getId();
                            r.indent(4);
                            vDesc.addElement(r);
                            Vector<Report> newReports = new Vector<>(damageEntity(en,
                                    new HitData(loc), en.getArmor(loc)));
                            if (en.hasRearArmor(loc)) {
                                newReports.addAll(damageEntity(en, new HitData(loc, true),
                                        en.getArmor(loc, true)));
                            }
                            newReports.addAll(damageEntity(en, new HitData(loc), 1));
                            for (Report rep : newReports) {
                                rep.indent(4);
                            }
                            vDesc.addAll(newReports);
                        } else {
                            // If only hittable crits are reactive,
                            // this crit is absorbed
                            boolean allHittableCritsReactive = true;
                            for (int i = 0; i < en.getNumberOfCriticals(loc); i++) {
                                CriticalSlot crit = en.getCritical(loc, i);
                                if (crit.isHittable()) {
                                    allHittableCritsReactive = false;
                                    break;
                                }
                                // We must have reactive crits to get to this
                                // point, so if nothing else is hittable, we
                                // must only have reactive crits
                            }
                            if (allHittableCritsReactive) {
                                hits--;
                            }
                            continue;
                        }
                    }
                }
                vDesc.addAll(applyCriticalHit(en, loc, slot, true, damage, isCapital));
                hits--;
            }
        } // Hit another slot in this location.

        return vDesc;
    }

    /**
     * Checks for location breach and returns phase logging.
     * <p>
     *
     * @param entity the <code>Entity</code> that needs to be checked.
     * @param loc    the <code>int</code> location on the entity that needs to be
     *               checked for a breach.
     * @param hex    the <code>Hex</code> the entity occupies when checking. This
     *               value will be <code>null</code> if the check is the result of
     *               an attack, and non-null if it occurs during movement.
     */
    private Vector<Report> breachCheck(Entity entity, int loc, Hex hex) {
        return breachCheck(entity, loc, hex, false);
    }

    /**
     * Checks for location breach and returns phase logging.
     *
     * @param entity     the <code>Entity</code> that needs to be checked.
     * @param loc        the <code>int</code> location on the entity that needs to be
     *                   checked for a breach.
     * @param hex        the <code>Hex</code> the entity occupies when checking. This
     *                   value will be <code>null</code> if the check is the result of
     *                   an attack, and non-null if it occurs during movement.
     * @param underWater Is the breach check a result of an underwater attack?
     */
    private Vector<Report> breachCheck(Entity entity, int loc, Hex hex, boolean underWater) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // Infantry do not suffer breaches, nor do Telemissiles
        // VTOLs can't operate in vacuum or underwater, so no breaches
        if (entity instanceof Infantry || entity instanceof TeleMissile || entity instanceof VTOL) {
            return vDesc;
        }

        boolean dumping = false;
        for (Mounted m : entity.getAmmo()) {
            if (m.isDumping()) {
                // dumping ammo underwater is very stupid thing to do
                dumping = true;
                break;
            }
        }
        // This handles both water and vacuum breaches.
        // Also need to account for hull breaches on surface naval vessels which
        // are technically not "wet"
        if ((entity.getLocationStatus(loc) > ILocationExposureStatus.NORMAL)
                || (entity.isSurfaceNaval() && (loc != ((Tank) entity).getLocTurret()))) {
            // Does the location have armor (check rear armor on Mek)
            // and is the check due to damage?
            int breachroll = 0;
            // set the target roll for the breach
            int target = 10;
            // if this is a vacuum check and we are in trace atmosphere then
            // adjust target
            if ((entity.getLocationStatus(loc) == ILocationExposureStatus.VACUUM)
                    && (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE)) {
                target = 12;
            }
            // if this is a surface naval vessel and the attack is not from
            // underwater
            // then the breach should only occur on a roll of 12
            if (entity.isSurfaceNaval() && !underWater) {
                target = 12;
            }
            if ((entity.getArmor(loc) > 0)
                    && (!(entity instanceof Mech) || entity.getArmor(loc, true) > 0) && (null == hex)) {
                // functional HarJel prevents breach
                if (entity.hasHarJelIn(loc)) {
                    r = new Report(6342);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    return vDesc;
                }
                if ((entity instanceof Mech) && (((Mech) entity).hasHarJelIIIn(loc)
                        || ((Mech) entity).hasHarJelIIIIn(loc))) {
                    r = new Report(6343);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    target -= 2;
                }
                // Impact-resistant armor easier to breach
                if ((entity.getArmorType(loc) == EquipmentType.T_ARMOR_IMPACT_RESISTANT)) {
                    r = new Report(6344);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    target += 1;
                }
                breachroll = Compute.d6(2);
                r = new Report(6345);
                r.subject = entity.getId();
                r.indent(3);
                r.add(entity.getLocationAbbr(loc));
                r.add(breachroll);
                r.newlines = 0;
                if (breachroll >= target) {
                    r.choose(false);
                } else {
                    r.choose(true);
                }
                vDesc.addElement(r);
            }
            // Breach by damage or lack of armor.
            if ((breachroll >= target) || !(entity.getArmor(loc) > 0)
                    || (dumping && (!(entity instanceof Mech)
                    || (loc == Mech.LOC_CT) || (loc == Mech.LOC_RT) || (loc == Mech.LOC_LT)))
                    || !(!(entity instanceof Mech) || entity.getArmor(loc, true) > 0)) {
                // Functional HarJel prevents breach as long as armor remains
                // (and, presumably, as long as you don't open your chassis on
                // purpose, say to dump ammo...).
                if ((entity.hasHarJelIn(loc)) && (entity.getArmor(loc) > 0)
                        && (!(entity instanceof Mech) || entity.getArmor(loc, true) > 0) && !dumping) {
                    r = new Report(6342);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    return vDesc;
                }
                vDesc.addAll(breachLocation(entity, loc, hex, false));
            }
        }
        return vDesc;
    }

    /**
     * Marks all equipment in a location on an entity as useless.
     *
     * @param entity the <code>Entity</code> that needs to be checked.
     * @param loc    the <code>int</code> location on the entity that needs to be
     *               checked for a breach.
     * @param hex    the <code>Hex</code> the entity occupies when checking. This
     *               value will be <code>null</code> if the check is the result of
     *               an attack, and non-null if it occurs during movement.
     * @param harJel a <code>boolean</code> value indicating if the uselessness is
     *               the cause of a critically hit HarJel system
     */
    private Vector<Report> breachLocation(Entity entity, int loc, Hex hex, boolean harJel) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        if ((entity.getInternal(loc) < 0)
                || (entity.getLocationStatus(loc) < ILocationExposureStatus.NORMAL)) {
            // already destroyed or breached? don't bother
            return vDesc;
        }

        r = new Report(6350);
        if (harJel) {
            r.messageId = 6351;
        }
        r.subject = entity.getId();
        r.add(entity.getShortName());
        r.add(entity.getLocationAbbr(loc));
        vDesc.addElement(r);

        if (entity instanceof Tank) {
            vDesc.addAll(destroyEntity(entity, "hull breach", true, true));
            return vDesc;
        }
        if (entity instanceof Mech) {
            Mech mech = (Mech) entity;
            // equipment and crits will be marked in applyDamage?

            // equipment marked missing
            for (Mounted mounted : entity.getEquipment()) {
                if (mounted.getLocation() == loc) {
                    mounted.setBreached(true);
                }
            }
            // all critical slots set as useless
            for (int i = 0; i < entity.getNumberOfCriticals(loc); i++) {
                final CriticalSlot cs = entity.getCritical(loc, i);
                if (cs != null) {
                    // for every undamaged actuator destroyed by breaching,
                    // we make a PSR (see bug 1040858)
                    if (entity.locationIsLeg(loc) && entity.canFall(true)) {
                        if (cs.isHittable()) {
                            switch (cs.getIndex()) {
                                case Mech.ACTUATOR_UPPER_LEG:
                                case Mech.ACTUATOR_LOWER_LEG:
                                case Mech.ACTUATOR_FOOT:
                                    // leg/foot actuator piloting roll
                                    game.addPSR(new PilotingRollData(entity.getId(), 1,
                                            "leg/foot actuator hit"));
                                    break;
                                case Mech.ACTUATOR_HIP:
                                    // hip piloting roll at +0, because we get the +2 anyway
                                    // because the location is breached.
                                    // The phase report will look a bit weird, but the
                                    // roll is correct
                                    game.addPSR(new PilotingRollData(entity.getId(), 0,
                                            "hip actuator hit"));
                                    break;
                            }
                        }
                    }
                    cs.setBreached(true);
                }
            }

            // Check location for engine/cockpit breach and report accordingly
            if (loc == Mech.LOC_CT) {
                vDesc.addAll(destroyEntity(entity, "hull breach"));
                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
                    vDesc.addAll(abandonEntity(entity));
                }
            }
            if (loc == Mech.LOC_HEAD) {
                entity.getCrew().setDoomed(true);
                vDesc.addAll(destroyEntity(entity, "hull breach"));
                if (entity.getLocationStatus(loc) == ILocationExposureStatus.WET) {
                    r = new Report(6355);
                } else {
                    r = new Report(6360);
                }
                r.subject = entity.getId();
                r.addDesc(entity);
                vDesc.addElement(r);
            }

            // Set the status of the location.
            // N.B. if we set the status before rolling water PSRs, we get a
            // "LEG DESTROYED" modifier; setting the status after gives a hip
            // actuator modifier.
            entity.setLocationStatus(loc, ILocationExposureStatus.BREACHED);

            // Did the hull breach destroy the engine?
            int hitsToDestroy = 3;
            if (mech.isSuperHeavy() && mech.hasEngine()
                    && (mech.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                hitsToDestroy = 2;
            }
            if ((entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT)
                    + entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT)
                    + entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT))
                    >= hitsToDestroy) {
                vDesc.addAll(destroyEntity(entity, "engine destruction"));
                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
                    vDesc.addAll(abandonEntity(entity));
                }
            }

            if (loc == Mech.LOC_LT) {
                vDesc.addAll(breachLocation(entity, Mech.LOC_LARM, hex, false));
            }
            if (loc == Mech.LOC_RT) {
                vDesc.addAll(breachLocation(entity, Mech.LOC_RARM, hex, false));
            }
        }

        return vDesc;
    }

    /**
     * Mark the unit as destroyed! Units transported in the destroyed unit will
     * get a chance to escape.
     *
     * @param entity - the <code>Entity</code> that has been destroyed.
     * @param reason - a <code>String</code> detailing why the entity was
     *               destroyed.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    private Vector<Report> destroyEntity(Entity entity, String reason) {
        return destroyEntity(entity, reason, true);
    }

    /**
     * Marks a unit as destroyed! Units transported inside the destroyed unit
     * will get a chance to escape unless the destruction was not survivable.
     *
     * @param entity     - the <code>Entity</code> that has been destroyed.
     * @param reason     - a <code>String</code> detailing why the entity was
     *                   destroyed.
     * @param survivable - a <code>boolean</code> that identifies the destruction as
     *                   unsurvivable for transported units.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    public Vector<Report> destroyEntity(Entity entity, String reason, boolean survivable) {
        // Generally, the entity can still be salvaged.
        return destroyEntity(entity, reason, survivable, true);
    }

    /**
     * Marks a unit as destroyed! Units transported inside the destroyed unit
     * will get a chance to escape unless the destruction was not survivable.
     *
     * @param entity     - the <code>Entity</code> that has been destroyed.
     * @param reason     - a <code>String</code> detailing why the entity was
     *                   destroyed.
     * @param survivable - a <code>boolean</code> that identifies the destruction as
     *                   unsurvivable for transported units.
     * @param canSalvage - a <code>boolean</code> that indicates if the unit can be
     *                   salvaged (or cannibalized for spare parts). If
     *                   <code>true</code>, salvage operations are possible, if
     *                   <code>false</code>, the unit is too badly damaged.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    public Vector<Report> destroyEntity(Entity entity, String reason, boolean survivable,
                                        boolean canSalvage) {
        // can't destroy an entity if it's already been destroyed
        if (entity.isDestroyed()) {
            return new Vector<>();
        }

        Vector<Report> vDesc = new Vector<>();
        Report r;

        //We'll need this later...
        Aero ship = null;
        if (entity.isLargeCraft()) {
            ship = (Aero) entity;
        }

        // regardless of what was passed in, units loaded onto aeros not on the
        // ground are destroyed
        if (entity.isAirborne()) {
            survivable = false;
        } else if (entity.isAero()) {
            survivable = true;
        }

        // The unit can suffer an ammo explosion after it has been destroyed.
        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
        if (!canSalvage) {
            entity.setSalvage(false);
            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
        }

        // Destroy the entity, unless it's already destroyed.
        if (!entity.isDoomed() && !entity.isDestroyed()) {
            r = new Report(6365);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(reason);
            vDesc.addElement(r);

            entity.setDoomed(true);

            // Kill any picked up MechWarriors
            Enumeration<Integer> iter = entity.getPickedUpMechWarriors().elements();
            while (iter.hasMoreElements()) {
                int mechWarriorId = iter.nextElement();
                Entity mw = game.getEntity(mechWarriorId);

                // in some situations, a "picked up" mechwarrior won't actually exist
                // probably this is brought about by picking up a mechwarrior in a previous MekHQ scenario
                // then having the same unit get blown up in a subsequent scenario
                // in that case, we simply move on
                if (mw == null) {
                    continue;
                }

                mw.setDestroyed(true);
                // We can safely remove these, as they can't be targeted
                game.removeEntity(mw.getId(), condition);
                entityUpdate(mw.getId());
                send(createRemoveEntityPacket(mw.getId(), condition));
                r = new Report(6370);
                r.subject = mw.getId();
                r.addDesc(mw);
                vDesc.addElement(r);
            }

            // make any remaining telemissiles operated by this entity
            // out of contact
            for (int missileId : entity.getTMTracker().getMissiles()) {
                Entity tm = game.getEntity(missileId);
                if ((null != tm) && !tm.isDestroyed() && (tm instanceof TeleMissile)) {
                    ((TeleMissile) tm).setOutContact(true);
                    entityUpdate(tm.getId());
                }
            }

            // Mechanized BA that could die on a 3+
            ArrayList<Entity> externalUnits = entity.getExternalUnits();

            // Handle escape of transported units.
            if (!entity.getLoadedUnits().isEmpty()) {
                Coords curPos = entity.getPosition();
                int curFacing = entity.getFacing();
                for (Entity other : entity.getLoadedUnits()) {
                    // If the unit has been destroyed (as from a cargo hit), skip it
                    if (other.isDestroyed()) {
                        continue;
                    }
                    // Can the other unit survive?
                    boolean survived = false;
                    if (entity instanceof Tank) {
                        if (entity.getMovementMode().isNaval()
                                || entity.getMovementMode().isHydrofoil()) {
                            if (other.getMovementMode().isUMUInfantry()) {
                                survived = Compute.d6() <= 3;
                            } else if (other.getMovementMode().isJumpInfantry()) {
                                survived = Compute.d6() == 1;
                            } else if (other.getMovementMode().isVTOL()) {
                                survived = Compute.d6() <= 2;
                            }
                        } else if (entity.getMovementMode().isSubmarine()) {
                            if (other.getMovementMode().isUMUInfantry()) {
                                survived = Compute.d6() == 1;
                            }
                        } else {
                            survived = Compute.d6() <= 4;
                        }
                    } else if (entity instanceof Mech) {
                        // mechanized BA can escape on a roll of 1 or 2
                        if (externalUnits.contains(other)) {
                            survived = Compute.d6() < 3;
                        }
                    }
                    if (!survivable || (externalUnits.contains(other) && !survived)
                            // Don't unload from ejecting spacecraft. The crews aren't in their units...
                            || (ship != null && ship.isEjecting())) {
                        // Nope.
                        other.setDestroyed(true);
                        // We need to unload the unit, since it's ID goes away
                        entity.unload(other);
                        // Safe to remove, as they aren't targeted
                        game.moveToGraveyard(other.getId());
                        send(createRemoveEntityPacket(other.getId(), condition));
                        r = new Report(6370);
                        r.subject = other.getId();
                        r.addDesc(other);
                        vDesc.addElement(r);
                    }
                    // Can we unload the unit to the current hex?
                    // TODO : unloading into stacking violation is not
                    // explicitly prohibited in the BMRr.
                    else if ((null != Compute.stackingViolation(game, other.getId(), curPos))
                            || other.isLocationProhibited(curPos)) {
                        // Nope.
                        other.setDestroyed(true);
                        // We need to unload the unit, since it's ID goes away
                        entity.unload(other);
                        // Safe to remove, as they aren't targeted
                        game.moveToGraveyard(other.getId());
                        send(createRemoveEntityPacket(other.getId(), condition));
                        r = new Report(6375);
                        r.subject = other.getId();
                        r.addDesc(other);
                        vDesc.addElement(r);
                    } else {
                        // The other unit survives.
                        unloadUnit(entity, other, curPos, curFacing, entity.getElevation(),
                                true, false);
                    }
                }
            }

            // Handle transporting unit.
            if (Entity.NONE != entity.getTransportId()) {
                final Entity transport = game.getEntity(entity.getTransportId());
                Coords curPos = transport.getPosition();
                int curFacing = transport.getFacing();
                if (!transport.isLargeCraft()) {
                    unloadUnit(transport, entity, curPos, curFacing, transport.getElevation());
                }
                entityUpdate(transport.getId());

                // if this is the last fighter in a fighter squadron then remove the squadron
                if ((transport instanceof FighterSquadron) && transport.getSubEntities().isEmpty()) {
                    transport.setDestroyed(true);

                    r = new Report(6365);
                    r.subject = transport.getId();
                    r.addDesc(transport);
                    r.add("fighter destruction");
                    vDesc.addElement(r);
                }
            }

            // Is this unit towing some trailers?
            // If so, disconnect them
            if (!entity.getAllTowedUnits().isEmpty()) {
                //Find the first trailer in the list and drop it
                //this will disconnect all that follow too
                Entity leadTrailer = game.getEntity(entity.getAllTowedUnits().get(0));
                disconnectUnit(entity, leadTrailer, entity.getPosition());
            }

            // Is this unit a trailer being towed? If so, disconnect it from its tractor
            if (entity.getTractor() != Entity.NONE) {
                Entity tractor = game.getEntity(entity.getTractor());
                disconnectUnit(tractor, entity, tractor.getPosition());
            }

            // Is this unit being swarmed?
            final int swarmerId = entity.getSwarmAttackerId();
            if (Entity.NONE != swarmerId) {
                final Entity swarmer = game.getEntity(swarmerId);

                swarmer.setSwarmTargetId(Entity.NONE);
                // a unit that stopped swarming due to the swarmed unit dieing
                // should be able to move: setSwarmTargetId to Entity.None
                // changes done to true and unloaded to true, need to undo this
                swarmer.setUnloaded(false);
                swarmer.setDone(false);
                entity.setSwarmAttackerId(Entity.NONE);
                Report.addNewline(vDesc);
                r = new Report(6380);
                r.subject = swarmerId;
                r.addDesc(swarmer);
                vDesc.addElement(r);
                // Swarming infantry shouldn't take damage when their target dies
                // http://bg.battletech.com/forums/total-warfare/swarming-question
                entityUpdate(swarmerId);
            }

            // Is this unit swarming somebody?
            final int swarmedId = entity.getSwarmTargetId();
            if (Entity.NONE != swarmedId) {
                final Entity swarmed = game.getEntity(swarmedId);
                swarmed.setSwarmAttackerId(Entity.NONE);
                entity.setSwarmTargetId(Entity.NONE);
                r = new Report(6385);
                r.subject = swarmed.getId();
                r.addDesc(swarmed);
                vDesc.addElement(r);
                entityUpdate(swarmedId);
            }

            // If in a grapple, release both mechs
            if (entity.getGrappled() != Entity.NONE) {
                int grappler = entity.getGrappled();
                entity.setGrappled(Entity.NONE, false);
                Entity e = game.getEntity(grappler);
                if (e != null) {
                    e.setGrappled(Entity.NONE, false);
                }
                entityUpdate(grappler);
            }

            ServerHelper.clearBloodStalkers(game, entity.getId(), this);
        }

        // if using battlefield wreckage rules, then the destruction of this unit might convert the
        // hex to rough
        Coords curPos = entity.getPosition();
        Hex entityHex = game.getBoard().getHex(curPos);
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_BATTLE_WRECK)
                && (entityHex != null) && game.getBoard().onGround()
                && !((entity instanceof Infantry) || (entity instanceof Protomech))) {
            // large support vees will create ultra rough, otherwise rough
            if (entity instanceof LargeSupportTank) {
                if (entityHex.terrainLevel(Terrains.ROUGH) < 2) {
                    entityHex.addTerrain(new Terrain(Terrains.ROUGH, 2));
                    sendChangedHex(curPos);
                }
            } else if ((entity.getWeight() >= 40) && !entityHex.containsTerrain(Terrains.ROUGH)) {
                entityHex.addTerrain(new Terrain(Terrains.ROUGH, 1));
                sendChangedHex(curPos);
            }
        }

        // update our entity, so clients have correct data needed for MekWars stuff
        entityUpdate(entity.getId());

        return vDesc;
    }

    /**
     * Makes a piece of equipment on a mech explode! POW! This expects either
     * ammo, or an explosive weapon. Returns a vector of Report objects.
     */
    private Vector<Report> explodeEquipment(Entity en, int loc, int slot) {
        CriticalSlot critSlot = en.getCritical(loc, slot);
        Vector<Report> reports = explodeEquipment(en, loc, critSlot.getMount());
        if (critSlot.getMount2() != null) {
            reports.addAll(explodeEquipment(en, loc, critSlot.getMount2()));
        }
        return reports;
    }

    /**
     * Explodes a piece of equipment on the unit.
     */
    public Vector<Report> explodeEquipment(Entity en, int loc, Mounted mounted) {
        return explodeEquipment(en, loc, mounted, false);
    }

    /**
     * Makes a piece of equipment on a mech explode! POW! This expects either
     * ammo, or an explosive weapon. Returns a vector of Report objects.
     * Possible to override 'is explosive' check
     */
    public Vector<Report> explodeEquipment(Entity en, int loc, Mounted mounted, boolean overrideExplosiveCheck) {
        Vector<Report> vDesc = new Vector<>();
        // is this already destroyed?
        if (mounted.isDestroyed()) {
            LogManager.getLogger().error("Called on destroyed equipment(" + mounted.getName() + ")");
            return vDesc;
        }

        // Special case: LAM bomb bays explode the bomb stored there, which may involve going through a
        // launch weapon to the bomb ammo.
        if ((mounted.getType() instanceof MiscType) && mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {
            while (mounted.getLinked() != null) {
                mounted = mounted.getLinked();
            }
            // Fuel tank explodes on 2d6 roll of 10+
            if ((mounted.getType() instanceof MiscType) && mounted.getType().hasFlag(MiscType.F_FUEL)) {
                Report r = new Report(9120);
                r.subject = en.getId();
                int boomTarget = 10;
                // check for possible explosion
                int fuelRoll = Compute.d6(2);
                r.choose(fuelRoll >= boomTarget);
                if (fuelRoll >= boomTarget) {
                    r.choose(true);
                    vDesc.add(r);
                } else {
                    r.choose(false);
                    vDesc.add(r);
                    return vDesc;
                }
            }
        }

        if (!overrideExplosiveCheck && !mounted.getType().isExplosive(mounted, false)) {
            return vDesc;
        }

        // Inferno ammo causes heat buildup as well as the damage
        if ((mounted.getType() instanceof AmmoType)
                && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM_IMP)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_IATM)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_MML))
                && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_INFERNO)
                && (mounted.getHittableShotsLeft() > 0)) {
            en.heatBuildup += Math.min(mounted.getExplosionDamage(), 30);
        }

        // Inferno bombs in LAM bomb bays
        if ((mounted.getType() instanceof BombType)
                && (((BombType) mounted.getType()).getBombType() == BombType.B_INFERNO)) {
            en.heatBuildup += Math.min(mounted.getExplosionDamage(), 30);
        }

        // determine and deal damage
        int damage = mounted.getExplosionDamage();

        // Smoke ammo halves damage
        if ((mounted.getType() instanceof AmmoType)
                && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM_IMP)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_LRM)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_LRM_IMP))
                && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_SMOKE_WARHEAD)
                && (mounted.getHittableShotsLeft() > 0)) {
            damage = ((mounted.getExplosionDamage()) / 2);
        }
        // coolant explodes for 2 damage and reduces heat by 3
        if ((mounted.getType() instanceof AmmoType)
                && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_VEHICLE_FLAMER)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_HEAVY_FLAMER))
                && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_COOLANT)
                && (mounted.getHittableShotsLeft() > 0)) {
            damage = 2;
            en.coolFromExternal += 3;
        }

        // divide damage by 10 for aeros, per TW rules on pg. 161
        if (en instanceof Aero) {
            int newDamage = (int) Math.floor(damage / 10.0);
            if ((newDamage == 0) && (damage > 0)) {
                damage = 1;
            } else {
                damage = newDamage;
            }
        }

        if (damage <= 0) {
            return vDesc;
        }

        Report r = new Report(6390);
        r.subject = en.getId();
        r.add(mounted.getName());
        r.add(damage);
        r.indent(3);
        vDesc.addElement(r);
        // Mounted is a weapon and has Hot-Loaded ammo in it and it exploded now
        // we need to roll for chain reaction
        if ((mounted.getType() instanceof WeaponType) && mounted.isHotLoaded()) {
            int roll = Compute.d6(2);
            int ammoExploded = 0;
            r = new Report(6077);
            r.subject = en.getId();
            r.add(roll);
            r.indent(2);
            vDesc.addElement(r);

            // roll of 2-5 means a chain reaction happened
            if (roll < 6) {
                for (Mounted ammo : en.getAmmo()) {
                    if ((ammo.getLocation() == loc) && (ammo.getExplosionDamage() > 0)
                            // Dead-Fire ammo bins are designed not to explode
                            // from the chain reaction
                            // Of Critted Launchers with DFM or HotLoaded ammo.
                            && (((AmmoType) ammo.getType()).getMunitionType() != AmmoType.M_DEAD_FIRE)) {
                        ammoExploded++;
                        vDesc.addAll(this.explodeEquipment(en, loc, ammo));
                        break;
                    }
                }
                if (ammoExploded == 0) {
                    r = new Report(6078);
                    r.subject = en.getId();
                    r.indent(2);
                    vDesc.addElement(r);
                }
            } else {
                r = new Report(6079);
                r.subject = en.getId();
                r.indent(2);
                vDesc.addElement(r);
            }
        }

        HitData hit = new HitData(loc);
        // check to determine whether this is capital scale if we have a capital
        // scale entity
        if (mounted.getType() instanceof AmmoType) {
            if (((AmmoType) mounted.getType()).isCapital()) {
                hit.setCapital(true);
            }
        }

        // exploding RISC laser pulse module should cause no normal crits, just
        // automatically crit the first uncritted crit of the laser it's
        // attached to
        if ((mounted.getType() instanceof MiscType)  && mounted.getType().hasFlag(MiscType.F_RISC_LASER_PULSE_MODULE)) {
            hit.setEffect(HitData.EFFECT_NO_CRITICALS);
            Mounted laser = mounted.getLinkedBy();
            if (en instanceof Mech) {
                for (int slot = 0; slot < en.getNumberOfCriticals(laser.getLocation()); slot++) {
                    CriticalSlot cs = en.getCritical(laser.getLocation(), slot);
                    if ((cs.getType() == CriticalSlot.TYPE_EQUIPMENT) && cs.getMount().equals(laser)
                            && cs.isHittable()) {
                        cs.setHit(true);
                        cs.setRepairable(true);
                        break;
                    }
                }
            }
            laser.setHit(true);
        }

        mounted.setShotsLeft(0);

        int pilotDamage = 2;
        if (en instanceof Aero) {
            pilotDamage = 1;
        }
        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_CASE_PILOT_DAMAGE)
                && (en.locationHasCase(hit.getLocation()) || en.hasCASEII(hit.getLocation()))) {
            pilotDamage = 1;
        }
        if (en.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)
                || en.hasAbility(OptionsConstants.MISC_IRON_MAN)) {
            pilotDamage -= 1;
        }
        // tanks only take pilot damage when using BVDNI or VDNI
        if ((en instanceof Tank) && !(en.hasAbility(OptionsConstants.MD_VDNI)
                || en.hasAbility(OptionsConstants.MD_BVDNI))) {
            pilotDamage = 0;
        }
        if (!en.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {
            vDesc.addAll(damageCrew(en, pilotDamage, en.getCrew().getCurrentPilotIndex()));
        }
        if (en.getCrew().isDoomed() || en.getCrew().isDead()) {
            vDesc.addAll(destroyEntity(en, "crew death", true));
        } else {
            Report.addNewline(vDesc);
        }

        Vector<Report> newReports = damageEntity(en, hit, damage, true);
        for (Report rep : newReports) {
            rep.indent(2);
        }
        vDesc.addAll(newReports);
        Report.addNewline(vDesc);

        return vDesc;
    }

    /**
     * Makes one slot of ammo, determined by certain rules, explode on a mech.
     */
    Vector<Report> explodeAmmoFromHeat(Entity entity) {
        int damage = 0;
        int rack = 0;
        int boomloc = -1;
        int boomslot = -1;
        Vector<Report> vDesc = new Vector<>();

        for (int j = 0; j < entity.locations(); j++) {
            for (int k = 0; k < entity.getNumberOfCriticals(j); k++) {
                CriticalSlot cs = entity.getCritical(j, k);
                if ((cs == null) || cs.isDestroyed() || cs.isHit()
                        || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {
                    continue;
                }
                Mounted mounted = cs.getMount();
                if ((mounted == null) || (!(mounted.getType() instanceof AmmoType))) {
                    continue;
                }
                AmmoType atype = (AmmoType) mounted.getType();
                if (!atype.isExplosive(mounted)) {
                    continue;
                }
                // coolant pods and flamer coolant ammo don't explode from heat
                if ((atype.getAmmoType() == AmmoType.T_COOLANT_POD)
                        || (((atype.getAmmoType() == AmmoType.T_VEHICLE_FLAMER)
                        || (atype.getAmmoType() == AmmoType.T_HEAVY_FLAMER))
                        && (atype.getMunitionType() == AmmoType.M_COOLANT))) {
                    continue;
                }
                // ignore empty, destroyed, or missing bins
                if (mounted.getHittableShotsLeft() == 0) {
                    continue;
                }
                // TW page 160, compare one rack's
                // damage. Ties go to most rounds.
                int newRack = atype.getDamagePerShot() * atype.getRackSize();
                int newDamage = mounted.getExplosionDamage();
                Mounted mount2 = cs.getMount2();
                if ((mount2 != null) && (mount2.getType() instanceof AmmoType)
                        && (mount2.getHittableShotsLeft() > 0)) {
                    // must be for same weaponType, so rackSize stays
                    atype = (AmmoType) mount2.getType();
                    newRack += atype.getDamagePerShot() * atype.getRackSize();
                    newDamage += mount2.getExplosionDamage();
                }
                if (!mounted.isHit()
                        && ((rack < newRack) || ((rack == newRack) && (damage < newDamage)))) {
                    rack = newRack;
                    damage = newDamage;
                    boomloc = j;
                    boomslot = k;
                }
            }
        }
        if ((boomloc != -1) && (boomslot != -1)) {
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);
            slot.setHit(true);
            slot.getMount().setHit(true);
            if (slot.getMount2() != null) {
                slot.getMount2().setHit(true);
            }
            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));
        } else {
            // Luckily, there is no ammo to explode.
            Report r = new Report(5105);
            r.subject = entity.getId();
            r.indent();
            vDesc.addElement(r);
        }
        return vDesc;
    }

    /**
     * Makes a mech fall.
     *
     * @param entity
     *            The Entity that is falling. It is expected that the Entity's
     *            position and elevation reflect the state prior to the fall
     * @param fallPos
     *            The location that the Entity is falling into.
     * @param fallHeight
     *            The height that Entity is falling.
     * @param facing
     *            The facing of the fall. Used to determine the hit location
     *            and also determines facing after the fall (used as an offset
     *            of the Entity's current facing).
     * @param roll
     *            The PSR required to avoid damage to the pilot/crew.
     * @param intoBasement
     *            Flag that determines whether this is a fall into a basement or
     *            not.
     */
    private Vector<Report> doEntityFall(Entity entity, Coords fallPos, int fallHeight, int facing,
                                        PilotingRollData roll, boolean intoBasement, boolean fromCliff) {
        entity.setFallen(true);

        Vector<Report> vPhaseReport = new Vector<>();
        Report r;

        Hex fallHex = game.getBoard().getHex(fallPos);

        boolean handlingBasement = false;
        int damageTable = ToHitData.HIT_NORMAL;

        // we don't need to deal damage yet, if the entity is doing DFA
        if (entity.isMakingDfa()) {
            r = new Report(2305);
            r.subject = entity.getId();
            vPhaseReport.add(r);
            entity.setProne(true);
            return vPhaseReport;
        }

        // facing after fall
        String side;
        int table;
        switch (facing) {
            case 1:
            case 2:
                side = "right side";
                table = ToHitData.SIDE_RIGHT;
                break;
            case 3:
                side = "rear";
                table = ToHitData.SIDE_REAR;
                break;
            case 4:
            case 5:
                side = "left side";
                table = ToHitData.SIDE_LEFT;
                break;
            case 0:
            default:
                side = "front";
                table = ToHitData.SIDE_FRONT;
        }

        int waterDepth = 0;
        if (fallHex.containsTerrain(Terrains.WATER)) {
            // *Only* use this if there actually is water in the hex, otherwise
            // we get Terrain.LEVEL_NONE, i.e. Integer.minValue...
            waterDepth = fallHex.terrainLevel(Terrains.WATER);
        }
        boolean fallOntoBridge = false;
        // only fall onto the bridge if we were in the hex and on it,
        // or we fell from a hex that the bridge exits to
        if ((entity.climbMode() && (entity.getPosition() != fallPos)
                && fallHex.containsTerrain(Terrains.BRIDGE)
                && fallHex.containsTerrainExit(Terrains.BRIDGE, fallPos.direction(entity.getPosition())))
                || (entity.getElevation() == fallHex.terrainLevel(Terrains.BRIDGE_ELEV))) {
            fallOntoBridge = true;
        }
        int bridgeElev = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
        int buildingElev = fallHex.terrainLevel(Terrains.BLDG_ELEV);
        int damageHeight = fallHeight;
        int newElevation = 0;

        // we might have to check if the building/bridge we are falling onto
        // collapses
        boolean checkCollapse = false;

        if ((entity.getElevation() >= buildingElev) && (buildingElev >= 0)) {
            // fallHeight should already reflect this
            newElevation = buildingElev;
            checkCollapse = true;
        } else if (fallOntoBridge && (entity.getElevation() >= bridgeElev) && (bridgeElev >= 0)) {
            // fallHeight should already reflect this
            waterDepth = 0;
            newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
            checkCollapse = true;
        } else if (fallHex.containsTerrain(Terrains.ICE) && (entity.getElevation() == 0)) {
            waterDepth = 0;
            newElevation = 0;
            // If we are in a basement, we are at a negative elevation, and so
            // setting newElevation = 0 will cause us to "fall up"
        } else if ((entity.getMovementMode() != EntityMovementMode.VTOL)
                && (game.getBoard().getBuildingAt(fallPos) != null)) {
            newElevation = entity.getElevation();
        }
        // HACK: if the destination hex is water, assume that the fall height given is
        // to the floor of the hex, and modify it so that it's to the surface
        else if (waterDepth > 0) {
            damageHeight = fallHeight - waterDepth;
            newElevation = -waterDepth;
        }
        // only do these basement checks if we didn't fall onto the building
        // from above
        if (intoBasement) {
            Building bldg = game.getBoard().getBuildingAt(fallPos);
            BasementType basement = bldg.getBasement(fallPos);
            if (!basement.isNone() && !basement.isOneDeepNormalInfantryOnly()
                    && (entity.getElevation() == 0) && (bldg.getBasementCollapsed(fallPos))) {

                if (fallHex.depth(true) == 0) {
                    LogManager.getLogger().error("Entity " + entity.getDisplayName() + " is falling into a depth "
                            + fallHex.depth(true) + " basement -- not allowed!!");
                    return vPhaseReport;
                }
                damageHeight = basement.getDepth();

                newElevation = newElevation - damageHeight;

                handlingBasement = true;
                // May have to adjust hit table for 'mechs
                if (entity instanceof Mech) {
                    switch (basement) {
                        case TWO_DEEP_FEET:
                        case ONE_DEEP_FEET:
                            damageTable = ToHitData.HIT_KICK;
                            break;
                        case ONE_DEEP_HEAD:
                        case TWO_DEEP_HEAD:
                            damageTable = ToHitData.HIT_PUNCH;
                            break;
                        default:
                            damageTable = ToHitData.HIT_NORMAL;
                            break;
                    }
                }
            }
        }

        if (entity instanceof Protomech) {
            damageTable = ToHitData.HIT_SPECIAL_PROTO;
        }
        // Falling into water instantly destroys most non-mechs
        if ((waterDepth > 0)
                && !(entity instanceof Mech)
                && !(entity instanceof Protomech)
                && !((entity.getRunMP() > 0) && (entity.getMovementMode() == EntityMovementMode.HOVER))
                && (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)
                && (entity.getMovementMode() != EntityMovementMode.NAVAL)
                && (entity.getMovementMode() != EntityMovementMode.SUBMARINE)
                && (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {
            vPhaseReport.addAll(destroyEntity(entity, "a watery grave", false));
            return vPhaseReport;
        }

        // set how deep the mech has fallen
        if (entity instanceof Mech) {
            Mech mech = (Mech) entity;
            mech.setLevelsFallen(damageHeight + waterDepth + 1);
            // an industrial mech now needs to check for a crit at the end of
            // the turn
            if (mech.isIndustrial()) {
                mech.setCheckForCrit(true);
            }
        }

        // calculate damage for hitting the surface
        int damage = (int) Math.round(entity.getWeight() / 10.0)
                * (damageHeight + 1);
        // different rules (pg. 151 of TW) for battle armor and infantry
        if (entity instanceof Infantry) {
            damage = (int) Math.ceil(damageHeight / 2.0);
            // no damage for fall from less than 2 levels
            if (damageHeight < 2) {
                damage = 0;
            }
            if (!(entity instanceof BattleArmor)) {
                int dice = 3;
                if (entity.getMovementMode() == EntityMovementMode.INF_MOTORIZED) {
                    dice = 2;
                } else if ((entity.getMovementMode() == EntityMovementMode.INF_JUMP)
                        || ((Infantry) entity).isMechanized()) {
                    dice = 1;
                }
                damage = damage * Compute.d6(dice);
            }
        }
        // Different rules (pg 62/63/152 of TW) for Tanks
        if (entity instanceof Tank) {
            // Falls from less than 2 levels don't damage combat vehicles
            // except if they fall off a sheer cliff
            if (damageHeight < 2 && !fromCliff) {
                damage = 0;
            }
            // Falls from >= 2 elevations damage like crashing VTOLs
            // Ends up being the regular damage: weight / 10 * (height + 1)
            // And this was already computed
        }
        // calculate damage for hitting the ground, but only if we actually fell
        // into water
        // if we fell onto the water surface, that damage is halved.
        int waterDamage = 0;
        if (waterDepth > 0) {
            damage /= 2;
            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (waterDepth + 1)) / 2;
        }

        // If the waterDepth is larger than the fall height, we fell underwater
        if ((waterDepth >= fallHeight) && ((waterDepth != 0) || (fallHeight != 0))) {
            damage = 0;
            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (fallHeight + 1)) / 2;
        }
        // adjust damage for gravity
        damage = Math
                .round(damage * game.getPlanetaryConditions().getGravity());
        waterDamage = Math.round(waterDamage
                * game.getPlanetaryConditions().getGravity());

        // report falling
        if (waterDamage == 0) {
            r = new Report(2310);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side);
            r.add(damage);
        } else if (damage > 0) {
            r = new Report(2315);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side);
            r.add(damage);
            r.add(waterDamage);
        } else {
            r = new Report(2310);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side);
            r.add(waterDamage);
        }
        vPhaseReport.add(r);

        // Any swarming infantry will be dislodged, but we don't want to
        // interrupt the fall's report. We have to get the ID now because
        // the fall may kill the entity which will reset the attacker ID.
        final int swarmerId = entity.getSwarmAttackerId();

        // Positioning must be prior to damage for proper handling of breaches
        // Only Mechs can fall prone.
        if (entity instanceof Mech) {
            entity.setProne(true);
        }
        entity.setPosition(fallPos);
        entity.setElevation(newElevation);
        // Only 'mechs change facing when they fall
        if (entity instanceof Mech) {
            entity.setFacing((entity.getFacing() + (facing)) % 6);
            entity.setSecondaryFacing(entity.getFacing());
        }

        // if falling into a bog-down hex, the entity automatically gets stuck (except when on a bridge or building)
        // but avoid reporting this twice in the case of DFAs
        if (!entity.isStuck() && (entity.getElevation() == 0)) {
            if (fallHex.getBogDownModifier(entity.getMovementMode(),
                    entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
                entity.setStuck(true);
                r = new Report(2081);
                r.subject = entity.getId();
                r.add(entity.getDisplayName(), true);
                vPhaseReport.add(r);
                // check for quicksand
                vPhaseReport.addAll(checkQuickSand(fallPos));
            }
        }

        // standard damage loop
        if ((entity instanceof Infantry) && (damage > 0)) {
            if (entity instanceof BattleArmor) {
                for (int i = 1; i < entity.locations(); i++) {
                    HitData h = new HitData(i);
                    vPhaseReport.addAll(damageEntity(entity, h, damage));
                    addNewLines();
                }
            } else {
                HitData h = new HitData(Infantry.LOC_INFANTRY);
                vPhaseReport.addAll(damageEntity(entity, h, damage));
            }
        } else {
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = entity.rollHitLocation(damageTable, table);
                hit.makeFallDamage(true);
                vPhaseReport.addAll(damageEntity(entity, hit, cluster));
                damage -= cluster;
            }
        }

        if (waterDepth > 0) {
            for (int loop = 0; loop < entity.locations(); loop++) {
                entity.setLocationStatus(loop, ILocationExposureStatus.WET);
            }
        }
        // Water damage
        while (waterDamage > 0) {
            int cluster = Math.min(5, waterDamage);
            HitData hit = entity.rollHitLocation(damageTable, table);
            hit.makeFallDamage(true);
            vPhaseReport.addAll(damageEntity(entity, hit, cluster));
            waterDamage -= cluster;
        }

        // check for location exposure
        vPhaseReport.addAll(doSetLocationsExposure(entity, fallHex, false,
                -waterDepth));

        // only mechs should roll to avoid pilot damage
        // vehicles may fall due to sideslips
        if (entity instanceof Mech) {
            vPhaseReport.addAll(checkPilotAvoidFallDamage(entity, fallHeight, roll));
        }

        // Now dislodge any swarming infantry.
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            entity.setSwarmAttackerId(Entity.NONE);
            swarmer.setSwarmTargetId(Entity.NONE);
            // Did the infantry fall into water?
            if ((waterDepth > 0)
                    && (swarmer.getMovementMode() != EntityMovementMode.INF_UMU)) {
                // Swarming infantry die.
                swarmer.setPosition(fallPos);
                r = new Report(2330);
                r.newlines = 0;
                r.subject = swarmer.getId();
                r.addDesc(swarmer);
                vPhaseReport.add(r);
                vPhaseReport.addAll(destroyEntity(swarmer, "a watery grave",
                        false));
            } else {
                // Swarming infantry take a 2d6 point hit.
                // ASSUMPTION : damage should not be doubled.
                r = new Report(2335);
                r.newlines = 0;
                r.subject = swarmer.getId();
                r.addDesc(swarmer);
                vPhaseReport.add(r);
                vPhaseReport.addAll(damageEntity(swarmer, swarmer
                        .rollHitLocation(ToHitData.HIT_NORMAL,
                                ToHitData.SIDE_FRONT), Compute.d6(2)));
                Report.addNewline(vPhaseReport);
            }
            swarmer.setPosition(fallPos);
            entityUpdate(swarmerId);
            if (!swarmer.isDone()) {
                game.removeTurnFor(swarmer);
                swarmer.setDone(true);
                send(createTurnVectorPacket());
            }
        } // End dislodge-infantry

        // clear all PSRs after a fall -- the Mek has already failed ONE and
        // fallen, it'd be cruel to make it fail some more!
        game.resetPSRs(entity);

        // if there is a minefield in this hex, then the mech may set it off
        if (game.containsMinefield(fallPos)
                && enterMinefield(entity, fallPos, newElevation, true,
                vPhaseReport, 12)) {
            resetMines();
        }
        // if we have to, check if the building/bridge we fell on collapses -
        // unless it's a fall into a basement,
        // then we're already gonna check that in building collapse, where we
        // came from
        if (checkCollapse && !handlingBasement) {

            checkForCollapse(game.getBoard().getBuildingAt(fallPos),
                    game.getPositionMap(), fallPos, false, vPhaseReport);
        }

        return vPhaseReport;
    }

    private Vector<Report> checkPilotAvoidFallDamage(Entity entity, int fallHeight, PilotingRollData roll) {
        Vector<Report> reports = new Vector<>();

        if (entity.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)
                || entity.hasAbility(OptionsConstants.MD_TSM_IMPLANT)) {
            return reports;
        }
        // we want to be able to avoid pilot damage even when it was
        // an automatic fall, only unconsciousness should cause auto-damage
        roll.removeAutos();

        if (fallHeight > 1) {
            roll.addModifier(fallHeight - 1, "height of fall");
        }

        if (entity.getCrew().getSlotCount() > 1) {
            //Extract the base from the list of modifiers so we can replace it with the piloting
            //skill of each crew member.
            List<TargetRollModifier> modifiers = new ArrayList<>(roll.getModifiers());
            if (!modifiers.isEmpty()) {
                modifiers.remove(0);
            }
            for (int pos = 0; pos < entity.getCrew().getSlotCount(); pos++) {
                if (entity.getCrew().isMissing(pos) || entity.getCrew().isDead(pos)) {
                    continue;
                }
                PilotingRollData prd;
                if (entity.getCrew().isDead(pos)) {
                    continue;
                } else if (entity.getCrew().isUnconscious(pos)) {
                    prd = new PilotingRollData(entity.getId(), TargetRoll.AUTOMATIC_FAIL,
                            "Crew member unconscious");
                } else {
                    prd = new PilotingRollData(entity.getId(),
                            entity.getCrew().getPiloting(pos), "Base piloting skill");
                    modifiers.forEach(prd::addModifier);
                }
                reports.addAll(resolvePilotDamageFromFall(entity, prd, pos));
            }
        } else {
            reports.addAll(resolvePilotDamageFromFall(entity, roll, 0));
        }
        return reports;
    }

    private Vector<Report> resolvePilotDamageFromFall(Entity entity, PilotingRollData roll, int crewPos) {
        Vector<Report> reports = new Vector<>();
        Report r;
        if (roll.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(2320);
            r.subject = entity.getId();
            r.add(entity.getCrew().getCrewType().getRoleName(crewPos));
            r.addDesc(entity);
            r.add(entity.getCrew().getName(crewPos));
            r.indent();
            reports.add(r);
            reports.addAll(damageCrew(entity, 1, crewPos));
        } else {
            int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2325);
            r.subject = entity.getId();
            r.add(entity.getCrew().getCrewType().getRoleName(crewPos));
            r.addDesc(entity);
            r.add(entity.getCrew().getName(crewPos));
            r.add(roll.getValueAsString());
            r.add(diceRoll);
            if (diceRoll >= roll.getValue()) {
                r.choose(true);
                reports.add(r);
            } else {
                r.choose(false);
                reports.add(r);
                reports.addAll(damageCrew(entity, 1, crewPos));
            }
        }
        Report.addNewline(reports);
        return reports;
    }

    /**
     * The mech falls into an unoccupied hex from the given height above
     */
    private Vector<Report> doEntityFall(Entity entity, Coords fallPos,
                                        int height, PilotingRollData roll) {
        return doEntityFall(entity, fallPos, height, Compute.d6(1) - 1, roll,
                false, false);
    }

    /**
     * The mech falls down in place
     */
    private Vector<Report> doEntityFall(Entity entity, PilotingRollData roll) {
        boolean fallToSurface = false;
        // on ice
        int toSubtract = 0;
        Hex currHex = game.getBoard().getHex(entity.getPosition());
        if (currHex.containsTerrain(Terrains.ICE)
                && (entity.getElevation() != -currHex.depth())) {
            fallToSurface = true;
            toSubtract = 0;
        }
        // on a bridge
        if (currHex.containsTerrain(Terrains.BRIDGE_ELEV)
                && (entity.getElevation() >= currHex
                .terrainLevel(Terrains.BRIDGE_ELEV))) {
            fallToSurface = true;
            toSubtract = currHex.terrainLevel(Terrains.BRIDGE_ELEV);
        }
        // on a building
        if (currHex.containsTerrain(Terrains.BLDG_ELEV)
                && (entity.getElevation() >= currHex
                .terrainLevel(Terrains.BLDG_ELEV))) {
            fallToSurface = true;
            toSubtract = currHex.terrainLevel(Terrains.BLDG_ELEV);
        }
        return doEntityFall(entity, entity.getPosition(), entity.getElevation()
                + (!fallToSurface ? currHex.depth(true) : -toSubtract), roll);
    }

    /**
     * Report: - Any ammo dumps beginning the following round. - Any ammo dumps
     * that have ended with the end of this round.
     */
    private void resolveAmmoDumps() {
        Report r;
        for (Entity entity : game.getEntitiesVector()) {
            for (Mounted m : entity.getAmmo()) {
                if (m.isPendingDump()) {
                    // report dumping next round
                    r = new Report(5110);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                    // update status
                    m.setPendingDump(false);
                    m.setDumping(true);
                } else if (m.isDumping()) {
                    // report finished dumping
                    r = new Report(5115);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                    // update status
                    m.setDumping(false);
                    m.setShotsLeft(0);
                }
            }
            // also do DWP dumping
            if (entity instanceof BattleArmor) {
                for (Mounted m : entity.getWeaponList()) {
                    if (m.isDWPMounted() && m.isPendingDump()) {
                        m.setMissing(true);
                        r = new Report(5116);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(m.getName());
                        addReport(r);
                        m.setPendingDump(false);
                        // Also dump all of the ammo in the DWP
                        for (Mounted ammo : entity.getAmmo()) {
                            if (m.equals(ammo.getLinkedBy())) {
                                ammo.setMissing(true);
                            }
                        }
                        // Check for jettisoning missiles
                    } else if (m.isBodyMounted() && m.isPendingDump()
                            && m.getType().hasFlag(WeaponType.F_MISSILE)
                            && (m.getLinked() != null)
                            && (m.getLinked().getUsableShotsLeft() > 0)) {
                        m.setMissing(true);
                        r = new Report(5116);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(m.getName());
                        addReport(r);
                        m.setPendingDump(false);
                        // Dump all ammo related to this launcher
                        // BA burdened is based on whether the launcher has
                        // ammo left
                        while ((m.getLinked() != null)
                                && (m.getLinked().getUsableShotsLeft() > 0)) {
                            m.getLinked().setMissing(true);
                            entity.loadWeapon(m);
                        }
                    }
                }
            }
            entity.reloadEmptyWeapons();
        }
    }

    /**
     * Checks for fire ignition based on a given target roll. If successful,
     * lights a fire also checks to see that fire is possible in the specified
     * hex.
     *
     * @param c        - the <code>Coords</code> to be lit.
     * @param roll     - the <code>TargetRoll</code> for the ignition roll
     * @param bInferno - <code>true</code> if the fire is an inferno fire. If this
     *                 value is <code>false</code> the hex will be lit only if it
     *                 contains Woods, jungle or a Building.
     * @param entityId - the entityId responsible for the ignite attempt. If the
     *                 value is Entity.NONE, then the roll attempt will not be
     *                 included in the report.
     */
    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno, int entityId,
                                 Vector<Report> vPhaseReport) {

        Hex hex = game.getBoard().getHex(c);

        // The hex might be null due to spreadFire translation
        // goes outside of the board limit.
        if (null == hex) {
            return false;
        }

        // The hex may already be on fire.
        if (hex.containsTerrain(Terrains.FIRE)) {
            return false;
        }

        if (!bInferno && !hex.isIgnitable()) {
            return false;
        }

        int fireRoll = Compute.d6(2);
        Report r;
        if (entityId != Entity.NONE) {
            r = new Report(3430);
            r.indent(2);
            r.subject = entityId;
            r.add(roll.getValueAsString());
            r.add(roll.getDesc());
            r.add(fireRoll);
            vPhaseReport.add(r);
        }
        if (fireRoll >= roll.getValue()) {
            ignite(c, Terrains.FIRE_LVL_NORMAL, vPhaseReport);
            return true;
        }
        return false;
    }

    /**
     * Returns true if the hex is set on fire with the specified roll. Of
     * course, also checks to see that fire is possible in the specified hex.
     * This version of the method will not report the attempt roll.
     *
     * @param c        - the <code>Coords</code> to be lit.
     * @param roll     - the <code>int</code> target number for the ignition roll
     * @param bInferno - <code>true</code> if the fire can be lit in any terrain. If
     *                 this value is <code>false</code> the hex will be lit only if
     *                 it contains Woods, jungle or a Building.
     */
    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno) {
        return checkIgnition(c, roll, bInferno, Entity.NONE, null);
    }

    /**
     * Returns true if the hex is set on fire with the specified roll. Of
     * course, also checks to see that fire is possible in the specified hex.
     * This version of the method will not report the attempt roll.
     *
     * @param c    - the <code>Coords</code> to be lit.
     * @param roll - the <code>int</code> target number for the ignition roll
     */
    public boolean checkIgnition(Coords c, TargetRoll roll) {
        // default signature, assuming only woods can burn
        return checkIgnition(c, roll, false, Entity.NONE, null);
    }

    /**
     * add fire to a hex
     *
     * @param c         - the <code>Coords</code> of the hex to be set on fire
     * @param fireLevel - The level of fire, see Terrains
     */
    public void ignite(Coords c, int fireLevel, Vector<Report> vReport) {
        // you can't start fires in some planetary conditions!
        if (null != game.getPlanetaryConditions().cannotStartFire()) {
            if (null != vReport) {
                Report r = new Report(3007);
                r.indent(2);
                r.add(game.getPlanetaryConditions().cannotStartFire());
                r.type = Report.PUBLIC;
                vReport.add(r);
            }
            return;
        }

        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_START_FIRE)) {
            if (null != vReport) {
                Report r = new Report(3008);
                r.indent(2);
                r.type = Report.PUBLIC;
                vReport.add(r);
            }
            return;
        }

        Hex hex = game.getBoard().getHex(c);
        if (null == hex) {
            return;
        }

        Report r = new Report(3005);
        r.indent(2);
        r.add(c.getBoardNum());
        r.type = Report.PUBLIC;

        // Adjust report message for inferno types
        switch (fireLevel) {
            case Terrains.FIRE_LVL_INFERNO:
                r.messageId = 3006;
                break;
            case Terrains.FIRE_LVL_INFERNO_BOMB:
                r.messageId = 3003;
                break;
            case Terrains.FIRE_LVL_INFERNO_IV:
                r.messageId = 3004;
                break;
        }

        // report it
        if (null != vReport) {
            vReport.add(r);
        }
        hex.addTerrain(new Terrain(Terrains.FIRE, fireLevel));
        sendChangedHex(c);
    }

    /**
     * remove fire from a hex
     *
     * @param fireCoords
     * @param reason
     */
    public void removeFire(Coords fireCoords, String reason) {
        Hex hex = game.getBoard().getHex(fireCoords);
        if (null == hex) {
            return;
        }
        hex.removeTerrain(Terrains.FIRE);
        hex.resetFireTurn();
        sendChangedHex(fireCoords);
        // fire goes out
        Report r = new Report(5170, Report.PUBLIC);
        r.add(fireCoords.getBoardNum());
        r.add(reason);
        addReport(r);
    }

    /**
     * Called when a fire is burning. Called 3 times per fire hex.
     *
     * @param coords The <code>Coords</code> x-coordinate of the hex
     */
    public void addSmoke(ArrayList<Coords> coords, int windDir, boolean bInferno) {
        // if a tornado, then no smoke!
        if (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_STORM) {
            return;
        }

        int smokeLevel = 0;
        for (Coords smokeCoords : coords) {
            Hex smokeHex = game.getBoard().getHex(smokeCoords);
            Report r;
            if (smokeHex == null) {
                continue;
            }
            // Have to check if it's inferno smoke or from a heavy/hardened
            // building
            // - heavy smoke from those
            if (bInferno || (Building.MEDIUM < smokeHex.terrainLevel(Terrains.FUEL_TANK))
                    || (Building.MEDIUM < smokeHex.terrainLevel(Terrains.BUILDING))) {
                if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {
                    // heavy smoke fills hex
                    r = new Report(5180, Report.PUBLIC);
                } else {
                    r = new Report(5185, Report.PUBLIC);
                }
                smokeLevel = SmokeCloud.SMOKE_HEAVY;
                r.add(smokeCoords.getBoardNum());
                addReport(r);
            } else {
                if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {
                    // heavy smoke overpowers light
                    r = new Report(5190, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                    addReport(r);
                } else if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT) {
                    // light smoke continue to fill hex
                    r = new Report(5195, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                } else {
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                    // light smoke fills hex
                    r = new Report(5200, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                }
            }
        }
        createSmoke(coords, smokeLevel, 0);
    }

    /**
     * Recursively scan the specified path to determine the board sizes
     * available.
     *
     * @param searchDir The directory to search below this path (may be null for all
     *                  in base path).
     * @param sizes     Where to store the discovered board sizes
     */
    private void getBoardSizesInDir(final File searchDir, TreeSet<BoardDimensions> sizes) {
        if (searchDir == null) {
            throw new IllegalArgumentException("must provide searchDir");
        }

        if (sizes == null) {
            throw new IllegalArgumentException("must provide sizes");
        }

        String[] file_list = searchDir.list();

        if (file_list != null) {
            for (String filename : file_list) {
                File query_file = new File(searchDir, filename);

                if (query_file.isDirectory()) {
                    getBoardSizesInDir(query_file, sizes);
                } else {
                    try {
                        if (filename.endsWith(".board")) {
                            BoardDimensions size = Board.getSize(query_file);
                            if (size == null) {
                                throw new Exception();
                            }
                            sizes.add(Board.getSize(query_file));
                        }
                    } catch (Exception e) {
                        LogManager.getLogger().error("Error parsing board: " + query_file.getAbsolutePath(), e);
                    }
                }
            }
        }
    }

    /**
     * Get a list of the available board sizes from the boards data directory.
     *
     * @return A Set containing all the available board sizes.
     */
    private Set<BoardDimensions> getBoardSizes() {
        TreeSet<BoardDimensions> board_sizes = new TreeSet<>();

        File boards_dir = Configuration.boardsDir();
        // Slightly overkill sanity check...
        if (boards_dir.isDirectory()) {
            getBoardSizesInDir(boards_dir, board_sizes);
        }
        boards_dir = new File(Configuration.userdataDir(), Configuration.boardsDir().toString());
        if (boards_dir.isDirectory()) {
            getBoardSizesInDir(boards_dir, board_sizes);
        }

        return board_sizes;
    }

    /**
     * @return whether this game is double blind or not and we should be blind in
     * the current phase
     */
    private boolean doBlind() {
        return game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)
                && game.getPhase().isDuringOrAfter(GamePhase.DEPLOYMENT);
    }

    private boolean suppressBlindBV() {
        return game.getOptions().booleanOption(OptionsConstants.ADVANCED_SUPPRESS_DB_BV);
    }

    /**
     * In a double-blind game, update only visible entities. Otherwise, update
     * everyone
     */
    public void entityUpdate(int nEntityID) {
        entityUpdate(nEntityID, new Vector<>(), true, null);
    }

    /**
     * In a double-blind game, update only visible entities. Otherwise, update
     * everyone
     *
     * @param updateVisibility Flag that determines if whoCanSee needs to be
     *                         called to update who can see the entity for
     *                         double-blind games.
     */
    public void entityUpdate(int nEntityID, Vector<UnitLocation> movePath, boolean updateVisibility,
                             Map<EntityTargetPair, LosEffects> losCache) {
        Entity eTarget = game.getEntity(nEntityID);
        if (eTarget == null) {
            if (game.getOutOfGameEntity(nEntityID) != null) {
                LogManager.getLogger().error("S: attempted to send entity update for out of game entity, id was " + nEntityID);
            } else {
                LogManager.getLogger().error("S: attempted to send entity update for null entity, id was " + nEntityID);
            }

            return; // do not send the update it will crash the client
        }

        // If we're doing double blind, be careful who can see it...
        if (doBlind()) {
            Vector<Player> playersVector = game.getPlayersVector();
            Vector<Player> vCanSee;
            if (updateVisibility) {
                vCanSee = whoCanSee(eTarget, true, losCache);
            } else {
                vCanSee = eTarget.getWhoCanSee();
            }

            // If this unit has ECM, players with units affected by the ECM will
            //  need to know about this entity, even if they can't see it.
            //  Otherwise, the client can't properly report things like to-hits.
            if ((eTarget.getECMRange() > 0) && (eTarget.getPosition() != null)) {
                int ecmRange = eTarget.getECMRange();
                Coords pos = eTarget.getPosition();
                for (Entity ent : game.getEntitiesVector()) {
                    if ((ent.getPosition() != null)
                            && (pos.distance(ent.getPosition()) <= ecmRange)) {
                        if (!vCanSee.contains(ent.getOwner())) {
                            vCanSee.add(ent.getOwner());
                        }
                    }
                }
            }

            // send an entity update to everyone who can see
            Packet pack = createEntityPacket(nEntityID, movePath);
            for (int x = 0; x < vCanSee.size(); x++) {
                Player p = vCanSee.elementAt(x);
                send(p.getId(), pack);
            }
            // send an entity delete to everyone else
            pack = createRemoveEntityPacket(nEntityID, eTarget.getRemovalCondition());
            for (int x = 0; x < playersVector.size(); x++) {
                if (!vCanSee.contains(playersVector.elementAt(x))) {
                    Player p = playersVector.elementAt(x);
                    send(p.getId(), pack);
                }
            }

            entityUpdateLoadedUnits(eTarget, vCanSee, playersVector);
        } else {
            // But if we're not, then everyone can see.
            send(createEntityPacket(nEntityID, movePath));
        }
    }

    /**
     * Whenever updating an Entity, we also need to update all of its loaded
     * Entity's, otherwise it could cause issues with Clients.
     *
     * @param loader        An Entity being updated that is transporting units that should
     *                      also send an update
     * @param vCanSee       The list of Players who can see the loader.
     * @param playersVector The list of all Players
     */
    private void entityUpdateLoadedUnits(Entity loader, Vector<Player> vCanSee,
                                         Vector<Player> playersVector) {
        // In double-blind, the client may not know about the loaded units,
        // so we need to send them.
        for (Entity eLoaded : loader.getLoadedUnits()) {
            // send an entity update to everyone who can see
            Packet pack = createEntityPacket(eLoaded.getId(), null);
            for (int x = 0; x < vCanSee.size(); x++) {
                Player p = vCanSee.elementAt(x);
                send(p.getId(), pack);
            }
            // send an entity delete to everyone else
            pack = createRemoveEntityPacket(eLoaded.getId(), eLoaded.getRemovalCondition());
            for (int x = 0; x < playersVector.size(); x++) {
                if (!vCanSee.contains(playersVector.elementAt(x))) {
                    Player p = playersVector.elementAt(x);
                    send(p.getId(), pack);
                }
            }
            entityUpdateLoadedUnits(eLoaded, vCanSee, playersVector);
        }
    }

    /**
     * Returns a vector of which players can see this entity, always allowing
     * for sensor detections.
     */
    private Vector<Player> whoCanSee(Entity entity) {
        return whoCanSee(entity, true, null);
    }

    /**
     * Returns a vector of which players can see the given entity, optionally
     * allowing for sensors to count.
     *
     * @param entity     The entity to check visibility for
     * @param useSensors A flag that determines whether sensors are allowed
     * @return A vector of the players who can see the entity
     */
    private Vector<Player> whoCanSee(Entity entity, boolean useSensors,
                                     Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        // Some times Null entities are sent to this
        if (entity == null) {
            return new Vector<>();
        }

        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS) && useSensors) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }

        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);
        List<Entity> vEntities = game.getEntitiesVector();

        Vector<Player> vCanSee = new Vector<>();
        vCanSee.addElement(entity.getOwner());
        if (bTeamVision) {
            addTeammates(vCanSee, entity.getOwner());
        }

        // Deal with players who can see all.
        for (Enumeration<Player> p = game.getPlayers(); p.hasMoreElements();) {
            Player player = p.nextElement();
            if (player.canIgnoreDoubleBlind() && !vCanSee.contains(player)) {
                vCanSee.addElement(player);
            }
        }

        // If the entity is hidden, skip; no one else will be able to see it.
        if (entity.isHidden()) {
            return vCanSee;
        }
        for (Entity spotter : vEntities) {
            // Certain conditions make the spotter ineligible
            if (!spotter.isActive() || spotter.isOffBoard()
                    || vCanSee.contains(spotter.getOwner())) {
                continue;
            }
            // See if the LosEffects is cached, and if not cache it
            EntityTargetPair etp = new EntityTargetPair(spotter, entity);
            LosEffects los = losCache.get(etp);
            if (los == null) {
                los = LosEffects.calculateLOS(game, spotter, entity);
                losCache.put(etp, los);
            }
            if (Compute.canSee(game, spotter, entity, useSensors, los,
                    allECMInfo)) {
                if (!vCanSee.contains(spotter.getOwner())) {
                    vCanSee.addElement(spotter.getOwner());
                }
                if (bTeamVision) {
                    addTeammates(vCanSee, spotter.getOwner());
                }
                addObservers(vCanSee);
            }
        }
        return vCanSee;
    }

    /**
     * Determine which players can detect the given entity with sensors.
     * Because recomputing ECM and LosEffects frequently can get expensive, this
     * data can be cached and passed in.
     *
     * @param entity        The Entity being detected.
     * @param allECMInfo    Cached ECMInfo for all Entities in the game.
     * @param losCache      Cached LosEffects for particular Entity/Targetable
     *                      pairs.  Can be passed in null.
     * @return
     */
    private Vector<Player> whoCanDetect(Entity entity,
                                        List<ECMInfo> allECMInfo,
                                        Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }

        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);
        List<Entity> vEntities = game.getEntitiesVector();

        Vector<Player> vCanDetect = new Vector<>();

        // If the entity is hidden, skip; no one else will be able to detect it
        if (entity.isHidden() || entity.isOffBoard()) {
            return vCanDetect;
        }

        for (Entity spotter : vEntities) {
            if (!spotter.isActive() || spotter.isOffBoard()
                    || vCanDetect.contains(spotter.getOwner())) {
                continue;
            }
            // See if the LosEffects is cached, and if not cache it
            EntityTargetPair etp = new EntityTargetPair(spotter, entity);
            LosEffects los = losCache.get(etp);
            if (los == null) {
                los = LosEffects.calculateLOS(game, spotter, entity);
                losCache.put(etp, los);
            }
            if (Compute.inSensorRange(game, los, spotter, entity, allECMInfo)) {
                if (!vCanDetect.contains(spotter.getOwner())) {
                    vCanDetect.addElement(spotter.getOwner());
                }
                if (bTeamVision) {
                    addTeammates(vCanDetect, spotter.getOwner());
                }
                addObservers(vCanDetect);
            }
        }

        return vCanDetect;
    }

    /**
     * Adds teammates of a player to the Vector. Utility function for whoCanSee.
     */
    private void addTeammates(Vector<Player> vector, Player player) {
        Vector<Player> playersVector = game.getPlayersVector();
        for (int j = 0; j < playersVector.size(); j++) {
            Player p = playersVector.elementAt(j);
            if (!player.isEnemyOf(p) && !vector.contains(p)) {
                vector.addElement(p);
            }
        }
    }

    /**
     * Adds observers to the Vector. Utility function for whoCanSee.
     */
    private void addObservers(Vector<Player> vector) {
        Vector<Player> playersVector = game.getPlayersVector();
        for (int j = 0; j < playersVector.size(); j++) {
            Player p = playersVector.elementAt(j);
            if (p.isObserver() && !vector.contains(p)) {
                vector.addElement(p);
            }
        }
    }

    /**
     * Send the complete list of entities to the players. If double_blind is in
     * effect, enforce it by filtering the entities
     */
    private void entityAllUpdate() {
        // If double-blind is in effect, filter each players' list individually,
        // and then quit out...
        if (doBlind()) {
            Vector<Player> playersVector = game.getPlayersVector();
            for (int x = 0; x < playersVector.size(); x++) {
                Player p = playersVector.elementAt(x);
                send(p.getId(), createFilteredEntitiesPacket(p, null));
            }
            return;
        }

        // Otherwise, send the full list.
        send(createEntitiesPacket());
    }

    /**
     * Filters an entity vector according to LOS
     */
    private List<Entity> filterEntities(Player pViewer,
                                        List<Entity> vEntities,
                                        Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        Vector<Entity> vCanSee = new Vector<>();
        Vector<Entity> vMyEntities = new Vector<>();
        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);

        // If they can see all, return the input list
        if (pViewer.canIgnoreDoubleBlind()) {
            return vEntities;
        }

        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game.getEntitiesVector());
        }

        // If they're an observer, they can see anything seen by any enemy.
        if (pViewer.isObserver()) {
            vMyEntities.addAll(vEntities);
            for (Entity a : vMyEntities) {
                for (Entity b : vMyEntities) {
                    if (a.isEnemyOf(b)
                            && Compute.canSee(game, b, a, true, null, allECMInfo)) {
                        addVisibleEntity(vCanSee, a);
                        break;
                    }
                }
            }
            return vCanSee;
        }

        // If they aren't an observer and can't see all, create the list of
        // "friendly" units.
        for (Entity e : vEntities) {
            if ((e.getOwner() == pViewer) || (bTeamVision && !e.getOwner().isEnemyOf(pViewer))) {
                vMyEntities.addElement(e);
            }
        }

        // Then, break down the list by whether they're friendly,
        // or whether or not any friendly unit can see them.
        for (Entity e : vEntities) {
            // If it's their own unit, obviously, they can see it.
            if (vMyEntities.contains(e)) {
                addVisibleEntity(vCanSee, e);
                continue;
            } else if (e.isHidden()) {
                // If it's NOT friendly and is hidden, they can't see it,
                // period.
                // LOS doesn't matter.
                continue;
            }
            for (Entity spotter : vMyEntities) {

                // If they're off-board, skip it; they can't see anything.
                if (spotter.isOffBoard()) {
                    continue;
                }

                // See if the LosEffects is cached, and if not cache it
                EntityTargetPair etp = new EntityTargetPair(spotter, e);
                LosEffects los = losCache.get(etp);
                if (los == null) {
                    los = LosEffects.calculateLOS(game, spotter, e);
                    losCache.put(etp, los);
                }
                // Otherwise, if they can see the entity in question
                if (Compute.canSee(game, spotter, e, true, los, allECMInfo)) {
                    addVisibleEntity(vCanSee, e);
                    break;
                }

                // If this unit has ECM, players with units affected by the ECM
                //  will need to know about this entity, even if they can't see
                //  it.  Otherwise, the client can't properly report things
                //  like to-hits.
                if ((e.getECMRange() > 0) && (e.getPosition() != null) &&
                        (spotter.getPosition() != null)) {
                    int ecmRange = e.getECMRange();
                    Coords pos = e.getPosition();
                    if (pos.distance(spotter.getPosition()) <= ecmRange) {
                        addVisibleEntity(vCanSee, e);
                    }
                }
            }
        }

        return vCanSee;
    }

    /**
     * Recursive method to add an <code>Entity</code> and all of its transported
     * units to the list of units visible to a particular player. It is
     * important to ensure that if a unit is in the list of visible units then
     * all of its transported units (and their transported units, and so on) are
     * also considered visible, otherwise it can lead to issues. This method
     * also ensures that no duplicate Entities are added.
     *
     * @param vCanSee A collection of units that can be see
     * @param e       An Entity that is seen and needs to be added to the collection
     *                of seen entities. All of
     */
    private void addVisibleEntity(Vector<Entity> vCanSee, Entity e) {
        if (!vCanSee.contains(e)) {
            vCanSee.add(e);
        }
        for (Entity transported : e.getLoadedUnits()) {
            addVisibleEntity(vCanSee, transported);
        }
    }

    /**
     * Filter a {@link Report} <code>Vector</code> for double blind.
     *
     * @param originalReportVector the original <code>Vector<Report></code>
     * @param p                    the <code>Player</code> who should see stuff only visible to
     *                             him
     * @return the <code>Vector<Report></code> with stuff only Player p can see
     */
    private Vector<Report> filterReportVector(Vector<Report> originalReportVector, Player p) {
        // If no double blind, no filtering to do
        if (!doBlind()) {
            return new Vector<>(originalReportVector);
        }
        // But if it is, then filter everything properly.
        Vector<Report> filteredReportVector = new Vector<>();
        for (Report r : originalReportVector) {
            Report filteredReport = filterReport(r, p, false);
            if (filteredReport != null) {
                filteredReportVector.addElement(filteredReport);
            }
        }
        return filteredReportVector;
    }

    /**
     * Filter a single report so that the correct double-blind obscuration takes
     * place. To mark a message as "this should be visible to anyone seeing this
     * entity" set r.subject to the entity id to mark a message as "only visible
     * to the player" set r.player to that player's id and set r.type to
     * Report.PLAYER to mark a message as visible to all, set r.type to
     * Report.PUBLIC
     *
     * @param r         the Report to filter
     * @param p         the Player that we are going to send the filtered report to
     * @param omitCheck boolean indicating that this report happened in the past, so we
     *                  no longer have access to the Player
     * @return a new Report, which has possibly been obscured
     */
    private Report filterReport(Report r, Player p, boolean omitCheck) {
        if ((r.subject == Entity.NONE) && (r.type != Report.PLAYER) && (r.type != Report.PUBLIC)) {
            // Reports that don't have a subject should be public.
            LogManager.getLogger().error("Attempting to filter a Report object that is not public yet "
                    + "but has no subject.\n\t\tmessageId: " + r.messageId);
            return r;
        }
        if ((r.type == Report.PUBLIC) || ((p == null) && !omitCheck)) {
            return r;
        }
        Entity entity = game.getEntity(r.subject);
        if (entity == null) {
            entity = game.getOutOfGameEntity(r.subject);
        }
        Player owner = null;
        if (entity != null) {
            owner = entity.getOwner();
            // off board (Artillery) units get treated as public messages
            if (entity.isOffBoard()) {
                return r;
            }
        }

        if ((r.type != Report.PLAYER) && !omitCheck
                && ((entity == null) || (owner == null))) {
            LogManager.getLogger().error("Attempting to filter a report object that is not public but has a subject ("
                    + entity + ") with owner (" + owner + ").\n\tmessageId: " + r.messageId);
            return r;
        }

        boolean shouldObscure = omitCheck
                || ((entity != null) && !entity.hasSeenEntity(p))
                || ((r.type == Report.PLAYER) && (p.getId() != r.player));
        // If suppressing double blind messages, don't send this report at all.
        if (game.getOptions()
                .booleanOption(OptionsConstants.ADVANCED_SUPRESS_ALL_DB_MESSAGES)
                && shouldObscure) {
            // Mark the original report to indicate it was filtered
            if (p != null) {
                r.addObscuredRecipient(p.getName());
            }
            return null;
        }
        Report copy = new Report(r);
        // Otherwise, obscure data in the report
        for (int j = 0; j < copy.dataCount(); j++) {
            if (shouldObscure) {
                // This report should be obscured
                if (r.isValueObscured(j)) {
                    copy.hideData(j);
                    // Mark the original report to indicate which players
                    // received an obscured version of it.
                    if (p != null) {
                        r.addObscuredRecipient(p.getName());
                    }
                }
            }
        }
        return copy;
    }

    /**
     *
     * @return a vector which has as its keys the round number and as its
     *         elements vectors that contain all the reports for the specified player
     *         that round. The reports returned this way are properly filtered for
     *         double blind.
     */
    private Vector<Vector<Report>> filterPastReports(
            Vector<Vector<Report>> pastReports, Player p) {
        // Only actually bother with the filtering if double-blind is in effect.
        if (!doBlind()) {
            return pastReports;
        }
        // Perform filtering
        Vector<Vector<Report>> filteredReports = new Vector<>();
        for (Vector<Report> roundReports : pastReports) {
            Vector<Report> filteredRoundReports = new Vector<>();
            for (Report r : roundReports) {
                if (r.isObscuredRecipient(p.getName())) {
                    r = filterReport(r, null, true);
                }
                if (r != null) {
                    filteredRoundReports.addElement(r);
                }
            }
            filteredReports.addElement(filteredRoundReports);
        }
        return filteredReports;
    }

    /**
     * Updates entities graphical "visibility indications" which are used in
     * double-blind games.
     *
     * @param losCache  It can be expensive to have to recompute LoSEffects
     *                  again and again, so in some cases where this may happen,
     *                  the LosEffects are cached.   This can safely be null.
     */
    private void updateVisibilityIndicator(Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }

        List<Entity> vAllEntities = game.getEntitiesVector();
        for (Entity e : vAllEntities) {
            Vector<Player> whoCouldSee = new Vector<>(e.getWhoCanSee());
            Vector<Player> whoCouldDetect = new Vector<>(e.getWhoCanDetect());
            e.setVisibleToEnemy(false);
            e.setDetectedByEnemy(false);
            e.clearSeenBy();
            e.clearDetectedBy();
            Vector<Player> vCanSee = whoCanSee(e, false, losCache);
            // Who can See this unit?
            for (Player p : vCanSee) {
                if (e.getOwner().isEnemyOf(p) && !p.isObserver()) {
                    e.setVisibleToEnemy(true);
                    e.setEverSeenByEnemy(true);
                    // If we can see it, it's detected
                    e.setDetectedByEnemy(true);
                }
                e.addBeenSeenBy(p);
            }
            // Who can Detect this unit?
            Vector<Player> vCanDetect = whoCanDetect(e, allECMInfo, losCache);
            for (Player p : vCanDetect) {
                if (e.getOwner().isEnemyOf(p) && !p.isObserver()) {
                    e.setDetectedByEnemy(true);
                }
                e.addBeenDetectedBy(p);
            }

            // If a client can now see/detect this entity, but couldn't before,
            // then the client needs to be updated with the Entity
            boolean hasClientWithoutEntity = false;
            for (Player p : vCanSee) {
                if (!whoCouldSee.contains(p) && !whoCouldDetect.contains(p)) {
                    hasClientWithoutEntity = true;
                    break;
                }
            }

            if (!hasClientWithoutEntity) {
                for (Player p : vCanDetect) {
                    if (!whoCouldSee.contains(p) && !whoCouldDetect.contains(p)) {
                        hasClientWithoutEntity = true;
                        break;
                    }
                }
            }

            if (hasClientWithoutEntity) {
                entityUpdate(e.getId(), new Vector<>(), false, losCache);
            } else {
                sendVisibilityIndicator(e);
            }
        }
    }

    /**
     * Checks if an entity added by the client is valid and if so, adds it to
     * the list
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityAdd(Packet c, int connIndex) {
        @SuppressWarnings("unchecked")
        final List<Entity> entities = (List<Entity>) c.getObject(0);
        List<Integer> entityIds = new ArrayList<>(entities.size());
        // Map client-received to server-given IDs:
        Map<Integer, Integer> idMap = new HashMap<>();
        // Map MUL force ids to real Server-given force ids;
        Map<Integer, Integer> forceMapping = new HashMap<>();

        // Need to use a new ArrayLiut to prevent a concurrent modification exception when removing
        // illegal entities
        for (final Entity entity : new ArrayList<>(entities)) {
            // Verify the entity's design
            if (entityVerifier == null) {
                entityVerifier = EntityVerifier.getInstance(new MegaMekFile(
                        Configuration.unitsDir(), EntityVerifier.CONFIG_FILENAME).getFile());
            }

            // Create a TestEntity instance for supported unit types
            TestEntity testEntity = null;
            entity.restore();
            if (entity instanceof Mech) {
                testEntity = new TestMech((Mech) entity, entityVerifier.mechOption, null);
            } else if ((entity.getEntityType() == Entity.ETYPE_TANK)
                    && (entity.getEntityType() != Entity.ETYPE_GUN_EMPLACEMENT)) {
                if (entity.isSupportVehicle()) {
                    testEntity = new TestSupportVehicle(entity, entityVerifier.tankOption, null);
                } else {
                    testEntity = new TestTank((Tank) entity, entityVerifier.tankOption, null);
                }
            } else if ((entity.getEntityType() == Entity.ETYPE_AERO)
                    && (entity.getEntityType() != Entity.ETYPE_DROPSHIP)
                    && (entity.getEntityType() != Entity.ETYPE_SMALL_CRAFT)
                    && (entity.getEntityType() != Entity.ETYPE_FIGHTER_SQUADRON)
                    && (entity.getEntityType() != Entity.ETYPE_JUMPSHIP)
                    && (entity.getEntityType() != Entity.ETYPE_SPACE_STATION)) {
                testEntity = new TestAero((Aero) entity, entityVerifier.aeroOption, null);
            } else if (entity instanceof BattleArmor) {
                testEntity = new TestBattleArmor((BattleArmor) entity, entityVerifier.baOption, null);
            }

            if (testEntity != null) {
                StringBuffer sb = new StringBuffer();
                if (testEntity.correctEntity(sb, TechConstants.getGameTechLevel(game, entity.isClan()))) {
                    entity.setDesignValid(true);
                } else {
                    LogManager.getLogger().error(sb.toString());
                    if (game.getOptions().booleanOption(OptionsConstants.ALLOWED_ALLOW_ILLEGAL_UNITS)) {
                        entity.setDesignValid(false);
                    } else {
                        Player cheater = game.getPlayer(connIndex);
                        sendServerChat(String.format(
                                "Player %s attempted to add an illegal unit design (%s), the unit was rejected.",
                                cheater.getName(), entity.getShortNameRaw()));
                        entities.remove(entity);
                        continue;
                    }
                }
            }

            // If we're adding a ProtoMech, calculate it's unit number.
            if (entity instanceof Protomech) {
                // How many ProtoMechs does the player already have?
                int numPlayerProtos = game.getSelectedEntityCount(new EntitySelector() {
                    private final int ownerId = entity.getOwnerId();

                    @Override
                    public boolean accept(Entity entity) {
                        return (entity instanceof Protomech) && (ownerId == entity.getOwnerId());
                    }
                });

                // According to page 54 of the BMRr, ProtoMechs must be
                // deployed in full Points of five, unless circumstances have
                // reduced the number to less than that.
                entity.setUnitNumber((short) (numPlayerProtos / 5));
            }

            // Only assign an entity ID when the client hasn't.
            if (Entity.NONE == entity.getId()) {
                entity.setId(game.getNextEntityId());
            }

            int clientSideId = entity.getId();
            game.addEntity(entity);

            // Remember which received ID corresponds to which actual ID
            idMap.put(clientSideId, entity.getId());

            // Now we relink C3/NC3/C3i to our guys! Yes, this is hackish... but, we
            // do what we must. Its just too bad we have to loop over the entire entities array..
            if (entity.hasC3() || entity.hasC3i() || entity.hasNavalC3()) {
                boolean C3iSet = false;

                for (Entity e : game.getEntitiesVector()) {

                    // C3 Checks
                    if (entity.hasC3()) {
                        if ((entity.getC3MasterIsUUIDAsString() != null)
                                && entity.getC3MasterIsUUIDAsString().equals(e.getC3UUIDAsString())) {
                            entity.setC3Master(e, false);
                            entity.setC3MasterIsUUIDAsString(null);
                        } else if ((e.getC3MasterIsUUIDAsString() != null)
                                && e.getC3MasterIsUUIDAsString().equals(entity.getC3UUIDAsString())) {
                            e.setC3Master(entity, false);
                            e.setC3MasterIsUUIDAsString(null);
                            // Taharqa: we need to update the other entity for
                            // the
                            // client
                            // or it won't show up right. I am not sure if I
                            // like
                            // the idea of updating other entities in this
                            // method,
                            // but it
                            // will work for now.
                            if (!entities.contains(e)) {
                                entityUpdate(e.getId());
                            }
                        }
                    }

                    // C3i Checks
                    if (entity.hasC3i() && !C3iSet) {
                        entity.setC3NetIdSelf();
                        int pos = 0;
                        while (pos < Entity.MAX_C3i_NODES) {
                            // We've found a network, join it.
                            if ((entity.getC3iNextUUIDAsString(pos) != null)
                                    && (e.getC3UUIDAsString() != null)
                                    && entity.getC3iNextUUIDAsString(pos)
                                    .equals(e.getC3UUIDAsString())) {
                                entity.setC3NetId(e);
                                C3iSet = true;
                                break;
                            }

                            pos++;
                        }
                    }

                    // NC3 Checks
                    if (entity.hasNavalC3() && !C3iSet) {
                        entity.setC3NetIdSelf();
                        int pos = 0;
                        while (pos < Entity.MAX_C3i_NODES) {
                            // We've found a network, join it.
                            if ((entity.getNC3NextUUIDAsString(pos) != null)
                                    && (e.getC3UUIDAsString() != null)
                                    && entity.getNC3NextUUIDAsString(pos)
                                    .equals(e.getC3UUIDAsString())) {
                                entity.setC3NetId(e);
                                C3iSet = true;
                                break;
                            }

                            pos++;
                        }
                    }
                }
            }
            // Give the unit a spotlight, if it has the spotlight quirk
            entity.setExternalSearchlight(entity.hasExternalSearchlight()
                    || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));
            entityIds.add(entity.getId());

            if (!getGame().getPhase().isLounge()) {
                entity.getOwner().changeInitialEntityCount(1);
                entity.getOwner().changeInitialBV(entity.calculateBattleValue());
            }

            // Restore forces from MULs or other external sources from the forceString, if any
            if (!entity.getForceString().isBlank()) {
                List<Force> forceList = Forces.parseForceString(entity);
                int realId = Force.NO_FORCE;
                boolean topLevel = true;

                for (Force force: forceList) {
                    if (!forceMapping.containsKey(force.getId())) {
                        if (topLevel) {
                            realId = game.getForces().addTopLevelForce(force, entity.getOwner());
                        } else {
                            Force parent = game.getForces().getForce(realId);
                            realId = game.getForces().addSubForce(force, parent);
                        }
                        forceMapping.put(force.getId(), realId);
                    } else {
                        realId = forceMapping.get(force.getId());
                    }
                    topLevel = false;
                }
                entity.setForceString("");
                game.getForces().addEntity(entity, realId);
            }
        }

        // Cycle through the entities again and update any carried units
        // and carrier units to use the correct server-given IDs.
        // Typically necessary when loading a MUL containing transported units.

        // First, deal with units loaded into bays. These are saved for the carrier
        // in MULs and must be restored exactly to recreate the bay loading.
        Set<Entity> transportCorrected = new HashSet<>();
        for (final Entity carrier : entities) {
            for (int carriedId : carrier.getBayLoadedUnitIds()) {
                // First, see if a bay loaded unit can be found and unloaded,
                // because it might be the wrong unit
                Entity carried = game.getEntity(carriedId);
                if (carried == null) {
                    continue;
                }
                int bay = carrier.getBay(carried).getBayNumber();
                carrier.unload(carried);
                // Now, load the correct unit if there is one
                if (idMap.containsKey(carriedId)) {
                    Entity newCarried = game.getEntity(idMap.get(carriedId));
                    if (carrier.canLoad(newCarried, false)) {
                        carrier.load(newCarried, false, bay);
                        newCarried.setTransportId(carrier.getId());
                        // Remember that the carried unit should not be treated again below
                        transportCorrected.add(newCarried);
                    }
                }
            }
        }

        // Now restore the transport settings from the entities' transporter IDs
        // With anything other than bays, MULs only show the carrier, not the carried units
        for (final Entity entity : entities) {
            // Don't correct those that are already corrected
            if (transportCorrected.contains(entity)) {
                continue;
            }
            // Get the original (client side) ID of the transporter
            int origTrsp = entity.getTransportId();
            // Only act if the unit thinks it is transported
            if (origTrsp != Entity.NONE) {
                // If the transporter is among the new units, go on with loading
                if (idMap.containsKey(origTrsp)) {
                    // The wrong transporter doesn't know of anything and does not need an update
                    Entity carrier = game.getEntity(idMap.get(origTrsp));
                    if (carrier.canLoad(entity, false)) {
                        // The correct transporter must be told it's carrying something and
                        // the carried unit must be told where it is embarked
                        carrier.load(entity, false);
                        entity.setTransportId(idMap.get(origTrsp));
                    } else {
                        // This seems to be an invalid carrier; update the entity accordingly
                        entity.setTransportId(Entity.NONE);
                    }
                } else {
                    // this transporter does not exist; update the entity accordingly
                    entity.setTransportId(Entity.NONE);
                }
            }
        }

        // Set the "loaded keepers" which is apparently used for deployment unloading to
        // differentiate between units loaded in the lobby and other carried units
        // When entering a game from the lobby, this list is generated again, but not when
        // the added entities are loaded during a game. When getting loaded units from a MUL,
        // act as if they were loaded in the lobby.
        for (final Entity entity : entities) {
            if (!entity.getLoadedUnits().isEmpty()) {
                Vector<Integer> v = new Vector<>();
                for (Entity en : entity.getLoadedUnits()) {
                    v.add(en.getId());
                }
                entity.setLoadedKeepers(v);
            }
        }

        List<Integer> changedForces = new ArrayList<>(forceMapping.values());

        send(createAddEntityPacket(entityIds, changedForces));
    }

    /**
     * adds a squadron to the game
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    @SuppressWarnings("unchecked")
    private void receiveSquadronAdd(Packet c, int connIndex) {
        final FighterSquadron fs = (FighterSquadron) c.getObject(0);
        final Collection<Integer> fighters = (Collection<Integer>) c.getObject(1);
        if (fighters.isEmpty()) {
            return;
        }
        // Only assign an entity ID when the client hasn't.
        if (Entity.NONE == fs.getId()) {
            fs.setId(game.getNextEntityId());
        }
        game.addEntity(fs);
        var formerCarriers = new HashSet<Entity>();

        for (int id : fighters) {
            Entity fighter = game.getEntity(id);
            if (null != fighter) {
                formerCarriers.addAll(ServerLobbyHelper.lobbyUnload(game, List.of(fighter)));
                fs.load(fighter, false);
                fs.autoSetMaxBombPoints();
                fighter.setTransportId(fs.getId());
                // If this is the lounge, we want to configure bombs
                if (getGame().getPhase().isLounge()) {
                    ((IBomber) fighter).setBombChoices(fs.getBombChoices());
                }
                entityUpdate(fighter.getId());
            }
        }
        if (!formerCarriers.isEmpty()) {
            send(new Packet(PacketCommand.ENTITY_MULTIUPDATE, formerCarriers));
        }
        send(createAddEntityPacket(fs.getId()));
    }

    /**
     * Updates an entity with the info from the client. Only valid to do this
     * during the lounge phase, except for heat sink changing.
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityUpdate(Packet c, int connIndex) {
        Entity entity = (Entity) c.getObject(0);
        Entity oldEntity = game.getEntity(entity.getId());
        if ((oldEntity != null) && (!oldEntity.getOwner().isEnemyOf(game.getPlayer(connIndex)))) {
            game.setEntity(entity.getId(), entity);
            entityUpdate(entity.getId());
            // In the chat lounge, notify players of customizing of unit
            if (game.getPhase().isLounge()) {
                sendServerChat(ServerLobbyHelper.entityUpdateMessage(entity, game));
            }
        }
    }

    /**
     * Updates multiple entities with the info from the client. Only valid
     * during the lobby phase!
     * Will only update units that are teammates of the sender. Other entities
     * remain unchanged but still be sent back to overwrite incorrect client changes.
     */
    private void receiveEntitiesUpdate(Packet c, int connIndex) {
        if (!getGame().getPhase().isLounge()) {
            LogManager.getLogger().error("Multi entity updates should not be used outside the lobby phase!");
        }
        Set<Entity> newEntities = new HashSet<>();
        @SuppressWarnings("unchecked")
        Collection<Entity> entities = (Collection<Entity>) c.getObject(0);
        for (Entity entity: entities) {
            Entity oldEntity = game.getEntity(entity.getId());
            // Only update entities that existed and are owned by a teammate of the sender
            if ((oldEntity != null) && (!oldEntity.getOwner().isEnemyOf(game.getPlayer(connIndex)))) {
                game.setEntity(entity.getId(), entity);
                sendServerChat(ServerLobbyHelper.entityUpdateMessage(entity, game));
                newEntities.add(game.getEntity(entity.getId()));
            }
        }
        send(new Packet(PacketCommand.ENTITY_MULTIUPDATE, newEntities));
    }

    /**
     * Handles a packet detailing removal of a list of forces. Only valid during the lobby phase.
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveForcesDelete(Packet c, int connIndex) {
        @SuppressWarnings("unchecked")
        List<Integer> forceList = (List<Integer>) c.getObject(0);

        // Gather the forces and entities to be deleted
        Forces forces = game.getForces();
        Set<Force> delForces = new HashSet<>();
        forceList.stream().map(forces::getForce).forEach(delForces::add);
        Set<Force> allSubForces = new HashSet<>();
        delForces.stream().map(forces::getFullSubForces).forEach(allSubForces::addAll);
        delForces.removeIf(allSubForces::contains);
        Set<Entity> delEntities = new HashSet<>();
        delForces.stream().map(forces::getFullEntities).map(ForceAssignable::filterToEntityList).forEach(delEntities::addAll);

        // Unload units and disconnect any C3 networks
        Set<Entity> updateCandidates = new HashSet<>();
        updateCandidates.addAll(ServerLobbyHelper.lobbyUnload(game, delEntities));
        updateCandidates.addAll(ServerLobbyHelper.performC3Disconnect(game, delEntities));

        // Units that get deleted must not receive updates
        updateCandidates.removeIf(delEntities::contains);
        if (!updateCandidates.isEmpty()) {
            send(ServerLobbyHelper.createMultiEntityPacket(updateCandidates));
        }

        // Delete entities and forces
        for (Entity entity : delEntities) {
            game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_NEVER_JOINED);
        }
        forces.deleteForces(delForces);
        send(ServerLobbyHelper.createForcesDeletePacket(forceList));
    }

    /**
     * loads an entity into another one. Meant to be called from the chat lounge
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityLoad(Packet c, int connIndex) {
        int loadeeId = (Integer) c.getObject(0);
        int loaderId = (Integer) c.getObject(1);
        int bayNumber = (Integer) c.getObject(2);
        Entity loadee = getGame().getEntity(loadeeId);
        Entity loader = getGame().getEntity(loaderId);

        if ((loadee != null) && (loader != null)) {
            loadUnit(loader, loadee, bayNumber);
            // In the chat lounge, notify players of customizing of unit
            if (getGame().getPhase().isLounge()) {
                ServerLobbyHelper.entityUpdateMessage(loadee, getGame());
                // Set this so units can be unloaded in the first movement phase
                loadee.setLoadedThisTurn(false);
            }
        }
    }

    /**
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveCustomInit(Packet c, int connIndex) {
        // In the chat lounge, notify players of customizing of unit
        if (game.getPhase().isLounge()) {
            Player p = (Player) c.getObject(0);
            sendServerChat("" + p.getName() + " has customized initiative.");
        }
    }

    /**
     * receive and process an entity mode change packet
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityModeChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int mode = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != game.getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }

        try {
            // Check for BA dumping body mounted missile launchers
            if ((e instanceof BattleArmor) && (!m.isMissing())
                    && m.isBodyMounted()
                    && m.getType().hasFlag(WeaponType.F_MISSILE)
                    && (m.getLinked() != null)
                    && (m.getLinked().getUsableShotsLeft() > 0)
                    && (mode <= 0)) {
                m.setPendingDump(mode == -1);
                // a mode change for ammo means dumping or hot loading
            } else if ((m.getType() instanceof AmmoType)
                    && !m.getType().hasInstantModeSwitch() && (mode < 0
                    || mode == 0 && m.isPendingDump())) {
                m.setPendingDump(mode == -1);
            } else if ((m.getType() instanceof WeaponType) && m.isDWPMounted()
                    && (mode <= 0)) {
                m.setPendingDump(mode == -1);
            } else {
                if (!m.setMode(mode)) {
                    String message = e.getShortName() + ": " + m.getName() + ": " + e.getLocationName(m.getLocation())
                            + " trying to compensate";
                    LogManager.getLogger().error(message);
                    sendServerChat(message);
                    e.setGameOptions();

                    if (!m.setMode(mode)) {
                        message = e.getShortName() + ": " + m.getName() + ": " + e.getLocationName(m.getLocation())
                                + " unable to compensate";
                        LogManager.getLogger().error(message);
                        sendServerChat(message);
                    }

                }
            }
        } catch (Exception ex) {
            LogManager.getLogger().error("", ex);
        }
    }

    /**
     * Receive and process an Entity Sensor Change Packet
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntitySensorChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int sensorId = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        e.setNextSensor(e.getSensors().elementAt(sensorId));
    }

    /**
     * Receive and process an Entity Heat Sinks Change Packet
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntitySinksChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int numSinks = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        if ((e instanceof Mech) && (connIndex == e.getOwnerId())) {
            ((Mech) e).setActiveSinksNextRound(numSinks);
        }
    }

    /**
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityActivateHidden(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        GamePhase phase = (GamePhase) c.getObject(1);
        Entity e = game.getEntity(entityId);
        if (connIndex != e.getOwnerId()) {
            LogManager.getLogger().error("Player " + connIndex
                    + " tried to activate a hidden unit owned by Player " + e.getOwnerId());
            return;
        }
        e.setHiddenActivationPhase(phase);
        entityUpdate(entityId);
    }

    /**
     * receive and process an entity nova network mode change packet
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityNovaNetworkModeChange(Packet c, int connIndex) {
        try {
            int entityId = c.getIntValue(0);
            String networkID = c.getObject(1).toString();
            Entity e = game.getEntity(entityId);
            if (e.getOwner() != game.getPlayer(connIndex)) {
                return;
            }
            // FIXME: Greg: This can result in setting the network to link to
            // hostile units.
            // However, it should be caught by both the isMemberOfNetwork test
            // from the c3 module as well as
            // by the clients possible input.
            e.setNewRoundNovaNetworkString(networkID);
        } catch (Exception ex) {
            LogManager.getLogger().error("", ex);
        }
    }

    /**
     * receive and process an entity mounted facing change packet
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityMountedFacingChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int facing = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != game.getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }
        m.setFacing(facing);
    }

    /**
     * receive and process an entity mode change packet
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityCalledShotChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != game.getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }
        m.getCalledShot().switchCalledShot();
    }

    /**
     * receive and process an entity system mode change packet
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntitySystemModeChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int mode = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != game.getPlayer(connIndex)) {
            return;
        }
        if ((e instanceof Mech) && (equipId == Mech.SYSTEM_COCKPIT)) {
            ((Mech) e).setCockpitStatus(mode);
        }
    }

    /**
     * Receive a packet that contains an Entity ammo change
     *
     * @param c the packet to be processed
     * @param connIndex the id for connection that received the packet.
     */
    private void receiveEntityAmmoChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int weaponId = c.getIntValue(1);
        int ammoId = c.getIntValue(2);
        Entity e = game.getEntity(entityId);

        // Did we receive a request for a valid Entity?
        if (null == e) {
            LogManager.getLogger().error("Could not find entity# " + entityId);
            return;
        }
        Player player = game.getPlayer(connIndex);
        if ((null != player) && (e.getOwner() != player)) {
            LogManager.getLogger().error("Player " + player.getName() + " does not own the entity " + e.getDisplayName());
            return;
        }

        // Make sure that the entity has the given equipment.
        Mounted mWeap = e.getEquipment(weaponId);
        Mounted mAmmo = e.getEquipment(ammoId);
        if (null == mAmmo) {
            LogManager.getLogger().error("Entity " + e.getDisplayName() + " does not have ammo #" + ammoId);
            return;
        }
        if (!(mAmmo.getType() instanceof AmmoType)) {
            LogManager.getLogger().error("Item #" + ammoId + " of entity " + e.getDisplayName()
                    + " is a " + mAmmo.getName() + " and not ammo.");
            return;
        }
        if (null == mWeap) {
            LogManager.getLogger().error("Entity " + e.getDisplayName() + " does not have weapon #" + weaponId);
            return;
        }
        if (!(mWeap.getType() instanceof WeaponType)) {
            LogManager.getLogger().error("Item #" + weaponId + " of entity " + e.getDisplayName()
                    + " is a " + mWeap.getName() + " and not a weapon.");
            return;
        }
        if (((WeaponType) mWeap.getType()).getAmmoType() == AmmoType.T_NA) {
            LogManager.getLogger().error("Item #" + weaponId + " of entity " + e.getDisplayName()
                    + " is a " + mWeap.getName() + " and does not use ammo.");
            return;
        }
        if (mWeap.getType().hasFlag(WeaponType.F_ONESHOT)
                && !mWeap.getType().hasFlag(WeaponType.F_DOUBLE_ONESHOT)) {
            LogManager.getLogger().error("Item #" + weaponId + " of entity " + e.getDisplayName()
                    + " is a " + mWeap.getName() + " and cannot use external ammo.");
            return;
        }

        // Load the weapon.
        e.loadWeapon(mWeap, mAmmo);
    }

    /**
     * Deletes an entity owned by a certain player from the list
     */
    private void receiveEntityDelete(Packet c, int connIndex) {
        @SuppressWarnings("unchecked")
        List<Integer> ids = (List<Integer>) c.getObject(0);

        Set<Entity> delEntities = new HashSet<>();
        ids.stream().map(id -> game.getEntity(id)).forEach(delEntities::add);

        // Unload units and disconnect any C3 networks
        Set<Entity> updateCandidates = new HashSet<>();
        updateCandidates.addAll(ServerLobbyHelper.lobbyUnload(game, delEntities));
        updateCandidates.addAll(ServerLobbyHelper.performC3Disconnect(game, delEntities));

        // Units that get deleted must not receive updates
        updateCandidates.removeIf(delEntities::contains);
        if (!updateCandidates.isEmpty()) {
            send(ServerLobbyHelper.createMultiEntityPacket(updateCandidates));
        }

        ArrayList<Force> affectedForces = new ArrayList<>();
        for (Integer entityId : ids) {
            final Entity entity = game.getEntity(entityId);

            // Players can delete units of their teammates
            if ((entity != null) && (!entity.getOwner().isEnemyOf(game.getPlayer(connIndex)))) {

                affectedForces.addAll(game.getForces().removeEntityFromForces(entity));

                // If we're deleting a ProtoMech, recalculate unit numbers.
                if (entity instanceof Protomech) {

                    // How many ProtoMechs does the player have (include this one)?
                    int numPlayerProtos = game.getSelectedEntityCount(new EntitySelector() {
                        private final int ownerId = entity.getOwnerId();

                        @Override
                        public boolean accept(Entity entity) {
                            return (entity instanceof Protomech) && (ownerId == entity.getOwnerId());
                        }
                    });

                    // According to page 54 of the BMRr, ProtoMechs must be
                    // deployed in full Points of five, unless "losses" have
                    // reduced the number to less than that.
                    final char oldMax = (char) (Math.ceil(numPlayerProtos / 5.0) - 1);
                    char newMax = (char) (Math.ceil((numPlayerProtos - 1) / 5.0) - 1);
                    short deletedUnitNum = entity.getUnitNumber();

                    // Do we have to update a ProtoMech from the last unit?
                    if ((oldMax != deletedUnitNum) && (oldMax != newMax)) {

                        // Yup. Find a ProtoMech from the last unit, and
                        // set it's unit number to the deleted entity.
                        Iterator<Entity> lastUnit =
                                game.getSelectedEntities(new EntitySelector() {
                                    private final int ownerId = entity.getOwnerId();

                                    private final char lastUnitNum = oldMax;

                                    @Override
                                    public boolean accept(Entity entity) {
                                        return (entity instanceof Protomech)
                                                && (ownerId == entity.getOwnerId())
                                                && (lastUnitNum == entity.getUnitNumber());
                                    }
                                });
                        Entity lastUnitMember = lastUnit.next();
                        lastUnitMember.setUnitNumber(deletedUnitNum);
                        entityUpdate(lastUnitMember.getId());
                    } // End update-unit-number
                } // End added-ProtoMech

                if (!getGame().getPhase().isDeployment()) {
                    // if a unit is removed during deployment just keep going
                    // without adjusting the turn vector.
                    game.removeTurnFor(entity);
                    game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);
                }

                if (!game.getPhase().isLounge()) {
                    ServerHelper.clearBloodStalkers(game, entityId, this);
                }
            }
        }

        // during deployment this absolutely must be called before game.removeEntity(), otherwise the game hangs
        // when a unit is removed. Cause unknown.
        send(createRemoveEntityPacket(ids, affectedForces, IEntityRemovalConditions.REMOVE_NEVER_JOINED));

        // Prevents deployment hanging. Only do this during deployment.
        if (game.getPhase().isDeployment()) {
            for (Integer entityId : ids) {
                final Entity entity = game.getEntity(entityId);
                game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);
                endCurrentTurn(entity);
            }
        }
    }

    /**
     * Sets a player's ready status
     */
    private void receivePlayerDone(Packet pkt, int connIndex) {
        boolean ready = pkt.getBooleanValue(0);
        Player player = game.getPlayer(connIndex);
        if (null != player) {
            player.setDone(ready);
        }
    }

    private void receiveInitiativeRerollRequest(Packet pkt, int connIndex) {
        Player player = game.getPlayer(connIndex);
        if (!game.getPhase().isInitiativeReport()) {
            StringBuilder message = new StringBuilder();
            if (null == player) {
                message.append("Player #").append(connIndex);
            } else {
                message.append(player.getName());
            }
            message.append(" is not allowed to ask for a reroll at this time.");
            LogManager.getLogger().error(message.toString());
            sendServerChat(message.toString());
            return;
        }
        if (game.hasTacticalGenius(player)) {
            game.addInitiativeRerollRequest(game.getTeamForPlayer(player));
        }
        if (null != player) {
            player.setDone(true);
        }
        checkReady();
    }

    /**
     * Sets game options, providing that the player has specified the password
     * correctly.
     *
     * @return true if any options have been successfully changed.
     */
    private boolean receiveGameOptions(Packet packet, int connId) {
        Player player = game.getPlayer(connId);
        // Check player
        if (null == player) {
            LogManager.getLogger().error("Server does not recognize player at connection " + connId);
            return false;
        }

        // check password
        if (!Server.getServerInstance().passwordMatches(packet.getObject(0))) {
            sendServerChat(connId, "The password you specified to change game options is incorrect.");
            return false;
        }

        if (game.getPhase().isDuringOrAfter(GamePhase.DEPLOYMENT)) {
            return false;
        }

        int changed = 0;

        for (Enumeration<?> i = ((Vector<?>) packet.getObject(1)).elements(); i.hasMoreElements(); ) {
            IBasicOption option = (IBasicOption) i.nextElement();
            IOption originalOption = game.getOptions().getOption(option.getName());

            if (originalOption == null) {
                continue;
            }

            String message = "Player " + player.getName() + " changed option \"" +
                    originalOption.getDisplayableName() + "\" to " + option.getValue().toString() + '.';
            sendServerChat(message);
            originalOption.setValue(option.getValue());
            changed++;
        }

        // Set proper RNG
        Compute.setRNG(game.getOptions().intOption(OptionsConstants.BASE_RNG_TYPE));

        if (changed > 0) {
            for (Entity en : game.getEntitiesVector()) {
                en.setGameOptions();
            }
            entityAllUpdate();
            return true;
        }
        return false;
    }

    /**
     * Performs the additional processing of the received options after the
     * <code>receiveGameOptions<code> done its job; should be called after
     * <code>receiveGameOptions<code> only if the <code>receiveGameOptions<code>
     * returned <code>true</code>
     *
     * @param packet the packet to be processed
     * @param connId the id for connection that received the packet.
     */
    private void receiveGameOptionsAux(Packet packet, int connId) {
        MapSettings mapSettings = game.getMapSettings();
        for (Enumeration<?> i = ((Vector<?>) packet.getObject(1)).elements(); i.hasMoreElements(); ) {
            IBasicOption option = (IBasicOption) i.nextElement();
            IOption originalOption = game.getOptions().getOption(option.getName());
            if (originalOption != null) {
                if ("maps_include_subdir".equals(originalOption.getName())) {
                    mapSettings.setBoardsAvailableVector(ServerBoardHelper.scanForBoards(mapSettings));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    send(createMapSettingsPacket());
                }
            }
        }

    }

    /**
     * Sends out the game victory event to all connections
     */
    private void transmitGameVictoryEventToAll() {
        send(new Packet(PacketCommand.GAME_VICTORY_EVENT));
    }

    /**
     * Creates a packet containing the player ready status
     */
    private Packet createPlayerDonePacket(int playerId) {
        return new Packet(PacketCommand.PLAYER_READY, playerId, game.getPlayer(playerId).isDone());
    }

    /**
     * Creates a packet containing the current turn vector
     */
    private Packet createTurnVectorPacket() {
        return new Packet(PacketCommand.SENDING_TURNS, getGame().getTurnVector());
    }

    /**
     * Creates a packet containing the current turn index
     */
    private Packet createTurnIndexPacket(int playerId) {
        return new Packet(PacketCommand.TURN, getGame().getTurnIndex(), playerId);
    }

    /**
     * Creates a packet containing the map settings
     */
    private Packet createMapSettingsPacket() {
        MapSettings mapSettings = game.getMapSettings();
        return new Packet(PacketCommand.SENDING_MAP_SETTINGS, mapSettings);
    }

    private Packet createMapSizesPacket() {
        return new Packet(PacketCommand.SENDING_AVAILABLE_MAP_SIZES, getBoardSizes());
    }

    /**
     * Creates a packet containing the planetary conditions
     */
    private Packet createPlanetaryConditionsPacket() {
        return new Packet(PacketCommand.SENDING_PLANETARY_CONDITIONS, getGame().getPlanetaryConditions());
    }

    /**
     * Creates a packet containing the game settings
     */
    private Packet createGameSettingsPacket() {
        return new Packet(PacketCommand.SENDING_GAME_SETTINGS, getGame().getOptions());
    }

    /**
     * Creates a packet containing the game board
     */
    private Packet createBoardPacket() {
        return new Packet(PacketCommand.SENDING_BOARD, getGame().getBoard());
    }

    /**
     * Creates a packet containing a single entity, for update
     */
    private Packet createEntityPacket(int entityId, Vector<UnitLocation> movePath) {
        return new Packet(PacketCommand.ENTITY_UPDATE, entityId, getGame().getEntity(entityId), movePath);
    }

    /**
     * Creates a packet containing a Vector of Reports
     */
    private Packet createReportPacket(Player p) {
        // When the final report is created, MM sends a null player to create the report. This will
        // handle that issue.
        return new Packet(PacketCommand.SENDING_REPORTS,
                (p == null) || !doBlind() ? vPhaseReport : filterReportVector(vPhaseReport, p));
    }

    /**
     * Creates a packet containing a Vector of special Reports which needs to be
     * sent during a phase that is not a report phase.
     */
    public Packet createSpecialReportPacket() {
        return new Packet(PacketCommand.SENDING_REPORTS_SPECIAL, vPhaseReport.clone());
    }

    /**
     * Creates a packet containing a Vector of Reports that represent a Tactical
     * Genius re-roll request which needs to update a current phase's report.
     */
    private Packet createTacticalGeniusReportPacket(Player p) {
        return new Packet(PacketCommand.SENDING_REPORTS_TACTICAL_GENIUS,
                (p == null) || !doBlind() ? vPhaseReport.clone() : filterReportVector(vPhaseReport, p));
    }

    /**
     * Creates a packet containing all the round reports
     */
    private Packet createAllReportsPacket(Player p) {
        return new Packet(PacketCommand.SENDING_REPORTS_ALL, filterPastReports(getGame().getAllReports(), p));
    }

    /**
     * Creates a packet containing all current entities
     */
    private Packet createEntitiesPacket() {
        return new Packet(PacketCommand.SENDING_ENTITIES, getGame().getEntitiesVector());
    }

    /**
     * Creates a packet containing all current and out-of-game entities
     */
    Packet createFullEntitiesPacket() {
        return new Packet(PacketCommand.SENDING_ENTITIES, getGame().getEntitiesVector(),
                getGame().getOutOfGameEntitiesVector(), getGame().getForces());
    }

    /**
     * Creates a packet containing all entities visible to the player in a blind game
     */
    private Packet createFilteredEntitiesPacket(Player p,
                                                Map<EntityTargetPair, LosEffects> losCache) {
        return new Packet(PacketCommand.SENDING_ENTITIES,
                filterEntities(p, getGame().getEntitiesVector(), losCache));
    }

    /**
     * Creates a packet containing all entities, including wrecks, visible to
     * the player in a blind game
     */
    private Packet createFilteredFullEntitiesPacket(Player p) {
        return new Packet(PacketCommand.SENDING_ENTITIES,
                filterEntities(p, getGame().getEntitiesVector(), null),
                getGame().getOutOfGameEntitiesVector(), getGame().getForces());
    }

    private Packet createAddEntityPacket(int entityId) {
        ArrayList<Integer> entityIds = new ArrayList<>(1);
        entityIds.add(entityId);
        return createAddEntityPacket(entityIds, new ArrayList<>());
    }

    /**
     * Creates a packet detailing the addition of an entity
     */
    Packet createAddEntityPacket(List<Integer> entityIds, List<Integer> forceIds) {
        final List<Entity> entities = entityIds.stream()
                .map(id -> getGame().getEntity(id))
                .collect(Collectors.toList());
        final List<Force> forceList = forceIds.stream()
                .map(id -> getGame().getForces().getForce(id))
                .collect(Collectors.toList());
        return new Packet(PacketCommand.ENTITY_ADD, entities, forceList);
    }

    /**
     * Creates a packet detailing the removal of an entity. Maintained for
     * backwards compatibility.
     *
     * @param entityId - the <code>int</code> ID of the entity being removed.
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(int entityId) {
        return createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_SALVAGEABLE);
    }

    /**
     * Creates a packet detailing the removal of an entity. Determines which force
     * is affected and adds it to the packet.
     *
     * @param entityId  - the <code>int</code> ID of the entity being removed.
     * @param condition - the <code>int</code> condition the unit was in. This value
     *                  must be one of constants in
     *                  <code>IEntityRemovalConditions</code>, or an
     *                  <code>IllegalArgumentException</code> will be thrown.
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(int entityId, int condition) {
        List<Integer> ids = new ArrayList<>(1);
        ids.add(entityId);
        return createRemoveEntityPacket(ids, getGame().getForces().removeEntityFromForces(entityId), condition);
    }

    /**
     * Creates a packet detailing the removal of a list of entities.
     *
     * @param entityIds - the <code>int</code> ID of each entity being removed.
     * @param condition - the <code>int</code> condition the units were in. This value
     *                  must be one of constants in
     *                  <code>IEntityRemovalConditions</code>, or an
     *                  <code>IllegalArgumentException</code> will be thrown.
     * @param affectedForces - a list of forces that are affected by the removal and
     *                  must be updated
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(List<Integer> entityIds, List<Force> affectedForces, int condition) {
        if ((condition != IEntityRemovalConditions.REMOVE_UNKNOWN)
                && (condition != IEntityRemovalConditions.REMOVE_IN_RETREAT)
                && (condition != IEntityRemovalConditions.REMOVE_PUSHED)
                && (condition != IEntityRemovalConditions.REMOVE_SALVAGEABLE)
                && (condition != IEntityRemovalConditions.REMOVE_EJECTED)
                && (condition != IEntityRemovalConditions.REMOVE_CAPTURED)
                && (condition != IEntityRemovalConditions.REMOVE_DEVASTATED)
                && (condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED)) {
            throw new IllegalArgumentException("Unknown unit condition: " + condition);
        }

        return new Packet(PacketCommand.ENTITY_REMOVE, entityIds, condition, affectedForces);
    }

    /**
     * Creates a packet indicating end of game, including detailed unit status
     */
    private Packet createEndOfGamePacket() {
        return new Packet(PacketCommand.END_OF_GAME, getDetailedVictoryReport(),
                getGame().getVictoryPlayerId(), getGame().getVictoryTeam());
    }

    /**
     * Sends out the player ready stats for all players to all connections
     */
    private void transmitAllPlayerDones() {
        for (Enumeration<Player> i = getGame().getPlayers(); i.hasMoreElements(); ) {
            final Player player = i.nextElement();
            send(createPlayerDonePacket(player.getId()));
        }
    }

    /**
     * Creates a packet containing a hex, and the coordinates it goes at.
     */
    private Packet createHexChangePacket(Coords coords, Hex hex) {
        return new Packet(PacketCommand.CHANGE_HEX, coords, hex);
    }

    public void sendSmokeCloudAdded(SmokeCloud cloud) {
        send(new Packet(PacketCommand.ADD_SMOKE_CLOUD, cloud));
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedHex(Coords coords) {
        send(createHexChangePacket(coords, game.getBoard().getHex(coords)));
    }

    /**
     * Creates a packet containing a hex, and the coordinates it goes at.
     */
    private Packet createHexesChangePacket(Set<Coords> coords, Set<Hex> hex) {
        return new Packet(PacketCommand.CHANGE_HEXES, coords, hex);
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedHexes(Set<Coords> coords) {
        send(createHexesChangePacket(coords, coords.stream()
                .map(coord -> game.getBoard().getHex(coord))
                .collect(Collectors.toCollection(LinkedHashSet::new))));
    }

    /**
     * Creates a packet containing a vector of mines.
     */
    private Packet createMineChangePacket(Coords coords) {
        return new Packet(PacketCommand.UPDATE_MINEFIELDS, getGame().getMinefields(coords));
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedMines(Coords coords) {
        send(createMineChangePacket(coords));
    }

    public void sendVisibilityIndicator(Entity e) {
        send(new Packet(PacketCommand.ENTITY_VISIBILITY_INDICATOR, e.getId(), e.isEverSeenByEnemy(),
                e.isVisibleToEnemy(), e.isDetectedByEnemy(), e.getWhoCanSee(), e.getWhoCanDetect()));
    }

    /**
     * Creates a packet for an attack
     */
    private Packet createAttackPacket(List<?> vector, int charges) {
        return new Packet(PacketCommand.ENTITY_ATTACK, vector, charges);
    }

    /**
     * Creates a packet for an attack
     */
    private Packet createAttackPacket(EntityAction ea, int charge) {
        Vector<EntityAction> vector = new Vector<>(1);
        vector.addElement(ea);
        return new Packet(PacketCommand.ENTITY_ATTACK, vector, charge);
    }

    private Packet createSpecialHexDisplayPacket(int toPlayer) {
        Hashtable<Coords, Collection<SpecialHexDisplay>> shdTable = game
                .getBoard().getSpecialHexDisplayTable();
        Hashtable<Coords, Collection<SpecialHexDisplay>> shdTable2 = new Hashtable<>();
        LinkedList<SpecialHexDisplay> tempList;
        Player player = game.getPlayer(toPlayer);
        if (player != null) {
            for (Coords coord : shdTable.keySet()) {
                tempList = new LinkedList<>();
                for (SpecialHexDisplay shd : shdTable.get(coord)) {
                    if (!shd.isObscured(player)) {
                        tempList.add(0, shd);
                    }
                }
                if (!tempList.isEmpty()) {
                    shdTable2.put(coord, tempList);
                }
            }
        }
        return new Packet(PacketCommand.SENDING_SPECIAL_HEX_DISPLAY, shdTable2);
    }

    /**
     * Creates a packet containing off board artillery attacks
     */
    private Packet createArtilleryPacket(Player p) {
        Vector<ArtilleryAttackAction> v = new Vector<>();
        int team = p.getTeam();
        for (Enumeration<AttackHandler> i = game.getAttacks(); i.hasMoreElements(); ) {
            WeaponHandler wh = (WeaponHandler) i.nextElement();
            if (wh.waa instanceof ArtilleryAttackAction) {
                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;
                if ((aaa.getPlayerId() == p.getId())
                        || ((team != Player.TEAM_NONE)
                        && (team == game.getPlayer(aaa.getPlayerId()).getTeam()))
                        || p.canIgnoreDoubleBlind()) {
                    v.addElement(aaa);
                }
            }
        }
        return new Packet(PacketCommand.SENDING_ARTILLERY_ATTACKS, v);
    }

    private Packet createIlluminatedHexesPacket() {
        return new Packet(PacketCommand.SENDING_ILLUM_HEXES, getGame().getIlluminatedPositions());
    }

    /**
     * Creates a packet containing flares
     */
    private Packet createFlarePacket() {
        return new Packet(PacketCommand.SENDING_FLARES, getGame().getFlares());
    }

    /**
     * Send a packet to all connected clients.
     */
    public void sendNovaChange(int id, String net) {
        send(new Packet(PacketCommand.ENTITY_NOVA_NETWORK_CHANGE, id, net));
    }

    private void sendReport() {
        sendReport(false);
    }

    /**
     * Send the round report to all connected clients.
     */
    private void sendReport(boolean tacticalGeniusReport) {
        EmailService mailer = Server.getServerInstance().getEmailService();
        if (mailer != null) {
            for (var player: mailer.getEmailablePlayers(game)) {
                try {
                    var reports = filterReportVector(vPhaseReport, player);
                    var message = mailer.newReportMessage(game, reports, player);
                    mailer.send(message);
                } catch (Exception ex) {
                    LogManager.getLogger().error("Error sending round report", ex);
                }
            }
        }

        for (Player p : game.getPlayersVector()) {
            send(p.getId(), tacticalGeniusReport ? createTacticalGeniusReportPacket(p) : createReportPacket(p));
        }
    }

    /**
     * Makes one slot of inferno ammo, determined by certain rules, explode on a
     * mech.
     *
     * @param entity
     *            The <code>Entity</code> that should suffer an inferno ammo
     *            explosion.
     */
    private Vector<Report> explodeInfernoAmmoFromHeat(Entity entity) {
        int damage = 0;
        int rack = 0;
        int boomloc = -1;
        int boomslot = -1;
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // Find the most destructive Inferno ammo.
        for (int j = 0; j < entity.locations(); j++) {
            for (int k = 0; k < entity.getNumberOfCriticals(j); k++) {
                CriticalSlot cs = entity.getCritical(j, k);
                // Ignore empty, destroyed, hit, and structure slots.
                if ((cs == null) || cs.isDestroyed() || cs.isHit()
                        || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {
                    continue;
                }
                // Ignore everything but ammo or LAM bomb bay slots.
                Mounted mounted = cs.getMount();
                int newRack;
                int newDamage;
                if (mounted.getType() instanceof AmmoType) {
                    AmmoType atype = (AmmoType) mounted.getType();
                    if (!atype.isExplosive(mounted)
                            || ((atype.getMunitionType() != AmmoType.M_INFERNO)
                            && (atype.getMunitionType() != AmmoType.M_IATM_IIW))) {
                        continue;
                    }
                    // ignore empty, destroyed, or missing bins
                    if (mounted.getHittableShotsLeft() == 0) {
                        continue;
                    }
                    // Find the most destructive undamaged ammo.
                    // TW page 160, compare one rack's
                    // damage. Ties go to most rounds.
                    newRack = atype.getDamagePerShot() * atype.getRackSize();
                    newDamage = mounted.getExplosionDamage();
                    Mounted mount2 = cs.getMount2();
                    if ((mount2 != null) && (mount2.getType() instanceof AmmoType)
                            && (mount2.getHittableShotsLeft() > 0)) {
                        // must be for same weaponType, so rackSize stays
                        atype = (AmmoType) mount2.getType();
                        newRack += atype.getDamagePerShot() * atype.getRackSize();
                        newDamage += mount2.getExplosionDamage();
                    }
                } else if ((mounted.getType() instanceof MiscType)
                        && mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {
                    while (mounted.getLinked() != null) {
                        mounted = mounted.getLinked();
                    }
                    if (mounted.getExplosionDamage() == 0) {
                        continue;
                    }
                    newRack = 1;
                    newDamage = mounted.getExplosionDamage();
                } else {
                    continue;
                }

                if (!mounted.isHit()
                        && ((rack < newRack) || ((rack == newRack) && (damage < newDamage)))) {
                    rack = newRack;
                    damage = newDamage;
                    boomloc = j;
                    boomslot = k;
                }
            }
        }
        // Did we find anything to explode?
        if ((boomloc != -1) && (boomslot != -1)) {
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);
            slot.setHit(true);
            Mounted equip = slot.getMount();
            equip.setHit(true);
            // We've allocated heatBuildup to heat in resolveHeat(),
            // so need to add to the entity's heat instead.
            if ((equip.getType() instanceof AmmoType)
                    || (equip.getLinked() != null
                    && equip.getLinked().getType() instanceof BombType
                    && ((BombType) equip.getLinked().getType()).getBombType() == BombType.B_INFERNO)) {
                entity.heat += Math.min(equip.getExplosionDamage(), 30);
            }
            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));
            r = new Report(5155);
            r.indent();
            r.subject = entity.getId();
            r.add(entity.heat);
            vDesc.addElement(r);
            entity.heatBuildup = 0;
        } else { // no ammo to explode
            r = new Report(5160);
            r.indent();
            r.subject = entity.getId();
            vDesc.addElement(r);
        }
        return vDesc;
    }

    /**
     * checks for unintended explosion of heavy industrial zone hex and applies
     * damage to entities occupying the hex
     */
    public void checkExplodeIndustrialZone(Coords c, Vector<Report> vDesc) {
        Report r;
        Hex hex = game.getBoard().getHex(c);
        if (null == hex) {
            return;
        }

        if (!hex.containsTerrain(Terrains.INDUSTRIAL)) {
            return;
        }

        r = new Report(3590, Report.PUBLIC);
        r.add(c.getBoardNum());
        r.indent(2);
        int effect = Compute.d6(2);
        r.add(8);
        r.add(effect);
        if (effect > 7) {
            r.choose(true);
            r.newlines = 0;
            vDesc.add(r);
            boolean onFire = false;
            boolean powerLine = false;
            boolean minorExp = false;
            boolean elecExp = false;
            boolean majorExp = false;
            if (effect == 8) {
                onFire = true;
                r = new Report(3600, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 9) {
                powerLine = true;
                r = new Report(3605, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 10) {
                minorExp = true;
                onFire = true;
                r = new Report(3610, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 11) {
                elecExp = true;
                r = new Report(3615, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else {
                onFire = true;
                majorExp = true;
                r = new Report(3620, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            }
            // apply damage here
            if (powerLine || minorExp || elecExp || majorExp) {
                // cycle through the entities in the hex and apply damage
                for (Entity en : game.getEntitiesVector(c)) {
                    int damage = 3;
                    if (minorExp) {
                        damage = 5;
                    }
                    if (elecExp) {
                        damage = Compute.d6(1) + 3;
                    }
                    if (majorExp) {
                        damage = Compute.d6(2);
                    }
                    HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    if (en instanceof BattleArmor) {
                        // ugly - I have to apply damage to each trooper
                        // separately
                        for (int loc = 0; loc < en.locations(); loc++) {
                            if ((IArmorState.ARMOR_NA != en.getInternal(loc))
                                    && (IArmorState.ARMOR_DESTROYED != en.getInternal(loc))
                                    && (IArmorState.ARMOR_DOOMED != en.getInternal(loc))) {
                                vDesc.addAll(damageEntity(en, new HitData(loc), damage));
                            }
                        }
                    } else {
                        vDesc.addAll(damageEntity(en, hit, damage));
                    }
                    if (majorExp) {
                        // lets pretend that the infernos came from the entity
                        // itself (should give us side_front)
                        vDesc.addAll(deliverInfernoMissiles(en, en, Compute.d6(2)));
                    }
                }
            }
            Report.addNewline(vDesc);
            if (onFire && !hex.containsTerrain(Terrains.FIRE)) {
                ignite(c, Terrains.FIRE_LVL_NORMAL, vDesc);
            }
        } else {
            // report no explosion
            r.choose(false);
            vDesc.add(r);
        }
    }

    /**
     * Determine the results of an entity moving through a wall of a building
     * after having moved a certain distance. This gets called when a Mech or a
     * Tank enters a building, leaves a building, or travels from one hex to
     * another inside a multi-hex building.
     *
     * @param entity
     *            - the <code>Entity</code> that passed through a wall. Don't
     *            pass <code>Infantry</code> units to this method.
     * @param bldg
     *            - the <code>Building</code> the entity is passing through.
     * @param lastPos
     *            - the <code>Coords</code> of the hex the entity is exiting.
     * @param curPos
     *            - the <code>Coords</code> of the hex the entity is entering
     * @param distance
     *            - the <code>int</code> number of hexes the entity has moved
     *            already this phase.
     * @param why
     *            - the <code>String</code> explanation for this action.
     * @param backwards
     *            - the <code>boolean</code> indicating if the entity is
     *            entering the hex backwards
     * @param entering
     *            - a <code>boolean</code> if the entity is entering or exiting
     *            a building
     */
    private void passBuildingWall(Entity entity, Building bldg, Coords lastPos, Coords curPos,
                                  int distance, String why, boolean backwards,
                                  EntityMovementType overallMoveType, boolean entering) {
        Report r;

        if (entity instanceof Protomech) {
            Vector<Report> vBuildingReport = damageBuilding(bldg, 1, curPos);
            for (Report report : vBuildingReport) {
                report.subject = entity.getId();
            }
            addReport(vBuildingReport);
        } else {
            // Need to roll based on building type.
            PilotingRollData psr = entity.rollMovementInBuilding(bldg, distance, why, overallMoveType);

            // Did the entity make the roll?
            if (0 < doSkillCheckWhileMoving(entity, entity.getElevation(), lastPos, curPos, psr, false)) {

                // Divide the building's current CF by 10, round up.
                int damage = (int) Math.floor(bldg.getDamageFromScale()
                        * Math.ceil(bldg.getCurrentCF(entering ? curPos : lastPos) / 10.0));

                // Infantry and Battle armor take different amounts of damage
                // then Meks and vehicles.
                if (entity instanceof Infantry) {
                    damage = bldg.getType() + 1;
                }
                // It is possible that the unit takes no damage.
                if (damage == 0) {
                    r = new Report(6440);
                    r.add(entity.getDisplayName());
                    r.subject = entity.getId();
                    r.indent(2);
                    addReport(r);
                } else {
                    // TW, pg. 268: if unit moves forward, damage from front,
                    // if backwards, damage from rear.
                    int side = ToHitData.SIDE_FRONT;
                    if (backwards) {
                        side = ToHitData.SIDE_REAR;
                    }
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, side);
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    addReport(damageEntity(entity, hit, damage));
                }
            }

            // Infantry and BA are damaged by buildings but do not damage them
            if (entity instanceof Infantry) {
                return;
            }
            // Damage the building. The CF can never drop below 0.
            int toBldg = (int) Math.floor(bldg.getDamageToScale()
                    * Math.ceil(entity.getWeight() / 10.0));
            int curCF = bldg.getCurrentCF(entering ? curPos : lastPos);
            curCF -= Math.min(curCF, toBldg);
            bldg.setCurrentCF(curCF, entering ? curPos : lastPos);

            // Apply the correct amount of damage to infantry in the building.
            // ASSUMPTION: We inflict toBldg damage to infantry and
            // not the amount to bring building to 0 CF.
            addReport(damageInfantryIn(bldg, toBldg, entering ? curPos : lastPos));
        }
    }

    /**
     * check if a building collapses because of a moving entity
     *
     * @param bldg
     *            the <code>Building</code>
     * @param entity
     *            the <code>Entity</code>
     * @param curPos
     *            the <code>Coords</code> of the position of the entity
     * @return a <code>boolean</code> value indicating if the building collapses
     */
    private boolean checkBuildingCollapseWhileMoving(Building bldg, Entity entity, Coords curPos) {
        Coords oldPos = entity.getPosition();
        // Count the moving entity in its current position, not
        // its pre-move position. Be sure to handle nulls.
        entity.setPosition(curPos);

        // Get the position map of all entities in the game.
        Hashtable<Coords, Vector<Entity>> positionMap = game.getPositionMap();

        // Check for collapse of this building due to overloading, and return.
        boolean rv = checkForCollapse(bldg, positionMap, curPos, true, vPhaseReport);

        // If the entity was not displaced and didn't fall, move it back where it was
        if (curPos.equals(entity.getPosition()) && !entity.isProne()) {
            entity.setPosition(oldPos);
        }
        return rv;
    }

    public Vector<Report> damageInfantryIn(Building bldg, int damage, Coords hexCoords) {
        return damageInfantryIn(bldg, damage, hexCoords, WeaponType.WEAPON_NA);
    }

    /**
     * Apply the correct amount of damage that passes on to any infantry unit in
     * the given building, based upon the amount of damage the building just
     * sustained. This amount is a percentage dictated by pg. 172 of TW.
     *
     * @param bldg   - the <code>Building</code> that sustained the damage.
     * @param damage - the <code>int</code> amount of damage.
     */
    public Vector<Report> damageInfantryIn(Building bldg, int damage, Coords hexCoords,
                                           int infDamageClass) {
        Vector<Report> vDesc = new Vector<>();

        if (bldg == null) {
            return vDesc;
        }
        // Calculate the amount of damage the infantry will sustain.
        float percent = bldg.getDamageReductionFromOutside();
        Report r;

        // Round up at .5 points of damage.
        int toInf = Math.round(damage * percent);

        // some buildings scale remaining damage
        toInf = (int) Math.floor(bldg.getDamageToScale() * toInf);

        // Walk through the entities in the game.
        for (Entity entity : game.getEntitiesVector()) {
            final Coords coords = entity.getPosition();

            // If the entity is infantry in the affected hex?
            if ((entity instanceof Infantry) && bldg.isIn(coords) && coords.equals(hexCoords)) {
                // Is the entity is inside of the building
                // (instead of just on top of it)?
                if (Compute.isInBuilding(game, entity, coords)) {

                    // Report if the infantry receive no points of damage.
                    if (toInf == 0) {
                        r = new Report(6445);
                        r.indent(3);
                        r.subject = entity.getId();
                        r.add(entity.getDisplayName());
                        vDesc.addElement(r);
                    } else {
                        // Yup. Damage the entity.
                        r = new Report(6450);
                        r.indent(3);
                        r.subject = entity.getId();
                        r.add(toInf);
                        r.add(entity.getDisplayName());
                        vDesc.addElement(r);
                        // need to adjust damage to conventional infantry
                        // TW page 217 says left over damage gets treated as
                        // direct fire ballistic damage
                        if (!(entity instanceof BattleArmor)) {
                            toInf = Compute.directBlowInfantryDamage(toInf, 0,
                                    WeaponType.WEAPON_DIRECT_FIRE, false, false);
                        }
                        int remaining = toInf;
                        int cluster = toInf;
                        // Battle Armor units use 5 point clusters.
                        if (entity instanceof BattleArmor) {
                            cluster = 5;
                        }
                        while (remaining > 0) {
                            int next = Math.min(cluster, remaining);
                            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                            vDesc.addAll((damageEntity(entity, hit, next)));
                            remaining -= next;
                        }
                    }

                    Report.addNewline(vDesc);
                } // End infantry-inside-building
            } // End entity-is-infantry-in-building-hex
        } // Handle the next entity

        return vDesc;
    } // End private void damageInfantryIn( Building, int )

    /**
     * Determine if the given building should collapse. If so, inflict the
     * appropriate amount of damage on each entity in the building and update
     * the clients. If the building does not collapse, determine if any entities
     * crash through its floor into its basement. Again, apply appropriate
     * damage.
     *
     * @param bldg
     *            - the <code>Building</code> being checked. This value should
     *            not be <code>null</code>.
     * @param positionMap
     *            - a <code>Hashtable</code> that maps the <code>Coords</code>
     *            positions or each unit in the game to a <code>Vector</code> of
     *            <code>Entity</code>s at that position. This value should not
     *            be <code>null</code>.
     * @param coords
     *            - the <code>Coords</code> of the building hex to be checked
     * @return <code>true</code> if the building collapsed.
     */
    public boolean checkForCollapse(Building bldg, Hashtable<Coords, Vector<Entity>> positionMap,
                                    Coords coords, boolean checkBecauseOfDamage,
                                    Vector<Report> vPhaseReport) {

        // If the input is meaningless, do nothing and throw no exception.
        if ((bldg == null) || (positionMap == null) || positionMap.isEmpty()
                || (coords == null) || !bldg.isIn(coords) || !bldg.hasCFIn(coords)) {
            return false;
        }

        // Get the building's current CF.
        int currentCF = bldg.getCurrentCF(coords);

        // Track all units that fall into the building's basement by Coords.
        Hashtable<Coords, Vector<Entity>> basementMap = new Hashtable<>();

        // look for a collapse.
        boolean collapse = false;

        boolean basementCollapse = false;

        boolean topFloorCollapse = false;

        if (checkBecauseOfDamage && (currentCF <= 0)) {
            collapse = true;
        }

        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> vector = positionMap.get(coords);

        // Are there any Entities at these coords?
        if (vector != null) {
            // How many levels does this building have in this hex?
            final Hex curHex = game.getBoard().getHex(coords);
            final int numFloors = Math.max(0, curHex.terrainLevel(Terrains.BLDG_ELEV));
            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);
            int numLoads = numFloors;
            if (bridgeEl != Terrain.LEVEL_NONE) {
                numLoads++;
            }
            if (numLoads < 1) {
                LogManager.getLogger().error("Check for collapse: hex " + coords
                        + " has no bridge or building");
                return false;
            }

            // Track the load of each floor (and of the roof) separately.
            // Track all units that fall into the basement in this hex.
            // track all floors, ground at index 0, the first floor is at
            // index 1, the second is at index 1, etc., and the roof is
            // at index (numFloors).
            // if bridge is present, bridge will be numFloors+1
            double[] loads = new double[numLoads + 1];
            // WiGEs flying over the building are also tracked, but can only collapse the top floor
            // and only count 25% of their tonnage.
            double wigeLoad = 0;
            // track all units that might fall into the basement
            Vector<Entity> basement = new Vector<>();

            boolean recheckLoop = true;
            for (int i = 0; (i < 2) && recheckLoop; i++) {
                recheckLoop = false;
                Arrays.fill(loads, 0);

                // Walk through the entities in this position.
                Enumeration<Entity> entities = vector.elements();
                while (!collapse && entities.hasMoreElements()) {
                    final Entity entity = entities.nextElement();
                    // WiGEs can collapse the top floor of a building by flying over it.
                    final int entityElev = entity.getElevation();
                    final boolean wigeFlyover = entity.getMovementMode() == EntityMovementMode.WIGE
                            && entityElev == numFloors + 1;

                    if (entityElev != bridgeEl && !wigeFlyover) {
                        // Ignore entities not *inside* the building
                        if (entityElev > numFloors) {
                            continue;
                        }
                    }

                    // if we're under a bridge, we can't collapse the bridge
                    if (entityElev < bridgeEl) {
                        continue;
                    }

                    if ((entity.getMovementMode() == EntityMovementMode.HYDROFOIL)
                            || (entity.getMovementMode() == EntityMovementMode.NAVAL)
                            || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)
                            || (entity.getMovementMode() == EntityMovementMode.INF_UMU)
                            || entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)) {
                        continue; // under the bridge even at same level
                    }

                    if (entityElev == 0) {
                        basement.add(entity);
                    }

                    // units already in the basement
                    if (entityElev < 0) {
                        continue;
                    }

                    // Add the weight to the correct floor.
                    double load = entity.getWeight();
                    int floor = entityElev;
                    if (floor == bridgeEl) {
                        floor = numLoads;
                    }
                    // Entities on the roof fall to the previous top floor/new roof
                    if (topFloorCollapse && floor == numFloors) {
                        floor--;
                    }

                    if (wigeFlyover) {
                        wigeLoad += load;
                        if (wigeLoad > currentCF * 4) {
                            topFloorCollapse = true;
                            loads[numFloors - 1] += loads[numFloors];
                            loads[numFloors] = 0;
                        }
                    } else {
                        loads[floor] += load;
                        if (loads[floor] > currentCF) {
                            // If the load on any floor but the ground floor
                            // exceeds the building's current CF it collapses.
                            if (floor != 0) {
                                collapse = true;
                            } else if (!bldg.getBasementCollapsed(coords)) {
                                basementCollapse = true;
                            }
                        }
                    } // End increase-load
                } // Handle the next entity.

                // Track all entities that fell into the basement.
                if (basementCollapse) {
                    basementMap.put(coords, basement);
                }

                // did anyone fall into the basement?
                if (!basementMap.isEmpty() && !bldg.getBasement(coords).isNone() && !collapse) {
                    collapseBasement(bldg, basementMap, coords, vPhaseReport);
                    if (currentCF == 0) {
                        collapse = true;
                        recheckLoop = false;
                    } else {
                        recheckLoop = true; // basement collapse might cause a further collapse
                    }
                } else {
                    recheckLoop = false; // don't check again, we didn't change the CF
                }
                if (collapse) {
                    recheckLoop = false;
                    // recheck if the basement collapsed since the basement falls
                    // might trigger a greater collapse.
                }
            } // End have-entities-here
        }

        // Collapse the building if the flag is set.
        if (collapse) {
            Report r = new Report(2375, Report.PUBLIC);
            r.add(bldg.getName());
            vPhaseReport.add(r);

            collapseBuilding(bldg, positionMap, coords, false, vPhaseReport);
        } else if (topFloorCollapse) {
            Report r = new Report(2376, Report.PUBLIC);
            r.add(bldg.getName());
            vPhaseReport.add(r);

            collapseBuilding(bldg, positionMap, coords, false, true, vPhaseReport);
        }

        // Return true if the building collapsed.
        return collapse || topFloorCollapse;

    } // End private boolean checkForCollapse( Building, Hashtable )

    public void collapseBuilding(Building bldg, Hashtable<Coords, Vector<Entity>> positionMap,
                                 Coords coords, Vector<Report> vPhaseReport) {
        collapseBuilding(bldg, positionMap, coords, true, false, vPhaseReport);
    }

    public void collapseBuilding(Building bldg, Hashtable<Coords, Vector<Entity>> positionMap,
                                 Coords coords, boolean collapseAll, Vector<Report> vPhaseReport) {
        collapseBuilding(bldg, positionMap, coords, collapseAll, false, vPhaseReport);
    }

    /**
     * Collapse a building basement. Inflict the appropriate amount of damage on
     * all entities that fell to the basement. Update all clients.
     *
     * @param bldg
     *            - the <code>Building</code> that has collapsed.
     * @param positionMap
     *            - a <code>Hashtable</code> that maps the <code>Coords</code>
     *            positions or each unit in the game to a <code>Vector</code> of
     *            <code>Entity</code>s at that position. This value should not
     *            be <code>null</code>.
     * @param coords
     *            - The <code>Coords</code> of the building basement hex that
     *            has collapsed
     */
    public void collapseBasement(Building bldg, Hashtable<Coords, Vector<Entity>> positionMap,
                                 Coords coords, Vector<Report> vPhaseReport) {
        if (!bldg.hasCFIn(coords)) {
            return;
        }
        int runningCFTotal = bldg.getCurrentCF(coords);

        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> entities = positionMap.get(coords);

        if (bldg.getBasement(coords).isNone()) {
            return;
        } else {
            bldg.collapseBasement(coords, game.getBoard(), vPhaseReport);
        }

        // Are there any Entities at these coords?
        if (entities != null) {

            // Sort in elevation order
            entities.sort((a, b) -> {
                if (a.getElevation() > b.getElevation()) {
                    return -1;
                } else if (a.getElevation() > b.getElevation()) {
                    return 1;
                }
                return 0;
            });
            // Walk through the entities in this position.
            for (Entity entity : entities) {

                // int floor = entity.getElevation();

                int cfDamage = (int) Math.ceil(Math.round(entity.getWeight() / 10.0));

                // all entities should fall
                // ASSUMPTION: PSR to avoid pilot damage
                PilotingRollData psr = entity.getBasePilotingRoll();
                entity.addPilotingModifierForTerrain(psr, coords);

                // fall into basement
                switch (bldg.getBasement(coords)) {
                    case NONE:
                    case ONE_DEEP_NORMAL_INFANTRY_ONLY:
                        LogManager.getLogger().error(entity.getDisplayName() + " is not falling into " + coords.toString());
                        break;
                    case TWO_DEEP_HEAD:
                    case TWO_DEEP_FEET:
                        LogManager.getLogger().info(entity.getDisplayName() + " is falling 2 floors into " + coords.toString());
                        // Damage is determined by the depth of the basement, so a fall of 0
                        // elevation is correct in this case
                        vPhaseReport.addAll(doEntityFall(entity, coords, 0, Compute.d6(), psr,
                                true, false));
                        runningCFTotal -= cfDamage * 2;
                        break;
                    default:
                        LogManager.getLogger().info(entity.getDisplayName() + " is falling 1 floor into " + coords.toString());
                        // Damage is determined by the depth of the basement, so a fall of 0
                        // elevation is correct in this case
                        vPhaseReport.addAll(doEntityFall(entity, coords, 0, Compute.d6(), psr,
                                true, false));
                        runningCFTotal -= cfDamage;
                        break;
                }

                // Update this entity.
                // ASSUMPTION: this is the correct thing to do.
                entityUpdate(entity.getId());
            } // Handle the next entity.
        }

        // Update the building
        if (runningCFTotal < 0) {
            bldg.setCurrentCF(0, coords);
            bldg.setPhaseCF(0, coords);
        } else {
            bldg.setCurrentCF(runningCFTotal, coords);
            bldg.setPhaseCF(runningCFTotal, coords);
        }
        sendChangedHex(coords);
        Vector<Building> buildings = new Vector<>();
        buildings.add(bldg);
        sendChangedBuildings(buildings);
    }

    /**
     * Collapse a building hex. Inflict the appropriate amount of damage on all
     * entities in the building. Update all clients.
     *
     * @param bldg
     *            - the <code>Building</code> that has collapsed.
     * @param positionMap
     *            - a <code>Hashtable</code> that maps the <code>Coords</code>
     *            positions or each unit in the game to a <code>Vector</code> of
     *            <code>Entity</code>s at that position. This value should not
     *            be <code>null</code>.
     * @param coords
     *            - The <code>Coords</code> of the building hex that has
     *            collapsed
     * @param collapseAll
     *            - A <code>boolean</code> indicating whether or not this
     *            collapse of a hex should be able to collapse the whole
     *            building
     * @param topFloor
     *            - A <code>boolean</code> indicating that only the top floor collapses
     *              (from a WiGE flying over the top).
     *
     */
    public void collapseBuilding(Building bldg, Hashtable<Coords, Vector<Entity>> positionMap,
                                 Coords coords, boolean collapseAll, boolean topFloor,
                                 Vector<Report> vPhaseReport) {
        // sometimes, buildings that reach CF 0 decide against collapsing
        // but we want them to go away anyway, as a building with CF 0 cannot stand
        final int phaseCF = bldg.hasCFIn(coords) ? bldg.getPhaseCF(coords) : 0;

        // Loop through the hexes in the building, and apply
        // damage to all entities inside or on top of the building.
        Report r;

        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> vector = positionMap.get(coords);

        // Are there any Entities at these coords?
        if (vector != null) {
            // How many levels does this building have in this hex?
            final Hex curHex = game.getBoard().getHex(coords);
            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);
            final int numFloors = Math.max(bridgeEl,
                    curHex.terrainLevel(Terrains.BLDG_ELEV));

            // Now collapse the building in this hex, so entities fall to
            // the ground
            if (topFloor && numFloors > 1) {
                curHex.removeTerrain(Terrains.BLDG_ELEV);
                curHex.addTerrain(new Terrain(Terrains.BLDG_ELEV, numFloors - 1));
                sendChangedHex(coords);
            } else {
                bldg.setCurrentCF(0, coords);
                bldg.setPhaseCF(0, coords);
                send(createCollapseBuildingPacket(coords));
                game.getBoard().collapseBuilding(coords);
            }

            // Sort in elevation order
            vector.sort((a, b) -> {
                if (a.getElevation() > b.getElevation()) {
                    return -1;
                } else if (a.getElevation() > b.getElevation()) {
                    return 1;
                }
                return 0;
            });
            // Walk through the entities in this position.
            Enumeration<Entity> entities = vector.elements();
            while (entities.hasMoreElements()) {
                final Entity entity = entities.nextElement();
                // all gun emplacements are simply destroyed
                if (entity instanceof GunEmplacement) {
                    vPhaseReport.addAll(destroyEntity(entity, "building collapse"));
                    addNewLines();
                    continue;
                }

                int floor = entity.getElevation();
                // If only the top floor collapses, we only care about units on the top level
                // or on the roof.
                if (topFloor && floor < numFloors - 1) {
                    continue;
                }
                // units trapped in a basement under a collapsing building are
                // destroyed
                if (floor < 0) {
                    vPhaseReport.addAll(destroyEntity(entity,
                            "Crushed under building rubble", false, false));
                }

                // Ignore units above the building / bridge.
                if (floor > numFloors) {
                    continue;
                }

                // Treat units on the roof like
                // they were in the top floor.
                if (floor == numFloors) {
                    floor--;
                }

                // Calculate collapse damage for this entity.
                int damage = (int) Math.floor(bldg.getDamageFromScale()
                        * Math.ceil((phaseCF * (numFloors - floor)) / 10.0));

                // Infantry suffer more damage.
                if (entity instanceof Infantry) {
                    if ((entity instanceof BattleArmor) || ((Infantry) entity).isMechanized()) {
                        damage *= 2;
                    } else {
                        damage *= 3;
                    }
                }

                // Apply collapse damage the entity.
                r = new Report(6455);
                r.indent();
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                r.add(damage);
                vPhaseReport.add(r);
                int remaining = damage;
                int cluster = damage;
                if ((entity instanceof BattleArmor) || (entity instanceof Mech)
                        || (entity instanceof Tank)) {
                    cluster = 5;
                }
                while (remaining > 0) {
                    int next = Math.min(cluster, remaining);
                    int table;
                    if (entity instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    } else if (entity.getElevation() == numFloors) {
                        table = ToHitData.HIT_NORMAL;
                    } else {
                        table = ToHitData.HIT_PUNCH;
                    }
                    HitData hit = entity.rollHitLocation(table, ToHitData.SIDE_FRONT);
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    vPhaseReport.addAll(damageEntity(entity, hit, next));
                    remaining -= next;
                }
                vPhaseReport.add(new Report(1210, Report.PUBLIC));

                // all entities should fall
                floor = entity.getElevation();
                if ((floor > 0) || (floor == bridgeEl)) {
                    // ASSUMPTION: PSR to avoid pilot damage
                    // should use mods for entity damage and
                    // 20+ points of collapse damage (if any).
                    PilotingRollData psr = entity.getBasePilotingRoll();
                    entity.addPilotingModifierForTerrain(psr, coords);
                    if (damage >= 20) {
                        psr.addModifier(1, "20+ damage");
                    }
                    vPhaseReport.addAll(doEntityFallsInto(entity, coords, psr,
                            true));
                }
                // Update this entity.
                // ASSUMPTION: this is the correct thing to do.
                entityUpdate(entity.getId());
            }
        } else {
            // Update the building.
            bldg.setCurrentCF(0, coords);
            bldg.setPhaseCF(0, coords);
            send(createCollapseBuildingPacket(coords));
            game.getBoard().collapseBuilding(coords);
        }
        // if more than half of the hexes are gone, collapse all
        if (bldg.getCollapsedHexCount() > (bldg.getOriginalHexCount() / 2)) {
            for (Enumeration<Coords> coordsEnum = bldg.getCoords(); coordsEnum.hasMoreElements();) {
                coords = coordsEnum.nextElement();
                collapseBuilding(bldg, game.getPositionMap(), coords, false, vPhaseReport);
            }
        }
    }

    /**
     * Tell the clients to replace the given building with rubble hexes.
     *
     * @param coords - the <code>Coords</code> that has collapsed.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createCollapseBuildingPacket(Coords coords) {
        Vector<Coords> coordsV = new Vector<>();
        coordsV.addElement(coords);
        return createCollapseBuildingPacket(coordsV);
    }

    /**
     * Tell the clients to replace the given building hexes with rubble hexes.
     *
     * @param coords - a <code>Vector</code> of <code>Coords</code>s that has
     *               collapsed.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createCollapseBuildingPacket(Vector<Coords> coords) {
        return new Packet(PacketCommand.BLDG_COLLAPSE, coords);
    }

    /**
     * Tell the clients to update the CFs of the given buildings.
     *
     * @param buildings - a <code>Vector</code> of <code>Building</code>s that need to
     *                  be updated.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createUpdateBuildingPacket(Vector<Building> buildings) {
        return new Packet(PacketCommand.BLDG_UPDATE, buildings);
    }

    /**
     * Apply this phase's damage to all buildings. Buildings may collapse due to
     * damage.
     */
    private void applyBuildingDamage() {

        // Walk through the buildings in the game.
        // Build the collapse and update vectors as you go.
        // N.B. never, NEVER, collapse buildings while you are walking through
        // the Enumeration from megamek.common.Board#getBuildings.
        Map<Building, Vector<Coords>> collapse = new HashMap<>();
        Map<Building, Vector<Coords>> update = new HashMap<>();
        Enumeration<Building> buildings = game.getBoard().getBuildings();
        while (buildings.hasMoreElements()) {
            Building bldg = buildings.nextElement();
            Vector<Coords> collapseCoords = new Vector<>();
            Vector<Coords> updateCoords = new Vector<>();
            Enumeration<Coords> buildingCoords = bldg.getCoords();
            while (buildingCoords.hasMoreElements()) {
                Coords coords = buildingCoords.nextElement();
                // If the CF is zero, the building should fall.
                if (bldg.getCurrentCF(coords) == 0) {
                    collapseCoords.addElement(coords);
                }
                // If the building took damage this round, update it.
                else if (bldg.getPhaseCF(coords) != bldg.getCurrentCF(coords)) {
                    bldg.setPhaseCF(bldg.getCurrentCF(coords), coords);
                    updateCoords.addElement(coords);
                }
            }
            collapse.put(bldg, collapseCoords);
            update.put(bldg, updateCoords);
        } // Handle the next building

        // If we have any buildings to collapse, collapse them now.
        if (!collapse.isEmpty()) {

            // Get the position map of all entities in the game.
            Hashtable<Coords, Vector<Entity>> positionMap = game
                    .getPositionMap();

            // Walk through the hexes that have collapsed.
            for (Building bldg : collapse.keySet()) {
                Vector<Coords> coordsVector = collapse.get(bldg);
                for (Coords coords : coordsVector) {
                    Report r = new Report(6460, Report.PUBLIC);
                    r.add(bldg.getName());
                    addReport(r);
                    collapseBuilding(bldg, positionMap, coords, vPhaseReport);
                }
            }
        }

        // check for buildings which should collapse due to being overloaded now
        // CF is reduced
        if (!update.isEmpty()) {
            Hashtable<Coords, Vector<Entity>> positionMap = game.getPositionMap();
            for (Building bldg : update.keySet()) {
                Vector<Coords> updateCoords = update.get(bldg);
                Vector<Coords> coordsToRemove = new Vector<>();
                for (Coords coords : updateCoords) {
                    if (checkForCollapse(bldg, positionMap, coords, false,
                            vPhaseReport)) {
                        coordsToRemove.add(coords);
                    }
                }
                updateCoords.removeAll(coordsToRemove);
                update.put(bldg, updateCoords);
            }
        }

        // If we have any buildings to update, send the message.
        if (!update.isEmpty()) {
            sendChangedBuildings(new Vector<>(update.keySet()));
        }
    }

    /**
     * Apply the given amount of damage to the building. Please note, this
     * method does <b>not</b> apply any damage to units inside the building,
     * update the clients, or check for the building's collapse.
     * <p>
     * A default message will be used to describe why the building took the
     * damage.
     *
     * @param bldg   - the <code>Building</code> that has been damaged. This value
     *               should not be <code>null</code>, but no exception will occur.
     * @param damage - the <code>int</code> amount of damage.
     * @param coords - the <code>Coords</code> of the building hex to be damaged
     * @return a <code>Report</code> to be shown to the players.
     */
    public Vector<Report> damageBuilding(Building bldg, int damage,
                                         Coords coords) {
        final String defaultWhy = " absorbs ";
        return damageBuilding(bldg, damage, defaultWhy, coords);
    }

    /**
     * Apply the given amount of damage to the building. Please note, this
     * method does <b>not</b> apply any damage to units inside the building,
     * update the clients, or check for the building's collapse.
     *
     * @param bldg   - the <code>Building</code> that has been damaged. This value
     *               should not be <code>null</code>, but no exception will occur.
     * @param damage - the <code>int</code> amount of damage.
     * @param why    - the <code>String</code> message that describes why the
     *               building took the damage.
     * @param coords - the <code>Coords</code> of the building hex to be damaged
     * @return a <code>Report</code> to be shown to the players.
     */
    public Vector<Report> damageBuilding(Building bldg, int damage, String why, Coords coords) {
        Vector<Report> vPhaseReport = new Vector<>();
        Report r = new Report(1210, Report.PUBLIC);

        // Do nothing if no building or no damage was passed.
        if ((bldg != null) && (damage > 0)) {
            r.messageId = 3435;
            r.add(bldg.toString());
            r.add(why);
            r.add(damage);
            vPhaseReport.add(r);
            int curArmor = bldg.getArmor(coords);
            if (curArmor >= damage) {
                curArmor -= Math.min(curArmor, damage);
                bldg.setArmor(curArmor, coords);
                r = new Report(3436, Report.PUBLIC);
                r.indent(0);
                r.add(damage);
                r.add(curArmor);
                vPhaseReport.add(r);
            } else {
                r.add(damage);
                if (curArmor > 0) {
                    bldg.setArmor(0, coords);
                    damage = damage - curArmor;
                    r = new Report(3436, Report.PUBLIC);
                    r.indent(0);
                    r.add(curArmor);
                    r.add(0);
                    vPhaseReport.add(r);
                }
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
                if (bldg.getDamageToScale() < 1.0) {
                    r = new Report(3437, Report.PUBLIC);
                    r.indent(0);
                    r.add(damage);
                    vPhaseReport.add(r);
                }
                if (bldg.getDamageToScale() > 1.0) {
                    r = new Report(3438, Report.PUBLIC);
                    r.indent(0);
                    r.add(damage);
                    vPhaseReport.add(r);
                }
                int curCF = bldg.getCurrentCF(coords);
                final int startingCF = curCF;
                curCF -= Math.min(curCF, damage);
                bldg.setCurrentCF(curCF, coords);

                r = new Report(6436, Report.PUBLIC);
                r.indent(1);
                if (curCF <= 0) {
                    r.add(r.warning(String.valueOf(curCF)));
                } else {
                    r.add(curCF);
                }
                vPhaseReport.add(r);

                final int damageThresh = (int) Math.ceil(bldg.getPhaseCF(coords) / 10.0);

                // If the CF is zero, the building should fall.
                if ((curCF == 0) && (startingCF != 0)) {
                    if (bldg instanceof FuelTank) {
                        // If this is a fuel tank, we'll give it its own
                        // message.
                        r = new Report(3441);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                        // ...But we ALSO need to blow up everything nearby.
                        // Bwahahahahaha...
                        r = new Report(3560);
                        r.type = Report.PUBLIC;
                        r.newlines = 1;
                        vPhaseReport.add(r);
                        Vector<Report> vRep = new Vector<>();
                        doExplosion(((FuelTank) bldg).getMagnitude(), 10,
                                false, bldg.getCoords().nextElement(), true,
                                vRep, null, -1);
                        Report.indentAll(vRep, 2);
                        vPhaseReport.addAll(vRep);
                        return vPhaseReport;
                    }
                    if (bldg.getType() == Building.WALL) {
                        r = new Report(3442);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                    } else {
                        r = new Report(3440);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                    }
                } else if ((curCF < startingCF) && (damage > damageThresh)) {
                    // need to check for crits
                    // don't bother unless we have some gun emplacements
                    Vector<GunEmplacement> guns = game.getGunEmplacements(coords);
                    if (!guns.isEmpty()) {
                        vPhaseReport.addAll(criticalGunEmplacement(guns, bldg, coords));
                    }
                }
            }
        }
        Report.indentAll(vPhaseReport, 2);
        return vPhaseReport;
    }

    private Vector<Report> criticalGunEmplacement(Vector<GunEmplacement> guns, Building bldg,
                                                  Coords coords) {
        Vector<Report> vDesc = new Vector<>();
        Report r;
        r = new Report(3800);
        r.type = Report.PUBLIC;
        r.indent(0);
        vDesc.add(r);

        int critRoll = Compute.d6(2);
        if (critRoll < 6) {
            r = new Report(3805);
            r.type = Report.PUBLIC;
            r.indent(1);
            vDesc.add(r);
        } else if (critRoll == 6) {
            // weapon malfunction
            // lets just randomly determine which weapon gets hit
            Vector<Mounted> wpns = new Vector<>();
            for (GunEmplacement gun : guns) {
                for (Mounted wpn : gun.getWeaponList()) {
                    if (!wpn.isHit() && !wpn.isJammed()
                            && !wpn.jammedThisPhase()) {
                        wpns.add(wpn);
                    }
                }
            }

            if (!wpns.isEmpty()) {
                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));
                weapon.setJammed(true);
                ((GunEmplacement) weapon.getEntity()).addJammedWeapon(weapon);
                r = new Report(3845);
                r.type = Report.PUBLIC;
                r.indent(1);
                r.add(weapon.getDesc());
            } else {
                r = new Report(3846);
                r.type = Report.PUBLIC;
                r.indent(1);
            }
            vDesc.add(r);
        } else if (critRoll == 7) {
            // gunners stunned
            for (GunEmplacement gun : guns) {
                gun.stunCrew();
                r = new Report(3810);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
            }
        } else if (critRoll == 8) {
            // weapon destroyed
            // lets just randomly determine which weapon gets hit
            Vector<Mounted> wpns = new Vector<>();
            for (GunEmplacement gun : guns) {
                for (Mounted wpn : gun.getWeaponList()) {
                    if (!wpn.isHit()) {
                        wpns.add(wpn);
                    }
                }
            }

            if (!wpns.isEmpty()) {
                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));
                weapon.setHit(true);
                r = new Report(3840);
                r.type = Report.PUBLIC;
                r.indent(1);
                r.add(weapon.getDesc());
            } else {
                r = new Report(3841);
                r.type = Report.PUBLIC;
                r.indent(1);
            }
            vDesc.add(r);
        } else if (critRoll == 9) {
            // gunners killed
            r = new Report(3815);
            r.type = Report.PUBLIC;
            r.indent(1);
            vDesc.add(r);
            for (GunEmplacement gun : guns) {
                gun.getCrew().setDoomed(true);
            }
        } else if (critRoll == 10) {
            if (Compute.d6() > 3) {
                // turret lock
                r = new Report(3820);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
                for (GunEmplacement gun : guns) {
                    gun.lockTurret(gun.getLocTurret());
                }
            } else {
                // turret jam
                r = new Report(3825);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
                for (GunEmplacement gun : guns) {
                    if (gun.isTurretEverJammed(gun.getLocTurret())) {
                        gun.lockTurret(gun.getLocTurret());
                    } else {
                        gun.jamTurret(gun.getLocTurret());
                    }
                }
            }
        } else if (critRoll == 11) {
            r = new Report(3830);
            r.type = Report.PUBLIC;
            r.indent(1);
            r.add(bldg.getName());
            int boom = 0;
            for (GunEmplacement gun : guns) {
                for (Mounted ammo : gun.getAmmo()) {
                    ammo.setHit(true);
                    if (ammo.getType().isExplosive(ammo)) {
                        boom += ammo.getHittableShotsLeft()
                                * ((AmmoType) ammo.getType())
                                .getDamagePerShot()
                                * ((AmmoType) ammo.getType()).getRackSize();
                    }
                }
            }
            boom = (int) Math.floor(bldg.getDamageToScale() * boom);

            if (boom == 0) {
                Report rNoAmmo = new Report(3831);
                rNoAmmo.type = Report.PUBLIC;
                rNoAmmo.indent(1);
                vDesc.add(rNoAmmo);
                return vDesc;
            }

            r.add(boom);
            int curCF = bldg.getCurrentCF(coords);
            curCF -= Math.min(curCF, boom);
            bldg.setCurrentCF(curCF, coords);
            r.add(bldg.getCurrentCF(coords));
            vDesc.add(r);
            // If the CF is zero, the building should fall.
            if ((curCF == 0) && (bldg.getPhaseCF(coords) != 0)) {

                // when a building collapses due to an ammo explosion, we can consider
                // that turret annihilated for the purposes of salvage.
                for (GunEmplacement gun : guns) {
                    vDesc.addAll(destroyEntity(gun, "ammo explosion", false, false));
                }

                if (bldg instanceof FuelTank) {
                    // If this is a fuel tank, we'll give it its own
                    // message.
                    r = new Report(3441);
                    r.type = Report.PUBLIC;
                    r.indent(0);
                    vDesc.add(r);
                    // ...But we ALSO need to blow up everything nearby.
                    // Bwahahahahaha...
                    r = new Report(3560);
                    r.type = Report.PUBLIC;
                    r.newlines = 1;
                    vDesc.add(r);
                    Vector<Report> vRep = new Vector<>();
                    doExplosion(((FuelTank) bldg).getMagnitude(), 10, false,
                            bldg.getCoords().nextElement(), true, vRep, null,
                            -1);
                    Report.indentAll(vRep, 2);
                    vDesc.addAll(vRep);
                    return vPhaseReport;
                }
                if (bldg.getType() == Building.WALL) {
                    r = new Report(3442);
                } else {
                    r = new Report(3440);
                }
                r.type = Report.PUBLIC;
                r.indent(0);
                vDesc.add(r);
            }
        } else if (critRoll == 12) {
            // non-weapon equipment is hit
            Vector<Mounted> equipmentList = new Vector<>();
            for (GunEmplacement gun : guns) {
                for (Mounted equipment : gun.getMisc()) {
                    if (!equipment.isHit()) {
                        equipmentList.add(equipment);
                    }
                }
            }

            if (!equipmentList.isEmpty()) {
                Mounted equipment = equipmentList.elementAt(Compute.randomInt(equipmentList.size()));
                equipment.setHit(true);
                r = new Report(3840);
                r.type = Report.PUBLIC;
                r.indent(1);
                r.add(equipment.getDesc());
            } else {
                r = new Report(3835);
                r.type = Report.PUBLIC;
                r.indent(1);
            }
            vDesc.add(r);
        }

        return vDesc;
    }

    public void sendChangedBuildings(Vector<Building> buildings) {
        send(createUpdateBuildingPacket(buildings));
    }

    /**
     * Receives an packet to unload entity is stranded on immobile transports,
     * and queue all valid requests for execution. If all players that have
     * stranded entities have answered, executes the pending requests and end
     * the current turn.
     */
    private void receiveUnloadStranded(Packet packet, int connId) {
        GameTurn.UnloadStrandedTurn turn;
        final Player player = game.getPlayer(connId);
        int[] entityIds = (int[]) packet.getObject(0);
        Vector<Player> declared;
        Player other;
        Enumeration<EntityAction> pending;
        UnloadStrandedAction action;
        Entity entity;

        // Is this the right phase?
        if (!getGame().getPhase().isMovement()) {
            LogManager.getLogger().error("Server got unload stranded packet in wrong phase");
            return;
        }

        // Are we in an "unload stranded entities" turn?
        if (getGame().getTurn() instanceof GameTurn.UnloadStrandedTurn) {
            turn = (GameTurn.UnloadStrandedTurn) getGame().getTurn();
        } else {
            LogManager.getLogger().error("Server got unload stranded packet out of sequence");
            sendServerChat(player.getName() + " should not be sending 'unload stranded entity' packets at this time.");
            return;
        }

        // Can this player act right now?
        if (!turn.isValid(connId, getGame())) {
            LogManager.getLogger().error("Server got unload stranded packet from invalid player");
            sendServerChat(player.getName() + " should not be sending 'unload stranded entity' packets.");
            return;
        }

        // Did the player already send an 'unload' request?
        // N.B. we're also building the list of players who
        // have declared their "unload stranded" actions.
        declared = new Vector<>();
        pending = getGame().getActions();
        while (pending.hasMoreElements()) {
            action = (UnloadStrandedAction) pending.nextElement();
            if (action.getPlayerId() == connId) {
                LogManager.getLogger().error("Server got multiple unload stranded packets from player");
                sendServerChat(player.getName() + " should not send multiple 'unload stranded entity' packets.");
                return;
            }
            // This player is not from the current connection.
            // Record this player to determine if this turn is done.
            other = getGame().getPlayer(action.getPlayerId());
            if (!declared.contains(other)) {
                declared.addElement(other);
            }
        } // Handle the next "unload stranded" action.

        // Make sure the player selected at least *one* valid entity ID.
        boolean foundValid = false;
        for (int index = 0; (null != entityIds) && (index < entityIds.length); index++) {
            entity = game.getEntity(entityIds[index]);
            if (!game.getTurn().isValid(connId, entity, game)) {
                LogManager.getLogger().error("Server got unload stranded packet for invalid entity");
                StringBuilder message = new StringBuilder();
                message.append(player.getName()).append(" can not unload stranded entity ");
                if (null == entity) {
                    message.append('#').append(entityIds[index]);
                } else {
                    message.append(entity.getDisplayName());
                }
                message.append(" at this time.");
                sendServerChat(message.toString());
            } else {
                foundValid = true;
                game.addAction(new UnloadStrandedAction(connId, entityIds[index]));
            }
        }

        // Did the player choose not to unload any valid stranded entity?
        if (!foundValid) {
            game.addAction(new UnloadStrandedAction(connId, Entity.NONE));
        }

        // Either way, the connection's player has now declared.
        declared.addElement(player);

        // Are all players who are unloading entities done? Walk
        // through the turn's stranded entities, and look to see
        // if their player has finished their turn.
        entityIds = turn.getEntityIds();
        for (int entityId : entityIds) {
            entity = game.getEntity(entityId);
            other = entity.getOwner();
            if (!declared.contains(other)) {
                // At least one player still needs to declare.
                return;
            }
        }

        // All players have declared whether they're unloading stranded units.
        // Walk the list of pending actions and unload the entities.
        pending = game.getActions();
        while (pending.hasMoreElements()) {
            action = (UnloadStrandedAction) pending.nextElement();

            // Some players don't want to unload any stranded units.
            if (Entity.NONE != action.getEntityId()) {
                entity = game.getEntity(action.getEntityId());
                if (null == entity) {
                    // After all this, we couldn't find the entity!!!
                    LogManager.getLogger().error("Server could not find stranded entity #"
                            + action.getEntityId() + " to unload!!!");
                } else {
                    // Unload the entity. Get the unit's transporter.
                    Entity transporter = game.getEntity(entity.getTransportId());
                    unloadUnit(transporter, entity, transporter.getPosition(),
                            transporter.getFacing(), transporter.getElevation());
                }
            }

        } // Handle the next pending unload action

        // Clear the list of pending units and move to the next turn.
        game.resetActions();
        changeToNextTurn(connId);
    }

    /**
     * For all current artillery attacks in the air from this entity with this
     * weapon, clear the list of spotters. Needed because firing another round
     * before first lands voids spotting.
     *
     * @param entityID the <code>int</code> id of the entity
     * @param weaponID the <code>int</code> id of the weapon
     */
    private void clearArtillerySpotters(int entityID, int weaponID) {
        for (Enumeration<AttackHandler> i = game.getAttacks(); i.hasMoreElements(); ) {
            WeaponHandler wh = (WeaponHandler) i.nextElement();
            if ((wh.waa instanceof ArtilleryAttackAction)
                    && (wh.waa.getEntityId() == entityID)
                    && (wh.waa.getWeaponId() == weaponID)) {
                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;
                aaa.setSpotterIds(null);
            }
        }
    }

    /**
     * Credits a Kill for an entity, if the target got killed.
     *
     * @param target   The <code>Entity</code> that got killed.
     * @param attacker The <code>Entity</code> that did the killing, which may be null
     */
    public void creditKill(final Entity target, @Nullable Entity attacker) {
        // Kills should be credited for each individual fighter, instead of the squadron
        if (target instanceof FighterSquadron) {
            return;
        }

        // If a squadron scores a kill, assign it randomly to one of the member fighters... provided
        // one still lives that is.
        if (attacker instanceof FighterSquadron) {
            attacker = attacker.getLoadedUnits().isEmpty() ? null
                    : attacker.getLoadedUnits().get(Compute.randomInt(attacker.getLoadedUnits().size()));
        }

        if ((attacker != null) && (target.isDoomed() || target.getCrew().isDoomed())
                && !target.getGaveKillCredit()) {
            attacker.addKill(target);
        }
    }

    /**
     * pre-treats a physical attack
     *
     * @param aaa The <code>AbstractAttackAction</code> of the physical attack
     *            to pre-treat
     * @return The <code>PhysicalResult</code> of that action, including
     * possible damage.
     */
    private PhysicalResult preTreatPhysicalAttack(AbstractAttackAction aaa) {
        final Entity ae = game.getEntity(aaa.getEntityId());
        int damage = 0;
        PhysicalResult pr = new PhysicalResult();
        ToHitData toHit = new ToHitData();
        pr.roll = Compute.d6(2);
        pr.aaa = aaa;
        if (aaa instanceof BrushOffAttackAction) {
            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;
            int arm = baa.getArm();
            baa.setArm(BrushOffAttackAction.LEFT);
            toHit = BrushOffAttackAction.toHit(game, aaa.getEntityId(),
                    aaa.getTarget(game), BrushOffAttackAction.LEFT);
            baa.setArm(BrushOffAttackAction.RIGHT);
            pr.toHitRight = BrushOffAttackAction.toHit(game, aaa.getEntityId(),
                    aaa.getTarget(game), BrushOffAttackAction.RIGHT);
            damage = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.LEFT);
            pr.damageRight = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.RIGHT);
            baa.setArm(arm);
            pr.rollRight = Compute.d6(2);
        } else if (aaa instanceof ChargeAttackAction) {
            ChargeAttackAction caa = (ChargeAttackAction) aaa;
            toHit = caa.toHit(game);
            Entity target = (Entity) caa.getTarget(game);

            if (target != null ) {
                if (caa.getTarget(game) instanceof Entity) {
                    damage = ChargeAttackAction.getDamageFor(ae, target, game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE), toHit.getMoS());
                } else {
                    damage = ChargeAttackAction.getDamageFor(ae);
                }
            }
            else {
                damage = 0;
            }
        } else if (aaa instanceof AirmechRamAttackAction) {
            AirmechRamAttackAction raa = (AirmechRamAttackAction) aaa;
            toHit = raa.toHit(game);
            damage = AirmechRamAttackAction.getDamageFor(ae);
        } else if (aaa instanceof ClubAttackAction) {
            ClubAttackAction caa = (ClubAttackAction) aaa;
            toHit = caa.toHit(game);
            damage = ClubAttackAction.getDamageFor(ae, caa.getClub(),
                    caa.getTarget(game).isConventionalInfantry(), caa.isZweihandering());
            if (caa.getTargetType() == Targetable.TYPE_BUILDING) {
                EquipmentType clubType = caa.getClub().getType();
                if (clubType.hasSubType(MiscType.S_BACKHOE)
                        || clubType.hasSubType(MiscType.S_CHAINSAW)
                        || clubType.hasSubType(MiscType.S_MINING_DRILL)
                        || clubType.hasSubType(MiscType.S_PILE_DRIVER)) {
                    damage += Compute.d6(1);
                } else if (clubType.hasSubType(MiscType.S_DUAL_SAW)) {
                    damage += Compute.d6(2);
                } else if (clubType.hasSubType(MiscType.S_ROCK_CUTTER)) {
                    damage += Compute.d6(3);
                }
                else if (clubType.hasSubType(MiscType.S_WRECKING_BALL)) {
                    damage += Compute.d6(4);
                }
            }
        } else if (aaa instanceof DfaAttackAction) {
            DfaAttackAction daa = (DfaAttackAction) aaa;
            toHit = daa.toHit(game);
            Entity target = (Entity) daa.getTarget(game);

            if (target != null) {
                damage = DfaAttackAction.getDamageFor(ae, daa.getTarget(game).isConventionalInfantry());
            }
            else {
                damage = 0;
            }
        } else if (aaa instanceof KickAttackAction) {
            KickAttackAction kaa = (KickAttackAction) aaa;
            toHit = kaa.toHit(game);
            damage = KickAttackAction.getDamageFor(ae, kaa.getLeg(),
                    kaa.getTarget(game).isConventionalInfantry());
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {
            ProtomechPhysicalAttackAction paa = (ProtomechPhysicalAttackAction) aaa;
            toHit = paa.toHit(game);
            damage = ProtomechPhysicalAttackAction.getDamageFor(ae, paa.getTarget(game));
        } else if (aaa instanceof PunchAttackAction) {
            PunchAttackAction paa = (PunchAttackAction) aaa;
            int arm = paa.getArm();
            int damageRight;
            paa.setArm(PunchAttackAction.LEFT);
            toHit = paa.toHit(game);
            paa.setArm(PunchAttackAction.RIGHT);
            ToHitData toHitRight = paa.toHit(game);
            damage = PunchAttackAction.getDamageFor(ae, PunchAttackAction.LEFT,
                    paa.getTarget(game).isConventionalInfantry(), paa.isZweihandering());
            damageRight = PunchAttackAction.getDamageFor(ae, PunchAttackAction.RIGHT,
                    paa.getTarget(game).isConventionalInfantry(), paa.isZweihandering());
            paa.setArm(arm);
            // If we're punching while prone (at a Tank,
            // duh), then we can only use one arm.
            if (ae.isProne()) {
                double oddsLeft = Compute.oddsAbove(toHit.getValue(),
                        ae.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING));
                double oddsRight = Compute.oddsAbove(toHitRight.getValue(),
                        ae.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING));
                // Use the best attack.
                if ((oddsLeft * damage) > (oddsRight * damageRight)) {
                    paa.setArm(PunchAttackAction.LEFT);
                } else {
                    paa.setArm(PunchAttackAction.RIGHT);
                }
            }
            pr.damageRight = damageRight;
            pr.toHitRight = toHitRight;
            pr.rollRight = Compute.d6(2);
        } else if (aaa instanceof PushAttackAction) {
            PushAttackAction paa = (PushAttackAction) aaa;
            toHit = paa.toHit(game);
        } else if (aaa instanceof TripAttackAction) {
            TripAttackAction paa = (TripAttackAction) aaa;
            toHit = paa.toHit(game);
        } else if (aaa instanceof LayExplosivesAttackAction) {
            LayExplosivesAttackAction leaa = (LayExplosivesAttackAction) aaa;
            toHit = leaa.toHit(game);
            damage = LayExplosivesAttackAction.getDamageFor(ae);
        } else if (aaa instanceof ThrashAttackAction) {
            ThrashAttackAction taa = (ThrashAttackAction) aaa;
            toHit = taa.toHit(game);
            damage = ThrashAttackAction.getDamageFor(ae);
        } else if (aaa instanceof JumpJetAttackAction) {
            JumpJetAttackAction jaa = (JumpJetAttackAction) aaa;
            toHit = jaa.toHit(game);
            if (jaa.getLeg() == JumpJetAttackAction.BOTH) {
                damage = JumpJetAttackAction.getDamageFor(ae, JumpJetAttackAction.LEFT);
                pr.damageRight = JumpJetAttackAction.getDamageFor(ae, JumpJetAttackAction.LEFT);
            } else {
                damage = JumpJetAttackAction.getDamageFor(ae, jaa.getLeg());
                pr.damageRight = 0;
            }
            ae.heatBuildup += (damage + pr.damageRight) / 3;
        } else if (aaa instanceof GrappleAttackAction) {
            GrappleAttackAction taa = (GrappleAttackAction) aaa;
            toHit = taa.toHit(game);
        } else if (aaa instanceof BreakGrappleAttackAction) {
            BreakGrappleAttackAction taa = (BreakGrappleAttackAction) aaa;
            toHit = taa.toHit(game);
        } else if (aaa instanceof RamAttackAction) {
            RamAttackAction raa = (RamAttackAction) aaa;
            toHit = raa.toHit(game);
            damage = RamAttackAction.getDamageFor((IAero) ae, (Entity) aaa.getTarget(game));
        } else if (aaa instanceof TeleMissileAttackAction) {
            TeleMissileAttackAction taa = (TeleMissileAttackAction) aaa;
            assignTeleMissileAMS(taa);
            taa.calcCounterAV(game, taa.getTarget(game));
            toHit = taa.toHit(game);
            damage = TeleMissileAttackAction.getDamageFor(ae);
        } else if (aaa instanceof BAVibroClawAttackAction) {
            BAVibroClawAttackAction bvca = (BAVibroClawAttackAction) aaa;
            toHit = bvca.toHit(game);
            damage = BAVibroClawAttackAction.getDamageFor(ae);
        }
        pr.toHit = toHit;
        pr.damage = damage;
        return pr;
    }

    /**
     * Resolve a Physical Attack
     *
     * @param pr  The <code>PhysicalResult</code> of the physical attack
     * @param cen The <code>int</code> Entity Id of the entity whose physical
     *            attack was last resolved
     */
    private void resolvePhysicalAttack(PhysicalResult pr, int cen) {
        AbstractAttackAction aaa = pr.aaa;
        if (aaa instanceof PunchAttackAction) {
            PunchAttackAction paa = (PunchAttackAction) aaa;
            if (paa.getArm() == PunchAttackAction.BOTH) {
                paa.setArm(PunchAttackAction.LEFT);
                pr.aaa = paa;
                resolvePunchAttack(pr, cen);
                cen = paa.getEntityId();
                paa.setArm(PunchAttackAction.RIGHT);
                pr.aaa = paa;
                resolvePunchAttack(pr, cen);
            } else {
                resolvePunchAttack(pr, cen);
                cen = paa.getEntityId();
            }
        } else if (aaa instanceof KickAttackAction) {
            resolveKickAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BrushOffAttackAction) {
            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;
            if (baa.getArm() == BrushOffAttackAction.BOTH) {
                baa.setArm(BrushOffAttackAction.LEFT);
                pr.aaa = baa;
                resolveBrushOffAttack(pr, cen);
                cen = baa.getEntityId();
                baa.setArm(BrushOffAttackAction.RIGHT);
                pr.aaa = baa;
                resolveBrushOffAttack(pr, cen);
            } else {
                resolveBrushOffAttack(pr, cen);
                cen = baa.getEntityId();
            }
        } else if (aaa instanceof ThrashAttackAction) {
            resolveThrashAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {
            resolveProtoAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ClubAttackAction) {
            resolveClubAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof PushAttackAction) {
            resolvePushAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ChargeAttackAction) {
            resolveChargeAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof AirmechRamAttackAction) {
            resolveAirmechRamAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof DfaAttackAction) {
            resolveDfaAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof LayExplosivesAttackAction) {
            resolveLayExplosivesAttack(pr);
            cen = aaa.getEntityId();
        } else if (aaa instanceof TripAttackAction) {
            resolveTripAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof JumpJetAttackAction) {
            resolveJumpJetAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof GrappleAttackAction) {
            resolveGrappleAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BreakGrappleAttackAction) {
            resolveBreakGrappleAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof RamAttackAction) {
            resolveRamAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof TeleMissileAttackAction) {
            resolveTeleMissileAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BAVibroClawAttackAction) {
            resolveBAVibroClawAttack(pr, cen);
            cen = aaa.getEntityId();
        } else {
            LogManager.getLogger().error("Unknown attack action declared.");
        }
        // Not all targets are Entities.
        Targetable target = game.getTarget(aaa.getTargetType(), aaa.getTargetId());

        if ((target != null) && (target instanceof Entity)) {
            Entity targetEntity = (Entity) target;
            targetEntity.setStruck(true);
            targetEntity.addAttackedByThisTurn(target.getId());
            creditKill(targetEntity, game.getEntity(cen));
        }
    }

    /**
     * Add any extreme gravity PSRs the entity gets due to its movement
     *
     * @param entity
     *            The <code>Entity</code> to check.
     * @param step
     *            The last <code>MoveStep</code> of this entity
     * @param moveType
     *            The movement type for the MovePath the supplied MoveStep comes
     *            from. This generally comes from the last step in the move
     *            path.
     * @param curPos
     *            The current <code>Coords</code> of this entity
     * @param cachedMaxMPExpenditure
     *            Server checks run/jump MP at start of move, as appropriate,
     *            caches to avoid mid-move change in MP causing erroneous grav
     *            check
     */
    private void checkExtremeGravityMovement(Entity entity, MoveStep step,
                                             EntityMovementType moveType, Coords curPos,
                                             int cachedMaxMPExpenditure) {
        PilotingRollData rollTarget;
        if (game.getPlanetaryConditions().getGravity() != 1) {
            if ((entity instanceof Mech) || (entity instanceof Tank)) {
                if ((moveType == EntityMovementType.MOVE_WALK)
                        || (moveType == EntityMovementType.MOVE_VTOL_WALK)
                        || (moveType == EntityMovementType.MOVE_RUN)
                        || (moveType == EntityMovementType.MOVE_SPRINT)
                        || (moveType == EntityMovementType.MOVE_VTOL_RUN)
                        || (moveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
                    int limit = cachedMaxMPExpenditure;
                    if (step.isOnlyPavement() && entity.isEligibleForPavementBonus()) {
                        limit++;
                    }
                    if (step.getMpUsed() > limit) {
                        // We moved too fast, let's make PSR to see if we get
                        // damage
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    }
                } else if (moveType == EntityMovementType.MOVE_JUMP) {
                    LogManager.getLogger().debug("Gravity move check jump: "
                            + step.getMpUsed() + "/" + cachedMaxMPExpenditure);
                    int origWalkMP = entity.getWalkMP(false, false);
                    int gravWalkMP = entity.getWalkMP();
                    if (step.getMpUsed() > cachedMaxMPExpenditure) {
                        // Jumped too far, make PSR to see if we get damaged
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    } else if ((game.getPlanetaryConditions().getGravity() > 1)
                            && ((origWalkMP - gravWalkMP) > 0)) {
                        // jumping in high g is bad for your legs
                        // Damage dealt = 1 pt for each MP lost due to gravity
                        // Ignore this if no damage would be dealt
                        rollTarget = entity.getBasePilotingRoll(moveType);
                        entity.addPilotingModifierForTerrain(rollTarget, step);
                        int gravMod = game.getPlanetaryConditions()
                                .getGravityPilotPenalty();
                        if ((gravMod != 0) && !game.getBoard().inSpace()) {
                            rollTarget.addModifier(gravMod, game
                                    .getPlanetaryConditions().getGravity()
                                    + "G gravity");
                        }
                        rollTarget.append(new PilotingRollData(entity.getId(),
                                0, "jumped in high gravity"));
                        game.addExtremeGravityPSR(rollTarget);
                    }
                }
            }
        }
    }

    /**
     * Damage the inner structure of a mech's leg / a tank's front. This only
     * happens when the Entity fails an extreme Gravity PSR.
     *
     * @param entity The <code>Entity</code> to damage.
     * @param damage The <code>int</code> amount of damage.
     */
    private Vector<Report> doExtremeGravityDamage(Entity entity, int damage) {
        Vector<Report> vPhaseReport = new Vector<>();
        HitData hit;
        if (entity instanceof BipedMech) {
            for (int i = 6; i <= 7; i++) {
                hit = new HitData(i);
                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                        DamageType.NONE, true));
            }
        }
        if (entity instanceof QuadMech) {
            for (int i = 4; i <= 7; i++) {
                hit = new HitData(i);
                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                        DamageType.NONE, true));
            }
        } else if (entity instanceof Tank) {
            hit = new HitData(Tank.LOC_FRONT);
            vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                    DamageType.NONE, true));
            vPhaseReport.addAll(vehicleMotiveDamage((Tank) entity, 0));
        }
        return vPhaseReport;
    }

    /**
     * Eject an Entity.
     *
     * @param entity    The <code>Entity</code> to eject.
     * @param autoEject The <code>boolean</code> state of the entity's auto- ejection
     *                  system
     * @return a <code>Vector</code> of report objects for the game log.
     */
    public Vector<Report> ejectEntity(Entity entity, boolean autoEject) {
        return ejectEntity(entity, autoEject, false);
    }

    /**
     * Eject an Entity.
     *
     * @param entity            The <code>Entity</code> to eject.
     * @param autoEject         The <code>boolean</code> state of the entity's auto- ejection
     *                          system
     * @param skin_of_the_teeth Perform a skin of the teeth ejection
     * @return a <code>Vector</code> of report objects for the game log.
     */
    public Vector<Report> ejectEntity(Entity entity, boolean autoEject,
                                      boolean skin_of_the_teeth) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // An entity can only eject it's crew once.
        if (entity.getCrew().isEjected()) {
            return vDesc;
        }

        // If the crew are already dead, don't bother
        if (entity.isCarcass()) {
            return vDesc;
        }

        // Mek and fighter pilots may get hurt during ejection,
        // and run around the board afterwards.
        if (entity instanceof Mech || entity.isFighter()) {
            int facing = entity.getFacing();
            Coords targetCoords = (null != entity.getPosition())
                    ? entity.getPosition().translated((facing + 3) % 6) : null;
            if (entity.isSpaceborne() && entity.getPosition() != null) {
                //Pilots in space should eject into the fighter's hex, not behind it
                targetCoords = entity.getPosition();
            }

            if (autoEject) {
                r = new Report(6395);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.indent(2);
                vDesc.addElement(r);
            }

            // okay, print the info
            PilotingRollData rollTarget = getEjectModifiers(game, entity,
                    entity.getCrew().getCurrentPilotIndex(), autoEject);
            r = new Report(2180);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rollTarget.getLastPlainDesc(), true);
            r.indent();
            vDesc.addElement(r);
            for (int crewPos = 0; crewPos < entity.getCrew().getSlotCount(); crewPos++) {
                if (entity.getCrew().isMissing(crewPos)) {
                    continue;
                }
                rollTarget = getEjectModifiers(game, entity, crewPos,
                        autoEject);
                // roll
                final int diceRoll = entity.getCrew().rollPilotingSkill();
                if (entity.getCrew().getSlotCount() > 1) {
                    r = new Report(2193);
                    r.add(entity.getCrew().getNameAndRole(crewPos));
                } else {
                    r = new Report(2190);
                }
                r.subject = entity.getId();
                r.add(rollTarget.getValueAsString());
                r.add(rollTarget.getDesc());
                r.add(diceRoll);
                r.indent();
                if (diceRoll < rollTarget.getValue()) {
                    r.choose(false);
                    vDesc.addElement(r);
                    Report.addNewline(vDesc);
                    if ((rollTarget.getValue() - diceRoll) > 1) {
                        // Pilots take damage based on ejection roll MoF
                        int damage = (rollTarget.getValue() - diceRoll);
                        if (entity instanceof Mech) {
                            // MechWarriors only take 1 damage per 2 points of MoF
                            damage /= 2;
                        }
                        if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_DIFFICULT_EJECT)) {
                            damage++;
                        }
                        vDesc.addAll(damageCrew(entity, damage, crewPos));
                    }

                    // If this is a skin of the teeth ejection...
                    if (skin_of_the_teeth && (entity.getCrew().getHits(crewPos) < 6)) {
                        Report.addNewline(vDesc);
                        vDesc.addAll(damageCrew(entity, 6 - entity.getCrew()
                                .getHits(crewPos)));
                    }
                } else {
                    r.choose(true);
                    vDesc.addElement(r);
                }
            }
            // create the MechWarrior in any case, for campaign tracking
            MechWarrior pilot = new MechWarrior(entity);
            pilot.setDeployed(true);
            pilot.setId(game.getNextEntityId());
            pilot.setLanded(false);
            if (entity.isSpaceborne()) {
                //In space, ejected pilots retain the heading and velocity of the unit they eject from
                pilot.setVectors(entity.getVectors());
                pilot.setFacing(entity.getFacing());
                pilot.setCurrentVelocity(entity.getVelocity());
                //If the pilot ejects, he should no longer be accelerating
                pilot.setNextVelocity(entity.getVelocity());
            } else if (entity.isAirborne()) {
                pilot.setAltitude(entity.getAltitude());
            }
            //Pilot flight suits are vacuum-rated. MechWarriors wear shorts...
            pilot.setSpaceSuit(entity.isAero());
            game.addEntity(pilot);
            send(createAddEntityPacket(pilot.getId()));
            // make him not get a move this turn
            pilot.setDone(true);
            int living = 0;
            for (int i = 0; i < entity.getCrew().getSlotCount(); i++) {
                if (!entity.getCrew().isDead(i) && entity.getCrew().getHits(i) < Crew.DEATH) {
                    living++;
                }
            }
            pilot.setInternal(living, MechWarrior.LOC_INFANTRY);
            if (entity.getCrew().isDead() || entity.getCrew().getHits() >= Crew.DEATH) {
                pilot.setDoomed(true);
            }

            if (entity.getCrew().isDoomed()) {
                vDesc.addAll(destroyEntity(pilot, "deadly ejection", false,
                        false));
            } else {
                // Add the pilot as an infantry unit on the battlefield.
                if (game.getBoard().contains(targetCoords)) {
                    pilot.setPosition(targetCoords);
                    // report safe ejection
                    r = new Report(6400);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    // Update the entity
                    entityUpdate(pilot.getId());
                    // check if the pilot lands in a minefield
                    if (!entity.isAirborne()) {
                        vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot,
                                entity.getPosition(), targetCoords,
                                entity.getElevation()));
                    }
                } else {
                    // ejects safely
                    r = new Report(6410);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    game.removeEntity(pilot.getId(),
                            IEntityRemovalConditions.REMOVE_IN_RETREAT);
                    send(createRemoveEntityPacket(pilot.getId(),
                            IEntityRemovalConditions.REMOVE_IN_RETREAT));
                    // }
                }
                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)
                        // Don't create a pilot entity on low-atmospheric maps
                        || game.getBoard().inAtmosphere()) {
                    game.removeEntity(pilot.getId(),
                            IEntityRemovalConditions.REMOVE_IN_RETREAT);
                    send(createRemoveEntityPacket(pilot.getId(),
                            IEntityRemovalConditions.REMOVE_IN_RETREAT));
                }

                // If this is a skin of the teeth ejection...
                if (skin_of_the_teeth && (pilot.getCrew().getHits() < 5)) {
                    Report.addNewline(vDesc);
                    vDesc.addAll(damageCrew(pilot, 5 - pilot.getCrew()
                            .getHits()));
                }
            } // Crew safely ejects.

            // ejection damages the cockpit
            // kind of irrelevant in stand-alone games, but important for MekHQ
            if (entity instanceof Mech) {
                Mech mech = (Mech) entity;
                // in case of mechs with 'full head ejection', the head is treated as blown off
                if (mech.hasFullHeadEject()) {
                    entity.destroyLocation(Mech.LOC_HEAD, true);
                } else {
                    for (CriticalSlot slot : (mech.getCockpit())) {
                        slot.setDestroyed(true);
                    }
                }
            }
        } // End entity-is-Mek or fighter
        else if (game.getBoard().contains(entity.getPosition())
                && (entity instanceof Tank)) {
            EjectedCrew crew = new EjectedCrew(entity);
            // Need to set game manually; since game.addEntity not called yet
            // Don't want to do this yet, as Entity may not be added
            crew.setGame(game);
            crew.setDeployed(true);
            crew.setId(game.getNextEntityId());
            // Make them not get a move this turn
            crew.setDone(true);
            // Place on board
            // Vehicles don't have ejection systems, so crew must abandon into
            // a legal hex
            Coords legalPosition = null;
            if (!crew.isLocationProhibited(entity.getPosition())) {
                legalPosition = entity.getPosition();
            } else {
                for (int dir = 0; (dir < 6) && (legalPosition == null); dir++) {
                    Coords adjCoords = entity.getPosition().translated(dir);
                    if (!crew.isLocationProhibited(adjCoords)) {
                        legalPosition = adjCoords;
                    }
                }
            }
            // Cannot abandon if there is no legal hex. This shouldn't have been allowed
            if (legalPosition == null) {
                LogManager.getLogger().error("Vehicle crews cannot abandon if there is no legal hex!");
                return vDesc;
            }
            crew.setPosition(legalPosition);
            // Add Entity to game
            game.addEntity(crew);
            // Tell clients about new entity
            send(createAddEntityPacket(crew.getId()));
            // Sent entity info to clients
            entityUpdate(crew.getId());
            // Check if the crew lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew,
                    entity.getPosition(), entity.getPosition(),
                    entity.getElevation()));
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {
                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        } //End ground vehicles

        // Mark the entity's crew as "ejected".
        entity.getCrew().setEjected(true);
        if (entity instanceof VTOL) {
            vDesc.addAll(crashVTOLorWiGE((VTOL) entity));
        }
        vDesc.addAll(destroyEntity(entity, "ejection", true, true));

        // only remove the unit that ejected manually
        if (!autoEject) {
            game.removeEntity(entity.getId(),
                    IEntityRemovalConditions.REMOVE_EJECTED);
            send(createRemoveEntityPacket(entity.getId(),
                    IEntityRemovalConditions.REMOVE_EJECTED));
        }
        return vDesc;
    }

    /**
     * Abandon a spacecraft (large or small).
     *
     * @param entity  The <code>Aero</code> to eject.
     * @param inSpace Is this ship spaceborne?
     * @param airborne Is this ship in atmospheric flight?
     * @param pos The coords of this ejection. Needed when abandoning a grounded ship
     * @return a <code>Vector</code> of report objects for the gamelog.
     */
    public Vector<Report> ejectSpacecraft(Aero entity, boolean inSpace, boolean airborne, Coords pos) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // An entity can only eject it's crew once.
        if (entity.getCrew().isEjected()) {
            return vDesc;
        }

        // If the crew are already dead, don't bother
        if (entity.isCarcass()) {
            return vDesc;
        }

        // Try to launch some escape pods and lifeboats, if any are left
        if ((inSpace && (entity.getPodsLeft() > 0 || entity.getLifeBoatsLeft() > 0))
                || (airborne && entity.getPodsLeft() > 0)) {
            // Report the ejection
            PilotingRollData rollTarget = getEjectModifiers(game, entity,
                    entity.getCrew().getCurrentPilotIndex(), false);
            r = new Report(2180);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rollTarget.getLastPlainDesc(), true);
            r.indent();
            vDesc.addElement(r);
            int roll = Compute.d6(2);
            int MOS = (roll - Math.max(2, rollTarget.getValue()));
            //Report the roll
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(roll);
            r.indent();
            r.choose(roll >= rollTarget.getValue());
            vDesc.addElement(r);
            //Per SO p27, you get a certain number of escape pods away per turn per 100k tons of ship
            int escapeMultiplier = (int) (entity.getWeight() / 100000);
            //Set up the maximum number that CAN launch
            int toLaunch = 0;
            if (roll < rollTarget.getValue()) {
                toLaunch = 1;
            } else {
                toLaunch = (1 + MOS) * Math.max(1, escapeMultiplier);
            }
            //And now modify it based on what the unit actually has TO launch
            int launchCounter = toLaunch;
            int totalLaunched = 0;
            boolean isPod = false;
            while (launchCounter > 0) {
                int launched = 0;
                if (entity.getPodsLeft() > 0 && (airborne || entity.getPodsLeft() >= entity.getLifeBoatsLeft())) {
                    //Entity has more escape pods than lifeboats (or equal numbers)
                    launched = Math.min(launchCounter, entity.getPodsLeft());
                    entity.setLaunchedEscapePods(entity.getLaunchedEscapePods() + launched);
                    totalLaunched += launched;
                    launchCounter -= launched;
                    isPod = true;
                } else if (inSpace && entity.getLifeBoatsLeft() > 0 && (entity.getLifeBoatsLeft() > entity.getPodsLeft())) {
                    //Entity has more lifeboats left
                    launched = Math.min(launchCounter, entity.getLifeBoatsLeft());
                    entity.setLaunchedLifeBoats(entity.getLaunchedLifeBoats() + launched);
                    totalLaunched += launched;
                    launchCounter -= launched;
                } else {
                    //We've run out of both. End the loop
                    break;
                }
            }
            int nEscaped = Math.min((entity.getCrew().getCurrentSize() + entity.getNPassenger()), (totalLaunched * 6));
            //Report how many pods launched and how many escaped
            if (totalLaunched > 0) {
                r = new Report(6401);
                r.subject = entity.getId();
                r.indent();
                r.add(totalLaunched);
                r.add(nEscaped);
                vDesc.addElement(r);
            }
            EscapePods pods = new EscapePods(entity, totalLaunched, isPod);
            entity.addEscapeCraft(pods.getExternalIdAsString());
            //Update the personnel numbers

            //If there are passengers aboard, get them out first
            if (entity.getNPassenger() > 0) {
                int change = Math.min(entity.getNPassenger(), nEscaped);
                entity.setNPassenger(Math.max(entity.getNPassenger() - nEscaped, 0));
                pods.addPassengers(entity.getExternalIdAsString(), change);
                nEscaped -= change;
            }
            //Now get the crew out with such space as is left
            if (nEscaped > 0) {
                entity.setNCrew(entity.getNCrew() - nEscaped);
                entity.getCrew().setCurrentSize(Math.max(0, entity.getCrew().getCurrentSize() - nEscaped));
                pods.addNOtherCrew(entity.getExternalIdAsString(), nEscaped);
                //*Damage* the host ship's crew to account for the people that left
                vDesc.addAll(damageCrew(entity, entity.getCrew().calculateHits()));
                if (entity.getCrew().getHits() >= Crew.DEATH) {
                    //Then we've finished ejecting
                    entity.getCrew().setEjected(true);
                }
            }
            // Need to set game manually; since game.addEntity not called yet
            // Don't want to do this yet, as Entity may not be added
            pods.setPosition(entity.getPosition());
            pods.setGame(game);
            pods.setDeployed(true);
            pods.setId(game.getNextEntityId());
            //Escape craft retain the heading and velocity of the unit they eject from
            pods.setVectors(entity.getVectors());
            pods.setFacing(entity.getFacing());
            pods.setCurrentVelocity(entity.getCurrentVelocity());
            //If the crew ejects, they should no longer be accelerating
            pods.setNextVelocity(entity.getVelocity());
            if (entity.isAirborne()) {
                pods.setAltitude(entity.getAltitude());
            }
            // Add Entity to game
            game.addEntity(pods);
            // No movement this turn
            pods.setDone(true);
            // Tell clients about new entity
            send(createAddEntityPacket(pods.getId()));
            // Sent entity info to clients
            entityUpdate(pods.getId());
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {
                game.removeEntity(pods.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(pods.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        } // End Escape Pod/Lifeboat Ejection
        else {
            if (airborne) {
                // Can't abandon in atmosphere with no escape pods
                r = new Report(6402);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.indent();
                vDesc.addElement(r);
                return vDesc;
            }

            // Eject up to 50 spacesuited crewmen out the nearest airlock!
            // This only works in space or on the ground
            int nEscaped = Math.min(entity.getNPassenger() + entity.getCrew().getCurrentSize(), 50);
            EjectedCrew crew = new EjectedCrew(entity, nEscaped);
            entity.addEscapeCraft(crew.getExternalIdAsString());

            //Report the escape
            r = new Report(6403);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(nEscaped);
            r.indent();
            vDesc.addElement(r);

            //If there are passengers aboard, get them out first
            if (entity.getNPassenger() > 0) {
                int change = Math.min(entity.getNPassenger(), nEscaped);
                entity.setNPassenger(Math.max(entity.getNPassenger() - nEscaped, 0));
                crew.addPassengers(entity.getExternalIdAsString(), change);
                nEscaped -= change;
            }
            //Now get the crew out with such airlock space as is left
            if (nEscaped > 0) {
                entity.setNCrew(entity.getNCrew() - nEscaped);
                entity.getCrew().setCurrentSize(Math.max(0, entity.getCrew().getCurrentSize() - nEscaped));
                crew.addNOtherCrew(entity.getExternalIdAsString(), nEscaped);
                //*Damage* the host ship's crew to account for the people that left
                vDesc.addAll(damageCrew(entity, entity.getCrew().calculateHits()));
                if (entity.getCrew().getHits() >= Crew.DEATH) {
                    //Then we've finished ejecting
                    entity.getCrew().setEjected(true);
                }
            }

            // Need to set game manually; since game.addEntity not called yet
            // Don't want to do this yet, as Entity may not be added
            crew.setGame(game);
            crew.setDeployed(true);
            crew.setId(game.getNextEntityId());
            if (inSpace) {
                //In space, ejected pilots retain the heading and velocity of the unit they eject from
                crew.setVectors(entity.getVectors());
                crew.setFacing(entity.getFacing());
                crew.setCurrentVelocity(entity.getVelocity());
                //If the crew ejects, they should no longer be accelerating
                crew.setNextVelocity(entity.getVelocity());
                // We're going to be nice and assume a ship has enough spacesuits for everyone aboard...
                crew.setSpaceSuit(true);
                crew.setPosition(entity.getPosition());
            } else {
                // On the ground, crew must abandon into a legal hex
                Coords legalPosition = null;
                //Small Craft can just abandon into the hex they occupy
                if (!entity.isLargeCraft() && !crew.isLocationProhibited(entity.getPosition())) {
                    legalPosition = entity.getPosition();
                } else {
                    //Use the passed in coords. We already calculated whether they're legal or not
                    legalPosition = pos;
                }
                // Cannot abandon if there is no legal hex.  This shoudln't have
                // been allowed
                if (legalPosition == null) {
                    LogManager.getLogger().error("Spacecraft crews cannot abandon if there is no legal hex!");
                    return vDesc;
                }
                crew.setPosition(legalPosition);
            }
            // Add Entity to game
            game.addEntity(crew);
            // No movement this turn
            crew.setDone(true);
            // Tell clients about new entity
            send(createAddEntityPacket(crew.getId()));
            // Sent entity info to clients
            entityUpdate(crew.getId());
            // Check if the crew lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew, entity.getPosition(),
                    entity.getPosition(), entity.getElevation()));
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {
                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        }
        // If we get here, end movement and return the report
        entity.setDone(true);
        entityUpdate(entity.getId());
        return vDesc;
    }

    public static PilotingRollData getEjectModifiers(Game game, Entity entity, int crewPos,
                                                     boolean autoEject) {
        int facing = entity.getFacing();
        if (entity.isPartOfFighterSquadron()) {
            // Because the components of a squadron have no position and will pass the next test
            Entity squadron = game.getEntity(entity.getTransportId());
            return getEjectModifiers(game, entity, crewPos, autoEject, squadron.getPosition(),
                    "ejecting");
        }
        if (null == entity.getPosition()) {
            // Off-board unit?
            return new PilotingRollData(entity.getId(), entity.getCrew().getPiloting(), "ejecting");
        }
        Coords targetCoords = entity.getPosition().translated((facing + 3) % 6);
        return getEjectModifiers(game, entity, crewPos, autoEject, targetCoords, "ejecting");
    }

    public static PilotingRollData getEjectModifiers(Game game, Entity entity, int crewPos,
                                                     boolean autoEject, Coords targetCoords, String desc) {
        PilotingRollData rollTarget = new PilotingRollData(entity.getId(),
                entity.getCrew().getPiloting(crewPos), desc);
        // Per SO p26, fighters can eject as per TO rules on 196 with some exceptions
        if (entity.isProne()) {
            rollTarget.addModifier(5, "Mech is prone");
        }
        if (entity.getCrew().isUnconscious(crewPos)) {
            rollTarget.addModifier(3, "pilot unconscious");
        }
        if (autoEject) {
            rollTarget.addModifier(1, "automatic ejection");
        }
        // Per SO p27, Large Craft roll too, to see how many escape pods launch successfully
        if ((entity.isAero() && ((IAero) entity).isOutControl())
                || (entity.isPartOfFighterSquadron() && ((IAero) game.getEntity(entity.getTransportId())).isOutControl())) {
            rollTarget.addModifier(5, "Out of Control");
        }
        // A decreased large craft crew makes it harder to eject large numbers of pods
        if (entity.isLargeCraft() && entity.getCrew().getHits() > 0) {
            rollTarget.addModifier(entity.getCrew().getHits(), "Crew hits");
        }
        if ((entity instanceof Mech)
                && (entity.getInternal(Mech.LOC_HEAD) < entity.getOInternal(Mech.LOC_HEAD))) {
            rollTarget.addModifier(entity.getOInternal(Mech.LOC_HEAD) - entity.getInternal(Mech.LOC_HEAD),
                    "Head Internal Structure Damage");
        }
        Hex targetHex = game.getBoard().getHex(targetCoords);
        //Terrain modifiers should only apply if the unit is on the ground...
        if (!entity.isSpaceborne() && !entity.isAirborne()) {
            if (targetHex != null) {
                if ((targetHex.terrainLevel(Terrains.WATER) > 0)
                        && !targetHex.containsTerrain(Terrains.ICE)) {
                    rollTarget.addModifier(-1, "landing in water");
                } else if (targetHex.containsTerrain(Terrains.ROUGH)) {
                    rollTarget.addModifier(0, "landing in rough");
                } else if (targetHex.containsTerrain(Terrains.RUBBLE)) {
                    rollTarget.addModifier(0, "landing in rubble");
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 1) {
                    rollTarget.addModifier(2, "landing in light woods");
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 2) {
                    rollTarget.addModifier(3, "landing in heavy woods");
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 3) {
                    rollTarget.addModifier(4, "landing in ultra heavy woods");
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 1) {
                    rollTarget.addModifier(3, "landing in light jungle");
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 2) {
                    rollTarget.addModifier(5, "landing in heavy jungle");
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 3) {
                    rollTarget.addModifier(7, "landing in ultra heavy jungle");
                } else if (targetHex.terrainLevel(Terrains.BLDG_ELEV) > 0) {
                    rollTarget.addModifier(
                            targetHex.terrainLevel(Terrains.BLDG_ELEV),
                            "landing in a building");
                } else {
                    rollTarget.addModifier(-2, "landing in clear terrain");
                }
            } else {
                rollTarget.addModifier(-2, "landing off the board");
            }
        }
        if (!entity.isSpaceborne()) {
            // At present, the UI lets you set these atmospheric conditions for a space battle, but it shouldn't
            // That's a fix for another day, probably when I get around to space terrain and 'weather'
            if (game.getPlanetaryConditions().getGravity() == 0) {
                rollTarget.addModifier(3, "Zero-G");
            } else if (game.getPlanetaryConditions().getGravity() < 0.8) {
                rollTarget.addModifier(2, "Low-G");
            } else if (game.getPlanetaryConditions().getGravity() > 1.2) {
                rollTarget.addModifier(2, "High-G");
            }

            //Vacuum shouldn't apply to ASF ejection since they're designed for it, but the rules don't specify
            //High and low pressures make more sense to apply to all
            if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VACUUM) {
                rollTarget.addModifier(3, "Vacuum");
            } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VHIGH) {
                rollTarget.addModifier(2, "Very High Atmosphere Pressure");
            } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE) {
                rollTarget.addModifier(2, "Trace atmosphere");
            }
        }

        if ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW)
                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_ICE_STORM)
                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_DOWNPOUR)
                || (game.getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE)) {
            rollTarget.addModifier(2, "Bad Weather");
        }

        if ((game.getPlanetaryConditions().getWindStrength() >= PlanetaryConditions.WI_STORM)
                || ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW) && (game
                .getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE))) {
            rollTarget.addModifier(3, "Really Bad Weather");
        }
        return rollTarget;
    }

    /**
     * Creates a new Ballistic Infantry unit at the end of the movement phase
     */
    public void resolveCallSupport() {
        for (Entity e : game.getEntitiesVector()) {
            if ((e instanceof Infantry) && ((Infantry) e).getIsCallingSupport()) {

                // Now lets create a new foot platoon
                Infantry guerrilla = new Infantry();
                guerrilla.setChassis("Insurgents");
                guerrilla.setModel("(Rifle)");
                guerrilla.setSquadCount(4);
                guerrilla.setSquadSize(7);
                guerrilla.autoSetInternal();
                guerrilla.getCrew().setGunnery(5, 0);
                try {
                    guerrilla.addEquipment(EquipmentType.get(EquipmentTypeLookup.INFANTRY_ASSAULT_RIFLE),
                            Infantry.LOC_INFANTRY);
                    guerrilla.setPrimaryWeapon((InfantryWeapon) InfantryWeapon
                            .get(EquipmentTypeLookup.INFANTRY_ASSAULT_RIFLE));
                } catch (Exception ex) {
                    LogManager.getLogger().error("", ex);
                }
                guerrilla.setDeployed(true);
                guerrilla.setDone(true);
                guerrilla.setId(game.getNextEntityId());
                guerrilla.setOwner(e.getOwner());
                game.addEntity(guerrilla);

                // Add the infantry unit on the battlefield. Should spawn within 3 hexes
                // First get coords then loop over some targets
                Coords tmpCoords = e.getPosition();
                Coords targetCoords = null;
                while (!game.getBoard().contains(targetCoords)) {
                    targetCoords = Compute.scatter(tmpCoords, (Compute.d6(1) / 2));
                    if (game.getBoard().contains(targetCoords)) {
                        guerrilla.setPosition(targetCoords);
                        break;
                    }
                }
                send(createAddEntityPacket(guerrilla.getId()));
                ((Infantry) e).setIsCallingSupport(false);
                /*
                // Update the entity
                entityUpdate(guerrilla.getId());
                Report r = new Report(5535, Report.PUBLIC);
                r.subject = e.getId();
                r.addDesc(e);
                addReport(r);*/
            }
        }
    }

    /**
     * Abandon an Entity.
     *
     * @param entity The <code>Entity</code> to abandon.
     * @return a <code>Vector</code> of report objects for the game log.
     */
    public Vector<Report> abandonEntity(Entity entity) {
        Vector<Report> vDesc = new Vector<>();
        Report r;

        // An entity can only eject it's crew once.
        if (entity.getCrew().isEjected()) {
            return vDesc;
        }

        if (entity.getCrew().isDoomed() || entity.getCrew().isDead()) {
            return vDesc;
        }

        Coords targetCoords = entity.getPosition();

        if (entity instanceof Mech || (entity.isAero() && !entity.isAirborne())) {
            // okay, print the info
            r = new Report(2027);
            r.subject = entity.getId();
            r.add(entity.getCrew().getName());
            r.addDesc(entity);
            r.indent(3);
            vDesc.addElement(r);
            // Don't make ill-equipped pilots abandon into vacuum
            if (game.getPlanetaryConditions().isVacuum() && !entity.isAero()) {
                return vDesc;
            }

            // create the MechWarrior in any case, for campaign tracking
            MechWarrior pilot = new MechWarrior(entity);
            pilot.getCrew().setUnconscious(entity.getCrew().isUnconscious());
            pilot.setDeployed(true);
            pilot.setId(game.getNextEntityId());
            //Pilot flight suits are vacuum-rated. MechWarriors wear shorts...
            pilot.setSpaceSuit(entity.isAero());
            if (entity.isSpaceborne()) {
                //In space, ejected pilots retain the heading and velocity of the unit they eject from
                pilot.setVectors(entity.getVectors());
                pilot.setFacing(entity.getFacing());
                pilot.setCurrentVelocity(entity.getVelocity());
                //If the pilot ejects, he should no longer be accelerating
                pilot.setNextVelocity(entity.getVelocity());
            }
            game.addEntity(pilot);
            send(createAddEntityPacket(pilot.getId()));
            // make him not get a move this turn
            pilot.setDone(true);
            // Add the pilot as an infantry unit on the battlefield.
            if (game.getBoard().contains(targetCoords)) {
                pilot.setPosition(targetCoords);
            }
            pilot.setCommander(entity.isCommander());
            // Update the entity
            entityUpdate(pilot.getId());
            // check if the pilot lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot, entity.getPosition(),
                    targetCoords, entity.getElevation()));
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {
                game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(pilot.getId(),
                        IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        } // End entity-is-Mek or Aero
        else if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLES_CAN_EJECT)
                && (entity instanceof Tank)) {
            // Don't make them abandon into vacuum
            if (game.getPlanetaryConditions().isVacuum()) {
                return vDesc;
            }
            EjectedCrew crew = new EjectedCrew(entity);
            crew.setDeployed(true);
            crew.setId(game.getNextEntityId());
            game.addEntity(crew);
            send(createAddEntityPacket(crew.getId()));
            // Make them not get a move this turn
            crew.setDone(true);
            // Place on board
            if (game.getBoard().contains(entity.getPosition())) {
                crew.setPosition(entity.getPosition());
            }
            // Update the entity
            entityUpdate(crew.getId());
            // Check if the crew lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew, entity.getPosition(),
                    entity.getPosition(), entity.getElevation()));
            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {
                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        }

        // Mark the entity's crew as "ejected".
        entity.getCrew().setEjected(true);

        return vDesc;
    }

    /**
     * Checks if ejected MechWarriors are eligible to be picked up, and if so,
     * captures them or picks them up
     */
    private void resolveMechWarriorPickUp() {
        Report r;

        // fetch all mechWarriors that are not picked up
        Iterator<Entity> mechWarriors = game.getSelectedEntities(entity -> {
            if (entity instanceof MechWarrior) {
                MechWarrior mw = (MechWarrior) entity;
                return (mw.getPickedUpById() == Entity.NONE)
                        && !mw.isDoomed()
                        && (mw.getTransportId() == Entity.NONE);
            }
            return false;
        });
        // loop through them, check if they are in a hex occupied by another
        // unit
        while (mechWarriors.hasNext()) {
            boolean pickedUp = false;
            MechWarrior e = (MechWarrior) mechWarriors.next();
            // Check for owner entities first...
            for (Entity pe : game.getEntitiesVector(e.getPosition())) {
                if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()
                        || (pe.isAirborne() && !pe.isSpaceborne())
                        || (pe.getElevation() != e.getElevation())
                        || (pe.getOwnerId() != e.getOwnerId())
                        || (pe.getId() == e.getId())) {
                    continue;
                }
                if (pe instanceof MechWarrior) {
                    // MWs have a beer together
                    r = new Report(6415, Report.PUBLIC);
                    r.add(pe.getDisplayName());
                    addReport(r);
                    continue;
                }
                // Pick up the unit.
                pe.pickUp(e);
                // The picked unit is being carried by the loader.
                e.setPickedUpById(pe.getId());
                e.setPickedUpByExternalId(pe.getExternalIdAsString());
                pickedUp = true;
                r = new Report(6420, Report.PUBLIC);
                r.add(e.getDisplayName());
                r.addDesc(pe);
                addReport(r);
                break;
            }
            // Check for allied entities next...
            if (!pickedUp) {
                for (Entity pe : game.getEntitiesVector(e.getPosition())) {
                    if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()
                            || (pe.isAirborne() && !pe.isSpaceborne())
                            || (pe.getElevation() != e.getElevation())
                            || (pe.getOwnerId() == e.getOwnerId()) || (pe.getId() == e.getId())
                            || (pe.getOwner().getTeam() == Player.TEAM_NONE)
                            || (pe.getOwner().getTeam() != e.getOwner().getTeam())) {
                        continue;
                    }
                    if (pe instanceof MechWarrior) {
                        // MWs have a beer together
                        r = new Report(6416, Report.PUBLIC);
                        r.add(pe.getDisplayName());
                        addReport(r);
                        continue;
                    }
                    // Pick up the unit.
                    pe.pickUp(e);
                    // The picked unit is being carried by the loader.
                    e.setPickedUpById(pe.getId());
                    e.setPickedUpByExternalId(pe.getExternalIdAsString());
                    pickedUp = true;
                    r = new Report(6420, Report.PUBLIC);
                    r.add(e.getDisplayName());
                    r.addDesc(pe);
                    addReport(r);
                    break;
                }
            }
            // Now check for anyone else...
            if (!pickedUp) {
                Iterator<Entity> pickupEnemyEntities = game.getEnemyEntities(e.getPosition(), e);
                while (pickupEnemyEntities.hasNext()) {
                    Entity pe = pickupEnemyEntities.next();
                    if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()
                            || pe.isAirborne() || (pe.getElevation() != e.getElevation())) {
                        continue;
                    }
                    if (pe instanceof MechWarrior) {
                        // MWs have a beer together
                        r = new Report(6417, Report.PUBLIC);
                        r.add(pe.getDisplayName());
                        addReport(r);
                        continue;
                    }
                    // Capture the unit.
                    pe.pickUp(e);
                    // The captured unit is being carried by the loader.
                    e.setCaptured(true);
                    e.setPickedUpById(pe.getId());
                    e.setPickedUpByExternalId(pe.getExternalIdAsString());
                    pickedUp = true;
                    r = new Report(6420, Report.PUBLIC);
                    r.add(e.getDisplayName());
                    r.addDesc(pe);
                    addReport(r);
                    break;
                }
            }
            if (pickedUp) {
                // Remove the picked-up unit from the screen.
                e.setPosition(null);
                // Update the loaded unit.
                entityUpdate(e.getId());
            }
        }
    }

    /**
     * destroy all wheeled and tracked Tanks that got displaced into water
     */
    private void resolveSinkVees() {
        Iterator<Entity> sinkableTanks = game.getSelectedEntities(entity -> {
            if (entity.isOffBoard() || (entity.getPosition() == null)
                    || !(entity instanceof Tank)) {
                return false;
            }
            final Hex hex = game.getBoard().getHex(entity.getPosition());
            final boolean onBridge = (hex.terrainLevel(Terrains.BRIDGE) > 0)
                    && (entity.getElevation() == hex.terrainLevel(Terrains.BRIDGE_ELEV));
            return ((entity.getMovementMode() == EntityMovementMode.TRACKED)
                    || (entity.getMovementMode() == EntityMovementMode.WHEELED)
                    || ((entity.getMovementMode() == EntityMovementMode.HOVER)))
                    && entity.isImmobile() && (hex.terrainLevel(Terrains.WATER) > 0)
                    && !onBridge && !(entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS))
                    && !(entity.hasWorkingMisc(MiscType.F_FLOTATION_HULL));
        });
        while (sinkableTanks.hasNext()) {
            Entity e = sinkableTanks.next();
            addReport(destroyEntity(e, "a watery grave", false));
        }
    }

    /**
     * let all Entities make their "break-free-of-swamp-stickyness" PSR
     */
    private void doTryUnstuck() {
        if (!getGame().getPhase().isMovement()) {
            return;
        }

        Report r;

        Iterator<Entity> stuckEntities = game.getSelectedEntities(Entity::isStuck);
        PilotingRollData rollTarget;
        while (stuckEntities.hasNext()) {
            Entity entity = stuckEntities.next();
            if (entity.getPosition() == null) {
                if (entity.isDeployed()) {
                    LogManager.getLogger().info("Entity #" + entity.getId() + " does not know its position.");
                } else { // If the Entity isn't deployed, then something goofy
                    // happened.  We'll just unstuck the Entity
                    entity.setStuck(false);
                    LogManager.getLogger().info("Entity #" + entity.getId() + " was stuck in a swamp, but not deployed. Stuck state reset");
                }
                continue;
            }
            rollTarget = entity.getBasePilotingRoll();
            entity.addPilotingModifierForTerrain(rollTarget);
            // apart from swamp & liquid magma, -1 modifier
            Hex hex = game.getBoard().getHex(entity.getPosition());
            hex.getUnstuckModifier(entity.getElevation(), rollTarget);
            // okay, print the info
            r = new Report(2340);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);

            // roll
            final int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            if (diceRoll < rollTarget.getValue()) {
                r.choose(false);
            } else {
                r.choose(true);
                entity.setStuck(false);
                entity.setCanUnstickByJumping(false);
                entity.setElevation(0);
                entityUpdate(entity.getId());
            }
            addReport(r);
        }
    }

    /**
     * Remove all iNarc pods from all vehicles that did not move and shoot this
     * round NOTE: this is not quite what the rules say, the player should be
     * able to choose whether or not to remove all iNarc Pods that are attached.
     */
    private void resolveVeeINarcPodRemoval() {
        Iterator<Entity> vees = game.getSelectedEntities(
                entity -> (entity instanceof Tank) && (entity.mpUsed == 0));
        boolean canSwipePods;
        while (vees.hasNext()) {
            canSwipePods = true;
            Entity entity = vees.next();
            for (int i = 0; i <= 5; i++) {
                if (entity.weaponFiredFrom(i)) {
                    canSwipePods = false;
                }
            }
            if (((Tank) entity).getStunnedTurns() > 0) {
                canSwipePods = false;
            }
            if (canSwipePods && entity.hasINarcPodsAttached()
                    && entity.getCrew().isActive()) {
                entity.removeAllINarcPods();
                Report r = new Report(2345);
                r.addDesc(entity);
                addReport(r);
            }
        }
    }

    /**
     * remove Ice in the hex that's at the passed coords, and let entities fall
     * into water below it, if there is water
     *
     * @param c the <code>Coords</code> of the hex where ice should be removed
     * @return a <code>Vector<Report></code> for the phase report
     */
    private Vector<Report> resolveIceBroken(Coords c) {
        Vector<Report> vPhaseReport = new Vector<>();
        Hex hex = game.getBoard().getHex(c);
        hex.removeTerrain(Terrains.ICE);
        sendChangedHex(c);
        // if there is water below the ice
        if (hex.terrainLevel(Terrains.WATER) > 0) {
            // drop entities on the surface into the water
            for (Entity e : game.getEntitiesVector(c)) {
                // If the unit is on the surface, and is no longer allowed in
                // the hex
                boolean isHoverOrWiGE = (e.getMovementMode() == EntityMovementMode.HOVER)
                        || (e.getMovementMode() == EntityMovementMode.WIGE);
                if ((e.getElevation() == 0)
                        && !(hex.containsTerrain(Terrains.BLDG_ELEV, 0))
                        && !(isHoverOrWiGE && (e.getRunMP() >= 0))
                        && (e.getMovementMode() != EntityMovementMode.INF_UMU)
                        && !e.hasUMU()
                        && !(e instanceof QuadVee && e.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)) {
                    vPhaseReport.addAll(doEntityFallsInto(e, c,
                            new PilotingRollData(TargetRoll.AUTOMATIC_FAIL),
                            true));
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * melt any snow or ice in a hex, including checking for the effects of
     * breaking through ice
     */
    private Vector<Report> meltIceAndSnow(Coords c, int entityId) {
        Vector<Report> vDesc = new Vector<>();
        Report r;
        Hex hex = game.getBoard().getHex(c);
        r = new Report(3069);
        r.indent(2);
        r.subject = entityId;
        vDesc.add(r);
        if (hex.containsTerrain(Terrains.SNOW)) {
            hex.removeTerrain(Terrains.SNOW);
            sendChangedHex(c);
        }
        if (hex.containsTerrain(Terrains.ICE)) {
            vDesc.addAll(resolveIceBroken(c));
        }
        // if we were not in water, then add mud
        if (!hex.containsTerrain(Terrains.MUD) && !hex.containsTerrain(Terrains.WATER)) {
            hex.addTerrain(new Terrain(Terrains.MUD, 1));
            sendChangedHex(c);
        }
        return vDesc;
    }

    /**
     * check to see if a swamp hex becomes quicksand
     */
    private Vector<Report> checkQuickSand(Coords c) {
        Vector<Report> vDesc = new Vector<>();
        Report r;
        Hex hex = game.getBoard().getHex(c);
        if (hex.terrainLevel(Terrains.SWAMP) == 1) {
            if (Compute.d6(2) == 12) {
                // better find a rope
                hex.removeTerrain(Terrains.SWAMP);
                hex.addTerrain(new Terrain(Terrains.SWAMP, 2));
                sendChangedHex(c);
                r = new Report(2440);
                r.indent(1);
                vDesc.add(r);
            }
        }
        return vDesc;
    }

    private Vector<Report> resolveVehicleFire(Tank tank, boolean existingStatus) {
        Vector<Report> vPhaseReport = new Vector<>();
        if (existingStatus && !tank.isOnFire()) {
            return vPhaseReport;
        }
        for (int i = 0; i < tank.locations(); i++) {
            if ((i == Tank.LOC_BODY) || ((tank instanceof VTOL) && (i == VTOL.LOC_ROTOR))) {
                continue;
            }
            if (existingStatus && !tank.isLocationBurning(i)) {
                continue;
            }
            HitData hit = new HitData(i);
            int damage = Compute.d6(1);
            vPhaseReport.addAll(damageEntity(tank, hit, damage));
            if ((damage == 1) && existingStatus) {
                tank.extinguishLocation(i);
            }
        }
        return vPhaseReport;
    }

    public Vector<Report> vehicleMotiveDamage(Tank te, int modifier) {
        return vehicleMotiveDamage(te, modifier, false, -1, false);
    }

    private Vector<Report> vehicleMotiveDamage(Tank te, int modifier, boolean noRoll,
                                               int damageType) {
        return vehicleMotiveDamage(te, modifier, noRoll, damageType, false);
    }

    /**
     * do vehicle movement damage
     *
     * @param te         the Tank to damage
     * @param modifier   the modifier to the roll
     * @param noRoll     don't roll, immediately deal damage
     * @param damageType the type to deal (1 = minor, 2 = moderate, 3 = heavy
     * @param jumpDamage is this a movement damage roll from using vehicular JJs
     * @return a <code>Vector<Report></code> containing what to add to the turn log
     */
    private Vector<Report> vehicleMotiveDamage(Tank te, int modifier, boolean noRoll,
                                               int damageType, boolean jumpDamage) {
        Vector<Report> vDesc = new Vector<>();
        Report r;
        switch (te.getMovementMode()) {
            case HOVER:
            case HYDROFOIL:
                if (jumpDamage) {
                    modifier -= 1;
                } else {
                    modifier += 3;
                }
                break;
            case WHEELED:
                if (jumpDamage) {
                    modifier += 1;
                } else {
                    modifier += 2;
                }
                break;
            case WIGE:
                if (jumpDamage) {
                    modifier -= 2;
                } else {
                    modifier += 4;
                }
                break;
            case TRACKED:
                if (jumpDamage) {
                    modifier += 2;
                }
                break;
            case VTOL:
                // VTOL don't roll, auto -1 MP as long as the rotor location
                // still exists (otherwise don't bother reporting).
                if (!(te.isLocationBad(VTOL.LOC_ROTOR) || te.isLocationDoomed(VTOL.LOC_ROTOR))) {
                    te.setMotiveDamage(te.getMotiveDamage() + 1);
                    if (te.getOriginalWalkMP() > te.getMotiveDamage()) {
                        r = new Report(6660);
                        r.indent(3);
                        r.subject = te.getId();
                        vDesc.add(r);
                    } else {
                        r = new Report(6670);
                        r.subject = te.getId();
                        vDesc.add(r);
                        te.immobilize();
                        // Being reduced to 0 MP by rotor damage forces a
                        // landing
                        // like an engine hit...
                        if (te.isAirborneVTOLorWIGE()
                                // ...but don't bother to resolve that if we're
                                // already otherwise destroyed.
                                && !(te.isDestroyed() || te.isDoomed())) {
                            vDesc.addAll(forceLandVTOLorWiGE(te));
                        }
                    }
                }
                // This completes our handling of VTOLs; the rest of the method
                // doesn't need to worry about them anymore.
                return vDesc;
            default:
                break;
        }
        // Apply vehicle effectiveness...except for jumps.
        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_VEHICLE_EFFECTIVE)
                && !jumpDamage) {
            modifier = Math.max(modifier - 1, 0);
        }

        if (te.hasWorkingMisc(MiscType.F_ARMORED_MOTIVE_SYSTEM)) {
            modifier -= 2;
        }
        int roll = Compute.d6(2) + modifier;
        r = new Report(6306);
        r.subject = te.getId();
        r.newlines = 0;
        r.indent(3);
        vDesc.add(r);
        if (!noRoll) {
            r = new Report(6310);
            r.subject = te.getId();
            r.add(roll);
            r.newlines = 0;
            vDesc.add(r);
            r = new Report(3340);
            r.add(modifier);
            r.subject = te.getId();
            vDesc.add(r);
        }

        if ((noRoll && (damageType == 0)) || (!noRoll && (roll <= 5))) {
            // no effect
            r = new Report(6005);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
        } else if ((noRoll && (damageType == 1)) || (!noRoll && (roll <= 7))) {
            // minor damage
            r = new Report(6470);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(1);
        } else if ((noRoll && (damageType == 2)) || (!noRoll && (roll <= 9))) {
            // moderate damage
            r = new Report(6471);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(2);
        } else if ((noRoll && (damageType == 3)) || (!noRoll && (roll <= 11))) {
            // heavy damage
            r = new Report(6472);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(3);
        } else {
            r = new Report(6473);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(4);
        }
        // These checks should perhaps be moved to Tank.applyDamage(), but I'm
        // unsure how to *report* any outcomes from there. Note that these treat
        // being reduced to 0 MP and being actually immobilized as the same thing,
        // which for these particular purposes may or may not be the intent of
        // the rules in all cases.
        // Immobile hovercraft on water sink...
        if (((te.getMovementMode() == EntityMovementMode.HOVER)
                || ((te.getMovementMode() == EntityMovementMode.WIGE) && (te.getElevation() == 0)))
                && (te.isMovementHitPending() || (te.getWalkMP() <= 0))
                // HACK: Have to check for *pending* hit here and below.
                && (game.getBoard().getHex(te.getPosition()).terrainLevel(Terrains.WATER) > 0)
                && !game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.ICE)) {
            vDesc.addAll(destroyEntity(te, "a watery grave", false));
        }
        // ...while immobile WiGEs crash.
        if (((te.getMovementMode() == EntityMovementMode.WIGE) && (te.isAirborneVTOLorWIGE()))
                && (te.isMovementHitPending() || (te.getWalkMP() <= 0))) {
            // report problem: add tab
            vDesc.addAll(crashVTOLorWiGE(te));
        }
        return vDesc;
    }

    /**
     * Add a whole lotta Reports to the players report queues as well as the
     * Master report queue vPhaseReport.
     */
    private void addReport(Vector<Report> reports) {
        vPhaseReport.addAll(reports);
    }

    /**
     * Add a whole lotta Reports to the players report queues as well as the
     * Master report queue vPhaseReport, indenting each report by the passed
     * value.
     */
    private void addReport(Vector<Report> reports, int indents) {
        for (Report r : reports) {
            r.indent(indents);
            vPhaseReport.add(r);
        }
    }

    /**
     * Add a single report to the report queue of all players and the master
     * vPhaseReport queue
     */
    @Override
    public void addReport(Report report) {
        vPhaseReport.addElement(report);
    }

    /**
     * New Round has started clear everyone's report queue
     */
    private void clearReports() {
        vPhaseReport.removeAllElements();
    }

    /**
     * make sure all the new lines that were added to the old vPhaseReport get
     * added to all of the players filters
     */
    private void addNewLines() {
        Report.addNewline(vPhaseReport);
    }

    /**
     * resolve the landing of an assault drop
     *
     * @param entity the <code>Entity</code> for which to resolve it
     */
    public void doAssaultDrop(Entity entity) {
        //resolve according to SO p.22

        Report r = new Report(2380);

        // whatever else happens, this entity is on the ground now
        entity.setAltitude(0);

        PilotingRollData psr;
        // LAMs that convert to fighter mode on the landing turn are processed as crashes
        if ((entity instanceof LandAirMech)
                && (entity.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER)) {
            addReport(processCrash(entity, 0, entity.getPosition()));
            return;
        }
        if ((entity instanceof Protomech) || (entity instanceof BattleArmor)) {
            psr = new PilotingRollData(entity.getId(), 5, "landing assault drop");
        } else if (entity instanceof Infantry) {
            psr = new PilotingRollData(entity.getId(), 4, "landing assault drop");
        } else {
            psr = entity.getBasePilotingRoll();
        }
        int roll = Compute.d6(2);
        // check for a safe landing
        addNewLines();
        r.subject = entity.getId();
        r.add(entity.getDisplayName(), true);
        r.add(psr);
        r.add(roll);
        r.newlines = 1;
        r.choose(roll >= psr.getValue());
        addReport(r);

        // if we are on an atmospheric map or the entity is off the map for some reason
        if (game.getBoard().inAtmosphere() || entity.getPosition() == null) {
            // then just remove the entity
            // TODO : for this and when the unit scatters off the board, we should really still
            // TODO : apply damage before we remove, but this causes all kinds of problems for
            // TODO : doEntityFallsInto and related methods which expect a coord on the board
            // TODO : - need to make those more robust
            r = new Report(2388);
            addReport(r);
            r.subject = entity.getId();
            r.add(entity.getDisplayName(), true);
            game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
            return;
        }

        if (roll < psr.getValue()) {
            int fallHeight = psr.getValue() - roll;

            // if you fail by more than 7, you automatically fail
            if (fallHeight > 7) {
                addReport(destroyEntity(entity, "failed assault drop", false, false));
                entityUpdate(entity.getId());
                return;
            }

            // determine where we really land
            Coords c = Compute.scatterAssaultDrop(entity.getPosition(), fallHeight);
            int distance = entity.getPosition().distance(c);
            r = new Report(2385);
            r.subject = entity.getId();
            r.add(distance);
            r.indent();
            r.newlines = 0;
            addReport(r);
            if (!game.getBoard().contains(c)) {
                r = new Report(2386);
                r.subject = entity.getId();
                addReport(r);
                game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);
                return;
            } else {
                r = new Report(2387);
                r.subject = entity.getId();
                r.add(c.getBoardNum());
                addReport(r);
            }
            entity.setPosition(c);

            // do fall damage from accidental fall
            //set elevation to fall height above ground or building roof
            Hex hex = game.getBoard().getHex(entity.getPosition());
            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV)
                    ? hex.terrainLevel(Terrains.BLDG_ELEV) : 0;
            entity.setElevation(fallHeight + bldgElev);
            if (entity.isConventionalInfantry()) {
                HitData hit = new HitData(Infantry.LOC_INFANTRY);
                addReport(damageEntity(entity, hit, 1));
                // LAMs that convert to fighter mode on the landing turn are processed as crashes regardless of roll
            } else {
                addReport(doEntityFallsInto(entity, c, psr, true));
            }
        } else {
            // set entity to expected elevation
            Hex hex = game.getBoard().getHex(entity.getPosition());
            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV)
                    ? hex.terrainLevel(Terrains.BLDG_ELEV) : 0;
            entity.setElevation(bldgElev);

            Building bldg = game.getBoard().getBuildingAt(entity.getPosition());
            if (bldg != null) {
                // whoops we step on the roof
                checkBuildingCollapseWhileMoving(bldg, entity, entity.getPosition());
            }

            // finally, check for any stacking violations
            Entity violated = Compute.stackingViolation(game, entity, entity.getPosition(), null);
            if (violated != null) {
                // StratOps explicitly says that this is not treated as an accident
                // fall from above
                // so we just need to displace the violating unit
                // check to see if the violating unit is a DropShip and if so, then
                // displace the unit dropping instead
                if (violated instanceof Dropship) {
                    violated = entity;
                }
                Coords targetDest = Compute.getValidDisplacement(game, violated.getId(),
                        violated.getPosition(), Compute.d6() - 1);
                if (null != targetDest) {
                    doEntityDisplacement(violated, violated.getPosition(), targetDest, null);
                    entityUpdate(violated.getId());
                } else {
                    // ack! automatic death! Tanks
                    // suffer an ammo/power plant hit.
                    // TODO : a Mech suffers a Head Blown Off crit.
                    vPhaseReport.addAll(destroyEntity(entity, "impossible displacement",
                            entity instanceof Mech, entity instanceof Mech));
                }
            }
        }
    }

    /**
     * resolve assault drops for all entities
     */
    void doAllAssaultDrops() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.isAssaultDropInProgress() && e.isDeployed()) {
                doAssaultDrop(e);
                e.setLandedAssaultDrop();
            }
        }
    }

    /**
     * do damage from magma
     *
     * @param en       the affected <code>Entity</code>
     * @param eruption <code>boolean</code> indicating whether or not this is because
     *                 of an eruption
     */
    void doMagmaDamage(Entity en, boolean eruption) {
        if ((((en.getMovementMode() == EntityMovementMode.VTOL) && (en.getElevation() > 0))
                || (en.getMovementMode() == EntityMovementMode.HOVER)
                || ((en.getMovementMode() == EntityMovementMode.WIGE)
                && (en.getOriginalWalkMP() > 0) && !eruption)) && !en.isImmobile()) {
            return;
        }
        Report r;
        boolean isMech = en instanceof Mech;
        if (isMech) {
            r = new Report(2405);
        } else {
            r = new Report(2400);
        }
        r.addDesc(en);
        r.subject = en.getId();
        addReport(r);
        if (isMech) {
            HitData h;
            for (int i = 0; i < en.locations(); i++) {
                if (eruption || en.locationIsLeg(i) || en.isProne()) {
                    h = new HitData(i);
                    addReport(damageEntity(en, h, Compute.d6(2)));
                }
            }
        } else {
            addReport(destroyEntity(en, "fell into magma", false, false));
        }
        addNewLines();
    }

    /**
     * Applies damage to any eligible unit hit by anti-TSM missiles or entering
     * a hex with green smoke.
     *
     * @param entity An entity subject to anti-TSM damage
     * @return The damage reports
     */
    public Vector<Report> doGreenSmokeDamage(Entity entity) {
        Vector<Report> reports = new Vector<>();
        // ignore if we're flying over the smoke or we're already toast
        if ((entity.getElevation() >= 2) || entity.isDestroyed() || entity.isDoomed()) {
            return reports;
        }
        Report r = new Report(6432);
        r.subject = entity.getId();
        r.addDesc(entity);
        reports.add(r);
        if (entity.isConventionalInfantry()) {
            reports.addAll(damageEntity(entity, new HitData(Infantry.LOC_INFANTRY), Compute.d6()));
        } else {
            for (int loc = 0; loc < entity.locations(); loc++) {
                if ((entity.getArmor(loc) <= 0 || (entity.hasRearArmor(loc) && (entity.getArmor(loc, true) < 0)))
                        && !entity.isLocationBlownOff(loc)) {
                    r = new Report(6433);
                    r.subject = entity.getId();
                    r.add(entity.getLocationName(loc));
                    r.indent(1);
                    reports.add(r);
                    reports.addAll(damageEntity(entity, new HitData(loc), 6, false,
                            DamageType.ANTI_TSM, true));
                }
            }
        }
        // Only report if the exposure has some effect
        if (reports.size() == 1) {
            reports.clear();
        }
        return reports;
    }

    /**
     * sink any entities in quicksand in the current hex
     */
    public void doSinkEntity(Entity en) {
        Report r;
        r = new Report(2445);
        r.addDesc(en);
        r.subject = en.getId();
        addReport(r);
        en.setElevation(en.getElevation() - 1);
        // if this means the entity is below the ground, then bye-bye!
        if (Math.abs(en.getElevation()) > en.getHeight()) {
            addReport(destroyEntity(en, "quicksand"));
        }
    }

    /**
     * deal area saturation damage to an individual hex
     *
     * @param coords         The hex being hit
     * @param attackSource   The location the attack came from. For hit table resolution
     * @param damage         Amount of damage to deal to each entity
     * @param ammo           The ammo type being used
     * @param subjectId      Subject for reports
     * @param killer         Who should be credited with kills
     * @param exclude        Entity that should take no damage (used for homing splash)
     * @param flak           Flak, hits flying units only, instead of flyers being immune
     * @param altitude       Absolute altitude for flak attack
     * @param vPhaseReport   The Vector of Reports for the phase report
     * @param asfFlak        Is this flak against ASF?
     * @param alreadyHit     a vector of unit ids for units that have already been hit that
     *                       will be ignored
     * @param variableDamage if true, treat damage as the number of six-sided dice to roll
     */
    public Vector<Integer> artilleryDamageHex(Coords coords,
                                              Coords attackSource, int damage, AmmoType ammo, int subjectId,
                                              Entity killer, Entity exclude, boolean flak, int altitude,
                                              Vector<Report> vPhaseReport, boolean asfFlak,
                                              Vector<Integer> alreadyHit, boolean variableDamage) {

        Hex hex = game.getBoard().getHex(coords);
        if (hex == null) {
            return alreadyHit; // not on board.
        }

        Report r;

        // Non-flak artillery damages terrain
        if (!flak) {
            // Report that damage applied to terrain, if there's TF to damage
            Hex h = game.getBoard().getHex(coords);
            if ((h != null) && h.hasTerrainFactor()) {
                r = new Report(3384);
                r.indent(2);
                r.subject = subjectId;
                r.add(coords.getBoardNum());
                r.add(damage * 2);
                vPhaseReport.addElement(r);
            }
            // Update hex and report any changes
            Vector<Report> newReports = tryClearHex(coords, damage * 2, subjectId);
            for (Report nr : newReports) {
                nr.indent(3);
            }
            vPhaseReport.addAll(newReports);
        }

        boolean isFuelAirBomb =
                ammo != null &&
                        (BombType.getBombTypeFromInternalName(ammo.getInternalName()) == BombType.B_FAE_SMALL ||
                                BombType.getBombTypeFromInternalName(ammo.getInternalName()) == BombType.B_FAE_LARGE);

        Building bldg = game.getBoard().getBuildingAt(coords);
        int bldgAbsorbs = 0;
        if ((bldg != null)
                && !(flak && (((altitude > hex.terrainLevel(Terrains.BLDG_ELEV))
                || (altitude > hex.terrainLevel(Terrains.BRIDGE_ELEV)))))) {
            bldgAbsorbs = bldg.getAbsorbtion(coords);
            if (!((ammo != null) && (ammo.getMunitionType() == AmmoType.M_FLECHETTE))) {
                int actualDamage = damage;

                if (isFuelAirBomb) {
                    // light buildings take 1.5x damage from fuel-air bombs
                    if (bldg.getType() == Building.LIGHT) {
                        actualDamage = (int) Math.ceil(actualDamage * 1.5);

                        r = new Report(9991);
                        r.indent(1);
                        r.subject = killer.getId();
                        r.newlines = 1;
                        vPhaseReport.addElement(r);
                    }

                    // armored and "castle brian" buildings take .5 damage from fuel-air bombs
                    // but I have no idea how to determine if a building is a castle or a brian
                    // note that being armored and being "light" are not mutually exclusive
                    if (bldg.getArmor(coords) > 0) {
                        actualDamage = (int) Math.floor(actualDamage * .5);

                        r = new Report(9992);
                        r.indent(1);
                        r.subject = killer.getId();
                        r.newlines = 1;
                        vPhaseReport.addElement(r);
                    }
                }


                // damage the building
                Vector<Report> buildingReport = damageBuilding(bldg, actualDamage, coords);
                for (Report report : buildingReport) {
                    report.subject = subjectId;
                }
                vPhaseReport.addAll(buildingReport);
            }
        }

        if (flak && ((altitude <= 0)
                || (altitude <= hex.terrainLevel(Terrains.BLDG_ELEV))
                || (altitude == hex.terrainLevel(Terrains.BRIDGE_ELEV)))) {
            // Flak in this hex would only hit landed units
            return alreadyHit;
        }

        // get units in hex
        for (Entity entity : game.getEntitiesVector(coords)) {
            // Check: is entity excluded?
            if ((entity == exclude) || alreadyHit.contains(entity.getId())) {
                continue;
            } else {
                alreadyHit.add(entity.getId());
            }

            AreaEffectHelper.artilleryDamageEntity(entity, damage, bldg, bldgAbsorbs,
                    variableDamage, asfFlak, flak, altitude,
                    attackSource, ammo, coords, isFuelAirBomb,
                    killer, hex, subjectId, vPhaseReport, this);
        }

        return alreadyHit;
    }

    /**
     * deal area saturation damage to the map, used for artillery
     *
     * @param centre       The hex on which damage is centred
     * @param attackSource The position the attack came from
     * @param ammo         The ammo type doing the damage
     * @param subjectId    Subject for reports
     * @param killer       Who should be credited with kills
     * @param flak         Flak, hits flying units only, instead of flyers being immune
     * @param altitude     Absolute altitude for flak attack
     * @param mineClear    Does this clear mines?
     * @param vPhaseReport The Vector of Reports for the phase report
     * @param asfFlak      Is this flak against ASF?
     * @param attackingBA  How many BA suits are in the squad if this is a BA Tube arty
     *                     attack, -1 otherwise
     */
    public void artilleryDamageArea(Coords centre, Coords attackSource,
                                    AmmoType ammo, int subjectId, Entity killer, boolean flak,
                                    int altitude, boolean mineClear, Vector<Report> vPhaseReport,
                                    boolean asfFlak, int attackingBA) {
        AreaEffectHelper.DamageFalloff damageFalloff = AreaEffectHelper.calculateDamageFallOff(ammo, attackingBA, mineClear);

        int damage = damageFalloff.damage;
        int falloff = damageFalloff.falloff;
        if (damageFalloff.clusterMunitionsFlag) {
            attackSource = centre;
        }

        artilleryDamageArea(centre, attackSource, ammo, subjectId, killer,
                damage, falloff, flak, altitude, vPhaseReport, asfFlak);
    }

    /**
     * Deals area-saturation damage to an area of the board. Used for artillery,
     * bombs, or anything else with linear decrease in damage
     *
     * @param centre
     *            The hex on which damage is centred
     * @param attackSource
     *            The position the attack came from
     * @param ammo
     *            The ammo type doing the damage
     * @param subjectId
     *            Subject for reports
     * @param killer
     *            Who should be credited with kills
     * @param damage
     *            Damage at ground zero
     * @param falloff
     *            Reduction in damage for each hex of distance
     * @param flak
     *            Flak, hits flying units only, instead of flyers being immune
     * @param altitude
     *            Absolute altitude for flak attack
     * @param vPhaseReport
     *            The Vector of Reports for the phase report
     * @param asfFlak
     *            Is this flak against ASF?
     */
    public void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId,
                                    Entity killer, int damage, int falloff, boolean flak, int altitude,
                                    Vector<Report> vPhaseReport, boolean asfFlak) {
        Vector<Integer> alreadyHit = new Vector<>();
        for (int ring = 0; damage > 0; ring++, damage -= falloff) {
            List<Coords> hexes = centre.allAtDistance(ring);
            for (Coords c : hexes) {
                alreadyHit = artilleryDamageHex(c, attackSource, damage, ammo,
                        subjectId, killer, null, flak, altitude, vPhaseReport,
                        asfFlak, alreadyHit, false);
            }
            attackSource = centre; // all splash comes from ground zero
        }
    }

    public void deliverBombDamage(Coords centre, int type, int subjectId, Entity killer,
                                  Vector<Report> vPhaseReport) {
        int range = 0;
        int damage = 10;
        if (type == BombType.B_CLUSTER) {
            range = 1;
            damage = 5;
        }
        Vector<Integer> alreadyHit = new Vector<>();

        alreadyHit = artilleryDamageHex(centre, centre, damage, null,
                subjectId, killer, null, false, 0, vPhaseReport, false,
                alreadyHit, false);
        if (range > 0) {
            List<Coords> hexes = centre.allAtDistance(range);
            for (Coords c : hexes) {
                alreadyHit = artilleryDamageHex(c, centre, damage, null,
                        subjectId, killer, null, false, 0, vPhaseReport, false,
                        alreadyHit, false);
            }
        }
    }

    /**
     * deliver inferno bomb
     *
     * @param coords    the <code>Coords</code> where to deliver
     * @param ae        the attacking <code>entity</code>
     * @param subjectId the <code>int</code> id of the target
     */
    public void deliverBombInferno(Coords coords, Entity ae, int subjectId,
                                   Vector<Report> vPhaseReport) {
        Hex h = game.getBoard().getHex(coords);
        Report r;
        // Unless there is a fire in the hex already, start one.
        if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_BOMB) {
            ignite(coords, Terrains.FIRE_LVL_INFERNO_BOMB, vPhaseReport);
        }
        // possibly melt ice and snow
        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {
            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));
        }
        for (Entity entity : game.getEntitiesVector(coords)) {
            if (entity.isAirborne() || entity.isAirborneVTOLorWIGE()) {
                continue;
            }
            // TacOps, p. 359 - treat as if hit by 5 inferno missiles
            r = new Report(6696);
            r.indent(3);
            r.add(entity.getDisplayName());
            r.subject = entity.getId();
            r.newlines = 0;
            vPhaseReport.add(r);
            if (entity instanceof Tank) {
                Report.addNewline(vPhaseReport);
            }
            Vector<Report> vDamageReport = deliverInfernoMissiles(ae, entity, 5);
            Report.indentAll(vDamageReport, 2);
            vPhaseReport.addAll(vDamageReport);
        }
    }

    /**
     * Resolve any Infantry units which are fortifying hexes
     */
    void resolveFortify() {
        Report r;
        for (Entity ent : game.getEntitiesVector()) {
            if (ent instanceof Infantry) {
                Infantry inf = (Infantry) ent;
                int dig = inf.getDugIn();
                if (dig == Infantry.DUG_IN_WORKING) {
                    r = new Report(5300);
                    r.addDesc(inf);
                    r.subject = inf.getId();
                    addReport(r);
                } else if (dig == Infantry.DUG_IN_FORTIFYING3) {
                    Coords c = inf.getPosition();
                    r = new Report(5305);
                    r.addDesc(inf);
                    r.add(c.getBoardNum());
                    r.subject = inf.getId();
                    addReport(r);
                    // fortification complete - add to map
                    Hex hex = game.getBoard().getHex(c);
                    hex.addTerrain(new Terrain(Terrains.FORTIFIED, 1));
                    sendChangedHex(c);
                    // Clear the dig in for any units in same hex, since they
                    // get it for free by fort
                    for (Entity ent2 : game.getEntitiesVector(c)) {
                        if (ent2 instanceof Infantry) {
                            Infantry inf2 = (Infantry) ent2;
                            inf2.setDugIn(Infantry.DUG_IN_NONE);
                        }
                    }
                }
            }

            if (ent instanceof Tank) {
                Tank tnk = (Tank) ent;
                int dig = tnk.getDugIn();
                if (dig == Tank.DUG_IN_FORTIFYING3) {
                    Coords c = tnk.getPosition();
                    r = new Report(5305);
                    r.addDesc(tnk);
                    r.add(c.getBoardNum());
                    r.subject = tnk.getId();
                    addReport(r);
                    // Fort complete, now add it to the map
                    Hex hex = game.getBoard().getHex(c);
                    hex.addTerrain(new Terrain(Terrains.FORTIFIED, 1));
                    sendChangedHex(c);
                    tnk.setDugIn(Tank.DUG_IN_NONE);
                    // Clear the dig in for any units in same hex, since they
                    // get it for free by fort
                    for (Entity ent2 : game.getEntitiesVector(c)) {
                        if (ent2 instanceof Infantry) {
                            Infantry inf2 = (Infantry) ent2;
                            inf2.setDugIn(Infantry.DUG_IN_NONE);
                        }
                    }
                }
            }
        }
    }

    /**
     * Check if spikes get broken in the given location
     *
     * @param e   The {@link Entity} to check
     * @param loc The location index
     * @return    A report showing the results of the roll
     */
    private Report checkBreakSpikes(Entity e, int loc) {
        int roll = Compute.d6(2);
        Report r;
        if (roll < 9) {
            r = new Report(4445);
            r.indent(2);
            r.add(roll);
            r.subject = e.getId();
        } else {
            r = new Report(4440);
            r.indent(2);
            r.add(roll);
            r.subject = e.getId();
            for (Mounted m : e.getMisc()) {
                if (m.getType().hasFlag(MiscType.F_SPIKES)
                        && (m.getLocation() == loc)) {
                    m.setHit(true);
                }
            }
        }
        return r;
    }

    /**
     * Loops through all the attacks the game has. Checks if they care about
     * current phase, if so, runs them, and removes them if they don't want to
     * stay. TODO : Refactor the new entity announcement out of here.
     */
    private void handleAttacks() {
        handleAttacks(false);
    }

    private void handleAttacks(boolean pointblankShot) {
        Report r;
        int lastAttackerId = -1;
        Vector<AttackHandler> currentAttacks, keptAttacks;
        currentAttacks = game.getAttacksVector();
        keptAttacks = new Vector<>();
        Vector<Report> handleAttackReports = new Vector<>();
        // first, do any TAGs, so homing arty will have TAG
        for (AttackHandler ah : currentAttacks) {
            if (!(ah instanceof TAGHandler)) {
                continue;
            }
            if (ah.cares(game.getPhase())) {
                int aId = ah.getAttackerId();
                if ((aId != lastAttackerId) && !ah.announcedEntityFiring()) {
                    // report who is firing
                    if (pointblankShot) {
                        r = new Report(3102);
                    } else {
                        r = new Report(3100);
                    }
                    r.subject = aId;
                    r.addDesc(ah.getAttacker());
                    handleAttackReports.addElement(r);
                    ah.setAnnouncedEntityFiring(true);
                    lastAttackerId = aId;
                }
                boolean keep = ah.handle(game.getPhase(), handleAttackReports);
                if (keep) {
                    keptAttacks.add(ah);
                }
                Report.addNewline(handleAttackReports);
            }
        }
        // now resolve everything but TAG
        for (AttackHandler ah : currentAttacks) {
            if (ah instanceof TAGHandler) {
                continue;
            }
            if (ah.cares(game.getPhase())) {
                int aId = ah.getAttackerId();
                if ((aId != lastAttackerId) && !ah.announcedEntityFiring()) {
                    // if this is a new attacker then resolve any
                    // standard-to-cap damage
                    // from previous
                    handleAttackReports.addAll(checkFatalThresholds(aId,
                            lastAttackerId));
                    // report who is firing
                    if (pointblankShot) {
                        r = new Report(3102);
                    } else if (ah.isStrafing()) {
                        r = new Report(3101);
                    } else {
                        r = new Report(3100);
                    }
                    r.subject = aId;
                    r.addDesc(ah.getAttacker());
                    handleAttackReports.addElement(r);
                    ah.setAnnouncedEntityFiring(true);
                    lastAttackerId = aId;
                }
                boolean keep = ah.handle(game.getPhase(), handleAttackReports);
                if (keep) {
                    keptAttacks.add(ah);
                }
                Report.addNewline(handleAttackReports);
            } else {
                keptAttacks.add(ah);
            }
        }

        // resolve standard to capital one more time
        handleAttackReports.addAll(checkFatalThresholds(lastAttackerId, lastAttackerId));
        Report.addNewline(handleAttackReports);
        addReport(handleAttackReports);
        // HACK, but anything else seems to run into weird problems.
        game.setAttacksVector(keptAttacks);
    }

    /**
     * create a <code>SmokeCloud</code> object and add it to the server list
     *
     * @param coords   the location to create the smoke
     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
     * @param duration How long the smoke will last.
     */
    public void createSmoke(Coords coords, int level, int duration) {
        SmokeCloud cloud = new SmokeCloud(coords, level, duration);
        game.addSmokeCloud(cloud);
        sendSmokeCloudAdded(cloud);
    }

    /**
     * create a <code>SmokeCloud</code> object and add it to the server list
     *
     * @param coords   the location to create the smoke
     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
     * @param duration duration How long the smoke will last.
     */
    public void createSmoke(ArrayList<Coords> coords, int level, int duration) {
        SmokeCloud cloud = new SmokeCloud(coords, level, duration);
        game.addSmokeCloud(cloud);
        sendSmokeCloudAdded(cloud);
    }

    /**
     * Update the map with a new set of coords.
     *
     * @param newCoords the location to move the smoke to
     */
    public void updateSmoke(SmokeCloud cloud, ArrayList<Coords> newCoords) {
        removeSmokeTerrain(cloud);
        cloud.getCoordsList().clear();
        cloud.getCoordsList().addAll(newCoords);
    }

    /**
     * remove a cloud from the map
     *
     * @param cloud the location to remove the smoke from
     */
    public void removeSmokeTerrain(SmokeCloud cloud) {
        for (Coords coords : cloud.getCoordsList()) {
            Hex nextHex = game.getBoard().getHex(coords);
            if ((nextHex != null) && nextHex.containsTerrain(Terrains.SMOKE)) {
                nextHex.removeTerrain(Terrains.SMOKE);
                sendChangedHex(coords);
            }
        }
    }

    public List<SmokeCloud> getSmokeCloudList() {
        return game.getSmokeCloudList();
    }

    /**
     * Check to see if blowing sand caused damage to airborne VTOL/WIGEs
     */
    private Vector<Report> resolveBlowingSandDamage() {
        Vector<Report> vFullReport = new Vector<>();
        vFullReport.add(new Report(5002, Report.PUBLIC));
        int damage_bonus = Math.max(0, game.getPlanetaryConditions().getWindStrength()
                - PlanetaryConditions.WI_MOD_GALE);
        // cycle through each team and damage 1d6 airborne VTOL/WiGE
        for (Team team : game.getTeams()) {
            Vector<Integer> airborne = getAirborneVTOL(team);
            if (!airborne.isEmpty()) {
                // how many units are affected
                int unitsAffected = Math.min(Compute.d6(), airborne.size());
                while ((unitsAffected > 0) && !airborne.isEmpty()) {
                    int loc = Compute.randomInt(airborne.size());
                    Entity en = game.getEntity(airborne.get(loc));
                    int damage = Math.max(1, Compute.d6() / 2) + damage_bonus;
                    while (damage > 0) {
                        HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_RANDOM);
                        vFullReport.addAll(damageEntity(en, hit, 1));
                        damage--;
                    }
                    unitsAffected--;
                    airborne.remove(loc);
                }
            }
        }
        Report.addNewline(vPhaseReport);
        return vFullReport;
    }

    /**
     * cycle through entities on team and collect all the airborne VTOL/WIGE
     *
     * @return a vector of relevant entity ids
     */
    public Vector<Integer> getAirborneVTOL(Team team) {
        // a vector of unit ids
        Vector<Integer> units = new Vector<>();
        for (Player player : team.players()) {
            units.addAll(player.getAirborneVTOL());
        }
        return units;
    }

    /**
     * let an entity lay a mine
     *
     * @param entity the <code>Entity</code> that should lay a mine
     * @param mineId an <code>int</code> pointing to the mine
     */
    private void layMine(Entity entity, int mineId, Coords coords) {
        Mounted mine = entity.getEquipment(mineId);
        Report r;
        if (!mine.isMissing()) {
            int reportId = 0;
            switch (mine.getMineType()) {
                case Mounted.MINE_CONVENTIONAL:
                    deliverThunderMinefield(coords, entity.getOwnerId(), 10,
                            entity.getId());
                    reportId = 3500;
                    break;
                case Mounted.MINE_VIBRABOMB:
                    deliverThunderVibraMinefield(coords, entity.getOwnerId(), 10,
                            mine.getVibraSetting(), entity.getId());
                    reportId = 3505;
                    break;
                case Mounted.MINE_ACTIVE:
                    deliverThunderActiveMinefield(coords, entity.getOwnerId(), 10,
                            entity.getId());
                    reportId = 3510;
                    break;
                case Mounted.MINE_INFERNO:
                    deliverThunderInfernoMinefield(coords, entity.getOwnerId(), 10,
                            entity.getId());
                    reportId = 3515;
                    break;
                // TODO : command-detonated mines
                // case 2:
            }
            mine.setShotsLeft(mine.getUsableShotsLeft() - 1);
            if (mine.getUsableShotsLeft() <= 0) {
                mine.setMissing(true);
            }
            r = new Report(reportId);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(coords.getBoardNum());
            addReport(r);
            entity.setLayingMines(true);
        }
    }

    public Set<Coords> getHexUpdateSet() {
        return hexUpdateSet;

    }
}
