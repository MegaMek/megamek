/*
 * MegaMek -
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
 * Copyright ������ 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */

package megamek.server;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URL;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import megamek.MegaMek;
import megamek.client.ui.swing.util.PlayerColors;
import megamek.common.Aero;
import megamek.common.AmmoType;
import megamek.common.BattleArmor;
import megamek.common.Bay;
import megamek.common.BipedMech;
import megamek.common.Board;
import megamek.common.BoardDimensions;
import megamek.common.BombType;
import megamek.common.Building;
import megamek.common.Building.BasementType;
import megamek.common.BuildingTarget;
import megamek.common.CalledShot;
import megamek.common.CommonConstants;
import megamek.common.Compute;
import megamek.common.ComputeECM;
import megamek.common.Configuration;
import megamek.common.ConvFighter;
import megamek.common.Coords;
import megamek.common.Crew;
import megamek.common.CriticalSlot;
import megamek.common.Dropship;
import megamek.common.ECMInfo;
import megamek.common.EjectedCrew;
import megamek.common.Engine;
import megamek.common.Entity;
import megamek.common.EntityMovementMode;
import megamek.common.EntityMovementType;
import megamek.common.EntitySelector;
import megamek.common.EntityWeightClass;
import megamek.common.EquipmentMode;
import megamek.common.EquipmentType;
import megamek.common.FighterSquadron;
import megamek.common.Flare;
import megamek.common.FuelTank;
import megamek.common.Game;
import megamek.common.GameTurn;
import megamek.common.GunEmplacement;
import megamek.common.HexTarget;
import megamek.common.HitData;
import megamek.common.IArmorState;
import megamek.common.IBoard;
import megamek.common.IEntityRemovalConditions;
import megamek.common.IGame;
import megamek.common.IGame.Phase;
import megamek.common.IHex;
import megamek.common.ILocationExposureStatus;
import megamek.common.INarcPod;
import megamek.common.IPlayer;
import megamek.common.ITerrain;
import megamek.common.Infantry;
import megamek.common.InfernoTracker;
import megamek.common.Jumpship;
import megamek.common.LargeSupportTank;
import megamek.common.LocationFullException;
import megamek.common.LosEffects;
import megamek.common.MapSettings;
import megamek.common.Mech;
import megamek.common.MechWarrior;
import megamek.common.Minefield;
import megamek.common.MiscType;
import megamek.common.Mounted;
import megamek.common.MovePath;
import megamek.common.MovePath.MoveStepType;
import megamek.common.MoveStep;
import megamek.common.OffBoardDirection;
import megamek.common.PhysicalResult;
import megamek.common.PilotingRollData;
import megamek.common.PlanetaryConditions;
import megamek.common.Player;
import megamek.common.Protomech;
import megamek.common.QuadMech;
import megamek.common.Report;
import megamek.common.Roll;
import megamek.common.SmallCraft;
import megamek.common.SpaceStation;
import megamek.common.SpecialHexDisplay;
import megamek.common.SuperHeavyTank;
import megamek.common.SupportTank;
import megamek.common.SupportVTOL;
import megamek.common.Tank;
import megamek.common.TargetRoll;
import megamek.common.Targetable;
import megamek.common.Team;
import megamek.common.TechConstants;
import megamek.common.TeleMissile;
import megamek.common.Terrain;
import megamek.common.Terrains;
import megamek.common.ToHitData;
import megamek.common.TripodMech;
import megamek.common.TurnOrdered;
import megamek.common.TurnVectors;
import megamek.common.UnitLocation;
import megamek.common.VTOL;
import megamek.common.Warship;
import megamek.common.WeaponComparatorBV;
import megamek.common.WeaponType;
import megamek.common.actions.AbstractAttackAction;
import megamek.common.actions.ArtilleryAttackAction;
import megamek.common.actions.AttackAction;
import megamek.common.actions.BAVibroClawAttackAction;
import megamek.common.actions.BreakGrappleAttackAction;
import megamek.common.actions.BrushOffAttackAction;
import megamek.common.actions.ChargeAttackAction;
import megamek.common.actions.ClearMinefieldAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.DfaAttackAction;
import megamek.common.actions.DodgeAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.FindClubAction;
import megamek.common.actions.FlipArmsAction;
import megamek.common.actions.GrappleAttackAction;
import megamek.common.actions.JumpJetAttackAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.LayExplosivesAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.RamAttackAction;
import megamek.common.actions.RepairWeaponMalfunctionAction;
import megamek.common.actions.SearchlightAttackAction;
import megamek.common.actions.SpotAction;
import megamek.common.actions.TeleMissileAttackAction;
import megamek.common.actions.ThrashAttackAction;
import megamek.common.actions.TorsoTwistAction;
import megamek.common.actions.TriggerAPPodAction;
import megamek.common.actions.TriggerBPodAction;
import megamek.common.actions.TripAttackAction;
import megamek.common.actions.UnjamAction;
import megamek.common.actions.UnjamTurretAction;
import megamek.common.actions.UnloadStrandedAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.containers.PlayerIDandList;
import megamek.common.event.GameListener;
import megamek.common.event.GameVictoryEvent;
import megamek.common.net.ConnectionFactory;
import megamek.common.net.ConnectionListenerAdapter;
import megamek.common.net.DisconnectedEvent;
import megamek.common.net.IConnection;
import megamek.common.net.Packet;
import megamek.common.net.PacketReceivedEvent;
import megamek.common.options.GameOptions;
import megamek.common.options.IBasicOption;
import megamek.common.options.IOption;
import megamek.common.options.OptionsConstants;
import megamek.common.preference.PreferenceManager;
import megamek.common.util.BoardUtilities;
import megamek.common.util.HashCodeUtil;
import megamek.common.util.StringUtil;
import megamek.common.verifier.EntityVerifier;
import megamek.common.verifier.TestAero;
import megamek.common.verifier.TestBattleArmor;
import megamek.common.verifier.TestEntity;
import megamek.common.verifier.TestMech;
import megamek.common.verifier.TestSupportVehicle;
import megamek.common.verifier.TestTank;
import megamek.common.weapons.AttackHandler;
import megamek.common.weapons.BPodWeapon;
import megamek.common.weapons.HVACWeapon;
import megamek.common.weapons.MPodWeapon;
import megamek.common.weapons.PPCWeapon;
import megamek.common.weapons.TAGHandler;
import megamek.common.weapons.TSEMPWeapon;
import megamek.common.weapons.Weapon;
import megamek.common.weapons.WeaponHandler;
import megamek.server.commands.AddBotCommand;
import megamek.server.commands.AllowTeamChangeCommand;
import megamek.server.commands.AssignNovaNetServerCommand;
import megamek.server.commands.CheckBVCommand;
import megamek.server.commands.CheckBVTeamCommand;
import megamek.server.commands.DefeatCommand;
import megamek.server.commands.ExportListCommand;
import megamek.server.commands.FixElevationCommand;
import megamek.server.commands.HelpCommand;
import megamek.server.commands.JoinTeamCommand;
import megamek.server.commands.KickCommand;
import megamek.server.commands.ListEntitiesCommand;
import megamek.server.commands.ListSavesCommand;
import megamek.server.commands.LoadGameCommand;
import megamek.server.commands.LocalLoadGameCommand;
import megamek.server.commands.LocalSaveGameCommand;
import megamek.server.commands.NukeCommand;
import megamek.server.commands.ResetCommand;
import megamek.server.commands.RollCommand;
import megamek.server.commands.RulerCommand;
import megamek.server.commands.SaveGameCommand;
import megamek.server.commands.SeeAllCommand;
import megamek.server.commands.ServerCommand;
import megamek.server.commands.ShowEntityCommand;
import megamek.server.commands.ShowTileCommand;
import megamek.server.commands.ShowValidTargetsCommand;
import megamek.server.commands.SkipCommand;
import megamek.server.commands.TeamCommand;
import megamek.server.commands.TraitorCommand;
import megamek.server.commands.VictoryCommand;
import megamek.server.commands.WhoCommand;
import megamek.server.victory.Victory;

import com.thoughtworks.xstream.XStream;

/**
 * @author Ben Mazur
 */
public class Server implements Runnable {

    private static class EntityTargetPair {
        Entity ent;

        Targetable target;

        EntityTargetPair (Entity e, Targetable t) {
            ent = e;
            target = t;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof EntityTargetPair)) {
                return false;
            }
            EntityTargetPair other = (EntityTargetPair)o;
            return ent.equals(other.ent)
                    && (((target != null) && target.equals(other.target))
                            || ((target == null) && (other.target == null)));
        }

        @Override
        public int hashCode() {
            int hashCode = HashCodeUtil.SEED;
            hashCode = HashCodeUtil.hash(hashCode, ent.getId());
            hashCode = HashCodeUtil.hash(hashCode, target);
            return hashCode;
        }

    }
    /**
     * The DamageType enumeration is used for the damageEntity function.
     */
    public enum DamageType {
        NONE, FRAGMENTATION, FLECHETTE, ACID, INCENDIARY, IGNORE_PASSENGER, ANTI_TSM, ANTI_INFANTRY, NAIL_RIVET,
        NONPENETRATING
    }

    // public final static String LEGAL_CHARS =
    // "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-";
    public final static String DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;

    // server setup
    private String password;

    private final String metaServerUrl;

    private ServerSocket serverSocket;

    private String motd;

    private class ReceivedPacket {
        public int connId;
        public Packet packet;

        ReceivedPacket(int cid, Packet p) {
            packet = p;
            connId = cid;
        }

    }

    private class PacketPump implements Runnable {

        boolean shouldStop;

        PacketPump() {
            shouldStop = false;
        }

        public void signalEnd() {
            shouldStop = true;
        }

        @Override
        public void run() {
            while (!shouldStop) {
                while (!packetQueue.isEmpty()) {
                    ReceivedPacket rp = packetQueue.poll();
                    synchronized (serverLock) {
                        handle(rp.connId, rp.packet);
                    }
                }
                try {
                    synchronized (packetQueue) {
                        packetQueue.wait();
                    }
                } catch (InterruptedException e) {
                    // If we are interrupted, just keep going, generally
                    // this happens after we are signalled to stop.
                }
            }
        }

    }

    // game info
    Vector<IConnection> connections = new Vector<IConnection>(4);

    Hashtable<Integer, ConnectionHandler> connectionHandlers = new Hashtable<Integer, ConnectionHandler>();

    ConcurrentLinkedQueue<ReceivedPacket> packetQueue = new ConcurrentLinkedQueue<ReceivedPacket>();

    /**
     * Special packet queue for client feedback requests.
     */
    ConcurrentLinkedQueue<ReceivedPacket> cfrPacketQueue = new ConcurrentLinkedQueue<ReceivedPacket>();

    Vector<IConnection> connectionsPending = new Vector<IConnection>(4);

    Hashtable<Integer, IConnection> connectionIds = new Hashtable<Integer, IConnection>();

    private int connectionCounter;

    IGame game = new Game();

    private Vector<Report> vPhaseReport = new Vector<Report>();

    public Vector<Report> getvPhaseReport() {
        return vPhaseReport;
    }

    private MapSettings mapSettings = MapSettings.getInstance();

    // commands
    private Hashtable<String, ServerCommand> commandsHash = new Hashtable<String, ServerCommand>();

    // listens for and connects players
    private Thread connector;

    private PacketPump packetPump;
    private Thread packetPumpThread;

    // Track buildings that are affected by an entity's movement.
    private Hashtable<Building, Boolean> affectedBldgs = new Hashtable<Building, Boolean>();

    // Track Physical Action results, HACK to deal with opposing pushes
    // canceling each other
    private Vector<PhysicalResult> physicalResults = new Vector<PhysicalResult>();

    private Vector<DynamicTerrainProcessor> terrainProcessors = new Vector<DynamicTerrainProcessor>();

    private Timer watchdogTimer = new Timer("Watchdog Timer");

    private static EntityVerifier entityVerifier;

    private ArrayList<int[]> scheduledNukes = new ArrayList<int[]>();

    private static Server serverInstance = null;

    private String serverAccessKey = null;

    private Timer serverBrowserUpdateTimer = null;

    /**
     * Keeps track of what team a player requested to join.
     */
    private int requestedTeam = IPlayer.TEAM_NONE;

    /**
     * Keeps track of what player made a request to change teams.
     */
    private IPlayer playerChangingTeam = null;

    /**
     * Flag that is set to true when all players have voted to allow another
     * player to change teams.
     */
    private boolean changePlayersTeam = false;

    /**
     * Stores a set of <code>Coords</code> that have changed during this phase.
     */
    private Set<Coords> hexUpdateSet = new LinkedHashSet<Coords>();

    private ConnectionListenerAdapter connectionListener = new ConnectionListenerAdapter() {

        /**
         * Called when it is sensed that a connection has terminated.
         */
        @Override
        public void disconnected(DisconnectedEvent e) {
            synchronized (serverLock) {
                IConnection conn = e.getConnection();

                // write something in the log
                System.out.println("s: connection " + conn.getId()
                                   + " disconnected");

                connections.removeElement(conn);
                connectionsPending.removeElement(conn);
                connectionIds.remove(conn.getId());
                ConnectionHandler ch = connectionHandlers.get(conn.getId());
                if (ch != null) {
                    ch.signalStop();
                    connectionHandlers.remove(conn.getId());
                }

                // if there's a player for this connection, remove it too
                IPlayer player = getPlayer(conn.getId());
                if (null != player) {
                    Server.this.disconnected(player);
                }
            }
        }

        @Override
        public void packetReceived(PacketReceivedEvent e) {
            ReceivedPacket rp = new ReceivedPacket(e.getConnection().getId(),
                    e.getPacket());
            int cmd = e.getPacket().getCommand();
            // Handled CFR packets specially
            if (cmd == Packet.COMMAND_CLIENT_FEEDBACK_REQUEST) {
                synchronized (cfrPacketQueue) {
                    cfrPacketQueue.add(rp);
                    cfrPacketQueue.notifyAll();
                }
            // Some packets should be handled immediately
            } else if ((cmd == Packet.COMMAND_CLOSE_CONNECTION)
                    || (cmd == Packet.COMMAND_CLIENT_NAME)
                    || (cmd == Packet.COMMAND_CLIENT_VERSIONS)
                    || (cmd == Packet.COMMAND_CHAT)) {
                handle(rp.connId, rp.packet);
            } else {
                synchronized (packetQueue) {
                    packetQueue.add(rp);
                    packetQueue.notifyAll();
                }
            }
        }

    };

    /**
     * Used to ensure only one thread at a time is accessing this particular
     * instance of the server.
     */
    private final Object serverLock = new Object();

    public Server(String password, int port) throws IOException {
        this(password, port, false, "");
    }

    /**
     * Construct a new GameHost and begin listening for incoming clients.
     *
     * @param password                  the <code>String</code> that is set as a password
     * @param port                      the <code>int</code> value that specifies the port that is
     *                                  used
     * @param registerWithServerBrowser a <code>boolean</code> indicating wether we should register
     *                                  with the master server browser on megamek.info
     */
    public Server(String password, int port, boolean registerWithServerBrowser,
                  String metaServerUrl) throws IOException {
        this.metaServerUrl = metaServerUrl;
        this.password = password.length() > 0 ? password : null;
        // initialize server socket
        serverSocket = new ServerSocket(port);

        motd = createMotd();

        game.getOptions().initialize();
        game.getOptions().loadOptions();

        changePhase(IGame.Phase.PHASE_LOUNGE);

        // display server start text
        System.out.println("s: starting a new server...");

        try {
            String host = InetAddress.getLocalHost().getHostName();
            System.out.print("s: hostname = '");
            System.out.print(host);
            System.out.print("' port = ");
            System.out.println(serverSocket.getLocalPort());
            InetAddress[] addresses = InetAddress.getAllByName(host);
            for (InetAddress addresse : addresses) {
                System.out.println("s: hosting on address = "
                                   + addresse.getHostAddress());
            }
        } catch (UnknownHostException e) {
            // oh well.
        }

        System.out.println("s: password = " + this.password);

        // register commands
        registerCommand(new DefeatCommand(this));
        registerCommand(new ExportListCommand(this));
        registerCommand(new FixElevationCommand(this));
        registerCommand(new HelpCommand(this));
        registerCommand(new KickCommand(this));
        registerCommand(new ListSavesCommand(this));
        registerCommand(new LocalSaveGameCommand(this));
        registerCommand(new LocalLoadGameCommand(this));
        registerCommand(new ResetCommand(this));
        registerCommand(new RollCommand(this));
        registerCommand(new SaveGameCommand(this));
        registerCommand(new LoadGameCommand(this));
        registerCommand(new SeeAllCommand(this));
        registerCommand(new SkipCommand(this));
        registerCommand(new VictoryCommand(this));
        registerCommand(new WhoCommand(this));
        registerCommand(new TeamCommand(this));
        registerCommand(new ShowTileCommand(this));
        registerCommand(new ShowEntityCommand(this));
        registerCommand(new RulerCommand(this));
        registerCommand(new ShowValidTargetsCommand(this));
        registerCommand(new AddBotCommand(this));
        registerCommand(new CheckBVCommand(this));
        registerCommand(new CheckBVTeamCommand(this));
        registerCommand(new NukeCommand(this));
        registerCommand(new TraitorCommand(this));
        registerCommand(new ListEntitiesCommand(this));
        registerCommand(new AssignNovaNetServerCommand(this));
        registerCommand(new AllowTeamChangeCommand(this));
        registerCommand(new JoinTeamCommand(this));

        // register terrain processors
        terrainProcessors.add(new FireProcessor(this));
        terrainProcessors.add(new SmokeProcessor(this));
        terrainProcessors.add(new GeyserProcessor(this));
        terrainProcessors.add(new ElevatorProcessor(this));
        terrainProcessors.add(new ScreenProcessor(this));
        terrainProcessors.add(new WeatherProcessor(this));
        terrainProcessors.add(new QuicksandProcessor(this));

        packetPump = new PacketPump();
        packetPumpThread = new Thread(packetPump, "Packet Pump");
        packetPumpThread.start();

        if (registerWithServerBrowser) {

            final TimerTask register = new TimerTask() {
                @Override
                public void run() {
                    registerWithServerBrowser(true,
                                              Server.getServerInstance().metaServerUrl);
                }
            };
            serverBrowserUpdateTimer = new Timer(
                    "Server Browser Register Timer", true);
            serverBrowserUpdateTimer.schedule(register, 1, 40000);
        }

        // Fully initialised, now accept connections
        connector = new Thread(this, "Connection Listener");
        connector.start();

        serverInstance = this;
    }

    /**
     * Sets the game for this server. Restores any transient fields, and sets
     * all players as ghosts. This should only be called during server
     * initialization before any players have connected.
     */
    public void setGame(IGame g) {
        // game listeners are transient so we need to save and restore them
        Vector<GameListener> gameListenersClone = new Vector<GameListener>();
        for (GameListener listener : getGame().getGameListeners()) {
            gameListenersClone.add(listener);
        }

        game = g;

        for (GameListener listener : gameListenersClone) {
            getGame().addGameListener(listener);
        }

        // reattach the transient fields and ghost the players
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            ent.setGame(game);
            if (ent instanceof Mech) {
                ((Mech) ent).setBAGrabBars();
            }
            if (ent instanceof Tank) {
                ((Tank) ent).setBAGrabBars();
            }
        }
        game.setOutOfGameEntitiesVector(game.getOutOfGameEntitiesVector());
        for (Enumeration<IPlayer> e = game.getPlayers(); e.hasMoreElements(); ) {
            IPlayer p = e.nextElement();
            p.setGame(game);
            p.setGhost(true);
        }
        // might need to restore weapon type for some attacks that take multiple
        // turns (like artillery)
        for (Enumeration<AttackHandler> a = game.getAttacks(); a
                .hasMoreElements(); ) {
            AttackHandler handler = a.nextElement();
            if (handler instanceof WeaponHandler) {
                ((WeaponHandler) handler).restore();
            }
        }

    }

    /**
     * Returns the current game object
     */
    public IGame getGame() {
        return game;
    }

    /**
     * Make a default message o' the day containing the version string, and if
     * it was found, the build timestamp
     */
    private String createMotd() {
        StringBuffer buf = new StringBuffer();
        buf.append("Welcome to MegaMek.  Server is running version ");
        buf.append(MegaMek.VERSION);
        buf.append(", build date ");
        if (MegaMek.TIMESTAMP > 0L) {
            buf.append(new Date(MegaMek.TIMESTAMP).toString());
        } else {
            buf.append("unknown");
        }
        buf.append('.');

        return buf.toString();
    }

    /**
     * @return true if the server has a password
     */
    public boolean isPassworded() {
        return password != null;
    }

    /**
     * @return true if the password matches
     */
    public boolean isPassword(Object guess) {
        return password.equals(guess);
    }

    /**
     * Registers a new command in the server command table
     */
    private void registerCommand(ServerCommand command) {
        commandsHash.put(command.getName(), command);
    }

    /**
     * Returns the command associated with the specified name
     */
    public ServerCommand getCommand(String name) {
        return commandsHash.get(name);
    }

    /**
     * Shuts down the server.
     */
    public void die() {
        watchdogTimer.cancel();

        // kill thread accepting new connections
        connector = null;
        packetPump.signalEnd();
        packetPumpThread.interrupt();
        packetPumpThread = null;

        // close socket
        try {
            serverSocket.close();
        } catch (IOException ex) {
        }

        // kill pending connnections
        for (Enumeration<IConnection> connEnum = connectionsPending.elements(); connEnum
                .hasMoreElements(); ) {
            IConnection conn = connEnum.nextElement();
            conn.close();
        }
        connectionsPending.removeAllElements();

        // Send "kill" commands to all connections
        // N.B. I may be starting a race here.
        for (Enumeration<IConnection> connEnum = connections.elements(); connEnum
                .hasMoreElements(); ) {
            IConnection conn = connEnum.nextElement();
            send(conn.getId(), new Packet(Packet.COMMAND_CLOSE_CONNECTION));
        }

        // kill active connnections
        for (Enumeration<IConnection> connEnum = connections.elements(); connEnum
                .hasMoreElements(); ) {
            IConnection conn = connEnum.nextElement();
            conn.close();
        }

        connections.removeAllElements();
        connectionIds.clear();
        if (serverBrowserUpdateTimer != null) {
            serverBrowserUpdateTimer.cancel();
        }
        if (metaServerUrl != "") {
            registerWithServerBrowser(false, metaServerUrl);
        }

        System.out.flush();
    }

    /**
     * Returns an enumeration of all the command names
     */
    public Enumeration<String> getAllCommandNames() {
        return commandsHash.keys();
    }

    /**
     * Sent when a client attempts to connect.
     */
    void greeting(int cn) {
        // send server greeting -- client should reply with client info.
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));
    }

    /**
     * Returns a free connection id.
     */
    public int getFreeConnectionId() {
        while ((getPendingConnection(connectionCounter) != null)
               || (getConnection(connectionCounter) != null)
               || (getPlayer(connectionCounter) != null)) {
            connectionCounter++;
        }
        return connectionCounter;
    }

    /**
     * Returns a free entity id. Perhaps this should be in Game instead.
     */
    public int getFreeEntityId() {
        return game.getNextEntityId();
    }

    /**
     * Allow the player to set whatever parameters he is able to
     */
    private void receivePlayerInfo(Packet packet, int connId) {
        IPlayer player = (IPlayer) packet.getObject(0);
        IPlayer gamePlayer = game.getPlayer(connId);
        if (null != gamePlayer) {
            gamePlayer.setColorIndex(player.getColorIndex());
            gamePlayer.setStartingPos(player.getStartingPos());
            gamePlayer.setTeam(player.getTeam());
            gamePlayer.setCamoCategory(player.getCamoCategory());
            gamePlayer.setCamoFileName(player.getCamoFileName());
            gamePlayer.setNbrMFConventional(player.getNbrMFConventional());
            gamePlayer.setNbrMFCommand(player.getNbrMFCommand());
            gamePlayer.setNbrMFVibra(player.getNbrMFVibra());
            gamePlayer.setNbrMFActive(player.getNbrMFActive());
            gamePlayer.setNbrMFInferno(player.getNbrMFInferno());
            if (gamePlayer.getConstantInitBonus()
                != player.getConstantInitBonus()) {
                sendServerChat("Player " + gamePlayer.getName()
                               + " changed their initiative bonus from "
                               + gamePlayer.getConstantInitBonus()
                               + " to " + player.getConstantInitBonus() + ".");
            }
            gamePlayer.setConstantInitBonus(player.getConstantInitBonus());
        }
    }

    /**
     * Correct a duplicate playername
     *
     * @param oldName the <code>String</code> old playername, that is a duplicate
     * @return the <code>String</code> new playername
     */
    private String correctDupeName(String oldName) {
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            IPlayer player = i.nextElement();
            if (player.getName().equals(oldName)) {
                // We need to correct it.
                String newName = oldName;
                int dupNum = 2;
                try {
                    dupNum = Integer.parseInt(oldName.substring(oldName
                                                                        .lastIndexOf(".") + 1));
                    dupNum++;
                    newName = oldName.substring(0, oldName.lastIndexOf("."));
                } catch (Exception e) {
                    // If this fails, we don't care much.
                    // Just assume it's the first time for this name.
                    dupNum = 2;
                }
                newName = newName.concat(".").concat(Integer.toString(dupNum));
                return correctDupeName(newName);
            }
        }
        return oldName;
    }

    private void receivePlayerVersion(Packet packet, int connId) {
        String version = (String) packet.getObject(0);
        String clientChecksum = (String) packet.getObject(1);
        String serverChecksum = MegaMek.getMegaMekSHA256();
        StringBuffer buf = new StringBuffer();
        boolean needs = false;
        if (!version.equals(MegaMek.VERSION)) {
            buf.append("Client/Server version mismatch. Server reports: "
                       + MegaMek.VERSION + ", Client reports: " + version);
            System.out.println("ERROR: Client/Server Version Mismatch -- Client: "+version+" Server: "+MegaMek.VERSION);
            needs = true;
        }
        if (!clientChecksum.equals(serverChecksum)) {
            if (!version.equals(MegaMek.VERSION)) {
                buf.append(System.lineSeparator());
            }
            buf.append("Client/Server checksum mismatch. Server reports: "
                    + serverChecksum + ", Client reports: " + clientChecksum);
            System.out.println("ERROR: Client/Server Checksum Mismatch -- Client: "+clientChecksum+" Server: "+serverChecksum);
            needs = true;
        }

        // Now, if we need to, send message!
        if (needs) {
            IPlayer player = getPlayer(connId);
            if (null != player) {
                sendServerChat("For " + player.getName() + " Server reports:"
                        + System.lineSeparator()
                        + buf.toString());
            }
        } else {
            System.out.println("SUCCESS: Client/Server Version ("+version+") and Checksum ("+clientChecksum+") matched");
        }
    }

    /**
     * Recieves a player name, sent from a pending connection, and connects that
     * connection.
     */
    private void receivePlayerName(Packet packet, int connId) {
        final IConnection conn = getPendingConnection(connId);
        String name = (String) packet.getObject(0);
        boolean returning = false;

        // this had better be from a pending connection
        if (conn == null) {
            System.out.println("server: got a client name from a non-pending"
                               + " connection");
            return;
        }

        // check if they're connecting with the same name as a ghost player
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            IPlayer player = i.nextElement();
            if (player.getName().equals(name)) {
                if (player.isGhost()) {
                    returning = true;
                    player.setGhost(false);
                    // switch id
                    connId = player.getId();
                    conn.setId(connId);
                }
            }
        }

        if (!returning) {
            // Check to avoid duplicate names...
            name = correctDupeName(name);
            sendToPending(connId, new Packet(Packet.COMMAND_SERVER_CORRECT_NAME, name));
        }

        // right, switch the connection into the "active" bin
        connectionsPending.removeElement(conn);
        connections.addElement(conn);
        connectionIds.put(new Integer(conn.getId()), conn);

        // add and validate the player info
        if (!returning) {
            addNewPlayer(connId, name);
        }

        // if it is not the lounge phase, this player becomes an observer
        IPlayer player = getPlayer(connId);
        if ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) && (null != player)
            && (game.getEntitiesOwnedBy(player) < 1)) {
            player.setObserver(true);
        }

        // send the player the motd
        sendServerChat(connId, motd);

        // send info that the player has connected
        send(createPlayerConnectPacket(connId));

        // tell them their local playerId
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));

        // send current game info
        sendCurrentInfo(connId);

        try {
            InetAddress[] addresses = InetAddress.getAllByName(InetAddress
                    .getLocalHost().getHostName());
            for (InetAddress addresse : addresses) {
                sendServerChat(connId,
                               "Machine IP is " + addresse.getHostAddress());
            }
        } catch (UnknownHostException e) {
            // oh well.
        }

        // Send the port we're listening on. Only useful for the player
        // on the server machine to check.
        sendServerChat(connId,
                       "Listening on port " + serverSocket.getLocalPort());

        // Get the player *again*, because they may have disconnected.
        player = getPlayer(connId);
        if (null != player) {
            StringBuffer buff = new StringBuffer();
            buff.append(player.getName()).append(" connected from ")
                .append(getClient(connId).getInetAddress());
            String who = buff.toString();
            System.out.print("s: player #");
            System.out.print(connId);
            System.out.print(", ");
            System.out.println(who);

            sendServerChat(who);

        } // Found the player

    }

    /**
     * Sends a player the info they need to look at the current phase. This is
     * triggered when a player first connects to the server.
     */
    public void sendCurrentInfo(int connId) {
        // why are these two outside the player != null check below?
        transmitAllPlayerConnects(connId);
        send(connId, createGameSettingsPacket());
        send(connId, createPlanetaryConditionsPacket());

        IPlayer player = game.getPlayer(connId);
        if (null != player) {
            send(connId,
                 new Packet(Packet.COMMAND_SENDING_MINEFIELDS, player
                         .getMinefields()));

            switch (game.getPhase()) {
                case PHASE_LOUNGE:
                    send(connId, createMapSettingsPacket());
                    send(createMapSizesPacket());
                    // Send Entities *after* the Lounge Phase Change
                    send(connId,
                         new Packet(Packet.COMMAND_PHASE_CHANGE, game.getPhase()));
                    if (doBlind()) {
                        send(connId, createFilteredFullEntitiesPacket(player));
                    } else {
                        send(connId, createFullEntitiesPacket());
                    }
                    break;
                default:
                    send(connId, new Packet(Packet.COMMAND_ROUND_UPDATE,
                                            new Integer(game.getRoundCount())));
                    send(connId, createBoardPacket());
                    send(connId, createAllReportsPacket(player));

                    // Send entities *before* other phase changes.
                    if (doBlind()) {
                        send(connId, createFilteredFullEntitiesPacket(player));
                    } else {
                        send(connId, createFullEntitiesPacket());
                    }
                    player.setDone(game.getEntitiesOwnedBy(player) <= 0);
                    send(connId,
                         new Packet(Packet.COMMAND_PHASE_CHANGE, game.getPhase()));
                    break;
            }
            if ((game.getPhase() == IGame.Phase.PHASE_FIRING)
                || (game.getPhase() == IGame.Phase.PHASE_TARGETING)
                || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)
                || (game.getPhase() == IGame.Phase.PHASE_PHYSICAL)) {
                // can't go above, need board to have been sent
                send(connId, createAttackPacket(game.getActionsVector(), 0));
                send(connId, createAttackPacket(game.getChargesVector(), 1));
                send(connId, createAttackPacket(game.getRamsVector(), 1));
                send(connId,
                     createAttackPacket(game.getTeleMissileAttacksVector(),
                                        1));
            }
            if (game.phaseHasTurns(game.getPhase())) {
                send(connId, createTurnVectorPacket());
                send(connId, createTurnIndexPacket());
            }

            send(connId, createArtilleryPacket(player));
            send(connId, createFlarePacket());
            send(connId, createSpecialHexDisplayPacket(connId));

        } // Found the player.

    }

    /**
     * Resend entities to the player called by seeall command
     */
    public void sendEntities(int connId) {
        if (doBlind()) {
            send(connId, createFilteredEntitiesPacket(getPlayer(connId), null));
        } else {
            send(connId, createEntitiesPacket());
        }
    }

    /**
     * Adds a new player to the game
     */
    private IPlayer addNewPlayer(int connId, String name) {
        int team = IPlayer.TEAM_UNASSIGNED;
        if (game.getPhase() == Phase.PHASE_LOUNGE) {
            team = IPlayer.TEAM_NONE;
            for (IPlayer p : game.getPlayersVector()) {
                if (p.getTeam() > team) {
                    team = p.getTeam();
                }
            }
            team++;
        }
        IPlayer newPlayer = new Player(connId, name);
        int colorInd = newPlayer.getColorIndex();
        Enumeration<IPlayer> players = game.getPlayers();
        while (players.hasMoreElements()
               && (colorInd < IPlayer.colorNames.length)) {
            final IPlayer p = players.nextElement();
            if (p.getId() == newPlayer.getId()) {
                continue;
            }
            if (p.getColorIndex() == colorInd) {
                colorInd++;
            }
        }
        if (colorInd == -1) {
            colorInd = 0;
        }
        newPlayer.setColorIndex(colorInd);
        newPlayer.setCamoCategory(IPlayer.NO_CAMO);
        newPlayer.setCamoFileName(IPlayer.colorNames[colorInd]);
        newPlayer.setTeam(Math.min(team, 5));
        game.addPlayer(connId, newPlayer);
        validatePlayerInfo(connId);
        return newPlayer;
    }

    /**
     * Validates the player info.
     */
    public void validatePlayerInfo(int playerId) {
        final IPlayer player = getPlayer(playerId);

        // maybe this isn't actually useful
        // // replace characters we don't like with "X"
        // StringBuffer nameBuff = new StringBuffer(player.getName());
        // for (int i = 0; i < nameBuff.length(); i++) {
        // int chr = nameBuff.charAt(i);
        // if (LEGAL_CHARS.indexOf(chr) == -1) {
        // nameBuff.setCharAt(i, 'X');
        // }
        // }
        // player.setName(nameBuff.toString());

        // TODO: check for duplicate or reserved names

        // make sure colorIndex is unique
        boolean[] colorUsed = new boolean[IPlayer.colorNames.length];
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer otherPlayer = i.nextElement();
            if (otherPlayer.getId() != playerId) {
                colorUsed[otherPlayer.getColorIndex()] = true;
            }
        }
        if ((null != player) && colorUsed[player.getColorIndex()]) {
            // find a replacement color;
            for (int i = 0; i < colorUsed.length; i++) {
                if (!colorUsed[i]) {
                    player.setColorIndex(i);
                    break;
                }
            }
        }

    }

    /**
     * Called when it's been determined that an actual player disconnected.
     * Notifies the other players and does the appropriate housekeeping.
     */
    void disconnected(IPlayer player) {
        IGame.Phase phase = game.getPhase();

        // in the lounge, just remove all entities for that player
        if (phase == IGame.Phase.PHASE_LOUNGE) {
            removeAllEntitesOwnedBy(player);
        }

        // if a player has active entities, he becomes a ghost
        // except the VICTORY_PHASE when the dosconnected
        // player is most likely the Bot disconnected after receiving
        // the COMMAND_END_OF_GAME command
        // see the Bug 1225949.
        // Ghost players (Bots mostly) are now removed during the
        // resetGame(), so we don't need to do it here.
        // This fixes Bug 3399000 without reintroducing 1225949
        if ((phase == IGame.Phase.PHASE_VICTORY)
            || (phase == IGame.Phase.PHASE_LOUNGE) || player.isObserver()) {
            game.removePlayer(player.getId());
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, new Integer(
                    player.getId())));
            // Prevent situation where all players but the disconnected one
            // are done, and the disconnecting player causes the game to start
            if (phase == IGame.Phase.PHASE_LOUNGE) {
                resetActivePlayersDone();
            }
        } else {
            player.setGhost(true);
            player.setDone(true);
            send(createPlayerUpdatePacket(player.getId()));
        }

        // make sure the game advances
        if (game.phaseHasTurns(game.getPhase()) && (null != game.getTurn())) {
            if (game.getTurn().isValid(player.getId(), game)) {
                sendGhostSkipMessage(player);
            }
        } else {
            checkReady();
        }

        // notify other players
        sendServerChat(player.getName() + " disconnected.");

        // log it
        System.out.println("s: removed player " + player.getName());

        // Reset the game after Elvis has left the building.
        if (0 == game.getNoOfPlayers()) {
            resetGame();
        }
    }

    /**
     * Checks each player to see if he has no entities, and if true, sets the
     * observer flag for that player. An exception is that there are no
     * observers during the lounge phase.
     */
    public void checkForObservers() {
        for (Enumeration<IPlayer> e = game.getPlayers(); e.hasMoreElements(); ) {
            IPlayer p = e.nextElement();
            p.setObserver((game.getEntitiesOwnedBy(p) < 1)
                          && (game.getPhase() != IGame.Phase.PHASE_LOUNGE));
        }
    }

    /**
     * Reset the game back to the lounge. TODO: couldn't this be a hazard if
     * there are other things executing at the same time?
     */
    public void resetGame() {
        // remove all entities
        game.reset();
        send(createEntitiesPacket());
        send(new Packet(Packet.COMMAND_SENDING_MINEFIELDS, new Vector<Object>()));

        // remove ghosts
        ArrayList<IPlayer> ghosts = new ArrayList<IPlayer>();
        for (Enumeration<IPlayer> players = game.getPlayers(); players
                .hasMoreElements(); ) {
            IPlayer p = players.nextElement();
            if (p.isGhost()) {
                ghosts.add(p);
            } else {
                // non-ghosts set their starting positions to any
                p.setStartingPos(Board.START_ANY);
                send(createPlayerUpdatePacket(p.getId()));
            }
        }
        for (IPlayer p : ghosts) {
            game.removePlayer(p.getId());
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE,
                            new Integer(p.getId())));
        }

        // reset all players
        resetPlayersDone();
        transmitAllPlayerDones();

        // Write end of game to stdout so controlling scripts can rotate logs.
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        System.out.print(format.format(new Date()));
        System.out.println(" END OF GAME");

        changePhase(IGame.Phase.PHASE_LOUNGE);
    }

    /**
     * automatically save the game
     */
    public void autoSave() {
        String fileName = "autosave";
        if (PreferenceManager.getClientPreferences().stampFilenames()) {
            fileName = StringUtil.addDateTimeStamp(fileName);
        }
        saveGame(fileName, game.getOptions().booleanOption("autosave_msg"));
    }

    /**
     * save the game and send it to the specified connection
     *
     * @param connId     The <code>int</code> connection id to send to
     * @param sFile      The <code>String</code> filename to use
     * @param sLocalPath The <code>String</code> path to the file to be used on the
     *                   client
     */
    public void sendSaveGame(int connId, String sFile, String sLocalPath) {
        saveGame(sFile, false);
        String sFinalFile = sFile;
        if (!sFinalFile.endsWith(".sav.gz")) {
            if (sFinalFile.endsWith(".sav")) {
                sFinalFile = sFile + ".gz";
            } else {
                sFinalFile = sFile + ".sav.gz";
            }
        }
        sLocalPath = sLocalPath.replaceAll("\\|", " ");
        String localFile = "savegames" + File.separator + sFinalFile;
        try {
            ArrayList<Integer> data = new ArrayList<Integer>();
            BufferedInputStream fin = new BufferedInputStream(
                    new FileInputStream(localFile));
            int input;
            while ((input = fin.read()) != -1) {
                data.add(input);
            }
            send(connId, new Packet(Packet.COMMAND_SEND_SAVEGAME, new Object[]{
                    sFinalFile, data, sLocalPath}));
            sendChat(connId, "***Server", "Savegame has been sent to you.");
            fin.close();
        } catch (Exception e) {
            System.err.println("Unable to load file: " + localFile);
            e.printStackTrace();
        }
    }

    /**
     * save the game
     *
     * @param sFile    The <code>String</code> filename to use
     * @param sendChat A <code>boolean</code> value wether or not to announce the
     *                 saving to the server chat.
     */
    public void saveGame(String sFile, boolean sendChat) {
        // We need to strip the .gz if it exists,
        // otherwise we'll double up on it.
        if (sFile.endsWith(".gz")) {
            sFile = sFile.replace(".gz", "");
        }
        XStream xstream = new XStream();
        String sFinalFile = sFile;
        if (!sFinalFile.endsWith(".sav")) {
            sFinalFile = sFile + ".sav";
        }
        try {
            File sDir = new File("savegames");
            if (!sDir.exists()) {
                sDir.mkdir();
            }

            sFinalFile = sDir + File.separator + sFinalFile;
            GZIPOutputStream gzo = new GZIPOutputStream(new FileOutputStream(
                    sFinalFile + ".gz"));
            Writer writer = new OutputStreamWriter(gzo, Charset.forName("UTF-8"));
            xstream.toXML(game, writer);
            writer.close();
            gzo.close();
        } catch (Exception e) {
            System.err.println("Unable to save file: " + sFinalFile);
            e.printStackTrace();
        }

        if (sendChat) {
            sendChat("MegaMek", "Game saved to " + sFinalFile);
        }
    }

    /**
     * save the game
     *
     * @param sFile The <code>String</code> filename to use
     */
    public void saveGame(String sFile) {
        saveGame(sFile, true);
    }

    /**
     * send a packet to the connection tells it load a locally saved game
     *
     * @param connId The <code>int</code> connection id to send to
     * @param sFile  The <code>String</code> filename to use
     */
    public void sendLoadGame(int connId, String sFile) {
        String sFinalFile = sFile;
        if (!sFinalFile.endsWith(".sav") && !sFinalFile.endsWith(".sav.gz")) {
            sFinalFile = sFile + ".sav";
        }
        if (!sFinalFile.endsWith(".gz")) {
            sFinalFile = sFinalFile + ".gz";
        }
        send(connId, new Packet(Packet.COMMAND_LOAD_SAVEGAME,
                                new Object[]{sFinalFile}));
    }

    /**
     * load the game
     *
     * @param f The <code>File</code> to load
     * @return A <code>boolean</code> value wether or not the loading was
     * successfull
     */
    public boolean loadGame(File f) {
        return loadGame(f, true);
    }

    /**
     * load the game
     *
     * @param f
     *            The <code>File</code> to load
     * @param sendInfo
     *            Determines whether the connections should be updated with
     *            current info. This may be false if some reconnection remapping
     *            needs to be done first.
     * @return A <code>boolean</code> value wether or not the loading was
     *         successfull
     */
    public boolean loadGame(File f, boolean sendInfo) {
        System.out.println("s: loading saved game file '" + f + '\'');
        IGame newGame;
        try {
            XStream xstream = new XStream();
            newGame = (IGame) xstream.fromXML(new GZIPInputStream(
                    new FileInputStream(f)));
        } catch (Exception e) {
            System.err.println("Unable to load file: " + f);
            e.printStackTrace();
            return false;
        }

        setGame(newGame);

        if (!sendInfo) {
            return true;
        }

        // update all the clients with the new game info
        for (IConnection conn : connections) {
            sendCurrentInfo(conn.getId());
        }
        return true;
    }

    /**
     * When the load command is used, there is a list of already connected
     * players which have assigned names and player id numbers with the id
     * numbers matching the connection numbers. When a new game is loaded, this
     * mapping may need to be updated. This method takes a map of player names
     * to their current ids, and uses the list of players to figure out what the
     * current ids should change to.
     *
     * @param nameToIdMap
     *            This maps a player name to the current connection ID
     * @param idToNameMap
     *            This maps a current conn ID to a player name, and is just the
     *            inverse mapping from nameToIdMap
     */
    public void remapConnIds(Map<String, Integer> nameToIdMap,
            Map<Integer, String> idToNameMap) {
        // Keeps track of connections without Ids
        List<IConnection> unassignedConns = new ArrayList<>();
       // Keep track of which ids are used
        Set<Integer> usedPlayerIds = new HashSet<>();
        Set<String> currentPlayerNames = new HashSet<>();
        for (IPlayer p : game.getPlayersVector()) {
            currentPlayerNames.add(p.getName());
        }
        // Map the old connection Id to new value
        Map<Integer,Integer> connIdRemapping = new HashMap<>();
        for (IPlayer p : game.getPlayersVector()) {
            // Check to see if this player was already connected
            Integer oldId = nameToIdMap.get(p.getName());
            if ((oldId != null) && (oldId != p.getId())) {
                connIdRemapping.put(oldId, p.getId());
            }
            // If the old and new Ids match, make sure we remove ghost status
            if ((oldId != null) && (oldId == p.getId())) {
                p.setGhost(false);
            }
            // Check to see if this player's Id is taken
            String oldName = idToNameMap.get(p.getId());
            if ((oldName != null) && !oldName.equals(p.getName())) {
                // If this name doesn't belong to a current player, unassign it
                if (!currentPlayerNames.contains(oldName)) {
                    unassignedConns.add(connectionIds.get(p.getId()));
                    // Make sure we don't add this to unassigned conns twice
                    connectionIds.remove(p.getId());
                }
                // If it does belong to a current player, it'll get handled
                // when that player comes up
            }
            // Keep track of what Ids are used
            usedPlayerIds.add(p.getId());
        }

        // Remap old connection Ids to new ones
        for (Integer currConnId : connIdRemapping.keySet()) {
            Integer newId = connIdRemapping.get(currConnId);
            IConnection conn = connectionIds.get(currConnId);
            conn.setId(newId);
            // If this Id is used, make sure we reassign that connection
            if (connectionIds.containsKey(newId)) {
                unassignedConns.add(connectionIds.get(newId));
            }
            // Map the new Id
            connectionIds.put(newId, conn);

            game.getPlayer(newId).setGhost(false);
            send(newId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(newId)));
        }

        // It's possible we have players not in the saved game, add 'em
        for (IConnection conn : unassignedConns) {
            int newId = 0;
            while (usedPlayerIds.contains(newId)) {
                newId++;
            }
            String name = idToNameMap.get(conn.getId());
            conn.setId(newId);
            IPlayer newPlayer = addNewPlayer(newId, name);
            newPlayer.setObserver(true);
            connectionIds.put(newId,  conn);
            send(newId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(newId)));
        }

        // Ensure all clients are up-to-date on player info
        transmitAllPlayerUpdates();
    }

    /**
     * Shortcut to game.getPlayer(id)
     */
    public IPlayer getPlayer(int id) {
        return game.getPlayer(id);
    }

    /**
     * Removes all entities owned by a player. Should only be called when it
     * won't cause trouble (the lounge, for instance, or between phases.)
     *
     * @param player whose entites are to be removed
     */
    private void removeAllEntitesOwnedBy(IPlayer player) {
        Vector<Entity> toRemove = new Vector<Entity>();

        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();

            if (entity.getOwner().equals(player)) {
                toRemove.addElement(entity);
            }
        }

        for (Entity entity : toRemove) {
            int id = entity.getId();
            game.removeEntity(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED);
            send(createRemoveEntityPacket(id,
                                          IEntityRemovalConditions.REMOVE_NEVER_JOINED));
        }
    }

    /**
     * a shorter name for getConnection()
     */
    private IConnection getClient(int connId) {
        return getConnection(connId);
    }

    /**
     * Returns a connection, indexed by id
     */
    public Enumeration<IConnection> getConnections() {
        return connections.elements();
    }

    /**
     * Returns a connection, indexed by id
     */
    public IConnection getConnection(int connId) {
        return connectionIds.get(new Integer(connId));
    }

    /**
     * Returns a pending connection
     */
    IConnection getPendingConnection(int connId) {
        for (IConnection conn : connectionsPending) {
            if (conn.getId() == connId) {
                return conn;
            }
        }
        return null;
    }

    /**
     * Called at the beginning of each game round to reset values on this entity
     * that are reset every round
     */
    private void resetEntityRound() {
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity entity = e.next();

            entity.newRound(game.getRoundCount());
        }
    }

    /**
     * Check a list of entity Ids for doomed entities and destroy those.
     */
    private void destroyDoomedEntities(Vector<Integer> entityIds) {
        Vector<Entity> toRemove = new Vector<Entity>(0, 10);
        for (Integer entityId : entityIds) {
            Entity entity = game.getEntity(entityId);
            if (entity.isDoomed()) {
                entity.setDestroyed(true);

                // Is this unit swarming somebody? Better let go before
                // it's too late.
                final int swarmedId = entity.getSwarmTargetId();
                if (Entity.NONE != swarmedId) {
                    final Entity swarmed = game.getEntity(swarmedId);
                    swarmed.setSwarmAttackerId(Entity.NONE);
                    entity.setSwarmTargetId(Entity.NONE);
                    Report r = new Report(5165);
                    r.subject = swarmedId;
                    r.addDesc(swarmed);
                    addReport(r);
                    entityUpdate(swarmedId);
                }
            }

            if (entity.isDestroyed()) {
                toRemove.addElement(entity);
            }
        }

        // actually remove all flagged entities
        for (Entity entity : toRemove) {
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
            if (!entity.isSalvage()) {
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
            }
            // If we removed a unit during the movement phase that hasn't moved,
            // remove its turn.
            if ((game.getPhase() == Phase.PHASE_MOVEMENT)
                && entity.isSelectableThisTurn()) {
                game.removeTurnFor(entity);
                send(createTurnVectorPacket());
            }
            entityUpdate(entity.getId());
            game.removeEntity(entity.getId(), condition);
            send(createRemoveEntityPacket(entity.getId(), condition));
        }
    }

    /**
     * Called at the beginning of each phase. Sets and resets any entity
     * parameters that need to be reset.
     */
    private void resetEntityPhase(IGame.Phase phase) {
        // first, mark doomed entities as destroyed and flag them
        Vector<Entity> toRemove = new Vector<Entity>(0, 10);
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();
            entity.newPhase(phase);
            if (entity.isDoomed()) {
                entity.setDestroyed(true);

                // Is this unit swarming somebody? Better let go before
                // it's too late.
                final int swarmedId = entity.getSwarmTargetId();
                if (Entity.NONE != swarmedId) {
                    final Entity swarmed = game.getEntity(swarmedId);
                    swarmed.setSwarmAttackerId(Entity.NONE);
                    entity.setSwarmTargetId(Entity.NONE);
                    Report r = new Report(5165);
                    r.subject = swarmedId;
                    r.addDesc(swarmed);
                    addReport(r);
                    entityUpdate(swarmedId);
                }
            }

            if (entity.isDestroyed()) {
                toRemove.addElement(entity);
            }
        }

        // actually remove all flagged entities
        for (Entity entity : toRemove) {
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
            if (!entity.isSalvage()) {
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
            }

            entityUpdate(entity.getId());
            game.removeEntity(entity.getId(), condition);
            send(createRemoveEntityPacket(entity.getId(), condition));
        }

        // do some housekeeping on all the remaining
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            final Entity entity = e.next();

            entity.applyDamage();

            entity.reloadEmptyWeapons();

            // reset damage this phase
            // tele-missiles need a record of damage last phase
            entity.damageThisRound += entity.damageThisPhase;
            entity.damageThisPhase = 0;
            entity.engineHitsThisPhase = 0;
            entity.rolledForEngineExplosion = false;
            entity.dodging = false;
            entity.setShutDownThisPhase(false);
            entity.setStartupThisPhase(false);

            // reset done to false

            if (phase == IGame.Phase.PHASE_DEPLOYMENT) {
                entity.setDone(!entity.shouldDeploy(game.getRoundCount()));
            } else {
                entity.setDone(false);
            }

            // reset spotlights
            entity.setIlluminated(false);
            entity.setUsedSearchlight(false);
            entity.setCarefulStand(false);

            if (entity instanceof MechWarrior) {
                ((MechWarrior) entity).setLanded(true);
            }
        }
        game.clearIlluminatedPositions();
        send(new Packet(Packet.COMMAND_CLEAR_ILLUM_HEXES));
    }

    /**
     * are we currently in a reporting phase
     *
     * @return <code>true</code> if we are or <code>false</code> if not.
     */
    private boolean isReportingPhase() {

        if ((game.getPhase() == IGame.Phase.PHASE_FIRING_REPORT)
            || (game.getPhase() == IGame.Phase.PHASE_INITIATIVE_REPORT)
            || (game.getPhase() == IGame.Phase.PHASE_MOVEMENT_REPORT)
            || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD_REPORT)
            || (game.getPhase() == IGame.Phase.PHASE_PHYSICAL_REPORT)) {
            return true;
        }

        return false;
    }

    /**
     * Called at the beginning of certain phases to make every player not ready.
     */
    private void resetPlayersDone() {
        if (isReportingPhase()) {
            return;
        }
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();
            player.setDone(false);
        }
        transmitAllPlayerDones();
    }

    /**
     * Called at the beginning of certain phases to make every active player not
     * ready.
     */
    private void resetActivePlayersDone() {
        /*
         * if (isReportingPhase()) { return; }
         */
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();

            player.setDone(game.getEntitiesOwnedBy(player) <= 0);

        }
        transmitAllPlayerDones();
    }

    /**
     * Writes the victory report
     */
    private void prepareVictoryReport() {
        Report r;

        // remove carcasses to the graveyard
        Vector<Entity> toRemove = new Vector<Entity>();
        for (Entity e : game.getEntitiesVector()) {
            if (e.isCarcass() && !e.isDestroyed()) {
                toRemove.add(e);
            }
        }
        for (Entity e : toRemove) {
            destroyEntity(e, "crew death", false, true);
            game.removeEntity(e.getId(),
                              IEntityRemovalConditions.REMOVE_SALVAGEABLE);
            e.setDestroyed(true);
        }

        addReport(new Report(7000, Report.PUBLIC));

        // Declare the victor
        r = new Report(1210);
        r.type = Report.PUBLIC;
        if (game.getVictoryTeam() == IPlayer.TEAM_NONE) {
            IPlayer player = getPlayer(game.getVictoryPlayerId());
            if (null == player) {
                r.messageId = 7005;
            } else {
                r.messageId = 7010;
                r.add(Server.getColorForPlayer(player));
            }
        } else {
            // Team victory
            r.messageId = 7015;
            r.add(game.getVictoryTeam());
        }
        addReport(r);

        // Show player BVs
        Enumeration<IPlayer> players = game.getPlayers();
        while (players.hasMoreElements()) {
            IPlayer player = players.nextElement();
            r = new Report();
            r.type = Report.PUBLIC;
            r.messageId = 7016;
            r.add(Server.getColorForPlayer(player));
            r.add(player.getBV());
            r.add(player.getInitialBV());
            r.add(player.getFledBV());
            addReport(r);
        }

        // List the survivors
        Iterator<Entity> survivors = game.getEntities();
        if (survivors.hasNext()) {
            addReport(new Report(7020, Report.PUBLIC));
            while (survivors.hasNext()) {
                Entity entity = survivors.next();

                if (!entity.isDeployed()) {
                    continue;
                }

                addReport(entity.victoryReport());
            }
        }
        // List units that never deployed
        Iterator<Entity> undeployed = game.getEntities();
        if (undeployed.hasNext()) {
            boolean wroteHeader = false;

            while (undeployed.hasNext()) {
                Entity entity = undeployed.next();

                if (entity.isDeployed()) {
                    continue;
                }

                if (!wroteHeader) {
                    addReport(new Report(7075, Report.PUBLIC));
                    wroteHeader = true;
                }

                addReport(entity.victoryReport());
            }
        }
        // List units that retreated
        Enumeration<Entity> retreat = game.getRetreatedEntities();
        if (retreat.hasMoreElements()) {
            addReport(new Report(7080, Report.PUBLIC));
            while (retreat.hasMoreElements()) {
                Entity entity = retreat.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // List destroyed units
        Enumeration<Entity> graveyard = game.getGraveyardEntities();
        if (graveyard.hasMoreElements()) {
            addReport(new Report(7085, Report.PUBLIC));
            while (graveyard.hasMoreElements()) {
                Entity entity = graveyard.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // List devastated units (not salvagable)
        Enumeration<Entity> devastated = game.getDevastatedEntities();
        if (devastated.hasMoreElements()) {
            addReport(new Report(7090, Report.PUBLIC));

            while (devastated.hasMoreElements()) {
                Entity entity = devastated.nextElement();
                addReport(entity.victoryReport());
            }
        }
        // Let player know about entitystatus.txt file
        addReport(new Report(7095, Report.PUBLIC));
    }

    /**
     * Generates a detailed report for campaign use
     */
    private String getDetailedVictoryReport() {
        StringBuffer sb = new StringBuffer();

        Vector<Entity> vAllUnits = new Vector<Entity>();
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vAllUnits.addElement(i.next());
        }

        for (Enumeration<Entity> i = game.getRetreatedEntities(); i
                .hasMoreElements(); ) {
            vAllUnits.addElement(i.nextElement());
        }

        for (Enumeration<Entity> i = game.getGraveyardEntities(); i
                .hasMoreElements(); ) {
            vAllUnits.addElement(i.nextElement());
        }

        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {

            // Record the player.
            IPlayer p = i.nextElement();
            sb.append("++++++++++ ").append(p.getName()).append(" ++++++++++");
            sb.append(CommonConstants.NL);

            // Record the player's alive, retreated, or salvageable units.
            for (int x = 0; x < vAllUnits.size(); x++) {
                Entity e = vAllUnits.elementAt(x);
                if (e.getOwner() == p) {
                    sb.append(UnitStatusFormatter.format(e));
                }
            }

            // Record the player's devastated units.
            Enumeration<Entity> devastated = game.getDevastatedEntities();
            if (devastated.hasMoreElements()) {
                sb.append("=============================================================");
                sb.append(CommonConstants.NL);
                sb.append("The following utterly destroyed units are not available for salvage:");
                sb.append(CommonConstants.NL);
                while (devastated.hasMoreElements()) {
                    Entity e = devastated.nextElement();
                    if (e.getOwner() == p) {
                        sb.append(e.getShortName()).append(", Pilot: ")
                          .append(e.getCrew().getName()).append(" (")
                          .append(e.getCrew().getGunnery()).append('/')
                          .append(e.getCrew().getPiloting()).append(')');
                        sb.append(CommonConstants.NL);
                    }
                } // Handle the next unsalvageable unit for the player
                sb.append("=============================================================");
                sb.append(CommonConstants.NL);
            }

        } // Handle the next player

        return sb.toString();
    }

    /**
     * Forces victory for the specified player, or his/her team at the end of
     * the round.
     */
    public void forceVictory(IPlayer victor) {
        game.setForceVictory(true);
        if (victor.getTeam() == IPlayer.TEAM_NONE) {
            game.setVictoryPlayerId(victor.getId());
            game.setVictoryTeam(IPlayer.TEAM_NONE);
        } else {
            game.setVictoryPlayerId(IPlayer.PLAYER_NONE);
            game.setVictoryTeam(victor.getTeam());
        }

        Vector<IPlayer> playersVector = game.getPlayersVector();
        for (int i = 0; i < playersVector.size(); i++) {
            IPlayer player = playersVector.elementAt(i);
            player.setAdmitsDefeat(false);
        }
    }

    /**
     * Cancels the force victory
     */
    public void cancelVictory() {
        game.setForceVictory(false);
        game.setVictoryPlayerId(IPlayer.PLAYER_NONE);
        game.setVictoryTeam(IPlayer.TEAM_NONE);
    }

    public void requestTeamChange(int team, IPlayer player) {
        requestedTeam = team;
        playerChangingTeam = player;
        changePlayersTeam = false;
    }

    public void allowTeamChange() {
        changePlayersTeam = true;
    }

    public boolean isTeamChangeRequestInProgress() {
        return playerChangingTeam != null;
    }

    public IPlayer getPlayerRequestingTeamChange() {
        return playerChangingTeam;
    }

    public int getRequestedTeam() {
        return requestedTeam;
    }

    private void processTeamChange() {
        if (playerChangingTeam != null) {
            playerChangingTeam.setTeam(requestedTeam);
            game.setupTeams();
            send(createPlayerUpdatePacket(playerChangingTeam.getId()));
            String teamString = "Team " + requestedTeam + "!";
            if (requestedTeam == IPlayer.TEAM_UNASSIGNED) {
                teamString = " unassigned!";
            } else if (requestedTeam == IPlayer.TEAM_NONE) {
                teamString = " lone wolf!";
            }
            sendServerChat(playerChangingTeam.getName()
                           + " has changed teams to " + teamString);
            playerChangingTeam = null;
        }
        changePlayersTeam = false;
    }

    /**
     * Called when a player declares that he is "done." Checks to see if all
     * players are done, and if so, moves on to the next phase.
     */
    private void checkReady() {
        // check if all active players are done
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();
            if (!player.isGhost() && !player.isObserver() && !player.isDone()) {
                return;
            }
        }

        // Tactical Genius pilot special ability (lvl 3)
        if (game.getNoOfInitiativeRerollRequests() > 0) {
            resetActivePlayersDone();
            game.rollInitAndResolveTies();

            determineTurnOrder(IGame.Phase.PHASE_INITIATIVE);
            clearReports();
            writeInitiativeReport(true);
            sendReport(true);
            return; // don't end the phase yet, players need to see new report
        }

        // need at least one entity in the game for the lounge phase to end
        if (!game.phaseHasTurns(game.getPhase())
            && ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) || (game
                                                                          .getNoOfEntities() > 0))) {
            endCurrentPhase();
        }
    }

    /**
     * Called when the current player has done his current turn and the turn
     * counter needs to be advanced. Also enforces the "protos_move_multi" and
     * the "protos_move_multi" option. If the player has just moved
     * infantry/protos with a "normal" turn, adds up to
     * Game.INF_AND_PROTOS_MOVE_MULTI - 1 more infantry/proto-specific turns
     * after the current turn.
     */
    private void endCurrentTurn(Entity entityUsed) {

        // Enforce "inf_move_multi" and "protos_move_multi" options.
        // The "isNormalTurn" flag is checking to see if any non-Infantry
        // or non-Protomech units can move during the current turn.
        boolean turnsChanged = false;
        boolean outOfOrder = false;
        GameTurn turn = game.getTurn();
        if (game.isPhaseSimultaneous() && (entityUsed != null)
            && (entityUsed != null)
            && !turn.isValid(entityUsed.getOwnerId(), game)) {
            // turn played out of order
            outOfOrder = true;
            entityUsed.setDone(false);
            GameTurn removed = game.removeFirstTurnFor(entityUsed);
            entityUsed.setDone(true);
            turnsChanged = true;
            if (removed != null) {
                turn = removed;
            }
        }
        final Phase currPhase = game.getPhase();
        final GameOptions gameOpts = game.getOptions();
        final int playerId = null == entityUsed ? IPlayer.PLAYER_NONE
                                                : entityUsed.getOwnerId();
        boolean infMoved = entityUsed instanceof Infantry;
        boolean infMoveMulti = gameOpts.booleanOption("inf_move_multi")
               && ((currPhase == IGame.Phase.PHASE_MOVEMENT)
                   || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
                   || (currPhase == IGame.Phase.PHASE_INITIATIVE));
        boolean protosMoved = entityUsed instanceof Protomech;
        boolean protosMoveMulti = gameOpts.booleanOption("protos_move_multi");
        boolean tanksMoved = entityUsed instanceof Tank;
        boolean tanksMoveMulti = gameOpts.booleanOption(
                "vehicle_lance_movement")
                && ((currPhase == IGame.Phase.PHASE_MOVEMENT)
                    || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
                    || (currPhase == IGame.Phase.PHASE_INITIATIVE));
        boolean meksMoved = entityUsed instanceof Mech;
        boolean meksMoveMulti = gameOpts.booleanOption("mek_lance_movement")
                && ((currPhase == IGame.Phase.PHASE_MOVEMENT)
                    || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
                    || (currPhase == IGame.Phase.PHASE_INITIATIVE));

        // If infantry or protos move multi see if any
        // other unit types can move in the current turn.
        int multiMask = 0;
        if (infMoveMulti && infMoved) {
            multiMask = GameTurn.CLASS_INFANTRY;
        } else if (protosMoveMulti && protosMoved) {
            multiMask = GameTurn.CLASS_PROTOMECH;
        } else if (tanksMoveMulti && tanksMoved) {
            multiMask = GameTurn.CLASS_TANK;
        } else if (meksMoveMulti && meksMoved) {
            multiMask = GameTurn.CLASS_MECH;
        }

        // In certain cases, a new SpecificEntityTurn could have been added for
        // the Entity whose turn we are ending as the next turn. If this has
        // happened, the remaining entity count will be off and we must ensure
        // that the SpecificEntityTurn for this unit remains the next turn
        List<GameTurn> turnVector = game.getTurnVector();
        int turnIndex = game.getTurnIndex();
        boolean usedEntityNotDone = false;
        if ((turnIndex + 1) < turnVector.size()) {
            GameTurn nextTurn = turnVector.get(turnIndex + 1);
            if (nextTurn instanceof GameTurn.SpecificEntityTurn) {
                GameTurn.SpecificEntityTurn seTurn =
                        (GameTurn.SpecificEntityTurn) nextTurn;
                if ((entityUsed != null)
                        && (seTurn.getEntityNum() == entityUsed.getId())) {
                    turnIndex++;
                    usedEntityNotDone = true;
                }
            }
        }

        // Was the turn we just took added as part of a multi-turn?
        //  This determines if we should add more multiturns
        boolean isMultiTurn = turn.isMultiTurn();

        // Unless overridden by the "protos_move_multi" option, all Protomechs
        // in a unit declare fire, and they don't mix with infantry.
        if (protosMoved && !protosMoveMulti && !isMultiTurn
            && (entityUsed != null)) {

            // What's the unit number and ID of the entity used?
            final char movingUnit = entityUsed.getUnitNumber();
            final int movingId = entityUsed.getId();

            // How many other Protomechs are in the unit that can fire?
            int protoTurns = game.getSelectedEntityCount(new EntitySelector() {
                private final int ownerId = playerId;

                private final int entityId = movingId;

                private final char unitNum = movingUnit;

                public boolean accept(Entity entity) {
                    if ((entity instanceof Protomech)
                        && entity.isSelectableThisTurn()
                        && (ownerId == entity.getOwnerId())
                        && (entityId != entity.getId())
                        && (unitNum == entity.getUnitNumber())) {
                        return true;
                    }
                    return false;
                }
            });

            // Add the correct number of turns for the Protomech unit number.
            for (int i = 0; i < protoTurns; i++) {
                GameTurn newTurn = new GameTurn.UnitNumberTurn(playerId,
                                                               movingUnit);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }
        // Otherwise, we may need to add turns for the "*_move_multi" options.
        else if (((infMoved && infMoveMulti)
                  || (protosMoved && protosMoveMulti)) && !isMultiTurn) {
            int remaining = 0;

            // Calculate the number of EntityClassTurns need to be added.
            if (infMoveMulti && infMoved) {
                remaining += game.getInfantryLeft(playerId);
            }
            if (protosMoveMulti && protosMoved) {
                remaining += game.getProtomechsLeft(playerId);
            }
            if (usedEntityNotDone) {
                remaining--;
            }
            int moreInfAndProtoTurns = Math.min(
                    gameOpts.intOption("inf_proto_move_multi") - 1, remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreInfAndProtoTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId,
                                                                multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        if (tanksMoved && tanksMoveMulti && !isMultiTurn) {
            int remaining = game.getVehiclesLeft(playerId);
            if (usedEntityNotDone) {
                remaining--;
            }
            int moreVeeTurns = Math.min(
                    gameOpts.intOption("vehicle_lance_movement_number") - 1,
                    remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreVeeTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId,
                                                                multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        if (meksMoved && meksMoveMulti && !isMultiTurn) {
            int remaining = game.getMechsLeft(playerId);
            if (usedEntityNotDone) {
                remaining--;
            }
            int moreMekTurns = Math.min(
                    gameOpts.intOption("mek_lance_movement_number") - 1,
                    remaining);

            // Add the correct number of turns for the right unit classes.
            for (int i = 0; i < moreMekTurns; i++) {
                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId,
                                                                multiMask);
                newTurn.setMultiTurn(true);
                game.insertTurnAfter(newTurn, turnIndex);
                turnsChanged = true;
            }
        }

        // brief everybody on the turn update, if they changed
        if (turnsChanged) {
            send(createTurnVectorPacket());
        }

        // move along
        if (outOfOrder) {
            send(createTurnIndexPacket());
        } else {
            changeToNextTurn();
        }
    }

    /**
     * Changes the current phase, does some bookkeeping and then tells the
     * players.
     *
     * @param phase the <code>int</code> id of the phase to change to
     */
    private void changePhase(IGame.Phase phase) {
        game.setLastPhase(game.getPhase());
        game.setPhase(phase);

        // prepare for the phase
        prepareForPhase(phase);

        if (isPhasePlayable(phase)) {
            // tell the players about the new phase
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, phase));

            // post phase change stuff
            executePhase(phase);
        } else {
            endCurrentPhase();
        }
    }

    /**
     * Prepares for, presumably, the next phase. This typically involves
     * resetting the states of entities in the game and making sure the client
     * has the information it needs for the new phase.
     *
     * @param phase the <code>int</code> id of the phase to prepare for
     */
    private void prepareForPhase(IGame.Phase phase) {
        switch (phase) {
            case PHASE_LOUNGE:
                clearReports();
                mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(
                        mapSettings.getBoardWidth(), mapSettings.getBoardHeight())));
                mapSettings.setNullBoards(DEFAULT_BOARD);
                send(createMapSettingsPacket());
                checkForObservers();
                transmitAllPlayerUpdates();
                break;
            case PHASE_INITIATIVE:
                // remove the last traces of last round
                game.resetActions();
                game.resetTagInfo();
                sendTagInfoReset();
                clearReports();
                resetEntityRound();
                resetEntityPhase(phase);
                checkForObservers();
                transmitAllPlayerUpdates();

                // roll 'em
                resetActivePlayersDone();
                rollInitiative();

                if (!game.shouldDeployThisRound()) {
                    incrementAndSendGameRound();
                }

                // setIneligible(phase);
                determineTurnOrder(phase);
                writeInitiativeReport(false);

                // checks for environmental survival
                checkForConditionDeath();

                checkForBlueShieldDamage();
                if (game.getBoard().inAtmosphere()) {
                    checkForAtmosphereDeath();
                }
                if (game.getBoard().inSpace()) {
                    checkForSpaceDeath();
                }

                System.out.println("Round " + game.getRoundCount()
                                   + " memory usage: " + MegaMek.getMemoryUsed());
                break;
            case PHASE_DEPLOY_MINEFIELDS:
                checkForObservers();
                transmitAllPlayerUpdates();
                resetActivePlayersDone();
                setIneligible(phase);

                Enumeration<IPlayer> e = game.getPlayers();
                Vector<GameTurn> turns = new Vector<GameTurn>();
                while (e.hasMoreElements()) {
                    IPlayer p = e.nextElement();
                    if (p.hasMinefields() && game.getBoard().onGround()) {
                        GameTurn gt = new GameTurn(p.getId());
                        turns.addElement(gt);
                    }
                }
                game.setTurnVector(turns);
                game.resetTurnIndex();

                // send turns to all players
                send(createTurnVectorPacket());
                break;
            case PHASE_SET_ARTYAUTOHITHEXES:
                // place off board entities actually off-board
                Iterator<Entity> entities = game.getEntities();
                while (entities.hasNext()) {
                    Entity en = entities.next();
                    en.deployOffBoard();
                }
                checkForObservers();
                transmitAllPlayerUpdates();
                resetActivePlayersDone();
                setIneligible(phase);

                Enumeration<IPlayer> players = game.getPlayers();
                Vector<GameTurn> turn = new Vector<GameTurn>();

                // Walk through the players of the game, and add
                // a turn for all players with artillery weapons.
                while (players.hasMoreElements()) {

                    // Get the next player.
                    final IPlayer p = players.nextElement();

                    // Does the player have any artillery-equipped units?
                    EntitySelector playerArtySelector = new EntitySelector() {
                        private IPlayer owner = p;

                        public boolean accept(Entity entity) {
                            if (owner.equals(entity.getOwner())
                                && entity.isEligibleForArtyAutoHitHexes()) {
                                return true;
                            }
                            return false;
                        }
                    };
                if (game.getSelectedEntities(playerArtySelector).hasNext()) {
                        // Yes, the player has arty-equipped units.
                        GameTurn gt = new GameTurn(p.getId());
                        turn.addElement(gt);
                    }
                }
                game.setTurnVector(turn);
                game.resetTurnIndex();

                // send turns to all players
                send(createTurnVectorPacket());
                break;
            case PHASE_MOVEMENT:
            case PHASE_DEPLOYMENT:
            case PHASE_FIRING:
            case PHASE_PHYSICAL:
            case PHASE_TARGETING:
            case PHASE_OFFBOARD:
                // Update visibility indications if using double blind.
                if (doBlind()) {
                    updateVisibilityIndicator(null);
                }
                resetEntityPhase(phase);
                checkForObservers();
                transmitAllPlayerUpdates();
                setIneligible(phase);
                determineTurnOrder(phase);
                resetActivePlayersDone();
                // send(createEntitiesPacket());
                entityAllUpdate();
                clearReports();
                doTryUnstuck();
                break;
            case PHASE_END:
                resetEntityPhase(phase);
                clearReports();
                resolveHeat();
                if (game.getPlanetaryConditions().isSandBlowing()
                    && (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_LIGHT_GALE)) {
                    addReport(resolveBlowingSandDamage());
                }
                addReport(resolveControlRolls());
                addReport(checkForTraitors());
                // write End Phase header
                addReport(new Report(5005, Report.PUBLIC));
                resolveHarjelRepairs();
                resolveEmergencyCoolantSystem();
                checkForSuffocation();
                game.getPlanetaryConditions().determineWind();
                send(createPlanetaryConditionsPacket());

                hexUpdateSet.clear();
                for (DynamicTerrainProcessor tp : terrainProcessors) {
                    tp.doEndPhaseChanges(vPhaseReport);
                }
                sendChangedHexes(hexUpdateSet);

                applyBuildingDamage();
                addReport(game.ageFlares());
                send(createFlarePacket());
                resolveAmmoDumps();
                resolveCrewWakeUp();
                resolveSelfDestruct();
                resolveShutdownCrashes();
                checkForIndustrialEndOfTurn();
                resolveMechWarriorPickUp();
                resolveVeeINarcPodRemoval();
                resolveFortify();
                checkForObservers();
                transmitAllPlayerUpdates();
                entityAllUpdate();
                break;
            case PHASE_INITIATIVE_REPORT:
                autoSave();
                // Show player BVs
                Enumeration<IPlayer> players2 = game.getPlayers();
                while (players2.hasMoreElements()) {
                    IPlayer player = players2.nextElement();
                    Report r = new Report();
                    r.type = Report.PUBLIC;
                    if (doBlind() && suppressBlindBV()) {
                        r.type = Report.PLAYER;
                        r.player = player.getId();
                    }
                    r.messageId = 7016;
                    r.add(Server.getColorForPlayer(player));
                    r.add(player.getBV());
                    r.add(player.getInitialBV());
                    r.add(player.getFledBV());
                    addReport(r);
                }
            case PHASE_TARGETING_REPORT:
            case PHASE_MOVEMENT_REPORT:
            case PHASE_OFFBOARD_REPORT:
            case PHASE_FIRING_REPORT:
            case PHASE_PHYSICAL_REPORT:
            case PHASE_END_REPORT:
                resetActivePlayersDone();
                sendReport();
                if (game.getOptions().booleanOption("paranoid_autosave")) {
                    autoSave();
                }
                break;
            case PHASE_VICTORY:
                resetPlayersDone();
                clearReports();
                prepareVictoryReport();
                game.addReports(vPhaseReport);
                // Before we send the full entities packet we need to loop
                // through the fighters in squadrons and damage them.
                for (Iterator<Entity> ents = game.getEntities(); ents.hasNext(); ) {
                    Entity entity = ents.next();
                    if ((entity instanceof Aero)
                        && !(entity instanceof FighterSquadron)) {
                        Aero a = (Aero) entity;
                        if (a.isPartOfFighterSquadron() || a.isCapitalFighter()) {
                            a.doDisbandDamage();
                        }
                    }
                    //fix the armor and SI of aeros if using aero sanity rules for the MUL
                    if (game.getOptions().booleanOption("aero_sanity") && (entity instanceof Aero)) {
                        //need to rescale SI and armor
                        int scale = 1;
                        if (entity.isCapitalScale()) {
                            scale = 10;
                        }
                        Aero a = (Aero) entity;
                        int currentSI = a.getSI() / (2 * scale);
                        a.set0SI(a.get0SI() / (2 * scale));
                        if (currentSI > 0) {
                            a.setSI(currentSI);
                        }
                        if (scale > 1) {
                            for (int loc = 0; loc < entity.locations(); loc++) {
                                int currentArmor = entity.getArmor(loc) / scale;
                                if (entity.getOArmor(loc) > 0) {
                                    entity.initializeArmor(entity.getOArmor(loc) / scale, loc);
                                }
                                if (entity.getArmor(loc) > 0) {
                                    entity.setArmor(currentArmor, loc);
                                }
                            }
                        }
                    }
                }
                send(createFullEntitiesPacket());
                send(createReportPacket(null));
                send(createEndOfGamePacket());
                break;
            default:
        }
    }

    /**
     * Should we play this phase or skip it?
     */
    private boolean isPhasePlayable(IGame.Phase phase) {
        switch (phase) {
            case PHASE_INITIATIVE:
            case PHASE_END:
                return false;
            case PHASE_SET_ARTYAUTOHITHEXES:
            case PHASE_DEPLOY_MINEFIELDS:
            case PHASE_DEPLOYMENT:
            case PHASE_MOVEMENT:
            case PHASE_FIRING:
            case PHASE_PHYSICAL:
            case PHASE_TARGETING:
                return game.hasMoreTurns();
            case PHASE_OFFBOARD:
                return isOffboardPlayable();
            default:
                return true;
        }
    }

    /**
     * Skip offboard phase, if there is no homing / semiguided ammo in play
     */
    private boolean isOffboardPlayable() {
        if (!game.hasMoreTurns()) {
            return false;
        }
        for (Iterator<Entity> e = game.getEntities(); e.hasNext();) {
            Entity entity = e.next();
            for (Mounted m : entity.getAmmo()) {
                AmmoType atype = (AmmoType) m.getType();
                if (((atype.getAmmoType() == AmmoType.T_LRM)
                        || (atype.getAmmoType() == AmmoType.T_MML)
                        || (atype.getAmmoType() == AmmoType.T_NLRM)
                        || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))
                        && (atype.getMunitionType() == AmmoType.M_SEMIGUIDED)) {
                    return true;
                }
                if (((atype.getAmmoType() == AmmoType.T_ARROW_IV)
                        || (atype.getAmmoType() == AmmoType.T_LONG_TOM) || (atype
                        .getAmmoType() == AmmoType.T_SNIPER))
                        && (atype.getMunitionType() == AmmoType.M_HOMING)) {
                    return true;
                }
            }
            for (Mounted b : entity.getBombs()) {
                if (!b.isDestroyed()
                    && (b.getUsableShotsLeft() > 0)
                    && (((BombType) b.getType()).getBombType() == BombType.B_LG)) {
                    return true;
                }
            }
        }
        // loop through all current attacks
        // if there are any that use homing ammo, we are playable
        // we need to do this because we might have a homing arty shot in flight
        // when the unit that mounted that ammo is no longer on the field
        for (Enumeration<AttackHandler> attacks = game.getAttacks(); attacks
                .hasMoreElements(); ) {
            AttackHandler ah = attacks.nextElement();
            Mounted ammo = ah.getWaa().getEntity(game)
                             .getEquipment(ah.getWaa().getAmmoId());
            if (ammo != null) {
                AmmoType atype = (AmmoType) ammo.getType();
                if (atype.getMunitionType() == AmmoType.M_HOMING) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Do anything we seed to start the new phase, such as give a turn to the
     * first player to play.
     */
    private void executePhase(IGame.Phase phase) {
        switch (phase) {
            case PHASE_EXCHANGE:
                resetPlayersDone();
                calculatePlayerBVs();
                // Build teams vector
                game.setupTeams();
                applyBoardSettings();
                game.getPlanetaryConditions().determineWind();
                send(createPlanetaryConditionsPacket());
                // transmit the board to everybody
                send(createBoardPacket());
                game.setupRoundDeployment();
                game.setVictoryContext(new HashMap<String, Object>());
                game.createVictoryConditions();
                // some entities may need to be checked and updated
                checkEntityExchange();
                break;
            case PHASE_MOVEMENT:
                // write Movement Phase header to report
                addReport(new Report(2000, Report.PUBLIC));
            case PHASE_SET_ARTYAUTOHITHEXES:
            case PHASE_DEPLOY_MINEFIELDS:
            case PHASE_DEPLOYMENT:
            case PHASE_FIRING:
            case PHASE_PHYSICAL:
            case PHASE_TARGETING:
            case PHASE_OFFBOARD:
                changeToNextTurn();
                if (game.getOptions().booleanOption("paranoid_autosave")) {
                    autoSave();
                }
                break;
            default:
        }
    }

    /**
     * Calculates all players initial BV, should only be called at start of game
     */
    public void calculatePlayerBVs() {
        for (Enumeration<IPlayer> players = game.getPlayers(); players
                .hasMoreElements(); ) {
            players.nextElement().setInitialBV();
        }
    }

    /**
     * loop through entities in the exchange phase (i.e. after leaving
     * chat lounge) and do any actions that need to be done
     */
    public void checkEntityExchange() {
        for (Iterator<Entity> entities = game.getEntities(); entities.hasNext();) {
            Entity entity = entities.next();
            if (entity instanceof Aero) {
                Aero a = (Aero) entity;
                if (game.getBoard().inSpace()) {
                    // altitude and elevation don't matter in space
                    a.liftOff(0);
                } else {
                    // check for grounding
                    if (game.getBoard().inAtmosphere() && !entity.isAirborne()) {
                        // you have to be airborne on the atmospheric map
                        a.liftOff(a.getAltitude());
                    }
                }
                // apply bombs and santa annas
                if (game.getOptions().booleanOption("at2_nukes")
                    && ((entity instanceof Dropship) || (entity instanceof Jumpship))) {
                    entity.applySantaAnna();
                }
                if (!((entity instanceof SmallCraft) || (entity instanceof Jumpship))) {
                    ((Aero) entity).applyBombs();
                }
            }

            // if units were loaded in the chat lounge, I need to keep track of
            // it here
            // because they can get dumped in the deployment phase
            if (entity.getLoadedUnits().size() > 0) {
                Vector<Integer> v = new Vector<Integer>();
                for (Entity en : entity.getLoadedUnits()) {
                    v.add(en.getId());
                }
                entity.setLoadedKeepers(v);
            }

            if (game.getOptions().booleanOption("aero_sanity")
                && (entity instanceof Aero)) {
                Aero a = (Aero) entity;
                if (entity.isCapitalScale()) {
                    int currentSI = a.getSI() * 20;
                    a.initializeSI(a.get0SI() * 20);
                    a.setSI(currentSI);
                    if (entity.isCapitalFighter()) {
                        a.autoSetCapArmor();
                        a.autoSetFatalThresh();
                    } else {
                        // all armor and SI is going to be at standard scale, so
                        // we need to adjust
                        for (int loc = 0; loc < entity.locations(); loc++) {
                            if (entity.getArmor(loc) > 0) {
                                int currentArmor = entity.getArmor(loc) * 10;
                                entity.initializeArmor(
                                        entity.getOArmor(loc) * 10, loc);
                                entity.setArmor(currentArmor, loc);

                            }
                        }
                    }
                } else {
                    int currentSI = a.getSI() * 2;
                    a.initializeSI(a.get0SI() * 2);
                    a.setSI(currentSI);
                }
            }
            // Give the unit a spotlight, if it has the spotlight quirk
            entity.setExternalSpotlight(entity.hasExternaSpotlight()
                                        || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));
            entityUpdate(entity.getId());
        }
    }

    /**
     * Ends this phase and moves on to the next.
     */
    private void endCurrentPhase() {
        switch (game.getPhase()) {
            case PHASE_LOUNGE:
                changePhase(IGame.Phase.PHASE_EXCHANGE);
                break;
            case PHASE_EXCHANGE:
                changePhase(IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES);
                break;
            case PHASE_STARTING_SCENARIO:
                changePhase(IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES);
                break;
            case PHASE_SET_ARTYAUTOHITHEXES:
                sendSpecialHexDisplayPackets();
                Enumeration<IPlayer> e = game.getPlayers();
                boolean mines = false;
                while (e.hasMoreElements() && !mines) {
                    IPlayer p = e.nextElement();
                    if (p.hasMinefields()) {
                        mines = true;
                    }
                }
                if (mines) {
                    changePhase(IGame.Phase.PHASE_DEPLOY_MINEFIELDS);
                } else {
                    changePhase(IGame.Phase.PHASE_INITIATIVE);
                }
                break;
            case PHASE_DEPLOY_MINEFIELDS:
                changePhase(IGame.Phase.PHASE_INITIATIVE);
                break;
            case PHASE_DEPLOYMENT:
                game.clearDeploymentThisRound();
                game.checkForCompleteDeployment();
                Enumeration<IPlayer> pls = game.getPlayers();
                while (pls.hasMoreElements()) {
                    IPlayer p = pls.nextElement();
                    p.adjustStartingPosForReinforcements();
                }

                if (game.getRoundCount() < 1) {
                    changePhase(IGame.Phase.PHASE_INITIATIVE);
                } else {
                    changePhase(IGame.Phase.PHASE_TARGETING);
                }
                break;
            case PHASE_INITIATIVE:
                resolveWhatPlayersCanSeeWhatUnits();
                game.addReports(vPhaseReport);
                changePhase(IGame.Phase.PHASE_INITIATIVE_REPORT);
                break;
            case PHASE_INITIATIVE_REPORT:
                // NOTE: now that aeros can come and go from the battlefield, I
                // need
                // to update the
                // deployment table every round. I think this it is OK to go
                // here.
                // (Taharqa)
                game.setupRoundDeployment();
                // boolean doDeploy = game.shouldDeployThisRound() &&
                // (game.getLastPhase() != IGame.Phase.PHASE_DEPLOYMENT);
                if (game.shouldDeployThisRound()) {
                    changePhase(IGame.Phase.PHASE_DEPLOYMENT);
                } else {
                    changePhase(IGame.Phase.PHASE_TARGETING);
                }
                break;
            case PHASE_MOVEMENT:
                resolveWhatPlayersCanSeeWhatUnits();
                doAllAssaultDrops();
                addMovementHeat();
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls()); // Skids cause damage in
                // movement phase
                checkForFlamingDamage();
                checkForTeleMissileAttacks();
                cleanupDestroyedNarcPods();
                checkForFlawedCooling();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_MOVEMENT_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(IGame.Phase.PHASE_OFFBOARD);
                }
                break;
            case PHASE_MOVEMENT_REPORT:
                changePhase(IGame.Phase.PHASE_OFFBOARD);
                break;
            case PHASE_FIRING:
                // write Weapon Attack Phase header
                addReport(new Report(3000, Report.PUBLIC));
                resolveWhatPlayersCanSeeWhatUnits();
                resolveAllButWeaponAttacks();
                resolveSelfDestructions();
                reportGhostTargetRolls();
                reportLargeCraftECCMRolls();
                resolveOnlyWeaponAttacks();
                assignAMS();
                handleAttacks();
                resolveScheduledNukes();
                applyBuildingDamage();
                checkForPSRFromDamage();
                cleanupDestroyedNarcPods();
                addReport(resolvePilotingRolls());
                checkForFlawedCooling();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_FIRING_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    sendReport();
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_PHYSICAL);
                }
                break;
            case PHASE_FIRING_REPORT:
                changePhase(IGame.Phase.PHASE_PHYSICAL);
                break;
            case PHASE_PHYSICAL:
                resolveWhatPlayersCanSeeWhatUnits();
                resolvePhysicalAttacks();
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls());
                resolveSinkVees();
                cleanupDestroyedNarcPods();
                checkForFlawedCooling();
                checkForChainWhipGrappleChecks();
                // check phase report
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_PHYSICAL_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(IGame.Phase.PHASE_END);
                }
                break;
            case PHASE_PHYSICAL_REPORT:
                changePhase(IGame.Phase.PHASE_END);
                break;
            case PHASE_TARGETING:
                vPhaseReport.addElement(new Report(1035, Report.PUBLIC));
                resolveAllButWeaponAttacks();
                resolveOnlyWeaponAttacks();
                handleAttacks();
                // check reports
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_TARGETING_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    vPhaseReport.addElement(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(IGame.Phase.PHASE_MOVEMENT);
                }

                sendSpecialHexDisplayPackets();
                for (Enumeration<IPlayer> i = game.getPlayers(); i
                        .hasMoreElements(); ) {
                    IPlayer player = i.nextElement();
                    int connId = player.getId();
                    send(connId, createArtilleryPacket(player));
                }

                break;
            case PHASE_OFFBOARD:
                // write Offboard Attack Phase header
                addReport(new Report(1100, Report.PUBLIC));
                resolveAllButWeaponAttacks(); // torso twist or flip arms
                // possible
                resolveOnlyWeaponAttacks(); // should only be TAG at this point
                handleAttacks();
                for (Enumeration<IPlayer> i = game.getPlayers(); i
                        .hasMoreElements(); ) {
                    IPlayer player = i.nextElement();
                    int connId = player.getId();
                    send(connId, createArtilleryPacket(player));
                }
                applyBuildingDamage();
                checkForPSRFromDamage();
                addReport(resolvePilotingRolls());

                cleanupDestroyedNarcPods();
                checkForFlawedCooling();

                sendSpecialHexDisplayPackets();
                sendTagInfoUpdates();

                // check reports
                if (vPhaseReport.size() > 1) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_OFFBOARD_REPORT);
                } else {
                    // just the header, so we'll add the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    changePhase(IGame.Phase.PHASE_FIRING);
                }
                break;
            case PHASE_OFFBOARD_REPORT:
                sendSpecialHexDisplayPackets();
                changePhase(IGame.Phase.PHASE_FIRING);
                break;
            case PHASE_TARGETING_REPORT:
                changePhase(IGame.Phase.PHASE_MOVEMENT);
                break;
            case PHASE_END:
                // remove any entities that died in the heat/end phase before
                // check
                // for victory
                resetEntityPhase(IGame.Phase.PHASE_END);
                boolean victory = victory(); // note this may add reports
                // check phase report
                // HACK: hardcoded message ID check
                if ((vPhaseReport.size() > 3)
                    || ((vPhaseReport.size() > 1) && (vPhaseReport.elementAt(1).messageId != 1205))) {
                    game.addReports(vPhaseReport);
                    changePhase(IGame.Phase.PHASE_END_REPORT);
                } else {
                    // just the heat and end headers, so we'll add
                    // the <nothing> label
                    addReport(new Report(1205, Report.PUBLIC));
                    game.addReports(vPhaseReport);
                    sendReport();
                    if (victory) {
                        changePhase(IGame.Phase.PHASE_VICTORY);
                    } else {
                        changePhase(IGame.Phase.PHASE_INITIATIVE);
                    }
                }
                break;
            case PHASE_END_REPORT:
                if (changePlayersTeam) {
                    processTeamChange();
                }
                if (victory()) {
                    changePhase(IGame.Phase.PHASE_VICTORY);
                } else {
                    changePhase(IGame.Phase.PHASE_INITIATIVE);
                }
                break;
            case PHASE_VICTORY:
                GameVictoryEvent gve = new GameVictoryEvent(this, game);
                game.processGameEvent(gve);
                transmitGameVictoryEventToAll();
                resetGame();
                break;
            default:
        }
    }

    /**
     *
     */
    private void sendSpecialHexDisplayPackets() {
        if (connections == null) {
            return;
        }
        for (int i = 0; i < connections.size(); i++) {
            if (connections.get(i) != null) {
                connections.get(i).send(createSpecialHexDisplayPacket(i));
            }
        }
    }

    private void sendTagInfoUpdates() {
        if (connections == null) {
            return;
        }
        for (int i = 0; i < connections.size(); i++) {
            if (connections.get(i) != null) {
                connections.get(i).send(createTagInfoUpdatesPacket());
            }
        }
    }

    public void sendTagInfoReset() {
        if (connections == null) {
            return;
        }
        for (int i = 0; i < connections.size(); i++) {
            if (connections.get(i) != null) {
                connections.get(i).send(
                        new Packet(Packet.COMMAND_RESET_TAGINFO));
            }
        }
    }

    /**
     * Increment's the server's game round and send it to all the clients
     */
    private void incrementAndSendGameRound() {
        game.incrementRoundCount();
        send(new Packet(Packet.COMMAND_ROUND_UPDATE, new Integer(
                game.getRoundCount())));
    }

    /**
     * Hand over a turn to the next player. This is only possible if you haven't
     * yet started your turn (i.e. not yet moved anything like infantry where
     * you have to move multiple units)
     *
     * @param packet -
     * @param connid
     */
    private void receiveForwardIni(Packet packet, int connid) {
        // this is the player sending the packet"

        IPlayer current = getPlayer(connid);

        if (game.getTurn().getPlayerNum() != current.getId()) {
            // this player is not the current player, so just ignore this
            // command!
            return;
        }
        // if individual initiative is active we cannot forward our initiative
        // ever!
        if (game.getOptions().booleanOption("individual_initiative")) {
            return;
        }
        // get the next player from the team this player is on.
        Team currentteam = game.getTeamForPlayer(current);
        IPlayer next = currentteam.getNextValidPlayer(current, game);
        // if the choosen player is a valid player, we change the turn order and
        // inform the clients.
        if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)
            && (game.getTurnForPlayer(next.getId()) != null)) {

            int currentturnindex = game.getTurnIndex();
            // now look for the next occurence of player next in the turn order
            List<GameTurn> turns = game.getTurnVector();
            GameTurn turn = game.getTurn();
            // not entirely necessary. As we will also check this for the
            // activity of the button but to be sure do it on the server too.
            boolean isGeneralMoveTurn = (!(turn instanceof GameTurn.SpecificEntityTurn)
                                         && !(turn instanceof GameTurn.UnitNumberTurn)
                                         && !(turn instanceof GameTurn.UnloadStrandedTurn)
                                         && !(turn instanceof GameTurn.TriggerBPodTurn) && !(turn instanceof GameTurn
                    .TriggerAPPodTurn));
            if (!isGeneralMoveTurn) {
                // if this is not a general turn the player cannot forward his
                // turn.
                return;
            }
            // if it is an entityclassturn we have to check make sure, that the
            // turn it is exchanged with is the same kind of turn!
            // in fact this requires an access function to the mask of an
            // entityclassturn.

            boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);
            int classmask = 0;
            if (isEntityClassTurn) {
                GameTurn.EntityClassTurn tempturn = (GameTurn.EntityClassTurn) turn;
                classmask = tempturn.getTurnCode();
            }

            boolean switched = false;
            int nextturnid = 0;
            for (int i = currentturnindex; i < turns.size(); i++) {
                // if we find a turn for the specific player, swap the current
                // player with the player noted there
                // and stop
                if (turns.get(i).isValid(next.getId(), game)) {
                    nextturnid = i;
                    if (isEntityClassTurn) {
                        // if we had an entityclassturn
                        if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {
                            // and found another entityclassturn
                            if (!(((GameTurn.EntityClassTurn) turns.get(i))
                                          .getTurnCode() == classmask)) {
                                // both have to refer to the SAME class(es) or
                                // they need to be rejected.
                                continue;
                            }
                        } else {
                            continue;
                        }
                    }
                    switched = true;
                    break;
                }
            }

            // update turn order
            if (switched) {
                game.swapTurnOrder(currentturnindex, nextturnid);
                // update the turn packages for all players.
                send(createTurnVectorPacket());
                send(createTurnIndexPacket());
            } else {
                // if nothing changed return without doing anything
                return;
            }

        }
    }

    /**
     * Tries to change to the next turn. If there are no more turns, ends the
     * current phase. If the player whose turn it is next is not connected, we
     * allow the other players to skip that player.
     */
    private void changeToNextTurn() {
        // if there aren't any more turns, end the phase
        if (!game.hasMoreTurns()) {
            endCurrentPhase();
            return;
        }

        // okay, well next turn then!
        GameTurn nextTurn = game.changeToNextTurn();

        IPlayer player = getPlayer(nextTurn.getPlayerNum());

        if ((player != null) && (game.getEntitiesOwnedBy(player) == 0)) {
            endCurrentTurn(null);
            return;
        }

        send(createTurnIndexPacket());

        if ((null != player) && player.isGhost()) {
            sendGhostSkipMessage(player);
        } else if ((null == game.getFirstEntity())
                && (null != player)
                && ((game.getPhase() != IGame.Phase.PHASE_DEPLOY_MINEFIELDS)
                        && (game.getPhase()
                                != IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES))) {
            sendTurnErrorSkipMessage(player);
        }
    }

    /**
     * Sends out a notification message indicating that a ghost player may be
     * skipped.
     *
     * @param ghost - the <code>Player</code> who is ghosted. This value must not
     *              be <code>null</code>.
     */
    private void sendGhostSkipMessage(IPlayer ghost) {
        StringBuffer message = new StringBuffer();
        message.append("Player '")
               .append(ghost.getName())
               .append("' is disconnected.  You may skip his/her current turn with the /skip command.");
        sendServerChat(message.toString());
    }

    /**
     * Sends out a notification message indicating that the current turn is an
     * error and should be skipped.
     *
     * @param skip - the <code>Player</code> who is to be skipped. This value
     *             must not be <code>null</code>.
     */
    private void sendTurnErrorSkipMessage(IPlayer skip) {
        StringBuffer message = new StringBuffer();
        message.append("Player '")
               .append(skip.getName())
               .append("' has no units to move.  You should skip his/her/your current turn with the /skip command. " +
                       "You may want to report this error.  See the MegaMek homepage (http://megamek.sf.net/) for " +
                       "details.");
        sendServerChat(message.toString());
    }

    /**
     * Skips the current turn. This only makes sense in phases that have turns.
     * Operates by finding an entity to move and then doing nothing with it.
     */
    public void skipCurrentTurn() {
        // find an entity to skip...
        Entity toSkip = game.getFirstEntity();

        switch (game.getPhase()) {
            case PHASE_DEPLOYMENT:
                // allow skipping during deployment,
                // we need that when someone removes a unit.
                endCurrentTurn(null);
                break;
            case PHASE_MOVEMENT:
                if (toSkip != null) {
                    processMovement(toSkip, new MovePath(game, toSkip), null);
                }
                endCurrentTurn(toSkip);
                break;
            case PHASE_FIRING:
            case PHASE_PHYSICAL:
            case PHASE_TARGETING:
            case PHASE_OFFBOARD:
                if (toSkip != null) {
                    processAttack(toSkip, new Vector<EntityAction>(0));
                }
                endCurrentTurn(toSkip);
                break;
            default:
        }
    }

    /**
     * Returns true if the current turn may be skipped. Ghost players' turns are
     * skippable, and a turn should be skipped if there's nothing to move.
     */
    public boolean isTurnSkippable() {
        GameTurn turn = game.getTurn();
        if (null == turn) {
            return false;
        }
        IPlayer player = getPlayer(turn.getPlayerNum());
        return (null == player) || player.isGhost()
               || (game.getFirstEntity() == null);
    }

    /**
     * Returns true if victory conditions have been met. Victory conditions are
     * when there is only one player left with mechs or only one team. will also
     * add some reports to reporting
     */
    public boolean victory() {
        Victory.Result vr = game.getVictory().victory(game,
                                                      game.getVictoryContext());
        for (Report r : vr.getReports()) {
            addReport(r);
        }

        if (vr.victory()) {
            boolean draw = vr.isDraw();
            int wonPlayer = vr.getWinningPlayer();
            int wonTeam = vr.getWinningTeam();

            if (wonPlayer != IPlayer.PLAYER_NONE) {
                Report r = new Report(7200, Report.PUBLIC);
                r.add(Server.getColorForPlayer(game.getPlayer(wonPlayer)));
                addReport(r);
            }
            if (wonTeam != IPlayer.TEAM_NONE) {
                Report r = new Report(7200, Report.PUBLIC);
                r.add("Team " + wonTeam);
                addReport(r);
            }
            if (draw) {
                // multiple-won draw
                game.setVictoryPlayerId(IPlayer.PLAYER_NONE);
                game.setVictoryTeam(IPlayer.TEAM_NONE);
            } else {
                // nobody-won draw or
                // single player won or
                // single team won
                game.setVictoryPlayerId(wonPlayer);
                game.setVictoryTeam(wonTeam);
            }
        } else {
            game.setVictoryPlayerId(IPlayer.PLAYER_NONE);
            game.setVictoryTeam(IPlayer.TEAM_NONE);
            if (game.isForceVictory()) {
                cancelVictory();
            }
        }
        return vr.victory();
    }// end victory

    private boolean isPlayerForcedVictory() {
        // check game options
        if (!game.getOptions().booleanOption("skip_forced_victory")) {
            return false;
        }

        if (!game.isForceVictory()) {
            return false;
        }

        for (IPlayer player : game.getPlayersVector()) {

            if ((player.getId() == game.getVictoryPlayerId())
                || ((player.getTeam() == game.getVictoryTeam()) && (game
                                                                            .getVictoryTeam() != IPlayer.TEAM_NONE))) {
                continue;
            }

            if (!player.admitsDefeat()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Applies board settings. This loads and combines all the boards that were
     * specified into one mega-board and sets that board as current.
     */
    public void applyBoardSettings() {
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);
        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth()
                                          * mapSettings.getMapHeight()];
        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings
                .getMapHeight()); i++) {
            sheetBoards[i] = new Board();
            String name = mapSettings.getBoardsSelectedVector().get(i);
            boolean isRotated = false;
            if (name.startsWith(Board.BOARD_REQUEST_ROTATION)) {
                // only rotate boards with an even width
                if ((mapSettings.getBoardWidth() % 2) == 0) {
                    isRotated = true;
                }
                name = name.substring(Board.BOARD_REQUEST_ROTATION.length());
            }
            if (name.startsWith(MapSettings.BOARD_GENERATED)
                || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {
                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);
            } else {
                sheetBoards[i].load(new File(Configuration.boardsDir(), name
                                                                        + ".board"));
                BoardUtilities.flip(sheetBoards[i], isRotated, isRotated);
            }
        }
        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(),
                                                 mapSettings.getBoardHeight(), mapSettings.getMapWidth(),
                                                 mapSettings.getMapHeight(), sheetBoards,
                                                 mapSettings.getMedium());
        if (game.getOptions().getOption("bridgeCF").intValue() > 0) {
            newBoard.setBridgeCF(game.getOptions().getOption("bridgeCF")
                                     .intValue());
        }
        if (!game.getOptions().booleanOption("random_basements")) {
            newBoard.setRandomBasementsOff();
        }
        if (game.getPlanetaryConditions().isTerrainAffected()) {
            BoardUtilities.addWeatherConditions(newBoard, game
                    .getPlanetaryConditions().getWeather(), game
                    .getPlanetaryConditions().getWindStrength());
        }
        game.setBoard(newBoard);
    }

    /**
     * Rolls initiative for all the players.
     */
    private void rollInitiative() {
        if (game.getOptions().booleanOption("individual_initiative")) {
            TurnOrdered.rollInitiative(game.getEntitiesVector(), false);
        } else {
            // Roll for initative on the teams.
            TurnOrdered.rollInitiative(
                    game.getTeamsVector(),
                    game.getOptions().booleanOption(
                            "initiative_streak_compensation")
                    && !game.shouldDeployThisRound());
        }

        transmitAllPlayerUpdates();
    }

    /**
     * Determines the turn oder for a given phase (with individual init)
     *
     * @param phase the <code>int</code> id of the phase
     */
    private void determineTurnOrderIUI(IGame.Phase phase) {
        for (Iterator<Entity> loop = game.getEntities(); loop.hasNext();) {
            final Entity entity = loop.next();
            entity.resetOtherTurns();
            if (entity.isSelectableThisTurn()) {
                entity.incrementOtherTurns();
            }
        }

        List<Entity> entities;
        // If the protos move multi option isn't on, protos move as a unit
        // Need to adjust entities vector otherwise we'll have too many turns
        // when first proto in a unit moves, new turns get added so rest of the
        // unit will move
        boolean protosMoveMulti = game.getOptions().booleanOption(
                "protos_move_multi");
        if (!protosMoveMulti) {
            entities = new ArrayList<>(game.getEntitiesVector().size());
            Set<Character> movedUnits = new HashSet<Character>();
            for (Entity e : game.getEntitiesVector()) {
                // This only effects Protos for the time being
                if (!(e instanceof Protomech)) {
                    entities.add(e);
                    continue;
                }
                char unitNumber = e.getUnitNumber();
                if ((unitNumber == Entity.NONE)
                        || !movedUnits.contains(unitNumber)) {
                    entities.add(e);
                    if (unitNumber != Entity.NONE) {
                        movedUnits.add(unitNumber);
                    }
                }
            }
        } else {
            entities = game.getEntitiesVector();
        }
        // Now, generate the global order of all teams' turns.
        TurnVectors team_order = TurnOrdered.generateTurnOrder(entities, game);

        // See if there are any loaded units stranded on immobile transports.
        Iterator<Entity> strandedUnits = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if (game.isEntityStranded(entity)) {
                            return true;
                        }
                        return false;
                    }
                });

        // Now, we collect everything into a single vector.
        Vector<GameTurn> turns;

        if (strandedUnits.hasNext()
                && (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {
            // Add a game turn to unload stranded units, if this
            // is the movement phase.
            turns = new Vector<GameTurn>(team_order.getTotalTurns()
                    + team_order.getEvenTurns() + 1);
            turns.addElement(new GameTurn.UnloadStrandedTurn(strandedUnits));
        } else {
            // No stranded units.
            turns = new Vector<GameTurn>(team_order.getTotalTurns()
                    + team_order.getEvenTurns());
        }

        // add the turns (this is easy)
        while (team_order.hasMoreElements()) {
            Entity e = (Entity) team_order.nextElement();
            if (e.isSelectableThisTurn()) {
                if (!protosMoveMulti && (e instanceof Protomech)
                        && (e.getUnitNumber() != Entity.NONE)) {
                    turns.addElement(new GameTurn.UnitNumberTurn(
                            e.getOwnerId(), e.getUnitNumber()));
                } else {
                    turns.addElement(new GameTurn.SpecificEntityTurn(e
                            .getOwnerId(), e.getId()));
                }

            }
        }

        // set fields in game
        game.setTurnVector(turns);
        game.resetTurnIndex();

        // send turns to all players
        send(createTurnVectorPacket());
    }

    /**
     * Determines the turn oder for a given phase
     *
     * @param phase the <code>int</code> id of the phase
     */
    private void determineTurnOrder(IGame.Phase phase) {

        if (game.getOptions().booleanOption("individual_initiative")) {
            determineTurnOrderIUI(phase);
            return;
        }
        // and/or deploy even according to game options.
        boolean infMoveEven = (game.getOptions().booleanOption("inf_move_even") && ((game
                .getPhase() == IGame.Phase.PHASE_INITIATIVE) || (game
                .getPhase() == IGame.Phase.PHASE_MOVEMENT)))
                || (game.getOptions().booleanOption("inf_deploy_even") && (game
                        .getPhase() == IGame.Phase.PHASE_DEPLOYMENT));
        boolean infMoveMulti = game.getOptions()
                .booleanOption("inf_move_multi")
                && ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE) || ((game
                        .getPhase() == IGame.Phase.PHASE_MOVEMENT) || (game
                        .getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));
        boolean protosMoveEven = (game.getOptions().booleanOption(
                "protos_move_even") && ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE) || ((game
                .getPhase() == IGame.Phase.PHASE_MOVEMENT) || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))))
                || (game.getOptions().booleanOption("protos_deploy_even") && (game
                        .getPhase() == IGame.Phase.PHASE_DEPLOYMENT));
        boolean protosMoveMulti = game.getOptions().booleanOption(
                "protos_move_multi");
        boolean protosMoveByPoint = !protosMoveMulti;
        boolean tankMoveByLance = game.getOptions().booleanOption(
                "vehicle_lance_movement")
                && ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE) || ((game
                        .getPhase() == IGame.Phase.PHASE_MOVEMENT) || (game
                        .getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));
        boolean mekMoveByLance = game.getOptions().booleanOption(
                "mek_lance_movement")
                && ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE) || ((game
                        .getPhase() == IGame.Phase.PHASE_MOVEMENT) || (game
                        .getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));

        int evenMask = 0;
        if (infMoveEven) {
            evenMask += GameTurn.CLASS_INFANTRY;
        }
        if (protosMoveEven) {
            evenMask += GameTurn.CLASS_PROTOMECH;
        }
        // Reset all of the Players' turn category counts
        for (Enumeration<IPlayer> loop = game.getPlayers(); loop
                .hasMoreElements(); ) {
            final IPlayer player = loop.nextElement();
            player.resetEvenTurns();
            player.resetMultiTurns();
            player.resetOtherTurns();
            player.resetSpaceStationTurns();
            player.resetJumpshipTurns();
            player.resetWarshipTurns();
            player.resetDropshipTurns();
            player.resetSmallCraftTurns();
            player.resetAeroTurns();

            // Add turns for protomechs weapons declaration.
            if (protosMoveByPoint) {

                // How many Protomechs does the player have?
                Iterator<Entity> playerProtos = game
                        .getSelectedEntities(new EntitySelector() {
                            private final int ownerId = player.getId();

                            public boolean accept(Entity entity) {
                                if ((entity instanceof Protomech)
                                    && (ownerId == entity.getOwnerId())
                                    && entity.isSelectableThisTurn()) {
                                    return true;
                                }
                                return false;
                            }
                        });
                HashSet<Integer> points = new HashSet<Integer>();
                int numPlayerProtos = 0;
                for (; playerProtos.hasNext(); ) {
                    Entity proto = playerProtos.next();
                    numPlayerProtos++;
                    points.add(new Integer(proto.getUnitNumber()));
                }
                int numProtoUnits = (int) Math.ceil(numPlayerProtos / 5.0);
                if (!protosMoveEven) {
                    numProtoUnits = points.size();
                }
                for (int unit = 0; unit < numProtoUnits; unit++) {
                    if (protosMoveEven) {
                        player.incrementEvenTurns();
                    } else {
                        player.incrementOtherTurns();
                    }
                }

            } // End handle-proto-firing-turns

        } // Handle the next player

        // Go through all entities, and update the turn categories of the
        // entity's player. The teams get their totals from their players.
        // N.B. protomechs declare weapons fire based on their point.
        for (Iterator<Entity> loop = game.getEntities(); loop.hasNext();) {
            final Entity entity = loop.next();
            if (entity.isSelectableThisTurn()) {
                final IPlayer player = entity.getOwner();
                if ((entity instanceof SpaceStation)
                    && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                        || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementSpaceStationTurns();
                } else if ((entity instanceof Warship)
                           && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                               || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementWarshipTurns();
                } else if ((entity instanceof Jumpship)
                           && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                               || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementJumpshipTurns();
                } else if ((entity instanceof Dropship) && entity.isAirborne()
                           && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                               || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementDropshipTurns();
                } else if ((entity instanceof SmallCraft)
                           && entity.isAirborne()
                           && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                               || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementSmallCraftTurns();
                } else if (entity.isAirborne()
                           && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                               || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
                    player.incrementAeroTurns();
                } else if ((entity instanceof Infantry)) {
                    if (infMoveEven) {
                        player.incrementEvenTurns();
                    } else if (infMoveMulti) {
                        player.incrementMultiTurns(GameTurn.CLASS_INFANTRY);
                    } else {
                        player.incrementOtherTurns();
                    }
                } else if (entity instanceof Protomech) {
                    if (!protosMoveByPoint) {
                        if (protosMoveEven) {
                            player.incrementEvenTurns();
                        } else if (protosMoveMulti) {
                            player.incrementMultiTurns(GameTurn.CLASS_PROTOMECH);
                        } else {
                            player.incrementOtherTurns();
                        }
                    }
                } else if ((entity instanceof Tank) && tankMoveByLance) {
                    player.incrementMultiTurns(GameTurn.CLASS_TANK);
                } else if ((entity instanceof Mech) && mekMoveByLance) {
                    player.incrementMultiTurns(GameTurn.CLASS_MECH);
                } else {
                    player.incrementOtherTurns();
                }
            }
        }

        // Generate the turn order for the Players *within*
        // each Team. Map the teams to their turn orders.
        // Count the number of teams moving this turn.
        int nTeams = game.getNoOfTeams();
        Hashtable<Team, TurnVectors> allTeamTurns = new Hashtable<Team, TurnVectors>(
                nTeams);
        Hashtable<Team, int[]> evenTrackers = new Hashtable<Team, int[]>(nTeams);
        int numTeamsMoving = 0;
        for (Enumeration<Team> loop = game.getTeams(); loop.hasMoreElements(); ) {
            final Team team = loop.nextElement();
            allTeamTurns.put(team, team.determineTeamOrder(game));

            // Track both the number of times we've checked the team for
            // "leftover" turns, and the number of "leftover" turns placed.
            int[] evenTracker = new int[2];
            evenTracker[0] = 0;
            evenTracker[1] = 0;
            evenTrackers.put(team, evenTracker);

            // Count this team if it has any "normal" moves.
            if (team.getNormalTurns(game) > 0) {
                numTeamsMoving++;
            }
        }

        // Now, generate the global order of all teams' turns.
        TurnVectors team_order = TurnOrdered.generateTurnOrder(
                game.getTeamsVector(), game);

        // See if there are any loaded units stranded on immobile transports.
        Iterator<Entity> strandedUnits = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if (game.isEntityStranded(entity)) {
                            return true;
                        }
                        return false;
                    }
                });

        // Now, we collect everything into a single vector.
        Vector<GameTurn> turns;

        if (strandedUnits.hasNext()
            && ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {
            // Add a game turn to unload stranded units, if this
            // is the movement phase.
            turns = new Vector<GameTurn>(team_order.getTotalTurns()
                                         + team_order.getEvenTurns() + 1);
            turns.addElement(new GameTurn.UnloadStrandedTurn(strandedUnits));
        } else {
            // No stranded units.
            turns = new Vector<GameTurn>(team_order.getTotalTurns()
                                         + team_order.getEvenTurns());
        }

        // Walk through the global order, assigning turns
        // for individual players to the single vector.
        // Keep track of how many turns we've added to the vector.
        Team prevTeam = null;
        int min = team_order.getMin();
        for (int numTurn = 0; team_order.hasMoreElements(); numTurn++) {
            Team team = (Team) team_order.nextElement();
            TurnVectors withinTeamTurns = allTeamTurns.get(team);

            int[] evenTracker = evenTrackers.get(team);
            float teamEvenTurns = team.getEvenTurns();

            // Calculate the number of "even" turns to add for this team.
            int numEven = 0;
            if (1 == numTeamsMoving) {
                // If there's only one team moving, we don't need to bother
                // with the evenTracker, just make sure the even turns are
                // evenly distributed
                numEven += (teamEvenTurns / min) + 0.5;
            } else if (prevTeam == null) {
                // Increment the number of times we've checked for "leftovers".
                evenTracker[0]++;

                // The first team to move just adds the "baseline" turns.
                numEven += teamEvenTurns / min;
            } else if (!team.equals(prevTeam)) {
                // Increment the number of times we've checked for "leftovers".
                evenTracker[0]++;

                // This wierd equation attempts to spread the "leftover"
                // turns accross the turn's moves in a "fair" manner.
                // It's based on the number of times we've checked for
                // "leftovers" the number of "leftovers" we started with,
                // the number of times we've added a turn for a "leftover",
                // and the total number of times we're going to check.
                numEven += Math
                                   .ceil(((evenTracker[0] * (teamEvenTurns % min)) / min) - 0.5)
                           - evenTracker[1];

                // Update the number of turns actually added for "leftovers".
                evenTracker[1] += numEven;

                // Add the "baseline" number of turns.
                numEven += teamEvenTurns / min;
            }

            // Record this team for the next move.
            prevTeam = team;

            int aeroMask = GameTurn.CLASS_AERO + GameTurn.CLASS_SMALL_CRAFT
                           + GameTurn.CLASS_DROPSHIP + GameTurn.CLASS_JUMPSHIP
                           + GameTurn.CLASS_WARSHIP + GameTurn.CLASS_SPACE_STATION;
            if (withinTeamTurns.hasMoreNormalElements()) {

                // Not a placeholder... get the player who moves next.
                IPlayer player = (IPlayer) withinTeamTurns.nextNormalElement();

                // If we've added all "normal" turns, allocate turns
                // for the infantry and/or protomechs moving even.
                GameTurn turn = null;
                if (numTurn >= team_order.getTotalTurns()) {
                    turn = new GameTurn.EntityClassTurn(player.getId(),
                                                        evenMask);
                }
                // If either Infantry or Protomechs move even, only allow
                // the other classes to move during the "normal" turn.
                else if (infMoveEven || protosMoveEven) {
                    int newMask = evenMask;
                    // if this is the movement phase, then don't allow Aeros on
                    // normal turns
                    if ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                        || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)) {
                        newMask += aeroMask;
                    }
                    turn = new GameTurn.EntityClassTurn(player.getId(),
                                                        ~newMask);
                }

                // Otherwise, let *anybody* move.
                else {
                    // well, almost anybody; Aero don't get normal turns during
                    // the movement phase
                    if ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)
                        || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)) {
                        turn = new GameTurn.EntityClassTurn(player.getId(),
                                                            ~aeroMask);
                    } else {
                        turn = new GameTurn(player.getId());
                    }
                }
                turns.addElement(turn);

            } // End team-has-"normal"-turns
            else if (withinTeamTurns.hasMoreSpaceStationElements()) {
                IPlayer player = (IPlayer) withinTeamTurns
                        .nextSpaceStationElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_SPACE_STATION);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreJumpshipElements()) {
                IPlayer player = (IPlayer) withinTeamTurns
                        .nextJumpshipElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_JUMPSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreWarshipElements()) {
                IPlayer player = (IPlayer) withinTeamTurns.nextWarshipElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_WARSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreDropshipElements()) {
                IPlayer player = (IPlayer) withinTeamTurns
                        .nextDropshipElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_DROPSHIP);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreSmallCraftElements()) {
                IPlayer player = (IPlayer) withinTeamTurns
                        .nextSmallCraftElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_SMALL_CRAFT);
                turns.addElement(turn);
            } else if (withinTeamTurns.hasMoreAeroElements()) {
                IPlayer player = (IPlayer) withinTeamTurns.nextAeroElement();
                GameTurn turn = null;
                turn = new GameTurn.EntityClassTurn(player.getId(),
                                                    GameTurn.CLASS_AERO);
                turns.addElement(turn);
            }

            // Add the calculated number of "even" turns.
            // Allow the player at least one "normal" turn before the
            // "even" turns to help with loading infantry in deployment.
            while ((numEven > 0) && withinTeamTurns.hasMoreEvenElements()) {
                IPlayer evenPlayer = (IPlayer) withinTeamTurns
                        .nextEvenElement();
                turns.addElement(new GameTurn.EntityClassTurn(evenPlayer
                                                                      .getId(), evenMask));
                numEven--;
            }
        }

        // set fields in game
        game.setTurnVector(turns);
        game.resetTurnIndex();

        // send turns to all players
        send(createTurnVectorPacket());

    }

    private static String getColorForPlayer(IPlayer p) {
        String colorcode = Integer.toHexString(PlayerColors.getColor(
                p.getColorIndex()).getRGB() & 0x00f0f0f0);
        return "<B><font color='" + colorcode + "'>" + p.getName()
               + "</font></B>";

    }

    /**
     * Write the initiative results to the report
     */
    private void writeInitiativeReport(boolean abbreviatedReport) {
        // write to report
        Report r;
        boolean deployment = false;
        if (!abbreviatedReport) {
            r = new Report(1210);
            r.type = Report.PUBLIC;
            if ((game.getLastPhase() == IGame.Phase.PHASE_DEPLOYMENT)
                || game.isDeploymentComplete()
                || !game.shouldDeployThisRound()) {
                r.messageId = 1000;
                r.add(game.getRoundCount());
            } else {
                deployment = true;
                if (game.getRoundCount() == 0) {
                    r.messageId = 1005;
                } else {
                    r.messageId = 1010;
                    r.add(game.getRoundCount());
                }
            }
            addReport(r);
            // write seperator
            addReport(new Report(1200, Report.PUBLIC));
        } else {
            addReport(new Report(1210, Report.PUBLIC));
        }

        if (game.getOptions().booleanOption("individual_initiative")) {
            r = new Report(1040, Report.PUBLIC);
            addReport(r);
            for (Enumeration<GameTurn> e = game.getTurns(); e.hasMoreElements(); ) {
                GameTurn t = e.nextElement();
                if (t instanceof GameTurn.SpecificEntityTurn) {
                    Entity entity = game
                            .getEntity(((GameTurn.SpecificEntityTurn) t)
                                               .getEntityNum());
                    r = new Report(1045);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(entity.getInitiative().toString());
                    addReport(r);
                } else {
                    IPlayer player = getPlayer(t.getPlayerNum());
                    if (null != player) {
                        r = new Report(1050, Report.PUBLIC);
                        r.add(Server.getColorForPlayer(player));
                        addReport(r);
                    }
                }
            }
        } else {
            for (Enumeration<Team> i = game.getTeams(); i.hasMoreElements(); ) {
                final Team team = i.nextElement();

                // If there is only one player, list them as the 'team', and
                // use the team iniative
                if (team.getSize() == 1) {
                    final IPlayer player = team.getPlayers().nextElement();
                    r = new Report(1015, Report.PUBLIC);
                    r.add(Server.getColorForPlayer(player));
                    r.add(team.getInitiative().toString());
                    addReport(r);
                } else {
                    // Multiple players. List the team, then break it down.
                    r = new Report(1015, Report.PUBLIC);
                    r.add(IPlayer.teamNames[team.getId()]);
                    r.add(team.getInitiative().toString());
                    addReport(r);
                    for (Enumeration<IPlayer> j = team.getPlayers(); j
                            .hasMoreElements(); ) {
                        final IPlayer player = j.nextElement();
                        r = new Report(1015, Report.PUBLIC);
                        r.indent();
                        r.add(player.getName());
                        r.add(player.getInitiative().toString());
                        addReport(r);
                    }
                }
            }

            if (!doBlind()) {

                // The turn order is different in movement phase
                // if a player has any "even" moving units.
                r = new Report(1020, Report.PUBLIC);

                boolean hasEven = false;
                for (Enumeration<GameTurn> i = game.getTurns(); i
                        .hasMoreElements(); ) {
                    GameTurn turn = i.nextElement();
                    IPlayer player = getPlayer(turn.getPlayerNum());
                    if (null != player) {
                        r.add(player.getName());
                        if (player.getEvenTurns() > 0) {
                            hasEven = true;
                        }
                    }
                }
                r.newlines = 2;
                addReport(r);
                if (hasEven) {
                    r = new Report(1021, Report.PUBLIC);
                    if ((game.getOptions().booleanOption("inf_deploy_even") || game
                            .getOptions().booleanOption("protos_deploy_even"))
                        && !(game.getLastPhase() == IGame.Phase.PHASE_END_REPORT)) {
                        r.choose(true);
                    } else {
                        r.choose(false);
                    }
                    r.indent();
                    r.newlines = 2;
                    addReport(r);
                }
            }

        }
        if (!abbreviatedReport) {
            // Wind direction and strength
            Report rWindDir = new Report(1025, Report.PUBLIC);
            rWindDir.add(game.getPlanetaryConditions().getWindDirDisplayableName());
            rWindDir.newlines = 0;
            Report rWindStr = new Report(1030, Report.PUBLIC);
            rWindStr.add(game.getPlanetaryConditions().getWindDisplayableName());
            rWindStr.newlines = 0;
            Report rWeather = new Report(1031, Report.PUBLIC);
            rWeather.add(game.getPlanetaryConditions().getWeatherDisplayableName());
            rWeather.newlines = 0;
            Report rLight = new Report(1032, Report.PUBLIC);
            rLight.add(game.getPlanetaryConditions().getLightDisplayableName());
            Report rVis = new Report(1033, Report.PUBLIC);
            rVis.add(game.getPlanetaryConditions().getFogDisplayableName());
            addReport(rWindDir);
            addReport(rWindStr);
            addReport(rWeather);
            addReport(rLight);
            addReport(rVis);

            if (deployment) {
                addNewLines();
            }
        }
    }

    private void applyDropshipLandingDamage(Coords centralPos, Entity killer) {

        // first cycle through hexes to figure out final elevation
        IHex centralHex = game.getBoard().getHex(centralPos);
        if (null == centralHex) {
            // shouldnt happen
            return;
        }
        int finalElev = centralHex.getLevel();
        if (!centralHex.containsTerrain(Terrains.PAVEMENT)
            && !centralHex.containsTerrain(Terrains.ROAD)) {
            finalElev--;
        }
        Vector<Coords> positions = new Vector<Coords>();
        positions.add(centralPos);
        for (int i = 0; i < 6; i++) {
            Coords pos = centralPos.translated(i);
            IHex hex = game.getBoard().getHex(pos);
            if (null == hex) {
                continue;
            }
            if (hex.getLevel() < finalElev) {
                finalElev = hex.getLevel();
            }
            positions.add(pos);
        }
        // ok now cycle through hexes and make all changes
        for (Coords pos : positions) {
            IHex hex = game.getBoard().getHex(pos);
            hex.setLevel(finalElev);
            // get rid of woods and replace with rough
            if (hex.containsTerrain(Terrains.WOODS)
                || hex.containsTerrain(Terrains.JUNGLE)) {
                hex.removeTerrain(Terrains.WOODS);
                hex.removeTerrain(Terrains.JUNGLE);
                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.ROUGH, 1));
            }
            sendChangedHex(pos);
        }

        applyDropshipProximityDamage(centralPos, killer);
    }

    private void applyDropshipProximityDamage(Coords centralPos, Entity killer) {
        applyDropshipProximityDamage(centralPos, false, 0, killer);
    }

    /**
     * apply damage to units and buildings within a certain radius of a landing
     * or lifting off dropship
     *
     * @param centralPos - the Coords for the central position of the dropship
     */
    private void applyDropshipProximityDamage(Coords centralPos,
                                              boolean rearArc, int facing, Entity killer) {

        Vector<Integer> alreadyHit = new Vector<Integer>();

        // anything in the central hex or adjacent hexes is destroyed
        Hashtable<Coords, Vector<Entity>> positionMap = game.getPositionMap();
        for (Entity en : game.getEntitiesVector(centralPos)) {
            if (!en.isAirborne()) {
                addReport(destroyEntity(en, "dropship proximity damage", false,
                                        false));
                alreadyHit.add(en.getId());
            }
        }
        Building bldg = game.getBoard().getBuildingAt(centralPos);
        if (null != bldg) {
            collapseBuilding(bldg, positionMap, centralPos, vPhaseReport);
        }
        for (int i = 0; i < 6; i++) {
            Coords pos = centralPos.translated(i);
            for (Entity en : game.getEntitiesVector(pos)) {
                if (!en.isAirborne()) {
                    addReport(destroyEntity(en, "dropship proximity damage",
                                            false, false));
                }
                alreadyHit.add(en.getId());
            }
            bldg = game.getBoard().getBuildingAt(pos);
            if (null != bldg) {
                collapseBuilding(bldg, positionMap, pos, vPhaseReport);
            }
        }

        // Report r;
        // ok now I need to look at the damage rings - start at 2 and go to 7
        for (int i = 2; i < 8; i++) {
            int damageDice = (8 - i) * 2;
            ArrayList<Coords> ring = Compute.coordsAtRange(centralPos, i);
            for (Coords pos : ring) {
                if (rearArc
                    && !Compute.isInArc(centralPos, facing, pos,
                                        Compute.ARC_AFT)) {
                    continue;
                }

                alreadyHit = artilleryDamageHex(pos, centralPos, damageDice,
                                                null, killer.getId(), killer, null, false, 0,
                                                vPhaseReport, false, alreadyHit, true);

                /*
                 * IHex hex = game.getBoard().getHex(pos); if (null == hex) {
                 * continue; }
                 *
                 * // code borrowed heavily from artilleryDamageHex bldg =
                 * game.getBoard().getBuildingAt(pos); int bldgAbsorbs = 0; if
                 * ((bldg != null)) { bldgAbsorbs = bldg.getAbsorbtion(pos);
                 * addReport(damageBuilding(bldg, Compute.d6(damageDice), pos));
                 * addAffectedBldg(bldg,false); }
                 *
                 * // get units in hex for (Enumeration<Entity> victims =
                 * game.getEntities(pos); victims .hasMoreElements();) { Entity
                 * entity = victims.nextElement(); int hits =
                 * Compute.d6(damageDice); ToHitData toHit = new ToHitData();
                 * int cluster = 5;
                 *
                 * // Check: is entity excluded? if (entity.isAirborne()) {
                 * continue; }
                 *
                 * // Check: is entity inside building? if ((bldg != null) &&
                 * (bldgAbsorbs > 0) && (entity.getElevation() < hex
                 * .terrainLevel(Terrains.BLDG_ELEV))) { cluster -= bldgAbsorbs;
                 * // some buildings scale remaining damage that is not //
                 * absorbed // TODO: this isn't quite right for castles brian
                 * cluster = (int) Math.floor(bldg.getDamageToScale() cluster);
                 * if (entity instanceof Infantry) { continue; // took its
                 * damage already from building // damage } else if (cluster <=
                 * 0) { // entity takes no damage r = new Report(6426);
                 * r.subject = entity.getId(); r.addDesc(entity); addReport(r);
                 * continue; } else { r = new Report(6428); r.subject =
                 * entity.getId(); r.add(bldgAbsorbs); addReport(r); } }
                 *
                 * // Work out hit table to use
                 * toHit.setSideTable(entity.sideTable(centralPos));
                 *
                 * // Do the damage r = new Report(6480); r.subject =
                 * entity.getId(); r.addDesc(entity);
                 * r.add(toHit.getTableDesc()); r.add(hits);
                 * vPhaseReport.add(r); while (hits > 0) { HitData hit =
                 * entity.rollHitLocation( toHit.getHitTable(),
                 * toHit.getSideTable()); addReport(damageEntity(entity, hit,
                 * Math.min(cluster, hits), false, DamageType.NONE, false, true,
                 * false)); hits -= Math.min(5, hits); } // Has the target been
                 * destroyed? if (entity.isDoomed()) { // Has the target taken a
                 * turn? if (!entity.isDone()) { // Dead entities don't take
                 * turns. game.removeTurnFor(entity);
                 * send(createTurnVectorPacket()); } // End target-still-to-move
                 * // Clean out the entity. entity.setDestroyed(true);
                 * game.moveToGraveyard(entity.getId());
                 * send(createRemoveEntityPacket(entity.getId())); }
                 * entityUpdate(entity.getId()); }
                 */
            }
        }
        destroyDoomedEntities(alreadyHit);
    }

    /**
     * Marks ineligible entities as not ready for this phase
     */
    private void setIneligible(IGame.Phase phase) {
        Vector<Entity> assistants = new Vector<Entity>();
        boolean assistable = false;

        if (isPlayerForcedVictory()) {
            assistants.addAll(game.getEntitiesVector());
        } else {
            for (Entity entity : game.getEntitiesVector()) {
                if (entity.isEligibleFor(phase)) {
                    assistable = true;
                } else {
                    assistants.addElement(entity);
                }
            }
        }
        for (Entity assistant : assistants) {
            if (!assistable || !assistant.canAssist(phase)) {
                assistant.setDone(true);
            }
        }
    }

    /**
     * Have the loader load the indicated unit. The unit being loaded loses its
     * turn.
     *
     * @param loader - the <code>Entity</code> that is loading the unit.
     * @param unit   - the <code>Entity</code> being loaded.
     */
    private void loadUnit(Entity loader, Entity unit, int bayNumber) {

        if ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) && !unit.isDone()) {
            // Remove the *last* friendly turn (removing the *first* penalizes
            // the opponent too much, and re-calculating moves is too hard).
            game.removeTurnFor(unit);
            send(createTurnVectorPacket());
        }

        // When loading an Aero into a squadron in the lounge, make sure the
        // loaded aero has the same bomb loadout as the squadron
        // We want to do this before the fighter is loaded: when the fighter
        // is loaded into the squadron, the squadrons bombing attacks are
        // adjusted based on the bomb-loadout on the fighter.
        if ((game.getPhase() == Phase.PHASE_LOUNGE)
            && (loader instanceof FighterSquadron)) {
            ((Aero) unit).setBombChoices(((FighterSquadron) loader)
                                                 .getBombChoices());
        }

        // Load the unit. Do not check for elevation during deployment
        boolean checkElevation = (game.getPhase() != Phase.PHASE_DEPLOYMENT)
                                 && (game.getPhase() != Phase.PHASE_LOUNGE);
        if (bayNumber == -1) {
            loader.load(unit, checkElevation);
        } else {
            loader.load(unit, checkElevation, bayNumber);
        }

        // The loaded unit is being carried by the loader.
        unit.setTransportId(loader.getId());

        // Remove the loaded unit from the screen.
        unit.setPosition(null);

        // set deployment round of the loadee to equal that of the loader
        unit.setDeployRound(loader.getDeployRound());

        // Update the loaded unit.
        entityUpdate(unit.getId());

        // Taharqa (2/28/13): I am not sure why the loader is not getting
        // updated too - not updating it
        // is causing problem in the chat lounge loading, so I am going to do it
        // here, but if we get
        // weird results for other loading, then the reason is probably this
        entityUpdate(loader.getId());
    }

    private boolean unloadUnit(Entity unloader, Targetable unloaded,
                               Coords pos, int facing, int elevation) {
        return unloadUnit(unloader, unloaded, pos, facing, elevation, false,
                false);
    }

    /**
     * Have the unloader unload the indicated unit. The unit being unloaded may
     * or may not gain a turn
     *
     * @param unloader
     *            - the <code>Entity</code> that is unloading the unit.
     * @param unloaded
     *            - the <code>Targetable</code> unit being unloaded.
     * @param pos
     *            - the <code>Coords</code> for the unloaded unit.
     * @param facing
     *            - the <code>int</code> facing for the unloaded unit.
     * @param elevation
     *            - the <code>int</code> elevation at which to unload, if both
     *            loader and loaded units use VTOL movement.
     * @param evacuation
     *            - a <code>boolean</code> indicating whether this unit is being
     *            unloaded as a result of its carrying units destruction
     * @return <code>true</code> if the unit was successfully unloaded,
     *         <code>false</code> if the unit isn't carried in unloader.
     */
    private boolean unloadUnit(Entity unloader, Targetable unloaded,
            Coords pos, int facing, int elevation, boolean evacuation,
            boolean duringDeployment) {

        // We can only unload Entities.
        Entity unit = null;
        if (unloaded instanceof Entity) {
            unit = (Entity) unloaded;
        } else {
            return false;
        }

        // Unload the unit.
        if (!unloader.unload(unit)) {
            return false;
        }

        // The unloaded unit is no longer being carried.
        unit.setTransportId(Entity.NONE);

        // Place the unloaded unit onto the screen.
        unit.setPosition(pos);

        // Units unloaded onto the screen are deployed.
        if (pos != null) {
            unit.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        unit.setFacing(facing);
        unit.setSecondaryFacing(facing);

        IHex hex = game.getBoard().getHex(pos);
        boolean isBridge = (hex != null)
                && hex.containsTerrain(Terrains.PAVEMENT);

        if (hex == null) {
            unit.setElevation(elevation);
        } else if (unloader.getMovementMode() == EntityMovementMode.VTOL) {
            if (unit.getMovementMode() == EntityMovementMode.VTOL) {
                // Flying units onload to the same elevation as the flying
                // transport
                unit.setElevation(elevation);
            } else if (game.getBoard().getBuildingAt(pos) != null) {
                // non-flying unit onloaded from a flying onto a building
                // -> sit on the roff
                unit.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
            } else {
                while (elevation >= -hex.depth()) {
                    if (unit.isElevationValid(elevation, hex)) {
                        unit.setElevation(elevation);
                        break;
                    }
                    elevation--;
                    // If unit is landed, the while loop breaks before here
                    // And unit.moved will be MOVE_NONE
                    // If we can jump, use jump
                    if (unit.getJumpMP() > 0) {
                        unit.moved = EntityMovementType.MOVE_JUMP;
                    } else { // Otherwise, use walk trigger check for ziplines
                        unit.moved = EntityMovementType.MOVE_WALK;
                    }
                }
                if (!unit.isElevationValid(elevation, hex)) {
                    return false;
                }
            }
        } else if (game.getBoard().getBuildingAt(pos) != null) {
            // non flying unit unloading units into a building
            // -> sit in the building at the same elevation
            unit.setElevation(elevation);
        } else if (hex.terrainLevel(Terrains.WATER) > 0) {
            if ((unit.getMovementMode() == EntityMovementMode.HOVER)
                || (unit.getMovementMode() == EntityMovementMode.WIGE)
                || (unit.getMovementMode() == EntityMovementMode.HYDROFOIL)
                || (unit.getMovementMode() == EntityMovementMode.NAVAL)
                || (unit.getMovementMode() == EntityMovementMode.SUBMARINE)
                || (unit.getMovementMode() == EntityMovementMode.INF_UMU)
                || hex.containsTerrain(Terrains.ICE) || isBridge) {
                // units that can float stay on the surface, or we go on the
                // bridge
                // this means elevation 0, because elevation is relative to the
                // surface
                unit.setElevation(0);
            }
        } else {
            // default to the floor of the hex.
            // unit elevation is relative to the surface
            unit.setElevation(hex.floor() - hex.surface());
        }

        // Check for zip lines PSR -- MOVE_WALK implies ziplines
        if (unit.moved == EntityMovementType.MOVE_WALK) {
            if (game.getOptions().booleanOption("tacops_ziplines")
                    && (unit instanceof Infantry)
                    && !((Infantry) unit).isMechanized()) {

               // Handle zip lines
                PilotingRollData psr = getEjectModifiers(game, unit, false,
                        unit.getPosition(), "Anti-mek skill");
                int roll = Compute.d6(2);

                // Report ziplining
                Report r = new Report(9920);
                r.subject = unit.getId();
                r.addDesc(unit);
                r.newlines = 0;
                addReport(r);

                // Report TN
                r = new Report(9921);
                r.subject = unit.getId();
                r.add(psr.getValue());
                r.add(psr.getDesc());
                r.add(roll);
                r.newlines = 0;
                addReport(r);

                if (roll < psr.getValue()) { // Failure!
                    r = new Report(9923);
                    r.subject = unit.getId();
                    r.add(psr.getValue());
                    r.add(roll);
                    addReport(r);

                    HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL,
                            ToHitData.SIDE_FRONT);
                    hit.setIgnoreInfantryDoubleDamage(true);
                    addReport(damageEntity(unit, hit, 5));
                } else { //  Report success
                    r = new Report(9922);
                    r.subject = unit.getId();
                    r.add(psr.getValue());
                    r.add(roll);
                    addReport(r);
                }
                addNewLines();
            } else {
                return false;
            }
        }

        addReport(doSetLocationsExposure(unit, hex, false, unit.getElevation()));

        // unlike other unloaders, entities unloaded from droppers can still
        // move (unless infantry)
        if (!evacuation && (unloader instanceof SmallCraft)
            && !(unit instanceof Infantry)) {
            unit.setUnloaded(false);
            unit.setDone(false);

            // unit uses half of walk mp and is treated as moving one hex
            unit.mpUsed = unit.getOriginalWalkMP() / 2;
            unit.delta_distance = 1;
        }

        // If we unloaded during deployment, allow a turn
        if (duringDeployment) {
            unit.setUnloaded(false);
            unit.setDone(false);
        }

        // Update the unloaded unit.
        entityUpdate(unit.getId());

        // Unloaded successfully.
        return true;
    }

    /**
     * Do a piloting skill check to attempt landing
     *
     * @param entity The <code>Entity</code> that is landing
     * @param roll   The <code>PilotingRollData</code> to be used for this landing.
     * @return true if check succeeds, false otherwise.
     */
    private void doAttemptLanding(Entity entity, PilotingRollData roll) {

        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return;
        }

        // okay, print the info
        Report r = new Report(9605);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9606);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        // boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            int mof = roll.getValue() - diceRoll;
            int damage = 10 * (mof);
            // Report damage taken
            r = new Report(9609);
            r.indent();
            r.addDesc(entity);
            r.add(damage);
            r.add(mof);
            addReport(r);

            int side = ToHitData.SIDE_FRONT;
            if ((entity instanceof Aero) && ((Aero) entity).isSpheroid()) {
                side = ToHitData.SIDE_REAR;
            }
            while (damage > 0) {
                HitData hit = entity
                        .rollHitLocation(ToHitData.HIT_NORMAL, side);
                addReport(damageEntity(entity, hit, 10));
                damage -= 10;
            }
            // suc = false;
        } else {
            r.choose(true);
            addReport(r);
            // suc = true;
        }
    }

    private boolean launchUnit(Entity unloader, Targetable unloaded,
                               Coords pos, int facing, int velocity, int altitude, int[] moveVec,
                               int bonus) {

        Entity unit = null;
        if (unloaded instanceof Entity) {
            unit = (Entity) unloaded;
        } else {
            return false;
        }

        // must be an ASF, Small Craft, or Dropship
        Aero a = new Aero();
        if ((unit instanceof Aero) && !(unit instanceof Jumpship)) {
            a = (Aero) unit;
        } else {
            return false;
        }

        Report r;

        // Unload the unit.
        if (!unloader.unload(unit)) {
            return false;
        }

        // The unloaded unit is no longer being carried.
        unit.setTransportId(Entity.NONE);

        // pg. 86 of TW: launched fighters can move in fire in the turn they are
        // unloaded
        unit.setUnloaded(false);

        // Place the unloaded unit onto the screen.
        unit.setPosition(pos);

        // Units unloaded onto the screen are deployed.
        if (pos != null) {
            unit.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        unit.setFacing(facing);
        unit.setSecondaryFacing(facing);

        // the velocity of the unloadd unit is the same as the loader
        a.setCurrentVelocity(velocity);
        a.setNextVelocity(velocity);

        // if using advanced movement then set vectors
        a.setVectors(moveVec);

        unit.setAltitude(altitude);

        // it seems that the done button is still being set and I can't figure
        // out where
        unit.setDone(false);

        // if the bonus was greater than zero then too many fighters were
        // launched and they
        // must all make control rolls
        if (bonus > 0) {
            PilotingRollData psr = unit.getBasePilotingRoll();
            psr.addModifier(bonus, "safe launch rate exceeded");
            int ctrlroll = Compute.d6(2);
            r = new Report(9375);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.add(psr.getValue());
            r.add(ctrlroll);
            r.indent(1);
            if (ctrlroll < psr.getValue()) {
                r.choose(false);
                addReport(r);
                // damage the unit
                int damage = 10 * (psr.getValue() - ctrlroll);
                HitData hit = a.rollHitLocation(ToHitData.HIT_NORMAL,
                                                ToHitData.SIDE_FRONT);
                Vector<Report> rep = damageEntity(unit, hit, damage);
                Report.indentAll(rep, 1);
                rep.lastElement().newlines++;
                addReport(rep);
                // did we destroy the unit?
                if (unit.isDoomed()) {
                    // Clean out the entity.
                    unit.setDestroyed(true);
                    game.moveToGraveyard(unit.getId());
                    send(createRemoveEntityPacket(unit.getId()));
                }
            } else {
                // avoided damage
                r.choose(true);
                r.newlines++;
                addReport(r);
            }
        } else {
            r = new Report(9374);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.indent(1);
            r.newlines++;
            addReport(r);
        }

        // launching from an OOC vessel causes damage
        // same thing if faster than 2 velocity in atmosphere
        if ((((Aero) unloader).isOutControlTotal() && !unit.isDoomed())
            || ((((Aero) unloader).getCurrentVelocity() > 2) && !game
                .getBoard().inSpace())) {
            int damroll = Compute.d6(2);
            int damage = damroll * 10;
            r = new Report(9385);
            r.subject = unit.getId();
            r.add(unit.getDisplayName());
            r.add(damage);
            addReport(r);
            HitData hit = a.rollHitLocation(ToHitData.HIT_NORMAL,
                                            ToHitData.SIDE_FRONT);
            addReport(damageEntity(unit, hit, damage));
            // did we destroy the unit?
            if (unit.isDoomed()) {
                // Clean out the entity.
                unit.setDestroyed(true);
                game.moveToGraveyard(unit.getId());
                send(createRemoveEntityPacket(unit.getId()));
            }
        }

        // Update the unloaded unit.
        entityUpdate(unit.getId());

        // Set the turn mask. We need to be specific otherwise we run the risk
        // of having a unit of another class consume the turn and leave the
        // unloaded unit without a turn
        int turnMask;
        List<GameTurn> turnVector = game.getTurnVector();
        if (unit instanceof Dropship) {
            turnMask = GameTurn.CLASS_DROPSHIP;
        } else if (unit instanceof SmallCraft) {
            turnMask = GameTurn.CLASS_SMALL_CRAFT;
        } else {
            turnMask = GameTurn.CLASS_AERO;
        }
        // Add one, otherwise we consider the turn we're currently processing
        int turnInsertIdx = game.getTurnIndex() + 1;
        // We have to figure out where to insert this turn, to maintain proper
        // space turn order (Jumpships, Smallcraft, Dropships, Aeros)
        for (; turnInsertIdx < turnVector.size(); turnInsertIdx++) {
            GameTurn turn = turnVector.get(turnInsertIdx);
            if (turn.isValidEntity(unit, game)) {
                break;
            }
        }

        // ok add another turn for the unloaded entity so that it can move
        GameTurn newTurn = new GameTurn.EntityClassTurn(
                unit.getOwner().getId(), turnMask);
        game.insertTurnAfter(newTurn, turnInsertIdx);
        // brief everybody on the turn update
        send(createTurnVectorPacket());

        return true;
    }

    public void dropUnit(Entity drop, Entity entity, Coords curPos, int altitude) {
        // Unload the unit.
        entity.unload(drop);
        // The unloaded unit is no longer being carried.
        drop.setTransportId(Entity.NONE);

        // OK accordind to Welshman's pending ruling, when on the ground map
        // units should be deployed in the ring two hexes away from the dropshp
        // optimally, we should let people choose here, but that would be
        // complicated
        // so for now I am just going to distribute them. I will give each unit
        // the first
        // emptiest hex that has no water or magma in it.
        // I will start the circle based on the facing of the dropper
        // Spheroid - facing
        // Aerodyne - opposite of facing
        // http://www.classicbattletech.com/forums/index.php?topic=65600.msg1568089#new
        if (game.getBoard().onGround() && (null != curPos)) {
            boolean selected = false;
            int count = 0;
            int max = 0;
            int facing = entity.getFacing();
            if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {
                // no real rule for this but it seems to make sense that units
                // would drop behind an
                // aerodyne rather than in front of it
                facing = (facing + 3) % 6;
            }
            boolean checkDanger = true;
            while (!selected) {
                // we can get caught in an infinite loop if all available hexes
                // are dangerous, so check for this
                boolean allDanger = true;
                for (int i = 0; i < 6; i++) {
                    int dir = (facing + i) % 6;
                    Coords newPos = curPos.translated(dir, 2);
                    count = 0;
                    if (game.getBoard().contains(newPos)) {
                        IHex newHex = game.getBoard().getHex(newPos);
                        Building bldg = game.getBoard().getBuildingAt(newPos);
                        boolean danger = newHex.containsTerrain(Terrains.WATER)
                                         || newHex.containsTerrain(Terrains.MAGMA)
                                         || (null != bldg);
                        for (Entity unit : game.getEntitiesVector(newPos)) {
                            if ((unit.getAltitude() == altitude)
                                && !(unit instanceof Aero)) {
                                count++;
                            }
                        }
                        if ((count <= max) && (!danger || !checkDanger)) {
                            selected = true;
                            curPos = newPos;
                            break;
                        }
                        if (!danger) {
                            allDanger = false;
                        }
                    }
                    newPos = newPos.translated((dir + 2) % 6);
                    count = 0;
                    if (game.getBoard().contains(newPos)) {
                        IHex newHex = game.getBoard().getHex(newPos);
                        Building bldg = game.getBoard().getBuildingAt(newPos);
                        boolean danger = newHex.containsTerrain(Terrains.WATER)
                                         || newHex.containsTerrain(Terrains.MAGMA)
                                         || (null != bldg);
                        for (Entity unit : game.getEntitiesVector(newPos)) {
                            if ((unit.getAltitude() == altitude)
                                && !(unit instanceof Aero)) {
                                count++;
                            }
                        }
                        if ((count <= max) && (!danger || !checkDanger)) {
                            selected = true;
                            curPos = newPos;
                            break;
                        }
                        if (!danger) {
                            allDanger = false;
                        }
                    }
                }
                if (allDanger && checkDanger) {
                    checkDanger = false;
                } else {
                    max++;
                }
            }
        }

        // Place the unloaded unit onto the screen.
        drop.setPosition(curPos);

        // Units unloaded onto the screen are deployed.
        if (curPos != null) {
            drop.setDeployed(true);
        }

        // Point the unloaded unit in the given direction.
        drop.setFacing(entity.getFacing());
        drop.setSecondaryFacing(entity.getFacing());

        drop.setAltitude(altitude);
        entityUpdate(drop.getId());
    }

    /**
     * Record that the given building has been affected by the current entity's
     * movement. At the end of the entity's movement, notify the clients about
     * the updates.
     *
     * @param bldg     - the <code>Building</code> that has been affected.
     * @param collapse - a <code>boolean</code> value that specifies that the
     *                 building collapsed (when <code>true</code>).
     */
    private void addAffectedBldg(Building bldg, boolean collapse) {

        // If the building collapsed, then the clients have already
        // been notified, so remove it from the notification list.
        if (collapse) {
            affectedBldgs.remove(bldg);
        } else { // Otherwise, make sure that this building is tracked.
            affectedBldgs.put(bldg, Boolean.FALSE);
        }
    }

    /**
     * Walk through the building hexes that were affected by the recent entity's
     * movement. Notify the clients about the updates to all affected entities
     * and uncollapsed buildings. The affected hexes is then cleared for the
     * next entity's movement.
     */
    private void applyAffectedBldgs() {

        // Build a list of Building updates.
        Vector<Building> bldgUpdates = new Vector<Building>();

        // Only send a single turn update.
        boolean bTurnsChanged = false;

        // Walk the set of buildings.
        Enumeration<Building> bldgs = affectedBldgs.keys();
        while (bldgs.hasMoreElements()) {
            final Building bldg = bldgs.nextElement();

            // Walk through the building's coordinates.
            Enumeration<Coords> bldgCoords = bldg.getCoords();
            while (bldgCoords.hasMoreElements()) {
                final Coords coords = bldgCoords.nextElement();

                // Walk through the entities at these coordinates.
                for (Entity entity : game.getEntitiesVector(coords)) {

                    // Is the entity infantry?
                    if (entity instanceof Infantry) {

                        // Is the infantry dead?
                        if (entity.isDoomed() || entity.isDestroyed()) {

                            // Has the entity taken a turn?
                            if (!entity.isDone()) {

                                // Dead entities don't take turns.
                                game.removeTurnFor(entity);
                                bTurnsChanged = true;

                            } // End entity-still-to-move

                            // Clean out the dead entity.
                            entity.setDestroyed(true);
                            game.moveToGraveyard(entity.getId());
                            send(createRemoveEntityPacket(entity.getId()));
                        }

                        // Infantry that aren't dead are damaged.
                        else {
                            entityUpdate(entity.getId());
                        }

                    } // End entity-is-infantry

                } // Check the next entity.

            } // Handle the next hex in this building.

            // Add this building to the report.
            bldgUpdates.addElement(bldg);

        } // Handle the next affected building.

        // Did we update the turns?
        if (bTurnsChanged) {
            send(createTurnVectorPacket());
        }

        // Are there any building updates?
        if (!bldgUpdates.isEmpty()) {

            // Send the building updates to the clients.
            sendChangedBuildings(bldgUpdates);

            // Clear the list of affected buildings.
            affectedBldgs.clear();
        }

        // And we're done.

    } // End private void applyAffectedBldgs()

    /**
     * Receives an entity movement packet, and if valid, executes it and ends
     * the current turn.
     */
    private void receiveMovement(Packet packet, int connId) {
        Map<EntityTargetPair, LosEffects> losCache = new HashMap<>();
        Entity entity = game.getEntity(packet.getIntValue(0));
        MovePath md = (MovePath) packet.getObject(1);

        // is this the right phase?
        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {
            System.err
                    .println("error: server got movement packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (game.isPhaseSimultaneous()) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null) || !turn.isValid(connId, entity, game)) {
            System.err.println("error: server got invalid movement packet");
            return;
        }

        // looks like mostly everything's okay
        processMovement(entity, md, losCache);

        // The attacker may choose to break a chain whip grapple by expending MP
        if ((entity.getGrappled() != Entity.NONE)
                && entity.isChainWhipGrappled() && entity.isGrappleAttacker()
                && (md.getMpUsed() > 0)) {

            Entity te = game.getEntity(entity.getGrappled());
            Report r = new Report(4316);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.addDesc(te);
            addReport(r);

            entity.setGrappled(Entity.NONE, false);
            te.setGrappled(Entity.NONE, false);

            entityUpdate(entity.getId());
            entityUpdate(te.getId());
        }

        // check the LOS of any telemissiles owned by this entity
        for (int missileId : entity.getTMTracker().getMissiles()) {
            Entity tm = game.getEntity(missileId);
            if ((null != tm) && !tm.isDestroyed()
                && (tm instanceof TeleMissile)) {
                if (LosEffects.calculateLos(game, entity.getId(), tm).canSee()) {
                    ((TeleMissile) tm).setOutContact(false);
                } else {
                    ((TeleMissile) tm).setOutContact(true);
                }
                entityUpdate(tm.getId());
            }
        }

        // Notify the clients about any building updates.
        applyAffectedBldgs();

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(losCache);
        }

        // This entity's turn is over.
        // N.B. if the entity fell, a *new* turn has already been added.
        endCurrentTurn(entity);
    }

    /**
     * makes a unit skid or sideslip on the board
     *
     * @param entity    the unit which should skid
     * @param start     the coordinates of the hex the unit was in prior to skidding
     * @param elevation the elevation of the unit
     * @param direction the direction of the skid
     * @param distance  the number of hexes skidded
     * @param step      the MoveStep which caused the skid
     * @return true if the entity was removed from play
     */
    private boolean processSkid(Entity entity, Coords start, int elevation,
            int direction, int distance, MoveStep step,
            EntityMovementType moveType) {
        Coords nextPos = start;
        Coords curPos = nextPos;
        IHex curHex = game.getBoard().getHex(start);
        Report r;
        int skidDistance = 0; // actual distance moved
        while (!entity.isDoomed() && (distance > 0)) {
            nextPos = curPos.translated(direction);
            // Is the next hex off the board?
            if (!game.getBoard().contains(nextPos)) {

                // Can the entity skid off the map?
                if (game.getOptions().booleanOption("push_off_board")) {
                    // Yup. One dead entity.
                    game.removeEntity(entity.getId(),
                                      IEntityRemovalConditions.REMOVE_PUSHED);
                    send(createRemoveEntityPacket(entity.getId(),
                                                  IEntityRemovalConditions.REMOVE_PUSHED));
                    r = new Report(2030, Report.PUBLIC);
                    r.addDesc(entity);
                    addReport(r);

                    for (Entity e : entity.getLoadedUnits()) {
                        game.removeEntity(e.getId(),
                                          IEntityRemovalConditions.REMOVE_PUSHED);
                        send(createRemoveEntityPacket(e.getId(),
                                                      IEntityRemovalConditions.REMOVE_PUSHED));
                    }
                    Entity swarmer = game
                            .getEntity(entity.getSwarmAttackerId());
                    if (swarmer != null) {
                        if (!swarmer.isDone()) {
                            game.removeTurnFor(swarmer);
                            swarmer.setDone(true);
                            send(createTurnVectorPacket());
                        }
                        game.removeEntity(swarmer.getId(),
                                          IEntityRemovalConditions.REMOVE_PUSHED);
                        send(createRemoveEntityPacket(swarmer.getId(),
                                                      IEntityRemovalConditions.REMOVE_PUSHED));
                    }
                    // The entity's movement is completed.
                    return true;

                }
                // Nope. Update the report.
                r = new Report(2035);
                r.subject = entity.getId();
                r.indent();
                addReport(r);
                // Stay in the current hex and stop skidding.
                break;
            }

            IHex nextHex = game.getBoard().getHex(nextPos);
            distance -= nextHex.movementCost(entity) + 1;
            // By default, the unit is going to fall to the floor of the next
            // hex
            int curAltitude = elevation + curHex.getLevel();
            int nextAltitude = nextHex.floor();

            // but VTOL keep altitude
            if (entity.getMovementMode() == EntityMovementMode.VTOL) {
                nextAltitude = Math.max(nextAltitude, curAltitude);
            } else {
                // Is there a building to "catch" the unit?
                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                    // unit will land on the roof, if at a higher level,
                    // otherwise it will skid through the wall onto the same
                    // floor.
                    // don't change this if the building starts at an elevation
                    // higher than the unit
                    // (e.g. the building is on a hill). Otherwise, we skid into
                    // solid earth.
                    if (curAltitude >= nextHex.floor()) {
                        nextAltitude = Math
                                .min(curAltitude,
                                     nextHex.getLevel()
                                     + nextHex
                                             .terrainLevel(Terrains.BLDG_ELEV));
                    }
                }
                // Is there a bridge to "catch" the unit?
                if (nextHex.containsTerrain(Terrains.BRIDGE)) {
                    // unit will land on the bridge, if at a higher level,
                    // and the bridge exits towards the current hex,
                    // otherwise the bridge has no effect
                    int exitDir = (direction + 3) % 6;
                    exitDir = 1 << exitDir;
                    if ((nextHex.getTerrain(Terrains.BRIDGE).getExits() & exitDir) == exitDir) {
                        nextAltitude = Math
                                .min(curAltitude,
                                     Math.max(
                                             nextAltitude,
                                             nextHex.getLevel()
                                             + nextHex
                                                     .terrainLevel(Terrains.BRIDGE_ELEV)));
                    }
                }
                if ((nextAltitude <= nextHex.surface())
                    && (curAltitude >= curHex.surface())) {
                    // Hovercraft can "skid" over water.
                    // all units can skid over ice.
                    if ((entity instanceof Tank)
                        && ((entity.getMovementMode() == EntityMovementMode.HOVER) || (entity
                                                                                               .getMovementMode() ==
                                                                                       EntityMovementMode.WIGE))) {
                        if (nextHex.containsTerrain(Terrains.WATER)) {
                            nextAltitude = nextHex.surface();
                        }
                    } else {
                        if (nextHex.containsTerrain(Terrains.ICE)) {
                            nextAltitude = nextHex.surface();
                        }
                    }
                }
            }

            // The elevation the skidding unit will occupy in next hex
            int nextElevation = nextAltitude - nextHex.surface();

            boolean crashedIntoTerrain = curAltitude < nextAltitude;
            if (entity.getMovementMode() == EntityMovementMode.VTOL) {
                if ((nextElevation == 0)
                    || ((nextElevation == 1) && (nextHex
                                                         .containsTerrain(Terrains.WOODS) || nextHex
                                                         .containsTerrain(Terrains.JUNGLE)))) {
                    crashedIntoTerrain = true;
                }
            }

            if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                Building bldg = game.getBoard().getBuildingAt(nextPos);

                if (bldg.getType() == Building.WALL) {
                    crashedIntoTerrain = true;
                }

                if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                    crashedIntoTerrain = true;
                }
            }

            // however WIGE can gain 1 level to avoid crashing into the terrain
            if (entity.getMovementMode() == EntityMovementMode.WIGE) {
                if ((nextElevation == 0)
                    && !(nextHex.containsTerrain(Terrains.WOODS) || nextHex
                        .containsTerrain(Terrains.JUNGLE))) {
                    nextElevation = 1;
                    crashedIntoTerrain = false;
                } else if ((nextElevation == 1)
                           && (nextHex.containsTerrain(Terrains.WOODS) || nextHex
                        .containsTerrain(Terrains.JUNGLE))) {
                    nextElevation = 2;
                    crashedIntoTerrain = false;
                }
            }

            Entity crashDropship = null;
            for (Entity en : game.getEntitiesVector(nextPos)) {
                if ((en instanceof Dropship) && !en.isAirborne()
                    && (nextAltitude <= (en.relHeight()))) {
                    crashDropship = en;
                }
            }

            if (crashedIntoTerrain) {

                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {
                    Building bldg = game.getBoard().getBuildingAt(nextPos);

                    // If you crash into a wall you want to stop in the hex
                    // before the wall not in the wall
                    // Like a building.
                    if (bldg.getType() == Building.WALL) {
                        r = new Report(2047);
                    } else if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                        r = new Report(2049);
                    } else {
                        r = new Report(2045);
                    }

                } else {
                    r = new Report(2045);
                }

                r.subject = entity.getId();
                r.indent();
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                    || (entity.getMovementMode() == EntityMovementMode.VTOL)) {
                    int hitSide = (step.getFacing() - direction) + 6;
                    hitSide %= 6;
                    int table = 0;
                    switch (hitSide) {// quite hackish...I think it ought to
                        // work, though.
                        case 0:// can this happen?
                            table = ToHitData.SIDE_FRONT;
                            break;
                        case 1:
                        case 2:
                            table = ToHitData.SIDE_LEFT;
                            break;
                        case 3:
                            table = ToHitData.SIDE_REAR;
                            break;
                        case 4:
                        case 5:
                            table = ToHitData.SIDE_RIGHT;
                            break;
                    }
                    elevation = nextElevation;
                    addReport(crashVTOLorWiGE((VTOL) entity, false, true,
                            distance, curPos, elevation, table));

                    if ((nextHex.containsTerrain(Terrains.WATER) && !nextHex
                            .containsTerrain(Terrains.ICE))
                            || nextHex.containsTerrain(Terrains.WOODS)
                            || nextHex.containsTerrain(Terrains.JUNGLE)) {
                        addReport(destroyEntity(entity,
                                "could not land in crash site"));
                    } else if (elevation < nextHex
                            .terrainLevel(Terrains.BLDG_ELEV)) {
                        Building bldg = game.getBoard().getBuildingAt(nextPos);

                        // If you crash into a wall you want to stop in the hex
                        // before the wall not in the wall
                        // Like a building.
                        if (bldg.getType() == Building.WALL) {
                            addReport(destroyEntity(entity,
                                    "crashed into a wall"));
                            break;
                        }
                        if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {
                            addReport(destroyEntity(entity,
                                    "crashed into a gun emplacement"));
                            break;
                        }

                        addReport(destroyEntity(entity, "crashed into building"));
                    } else {
                        entity.setPosition(nextPos);
                        entity.setElevation(0);
                        addReport(doEntityDisplacementMinefieldCheck(entity,
                                curPos, nextPos, nextElevation));
                    }
                    curPos = nextPos;
                    break;

                }
                // skidding into higher terrain does weight/20
                // damage in 5pt clusters to front.
                int damage = ((int) entity.getWeight() + 19) / 20;
                while (damage > 0) {
                    int table = ToHitData.HIT_NORMAL;
                    int side = entity.sideTable(nextPos);
                    if (entity instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    }
                    addReport(damageEntity(entity,
                                           entity.rollHitLocation(table, side),
                                           Math.min(5, damage)));
                    damage -= 5;
                }
                // Stay in the current hex and stop skidding.
                break;
            }

            // did we hit a dropship. Oww!
            // Taharqa: The rules on how to handle this are completely missing,
            // so I am assuming
            // we assign damage as per an accidental charge, but do not displace
            // the dropship and
            // end the skid
            else if (null != crashDropship) {
                r = new Report(2050);
                r.subject = entity.getId();
                r.indent();
                r.add(crashDropship.getShortName(), true);
                r.add(nextPos.getBoardNum(), true);
                addReport(r);
                ChargeAttackAction caa = new ChargeAttackAction(entity.getId(),
                        crashDropship.getTargetType(),
                        crashDropship.getTargetId(),
                        crashDropship.getPosition());
                ToHitData toHit = caa.toHit(game, true);
                resolveChargeDamage(entity, crashDropship, toHit, direction);
                if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                    || (entity.getMovementMode() == EntityMovementMode.VTOL)) {
                    int hitSide = (step.getFacing() - direction) + 6;
                    hitSide %= 6;
                    int table = 0;
                    switch (hitSide) {// quite hackish...I think it ought to
                        // work, though.
                        case 0:// can this happen?
                            table = ToHitData.SIDE_FRONT;
                            break;
                        case 1:
                        case 2:
                            table = ToHitData.SIDE_LEFT;
                            break;
                        case 3:
                            table = ToHitData.SIDE_REAR;
                            break;
                        case 4:
                        case 5:
                            table = ToHitData.SIDE_RIGHT;
                            break;
                    }
                    elevation = nextElevation;
                    addReport(crashVTOLorWiGE((VTOL) entity, false, true,
                            distance, curPos, elevation, table));
                    break;
                }
                if (!crashDropship.isDoomed() && !crashDropship.isDestroyed()
                    && !game.isOutOfGame(crashDropship)) {
                    break;
                }
            }

            // Have skidding units suffer falls (off a cliff).
            else if (curAltitude > (nextAltitude + entity
                    .getMaxElevationChange())) {
                // WIGE can avoid this too, if they have 2MP to spend
                if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                    && ((entity.getRunMP() - 2) >= entity.mpUsed)) {
                    entity.mpUsed += 2;
                    nextAltitude = curAltitude;
                } else {
                    addReport(doEntityFallsInto(entity, entity.getElevation(),
                            curPos, nextPos,
                            entity.getBasePilotingRoll(moveType), true));
                    addReport(doEntityDisplacementMinefieldCheck(entity,
                            curPos, nextPos, nextElevation));
                    // Stay in the current hex and stop skidding.
                    break;
                }
            }

            // Get any building in the hex.
            Building bldg = null;
            if (nextElevation < nextHex.terrainLevel(Terrains.BLDG_ELEV)) {
                // We will only run into the building if its at a higher level,
                // otherwise we skid over the roof
                bldg = game.getBoard().getBuildingAt(nextPos);
            }
            boolean bldgSuffered = false;
            boolean stopTheSkid = false;
            // Does the next hex contain an entities?
            // ASSUMPTION: hurt EVERYONE in the hex.
            Iterator<Entity> targets = game.getEntities(nextPos);
            if (targets.hasNext()) {
                ArrayList<Entity> avoidedChargeUnits = new ArrayList<Entity>();
                boolean skidChargeHit = false;
                while (targets.hasNext()) {
                    Entity target = targets.next();

                    if ((target.getElevation() > (nextElevation + entity
                            .getHeight()))
                        || (target.relHeight() < nextElevation)) {
                        // target is not in the way
                        continue;
                    }

                    // Can the target avoid the skid?
                    if (!target.isDone()) {
                        if (target instanceof Infantry) {
                            r = new Report(2420);
                            r.subject = target.getId();
                            r.addDesc(target);
                            addReport(r);
                            continue;
                        } else if (target instanceof Protomech) {
                            if (target != Compute.stackingViolation(game,
                                    entity, nextPos, null)) {
                                r = new Report(2420);
                                r.subject = target.getId();
                                r.addDesc(target);
                                addReport(r);
                                continue;
                            }
                        } else {
                            PilotingRollData psr = target.getBasePilotingRoll();
                            psr.addModifier(0, "avoiding collision");
                            int roll = Compute.d6(2);
                            r = new Report(2425);
                            r.subject = target.getId();
                            r.addDesc(target);
                            r.add(psr.getValue());
                            r.add(psr.getDesc());
                            r.add(roll);
                            addReport(r);
                            if (roll >= psr.getValue()) {
                                game.removeTurnFor(target);
                                avoidedChargeUnits.add(target);
                                continue;
                                // TODO: the charge should really be suspended
                                // and resumed after the target moved.
                            }
                        }
                    }

                    // Mechs and vehicles get charged,
                    // but need to make a to-hit roll
                    if ((target instanceof Mech) || (target instanceof Tank)
                        || (target instanceof Aero)) {
                        ChargeAttackAction caa = new ChargeAttackAction(
                                entity.getId(), target.getTargetType(),
                                target.getTargetId(), target.getPosition());
                        ToHitData toHit = caa.toHit(game, true);

                        // roll
                        int roll = Compute.d6(2);
                        // Update report.
                        r = new Report(2050);
                        r.subject = entity.getId();
                        r.indent();
                        r.add(target.getShortName(), true);
                        r.add(nextPos.getBoardNum(), true);
                        r.newlines = 0;
                        addReport(r);
                        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
                            roll = -12;
                            r = new Report(2055);
                            r.subject = entity.getId();
                            r.add(toHit.getDesc());
                            r.newlines = 0;
                            addReport(r);
                        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
                            r = new Report(2060);
                            r.subject = entity.getId();
                            r.add(toHit.getDesc());
                            r.newlines = 0;
                            addReport(r);
                            roll = Integer.MAX_VALUE;
                        } else {
                            // report the roll
                            r = new Report(2065);
                            r.subject = entity.getId();
                            r.add(toHit.getValue());
                            r.add(roll);
                            r.newlines = 0;
                            addReport(r);
                        }

                        // Resolve a charge against the target.
                        // ASSUMPTION: buildings block damage for
                        // *EACH* entity charged.
                        if (roll < toHit.getValue()) {
                            r = new Report(2070);
                            r.subject = entity.getId();
                            addReport(r);
                        } else {
                            // Resolve the charge.
                            resolveChargeDamage(entity, target, toHit,
                                                direction);
                            // HACK: set the entity's location
                            // to the original hex again, for the other targets
                            if (targets.hasNext()) {
                                entity.setPosition(curPos);
                            }
                            bldgSuffered = true;
                            skidChargeHit = true;
                            // The skid ends here if the target lives.
                            if (!target.isDoomed() && !target.isDestroyed()
                                && !game.isOutOfGame(target)) {
                                stopTheSkid = true;
                            }
                        }

                        // if we don't do this here,
                        // we can have a mech without a leg
                        // standing on the field and moving
                        // as if it still had his leg after
                        // getting skid-charged.
                        if (!target.isDone()) {
                            addReport(resolvePilotingRolls(target));
                            game.resetPSRs(target);
                            target.applyDamage();
                            addNewLines();
                        }

                    }

                    // Resolve "move-through" damage on infantry.
                    // Infantry inside of a building don't get a
                    // move-through, but suffer "bleed through"
                    // from the building.
                    else if ((target instanceof Infantry) && (bldg != null)) {
                        // Update report.
                        r = new Report(2075);
                        r.subject = entity.getId();
                        r.indent();
                        r.add(target.getShortName(), true);
                        r.add(nextPos.getBoardNum(), true);
                        r.newlines = 0;
                        addReport(r);

                        // Infantry don't have different
                        // tables for punches and kicks
                        HitData hit = target.rollHitLocation(
                                ToHitData.HIT_NORMAL,
                                Compute.targetSideTable(entity, target));
                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                        // Damage equals tonnage, divided by 5.
                        // ASSUMPTION: damage is applied in one hit.
                        addReport(damageEntity(target, hit,
                                               Math.round(entity.getWeight() / 5)));
                        addNewLines();
                    }

                    // Has the target been destroyed?
                    if (target.isDoomed()) {

                        // Has the target taken a turn?
                        if (!target.isDone()) {

                            // Dead entities don't take turns.
                            game.removeTurnFor(target);
                            send(createTurnVectorPacket());

                        } // End target-still-to-move

                        // Clean out the entity.
                        target.setDestroyed(true);
                        game.moveToGraveyard(target.getId());
                        send(createRemoveEntityPacket(target.getId()));
                    }

                    // Update the target's position,
                    // unless it is off the game map.
                    if (!game.isOutOfGame(target)) {
                        entityUpdate(target.getId());
                    }

                } // Check the next entity in the hex.

                if (skidChargeHit) {
                    // HACK: set the entities position to that
                    // hex's coords, because we had to move the entity
                    // back earlier for the other targets
                    entity.setPosition(nextPos);
                }
                for (Entity e : avoidedChargeUnits) {
                    GameTurn newTurn = new GameTurn.SpecificEntityTurn(e
                            .getOwner().getId(), e.getId());
                    // Prevents adding extra turns for multi-turns
                    newTurn.setMultiTurn(true);
                    game.insertNextTurn(newTurn);
                    send(createTurnVectorPacket());
                }
            }

            // Handle the building in the hex.
            if (bldg != null) {

                // Report that the entity has entered the bldg.
                r = new Report(2080);
                r.subject = entity.getId();
                r.indent();
                r.add(bldg.getName());
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                // If the building hasn't already suffered
                // damage, then apply charge damage to the
                // building and displace the entity inside.
                // ASSUMPTION: you don't charge the building
                // if Tanks or Mechs were charged.
                int chargeDamage = ChargeAttackAction.getDamageFor(entity, game
                        .getOptions().booleanOption("tacops_charge_damage"),
                        entity.delta_distance);
                if (!bldgSuffered) {
                    Vector<Report> reports = damageBuilding(bldg, chargeDamage,
                                                            nextPos);
                    for (Report report : reports) {
                        report.subject = entity.getId();
                    }
                    addReport(reports);

                    // Apply damage to the attacker.
                    int toAttacker = ChargeAttackAction.getDamageTakenBy(
                            entity, bldg, nextPos);
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         entity.sideTable(nextPos));
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    addReport(damageEntity(entity, hit, toAttacker));
                    addNewLines();

                    entity.setPosition(nextPos);
                    entity.setElevation(nextElevation);
                    addReport(doEntityDisplacementMinefieldCheck(entity,
                                                                 curPos, nextPos, nextElevation));
                    curPos = nextPos;
                } // End buildings-suffer-too

                // Any infantry in the building take damage
                // equal to the building being charged.
                // ASSUMPTION: infantry take no damage from the
                // building absorbing damage from
                // Tanks and Mechs being charged.
                addReport(damageInfantryIn(bldg, chargeDamage, nextPos));

                // If a building still stands, then end the skid,
                // and add it to the list of affected buildings.
                if (bldg.getCurrentCF(nextPos) > 0) {
                    stopTheSkid = true;
                    if (bldg.rollBasement(nextPos, game.getBoard(),
                                          vPhaseReport)) {
                        sendChangedHex(nextPos);
                        Vector<Building> buildings = new Vector<Building>();
                        buildings.add(bldg);
                        sendChangedBuildings(buildings);
                    }
                    addAffectedBldg(
                            bldg,
                            checkBuildingCollapseWhileMoving(bldg, entity,
                                                             nextPos));
                } else {
                    // otherwise it collapses immediately on our head
                    checkForCollapse(bldg, game.getPositionMap(), nextPos,
                                     true, vPhaseReport);
                }

            } // End handle-building.

            // Do we stay in the current hex and stop skidding?
            if (stopTheSkid) {
                break;
            }

            // Update entity position and elevation
            entity.setPosition(nextPos);
            entity.setElevation(nextElevation);
            addReport(doEntityDisplacementMinefieldCheck(entity, curPos,
                                                         nextPos, nextElevation));
            skidDistance++;

            // Check for collapse of any building the entity might be on
            Building roof = game.getBoard().getBuildingAt(nextPos);
            if (roof != null) {
                if (checkForCollapse(roof, game.getPositionMap(), nextPos,
                                     true, vPhaseReport)) {
                    break; // stop skidding if the building collapsed
                }
            }

            // Can the skiding entity enter the next hex from this?
            // N.B. can skid along roads.
            if ((entity.isLocationProhibited(start) || entity
                    .isLocationProhibited(nextPos))
                    && !Compute.canMoveOnPavement(game, curPos, nextPos, step)) {
                // Update report.
                r = new Report(2040);
                r.subject = entity.getId();
                r.indent();
                r.add(nextPos.getBoardNum(), true);
                addReport(r);

                // If the prohibited terrain is water, entity is destroyed
                if ((nextHex.terrainLevel(Terrains.WATER) > 0)
                        && (entity instanceof Tank)
                        && (entity.getMovementMode() != EntityMovementMode.HOVER)
                        && (entity.getMovementMode() != EntityMovementMode.WIGE)) {
                    addReport(destroyEntity(entity,
                            "skidded into a watery grave", false, true));
                }

                // otherwise, damage is weight/5 in 5pt clusters
                int damage = ((int) entity.getWeight() + 4) / 5;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(
                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
                            Math.min(5, damage)));
                    damage -= 5;
                }
                // and unit is immobile
                if (entity instanceof Tank) {
                    ((Tank) entity).immobilize();
                }

                // Stay in the current hex and stop skidding.
                break;
            }

            if ((nextHex.terrainLevel(Terrains.WATER) > 0)
                && (entity.getMovementMode() != EntityMovementMode.HOVER)
                && (entity.getMovementMode() != EntityMovementMode.WIGE)) {
                // water ends the skid
                break;
            }

            // check for breaking magma crust
            if ((nextHex.terrainLevel(Terrains.MAGMA) == 1)
                && (nextElevation == 0)) {
                int roll = Compute.d6(1);
                r = new Report(2395);
                r.addDesc(entity);
                r.add(roll);
                r.subject = entity.getId();
                addReport(r);
                if (roll == 6) {
                    nextHex.removeTerrain(Terrains.MAGMA);
                    nextHex.addTerrain(Terrains.getTerrainFactory()
                                               .createTerrain(Terrains.MAGMA, 2));
                    sendChangedHex(curPos);
                    for (Entity en : game.getEntitiesVector(curPos)) {
                        if (en != entity) {
                            doMagmaDamage(en, false);
                        }
                    }
                }
            }

            // check for entering liquid magma
            if ((nextHex.terrainLevel(Terrains.MAGMA) == 2)
                && (nextElevation == 0)) {
                doMagmaDamage(entity, false);
            }

            // is the next hex a swamp?
            PilotingRollData rollTarget = entity.checkBogDown(
                    step,
                    moveType,
                    nextHex,
                    curPos,
                    nextPos,
                    step.getElevation(),
                    Compute.canMoveOnPavement(game, curPos, nextPos, step));
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Taharqa: According to TacOps, you automatically stick if you
                // are skidding, (pg. 63)
                // if (0 < doSkillCheckWhileMoving(entity, curPos, nextPos,
                // rollTarget, false)) {
                entity.setStuck(true);
                r = new Report(2081);
                r.subject = entity.getId();
                r.add(entity.getDisplayName(), true);
                addReport(r);
                // check for quicksand
                addReport(checkQuickSand(nextPos));
                // check for accidental stacking violation
                Entity violation = Compute.stackingViolation(game,
                        entity.getId(), curPos);
                if (violation != null) {
                    // target gets displaced, because of low elevation
                    Coords targetDest = Compute.getValidDisplacement(game,
                                                                     entity.getId(), curPos, direction);
                    addReport(doEntityDisplacement(violation, curPos,
                                                   targetDest, new PilotingRollData(violation.getId(),
                                                                                    0, "domino effect")));
                    // Update the violating entity's postion on the client.
                    entityUpdate(violation.getId());
                }
                // stay here and stop skidding, see bug 1115608
                break;
                // }
            }

            // Update the position and keep skidding.
            curPos = nextPos;
            curHex = nextHex;
            r = new Report(2085);
            r.subject = entity.getId();
            r.indent();
            r.add(curPos.getBoardNum(), true);
            addReport(r);

        } // Handle the next skid hex.

        // If the skidding entity violates stacking,
        // displace targets until it doesn't.
        curPos = entity.getPosition();
        Entity target = Compute.stackingViolation(game, entity.getId(), curPos);
        while (target != null) {
            nextPos = Compute.getValidDisplacement(game, target.getId(),
                                                   target.getPosition(), direction);
            // ASSUMPTION
            // There should always be *somewhere* that
            // the target can go... last skid hex if
            // nothing else is available.
            if (null == nextPos) {
                // But I don't trust the assumption fully.
                // Report the error and try to continue.
                System.err.println("The skid of " + entity.getShortName()
                                   + " should displace " + target.getShortName()
                                   + " in hex " + curPos.getBoardNum()
                                   + " but there is nowhere to go.");
                break;
            }
            // indent displacement
            r = new Report(1210, Report.PUBLIC);
            r.indent();
            r.newlines = 0;
            addReport(r);
            addReport(doEntityDisplacement(target, curPos, nextPos, null));
            addReport(doEntityDisplacementMinefieldCheck(entity, curPos,
                                                         nextPos, entity.getElevation()));
            target = Compute.stackingViolation(game, entity.getId(), curPos);
        }

        // Mechs suffer damage for every hex skidded.
        if (entity instanceof Mech) {
            // Calculate one half falling damage times skid length.
            int damage = skidDistance
                         * (int) Math
                    .ceil(Math.round(entity.getWeight() / 10.0) / 2.0);

            // report skid damage
            r = new Report(2090);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(damage);
            addReport(r);

            // standard damage loop
            // All skid damage is to the front.
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                addReport(damageEntity(entity, hit, cluster));
                damage -= cluster;
            }
            addNewLines();
        }

        // Clean up the entity if it has been destroyed.
        if (entity.isDoomed()) {
            entity.setDestroyed(true);
            game.moveToGraveyard(entity.getId());
            send(createRemoveEntityPacket(entity.getId()));

            // The entity's movement is completed.
            return true;
        }

        // Let the player know the ordeal is over.
        r = new Report(2095);
        r.subject = entity.getId();
        r.indent();
        addReport(r);

        return false;
    }

    /**
     * processes a potential collision
     *
     * @param entity
     * @param target
     * @param src
     * @return
     */
    private boolean processCollision(Entity entity, Entity target, Coords src) {
        Report r;

        r = new Report(9035);
        r.subject = entity.getId();
        r.add(entity.getDisplayName());
        r.add(target.getDisplayName());
        addReport(r);
        int partialroll = Compute.d6(1);
        boolean partial = (partialroll == 6);
        // if aero chance to avoid
        if ((target instanceof Aero)
            && (target.mpUsed < target.getRunMPwithoutMASC())
            && !((Aero) target).isOutControlTotal() && !target.isImmobile()) {
            // give them a control roll to avoid the collision
            // TODO: I should make this voluntary really
            Aero ta = (Aero) target;
            PilotingRollData psr = target.getBasePilotingRoll();
            psr.addModifier(0, "avoiding collision");
            int ctrlroll = Compute.d6(2);
            r = new Report(9045);
            r.subject = target.getId();
            r.add(target.getDisplayName());
            r.add(psr.getValue());
            r.add(ctrlroll);
            r.newlines = 0;
            r.indent(2);
            if (ctrlroll < psr.getValue()) {
                r.choose(false);
                addReport(r);
            } else {
                // avoided collision
                r.choose(true);
                addReport(r);
                // two possibilities:
                // 1) the target already moved, but had MP left - check for
                // control roll conditions
                // 2) the target had not yet moved, move them in straight line
                if (!target.isDone()) {
                    int vel = ta.getCurrentVelocity();
                    MovePath md = new MovePath(game, target);
                    while (vel > 0) {
                        md.addStep(MoveStepType.FORWARDS);
                        vel--;
                    }
                    game.removeTurnFor(target);
                    send(createTurnVectorPacket());
                    processMovement(target, md, null);
                    // for some reason it is not clearing out turn
                } else {
                    // what needs to get checked?
                    // this move puts them at over-thrust
                    target.moved = EntityMovementType.MOVE_OVER_THRUST;
                    // they may have exceeded SI, only add if they hadn't
                    // exceeded it before
                    if (target.mpUsed <= ta.getSI()) {
                        PilotingRollData rollTarget = ta.checkThrustSITotal(
                                target.getRunMPwithoutMASC(), ta.moved);
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                            game.addControlRoll(new PilotingRollData(
                                    ta.getId(), 0,
                                    "Thrust spent during turn exceeds SI"));
                        }
                    }
                    target.mpUsed = target.getRunMPwithoutMASC();
                }
                return false;
            }
        } else {
            // can't avoid collision - write report
            r = new Report(9040);
            r.subject = entity.getId();
            r.add(entity.getDisplayName());
            r.indent(2);
            addReport(r);
        }

        // if we are still here, then collide
        ToHitData toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS,
                                        "Its a collision");
        toHit.setSideTable(target.sideTable(src));
        resolveRamDamage((Aero) entity, target, toHit, partial, false);

        // Has the target been destroyed?
        if (target.isDoomed()) {
            // Has the target taken a turn?
            if (!target.isDone()) {
                // Dead entities don't take turns.
                game.removeTurnFor(target);
                send(createTurnVectorPacket());
            } // End target-still-to-move
            // Clean out the entity.
            target.setDestroyed(true);
            game.moveToGraveyard(target.getId());
            send(createRemoveEntityPacket(target.getId()));
        }
        // Update the target's position,
        // unless it is off the game map.
        if (!game.isOutOfGame(target)) {
            entityUpdate(target.getId());
        }

        return true;

    }

    private boolean checkCrash(Entity entity, Coords pos, int altitude) {

        // only Aeros can crash
        if (!(entity instanceof Aero)) {
            return false;
        }
        // no crashing in space
        if (game.getBoard().inSpace()) {
            return false;
        }
        // if aero on the ground map, then only crash if elevation is zero
        else if (game.getBoard().onGround()) {
            if (altitude <= 0) {
                return true;
            }
            return false;
        }
        // we must be in atmosphere
        // if we're off the map, assume hex ceiling 0
        int ceiling = 0;
        if (game.getBoard().getHex(pos) != null) {
            ceiling = game.getBoard().getHex(pos).ceiling(true);
        }
        return ceiling >= altitude;
    }

    private Vector<Report> processCrash(Entity entity, int vel, Coords c) {
        Vector<Report> vReport = new Vector<Report>();
        Report r;
        if (c == null) {
            r = new Report(9701);
            r.subject = entity.getId();
            vReport.add(r);
            vReport.addAll(destroyEntity(entity, "crashed off the map", true,
                                         true));
            return vReport;
        }

        if (game.getBoard().inAtmosphere()) {
            r = new Report(9393, Report.PUBLIC);
            r.indent();
            r.addDesc(entity);
            vReport.add(r);
            entity.setDoomed(true);
        } else {
            ((Aero) entity).land();
        }

        // we might hit multiple hexes, if we're a dropship, so we do some
        // checks for all of them
        ArrayList<Coords> coords = new ArrayList<Coords>();
        coords.add(c);
        IHex h = game.getBoard().getHex(c);
        int crateredElevation;
        boolean containsWater = false;
        if (h.containsTerrain(Terrains.WATER)) {
            crateredElevation = Math.min(2, h.depth() + 1);
            containsWater = true;
        } else {
            crateredElevation = h.getLevel() - 2;
        }
        if (entity instanceof Dropship) {
            for (int i = 0; i < 6; i++) {
                Coords adjCoords = c.translated(i);
                if (!game.getBoard().contains(c)) {
                    continue;
                }
                IHex adjHex = game.getBoard().getHex(adjCoords);
                coords.add(adjCoords);
                if (adjHex.containsTerrain(Terrains.WATER)) {
                    if (containsWater) {
                        int newDepth = Math.min(2, adjHex.depth() + 1);
                        if (newDepth > crateredElevation) {
                            crateredElevation = newDepth;
                        }
                    } else {
                        crateredElevation = Math.min(2, adjHex.depth() + 1);
                        containsWater = true;
                    }
                } else if (!containsWater
                           && (adjHex.getLevel() < crateredElevation)) {
                    crateredElevation = adjHex.getLevel();
                }
            }
        }
        if (vel < 1) {
            vel = 1;
        }

        // deal crash damage only once
        boolean damageDealt = false;
        for (Coords hitCoords : coords) {
            int orig_crash_damage = Compute.d6(2) * 10 * vel;
            int crash_damage = orig_crash_damage;
            int direction = entity.getFacing();
            // first check for buildings
            Building bldg = game.getBoard().getBuildingAt(hitCoords);
            if ((null != bldg) && (bldg.getType() == Building.HARDENED)) {
                crash_damage *= 2;
            }
            if (null != bldg) {
                collapseBuilding(bldg, game.getPositionMap(), hitCoords, true,
                                 vReport);
            }
            if (!damageDealt) {
                r = new Report(9700, Report.PUBLIC);
                r.indent();
                r.addDesc(entity);
                r.add(crash_damage);
                vReport.add(r);
                while (crash_damage > 0) {
                    HitData hit;
                    if ((entity instanceof SmallCraft)
                        && ((SmallCraft) entity).isSpheroid()) {
                        hit = entity.rollHitLocation(
                                ToHitData.HIT_SPHEROID_CRASH,
                                ToHitData.SIDE_REAR);
                    } else {
                        hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                    }

                    if (crash_damage > 10) {
                        vReport.addAll(damageEntity(entity, hit, 10));
                    } else {
                        vReport.addAll(damageEntity(entity, hit, crash_damage));
                    }
                    crash_damage -= 10;
                }
                damageDealt = true;
            }

            // ok, now lets cycle through the entities in this spot and
            // potentially
            // damage them
            for (Entity victim : game.getEntitiesVector(hitCoords)) {
                if (victim.getId() == entity.getId()) {
                    continue;
                }
                if (((victim.getElevation() > 0) && victim
                        .isAirborneVTOLorWIGE()) || (victim.getAltitude() > 0)) {
                    continue;
                }
                // if the crasher is a dropship and the victim is not a mech,
                // then
                // it is automatically
                // destroyed
                if ((entity instanceof Dropship) && !(victim instanceof Mech)) {
                    vReport.addAll(destroyEntity(victim,
                                                 "hit by crashing dropship"));
                } else {
                    crash_damage = orig_crash_damage / 2;
                    // roll dice to see if they got hit
                    int target = 2;
                    if (victim instanceof Infantry) {
                        target = 3;
                    }
                    int roll = Compute.d6();
                    r = new Report(9705, Report.PUBLIC);
                    r.indent();
                    r.addDesc(victim);
                    r.add(target);
                    r.add(crash_damage);
                    r.add(roll);
                    if (roll > target) {
                        r.choose(true);
                        vReport.add(r);
                        // apply half the crash damage in 5 point clusters
                        // (check
                        // hit tables)
                        while (crash_damage > 0) {
                            HitData hit = victim.rollHitLocation(
                                    ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                            if (victim instanceof Mech) {
                                hit = victim.rollHitLocation(
                                        ToHitData.HIT_PUNCH,
                                        ToHitData.SIDE_FRONT);
                            }
                            if (victim instanceof Protomech) {
                                hit = victim.rollHitLocation(
                                        ToHitData.HIT_SPECIAL_PROTO,
                                        ToHitData.SIDE_FRONT);
                            }
                            if (crash_damage > 5) {
                                vReport.addAll(damageEntity(victim, hit, 5));
                            } else {
                                vReport.addAll(damageEntity(victim, hit,
                                                            crash_damage));
                            }
                            crash_damage -= 5;
                        }

                    } else {
                        r.choose(false);
                        vReport.add(r);
                    }
                }

                if (!victim.isDoomed() && !victim.isDestroyed()) {
                    // entity displacement
                    Coords dest = Compute.getValidDisplacement(game,
                                                               victim.getId(), hitCoords, direction);
                    if (null != dest) {
                        doEntityDisplacement(
                                victim,
                                hitCoords,
                                dest,
                                new PilotingRollData(victim.getId(), 0, "crash"));
                    } else if (!(victim instanceof Dropship)) {
                        // destroy entity - but not dropships which are
                        // immovable
                        addReport(destroyEntity(victim,
                                                "impossible displacement",
                                                victim instanceof Mech, victim instanceof Mech));
                    }
                }

            }

            // reduce woods
            h = game.getBoard().getHex(hitCoords);
            if (h.containsTerrain(Terrains.WOODS)) {
                if (entity instanceof Dropship) {
                    h.removeTerrain(Terrains.WOODS);
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                            Terrains.ROUGH, 1));
                } else {
                    int level = h.terrainLevel(Terrains.WOODS) - 1;
                    if (level > 0) {
                        h.removeTerrain(Terrains.WOODS);
                        h.addTerrain(Terrains.getTerrainFactory()
                                             .createTerrain(Terrains.WOODS, level));
                    } else {
                        h.removeTerrain(Terrains.WOODS);
                        h.addTerrain(Terrains.getTerrainFactory()
                                             .createTerrain(Terrains.ROUGH, 1));
                    }
                }
            }
            // do the same for jungles
            if (h.containsTerrain(Terrains.JUNGLE)) {
                if (entity instanceof Dropship) {
                    h.removeTerrain(Terrains.JUNGLE);
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                            Terrains.ROUGH, 1));
                } else {
                    int level = h.terrainLevel(Terrains.JUNGLE) - 1;
                    if (level > 0) {
                        h.removeTerrain(Terrains.JUNGLE);
                        h.addTerrain(Terrains.getTerrainFactory()
                                             .createTerrain(Terrains.JUNGLE, level));
                    } else {
                        h.removeTerrain(Terrains.JUNGLE);
                        h.addTerrain(Terrains.getTerrainFactory()
                                             .createTerrain(Terrains.ROUGH, 1));
                    }
                }
            }
            if (entity instanceof Dropship) {
                if (!containsWater) {
                    h.setLevel(crateredElevation);
                } else {
                    if (!h.containsTerrain(Terrains.WATER)) {
                        h.removeAllTerrains();
                    }
                    h.addTerrain(new Terrain(Terrains.WATER, crateredElevation,
                                             false, 0));
                }
            }
            sendChangedHex(hitCoords);
        }

        // check for a stacking violation - which should only happen in the
        // case of
        // grounded dropships, because they are not moveable
        if (null != Compute.stackingViolation(game, entity.getId(), c)) {
            Coords dest = Compute.getValidDisplacement(game, entity.getId(), c,
                                                       Compute.d6() - 1);
            if (null != dest) {
                doEntityDisplacement(entity, c, dest, null);
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                vPhaseReport.addAll(destroyEntity(entity,
                                                  "impossible displacement", entity instanceof Mech,
                                                  entity instanceof Mech));
            }
        }

        // Check for watery death
        h = game.getBoard().getHex(c);
        if (h.containsTerrain(Terrains.WATER) && !entity.isDestroyed()
            && !entity.isDoomed()) {
            int lethalDepth;
            if (entity instanceof Dropship) {
                lethalDepth = 2;
            } else {
                lethalDepth = 1;
            }

            if (h.depth() >= lethalDepth) {
                // Oh snap... we is dead
                vReport.addAll(destroyEntity(entity,
                                             "crashing into deep water", true, true));
            }
        }

        return vReport;
    }

    /**
     * Process any flee movement actions, including flying off the map
     *
     * @param entity     the entity fleeing
     * @param flewOff    whether this fleeing is a result of accidently flying off the
     *                   map
     * @param returnable the number of rounds until the unit can return to the map (-1
     *                   if it can't return)
     * @return
     */
    private Vector<Report> processLeaveMap(Entity entity, int facing,
                                           boolean flewOff, int returnable) {
        Vector<Report> vReport = new Vector<Report>();
        Report r;
        // Unit has fled the battlefield.
        r = new Report(2005, Report.PUBLIC);
        if (flewOff) {
            r = new Report(9370, Report.PUBLIC);
        }
        r.addDesc(entity);
        addReport(r);
        OffBoardDirection fleeDirection;
        if (facing == 0) {
            fleeDirection = OffBoardDirection.NORTH;
        } else if (facing == 3) {
            fleeDirection = OffBoardDirection.SOUTH;
        } else if (facing > 3) {
            fleeDirection = OffBoardDirection.WEST;
        } else {
            fleeDirection = OffBoardDirection.EAST;
        }

        if (returnable > -1) {

            entity.setDeployed(false);
            entity.setDeployRound(1 + game.getRoundCount() + returnable);
            entity.setPosition(null);
            entity.setDone(true);
            if (entity instanceof Aero) {
                // If we're flying off because we're OOC, when we come back we
                // should no longer be OOC
                // If we don't, this causes a major problem as aeros tend to
                // return, re-deploy then
                // fly off again instantly.
                ((Aero) entity).setOutControl(false);
            }
            switch (fleeDirection) {
                case WEST:
                    entity.setStartingPos(Board.START_W);
                    break;
                case NORTH:
                    entity.setStartingPos(Board.START_N);
                    break;
                case EAST:
                    entity.setStartingPos(Board.START_E);
                    break;
                case SOUTH:
                    entity.setStartingPos(Board.START_S);
                    break;
                default:
                    entity.setStartingPos(Board.START_EDGE);
            }
            entityUpdate(entity.getId());
            return vReport;
        }

        // Is the unit carrying passengers?
        final List<Entity> passengers = entity.getLoadedUnits();
        if (!passengers.isEmpty()) {
            for (Entity passenger : passengers) {
                // Unit has fled the battlefield.
                r = new Report(2010, Report.PUBLIC);
                r.indent();
                r.addDesc(passenger);
                addReport(r);
                passenger.setRetreatedDirection(fleeDirection);
                game.removeEntity(passenger.getId(),
                                  IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(passenger.getId(),
                                              IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        }

        // Handle any picked up MechWarriors
        for (Integer mechWarriorId : entity.getPickedUpMechWarriors()) {
            Entity mw = game.getEntity(mechWarriorId.intValue());

            // Is the MechWarrior an enemy?
            int condition = IEntityRemovalConditions.REMOVE_IN_RETREAT;
            r = new Report(2010);
            if (mw.isCaptured()) {
                r = new Report(2015);
                condition = IEntityRemovalConditions.REMOVE_CAPTURED;
            } else {
                mw.setRetreatedDirection(fleeDirection);
            }
            game.removeEntity(mw.getId(), condition);
            send(createRemoveEntityPacket(mw.getId(), condition));
            r.addDesc(mw);
            r.indent();
            addReport(r);
        }
        // Is the unit being swarmed?
        final int swarmerId = entity.getSwarmAttackerId();
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);

            // Has the swarmer taken a turn?
            if (!swarmer.isDone()) {

                // Dead entities don't take turns.
                game.removeTurnFor(swarmer);
                send(createTurnVectorPacket());

            } // End swarmer-still-to-move

            // Unit has fled the battlefield.
            swarmer.setSwarmTargetId(Entity.NONE);
            entity.setSwarmAttackerId(Entity.NONE);
            r = new Report(2015, Report.PUBLIC);
            r.indent();
            r.addDesc(swarmer);
            addReport(r);
            game.removeEntity(swarmerId,
                              IEntityRemovalConditions.REMOVE_CAPTURED);
            send(createRemoveEntityPacket(swarmerId,
                                          IEntityRemovalConditions.REMOVE_CAPTURED));
        }
        entity.setRetreatedDirection(fleeDirection);
        game.removeEntity(entity.getId(),
                          IEntityRemovalConditions.REMOVE_IN_RETREAT);
        send(createRemoveEntityPacket(entity.getId(),
                                      IEntityRemovalConditions.REMOVE_IN_RETREAT));
        return vReport;
    }

    /**
     * Steps through an entity movement packet, executing it.
     *
     * @param entity   The Entity that is moving
     * @param md       The MovePath that defines how the Entity moves
     * @param losCache A cache that stores Los between various Entities and
     *                 targets.  In doubleblind games, we may need to compute a
     *                 lot of LosEffects, so caching them can really speed
     *                 things up.
     */
    private void processMovement(Entity entity, MovePath md,
            Map<EntityTargetPair, LosEffects> losCache) {
        // Make sure the cache isn't null
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        Report r;
        boolean sideslipped = false; // for VTOL sideslipping
        PilotingRollData rollTarget;

        // check for fleeing
        if (md.contains(MoveStepType.FLEE)) {
            addReport(processLeaveMap(entity, entity.getFacing(), false, -1));
            return;
        }

        if (md.contains(MoveStepType.EJECT)) {
            if ((entity instanceof Mech) || (entity instanceof Aero)) {
                r = new Report(2020);
                r.subject = entity.getId();
                r.add(entity.getCrew().getName());
                r.addDesc(entity);
                addReport(r);
            } else if ((entity instanceof Tank) && !entity.isCarcass()) {
                r = new Report(2025);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
            }
            addReport(ejectEntity(entity, false));

            return;
        }

        if (md.contains(MoveStepType.CAREFUL_STAND)) {
            entity.setCarefulStand(true);
        }
        if (md.contains(MoveStepType.BACKWARDS)) {
            entity.setMovedBackwards(true);
            if (md.getMpUsed() > entity.getWalkMP()) {
                entity.setPowerReverse(true);
            }
        }



        if (md.contains(MoveStepType.TAKEOFF) && (entity instanceof Aero)) {
            Aero a = (Aero) entity;
            a.setCurrentVelocity(1);
            a.liftOff(1);
            if (entity instanceof Dropship) {
                applyDropshipProximityDamage(md.getFinalCoords(), true,
                                             md.getFinalFacing(), entity);
            }
            checkForTakeoffDamage(a);
            a.setPosition(a.getPosition().translated(a.getFacing(),
                                                     a.getTakeOffLength()));
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MoveStepType.VTAKEOFF) && (entity instanceof Aero)) {
            Aero a = (Aero) entity;
            rollTarget = a.checkVerticalTakeOff();
            if (doVerticalTakeOffCheck(entity, rollTarget)) {
                a.setCurrentVelocity(0);
                a.liftOff(1);
                if (entity instanceof Dropship) {
                    applyDropshipProximityDamage(md.getFinalCoords(), a);
                }
                checkForTakeoffDamage(a);
            }
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MoveStepType.LAND) && (entity instanceof Aero)) {
            Aero a = (Aero) entity;
            rollTarget = a.checkLanding(md.getLastStepMovementType(),
                    md.getFinalVelocity(), md.getFinalCoords(),
                    md.getFinalFacing(), false);
            doAttemptLanding(entity, rollTarget);
            a.land();
            entity.setPosition(md.getFinalCoords().translated(
                    md.getFinalFacing(), a.getLandingLength()));
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        if (md.contains(MoveStepType.VLAND) && (entity instanceof Aero)) {
            Aero a = (Aero) entity;
            rollTarget = a.checkLanding(md.getLastStepMovementType(),
                    md.getFinalVelocity(), md.getFinalCoords(),
                    md.getFinalFacing(), true);
            doAttemptLanding(entity, rollTarget);
            if (entity instanceof Dropship) {
                applyDropshipLandingDamage(md.getFinalCoords(), a);
            }
            a.land();
            entity.setPosition(md.getFinalCoords());
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        // okay, proceed with movement calculations
        Coords lastPos = entity.getPosition();
        Coords curPos = entity.getPosition();
        int curFacing = entity.getFacing();
        int curVTOLElevation = entity.getElevation();
        int curElevation = entity.getElevation();
        int lastElevation = entity.getElevation();
        int curAltitude = entity.getAltitude();
        // if the entity already used some MPs,
        // it previously tried to get up and fell,
        // and then got another turn. set moveType
        // and overallMoveType accordingly
        // (these are all cleared by Entity.newRound)
        int distance = entity.delta_distance;
        int mpUsed = entity.mpUsed;
        EntityMovementType moveType = entity.moved;
        EntityMovementType overallMoveType = entity.moved;
        boolean firstStep;
        boolean wasProne = entity.isProne();
        boolean fellDuringMovement = false;
        boolean crashedDuringMovement = false;
        boolean dropshipStillUnloading = false;
        boolean turnOver;
        boolean wigeStartedLanded = false;
        int prevFacing = curFacing;
        IHex prevHex = null;
        final boolean isInfantry = entity instanceof Infantry;
        AttackAction charge = null;
        RamAttackAction ram = null;
        // cache this here, otherwise changing MP in the turn causes
        // errorneous gravity PSRs
        int cachedGravityLimit = -1;
        int thrustUsed = 0;
        int j = 0;
        boolean didMove = false;
        boolean recovered = false;
        Entity loader = null;

        // get a list of coordinates that the unit passed through this turn
        // so that I can later recover potential bombing targets
        // it may already have some values
        Vector<Coords> passedThrough = entity.getPassedThrough();
        passedThrough.add(curPos);
        List<Integer> passedThroughFacing = entity.getPassedThroughFacing();
        passedThroughFacing.add(curFacing);

        // Compile the move
        md.compile(game, entity);

        // if advanced movement is being used then set the new vectors based on
        // movepath
        entity.setVectors(md.getFinalVectors());

        overallMoveType = md.getLastStepMovementType();

        // check for starting in liquid magma
        if ((game.getBoard().getHex(entity.getPosition())
                 .terrainLevel(Terrains.MAGMA) == 2)
            && (entity.getElevation() == 0)) {
            doMagmaDamage(entity, false);
        }

        // set acceleration used to default
        if (entity instanceof Aero) {
            Aero a = (Aero) entity;
            a.setAccLast(false);
        }

        // check for dropping troops and drop them
        if (entity.isDropping()) {
            entity.setAltitude(entity.getAltitude()
                               - game.getPlanetaryConditions().getDropRate());
            // they may have changed their facing
            if (md.length() > 0) {
                entity.setFacing(md.getFinalFacing());
            }
            passedThrough.add(entity.getPosition());
            entity.setPassedThrough(passedThrough);
            passedThroughFacing.add(entity.getFacing());
            entity.setPassedThroughFacing(passedThroughFacing);
            entity.setDone(true);
            entityUpdate(entity.getId());
            return;
        }

        // iterate through steps
        firstStep = true;
        turnOver = false;
        /* Bug 754610: Revert fix for bug 702735. */
        MoveStep prevStep = null;

        Vector<UnitLocation> movePath = new Vector<UnitLocation>();
        EntityMovementType lastStepMoveType = md.getLastStepMovementType();
        for (final Enumeration<MoveStep> i = md.getSteps(); i.hasMoreElements(); ) {
            final MoveStep step = i.nextElement();
            EntityMovementType stepMoveType = step.getMovementType(md
                    .isEndStep(step));
            wasProne = entity.isProne();
            boolean isPavementStep = step.isPavementStep();
            entity.inReverse = step.isThisStepBackwards();
            boolean entityFellWhileAttemptingToStand = false;
            boolean isOnGround = !i.hasMoreElements();
            isOnGround |= stepMoveType != EntityMovementType.MOVE_JUMP;
            isOnGround &= step.getElevation() < 1;

            // stop for illegal movement
            if (stepMoveType == EntityMovementType.MOVE_ILLEGAL) {
                break;
            }

            // stop if the entity already killed itself
            if (entity.isDestroyed() || entity.isDoomed()) {
                break;
            }

            if (firstStep
                && (entity.getMovementMode() == EntityMovementMode.WIGE)
                && (entity.getElevation() == 0)) {
                wigeStartedLanded = true;
            }

            // check for MASC failure on first step
            // also check Tanks because they can have superchargers that act
            // like MASc
            if (firstStep
                && ((entity instanceof Mech) || (entity instanceof Tank))) {
                HashMap<Integer, List<CriticalSlot>> crits = new HashMap<Integer, List<CriticalSlot>>();
                Vector<Report> vReport = new Vector<Report>();
                if (entity.checkForMASCFailure(md, vReport, crits)) {
                    boolean mascFailure = true;
                    // Check to see if the pilot can reroll due to Edge
                    if (entity.getCrew().hasEdgeRemaining()
                        && entity.getCrew().getOptions()
                                 .booleanOption("edge_when_masc_fails")) {
                        entity.getCrew().decreaseEdge();
                        // Need to reset the MASCUsed flag
                        entity.setMASCUsed(false);
                        // Report to notify user that masc check was rerolled
                        Report masc_report = new Report(6501);
                        masc_report.subject = entity.getId();
                        masc_report.indent(2);
                        masc_report.addDesc(entity);
                        vReport.add(masc_report);
                        // Report to notify user how much edge pilot has left
                        masc_report = new Report(6510);
                        masc_report.subject = entity.getId();
                        masc_report.indent(2);
                        masc_report.addDesc(entity);
                        masc_report.add(entity.getCrew().getOptions()
                                              .intOption("edge"));
                        vReport.addElement(masc_report);
                        // Recheck MASC failure
                        if (!entity.checkForMASCFailure(md, vReport, crits)) { // The
                            // reroll
                            // passed,
                            // don't
                            // process
                            // the
                            // failure
                            mascFailure = false;
                            addReport(vReport);
                        }
                    }
                    // Check for failure and process it
                    if (mascFailure) {
                        addReport(vReport);
                        for (Integer loc : crits.keySet()) {
                            List<CriticalSlot> lcs = crits.get(loc);
                            for (CriticalSlot cs : lcs) {
                                // HACK: if loc is -1, we need to deal motive
                                // damage
                                // to
                                // the tank, the severity of which is stored in
                                // the
                                // critslot index
                                if (loc == -1) {
                                    addReport(vehicleMotiveDamage(
                                            (Tank) entity, 0, true,
                                            cs.getIndex()));
                                } else {
                                    addReport(applyCriticalHit(entity, loc, cs,
                                                               true, 0, false));
                                }
                            }
                        }
                        // do any PSR immediately
                        addReport(resolvePilotingRolls(entity));
                        game.resetPSRs(entity);
                        // let the player replot their move as MP might be
                        // changed
                        md.clear();
                        fellDuringMovement = true; // so they get a new turn
                    }
                } else {
                    addReport(vReport);
                }
            }

            // did the entity move?
            didMove = step.getDistance() > distance;

            // check for aero stuff
            if (entity.isAirborne() && (entity instanceof Aero)) {
                Aero a = (Aero) entity;
                j++;

                // increment straight moves (can't do it at end, because not all
                // steps may be processed)
                a.setStraightMoves(step.getNStraight());

                // TODO: change the way this check is made
                if (!didMove && (md.length() != j)) {
                    thrustUsed += step.getMp();
                } else {
                    // if this was the last move and distance was zero, then add
                    // thrust
                    if (!didMove && (md.length() == j)) {
                        thrustUsed += step.getMp();
                    }
                    // then we moved to a new hex or the last step so check
                    // conditions
                    // structural damage
                    rollTarget = a.checkThrustSI(thrustUsed, overallMoveType);
                    if ((rollTarget.getValue() != TargetRoll.CHECK_FALSE)
                        && !(entity instanceof FighterSquadron)
                        && !game.useVectorMove()) {
                        if (!doSkillCheckInSpace(entity, rollTarget)) {
                            a.setSI(a.getSI() - 1);
                            // check for destruction
                            if (a.getSI() == 0) {
                                addReport(destroyEntity(entity,
                                        "Structural Integrity Collapse", false));
                            }
                        }
                    }

                    // check for pilot damage
                    int hits = entity.getCrew().getHits();
                    int health = 6 - hits;

                    if ((thrustUsed > (2 * health)) && !game.useVectorMove()
                        && !(entity instanceof TeleMissile)) {
                        int targetroll = 2 + (thrustUsed - (2 * health))
                                         + (2 * hits);
                        resistGForce(entity, targetroll);
                    }

                    thrustUsed = 0;
                }

                if (step.getType() == MoveStepType.RETURN) {
                    a.setCurrentVelocity(md.getFinalVelocity());
                    a.setAltitude(curAltitude);
                    processLeaveMap(entity, curFacing, true,
                                    Compute.roundsUntilReturn(game, entity));
                    return;
                }

                if (step.getType() == MoveStepType.OFF) {
                    a.setCurrentVelocity(md.getFinalVelocity());
                    a.setAltitude(curAltitude);
                    processLeaveMap(entity, curFacing, true, -1);
                    return;
                }

                rollTarget = a.checkRolls(step, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                             "excess roll"));
                }

                rollTarget = a.checkManeuver(step, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    if (!doSkillCheckManeuver(entity, rollTarget)) {
                        a.setFailedManeuver(true);
                        int forward = Math.max(step.getVelocityLeft() / 2, 1);
                        if (forward < step.getVelocityLeft()) {
                            fellDuringMovement = true;
                        }
                        // multiply forward by 16 when on ground hexes
                        if (game.getBoard().onGround()) {
                            forward *= 16;
                        }
                        while (forward > 0) {
                            curPos = curPos.translated(step.getFacing());
                            forward--;
                            distance++;
                            a.setStraightMoves(a.getStraightMoves() + 1);
                            // make sure it didn't fly off the map
                            if (!game.getBoard().contains(curPos)) {
                                a.setCurrentVelocity(md.getFinalVelocity());
                                processLeaveMap(entity, curFacing, true,
                                                Compute.roundsUntilReturn(game, entity));
                                return;
                                // make sure it didn't crash
                            } else if (checkCrash(entity, curPos,
                                                  step.getAltitude())) {
                                addReport(processCrash(entity,
                                                       step.getVelocity(), curPos));
                                forward = 0;
                                fellDuringMovement = false;
                                crashedDuringMovement = true;
                            }
                            lastPos = curPos;
                        }
                        break;
                    }
                }

                // if out of control, check for possible collision
                if (didMove && a.isOutControlTotal()) {
                    Iterator<Entity> targets = game.getEntities(step
                            .getPosition());
                    if (targets.hasNext()) {
                        // Somebody here so check to see if there is a collision
                        int checkroll = Compute.d6(2);
                        // TODO: change this to 11 for Large Craft
                        int targetroll = 11;
                        if ((a instanceof Dropship)
                            || (entity instanceof Jumpship)) {
                            targetroll = 10;
                        }
                        if (checkroll >= targetroll) {
                            // this gets complicated, I need to check for each
                            // unit type
                            // by order of movement subphase
                            Vector<Integer> potentialSpaceStation;
                            Vector<Integer> potentialWarship;
                            Vector<Integer> potentialJumpship;
                            Vector<Integer> potentialDropship;
                            Vector<Integer> potentialSmallCraft;
                            Vector<Integer> potentialASF;
                            potentialSpaceStation = new Vector<Integer>();
                            potentialWarship = new Vector<Integer>();
                            potentialJumpship = new Vector<Integer>();
                            potentialDropship = new Vector<Integer>();
                            potentialSmallCraft = new Vector<Integer>();
                            potentialASF = new Vector<Integer>();
                            while (targets.hasNext()) {
                                int id = targets.next().getId();
                                Entity ce = game.getEntity(id);
                                // if we are in atmo and not the same altitude
                                // then skip
                                if (!game.getBoard().inSpace()
                                    && (ce.getAltitude() != curAltitude)) {
                                    continue;
                                }
                                // you can't collide with yourself
                                if (ce.equals(a)) {
                                    continue;
                                }
                                if (ce instanceof SpaceStation) {
                                    potentialSpaceStation.addElement(id);
                                } else if (ce instanceof Warship) {
                                    potentialWarship.addElement(id);
                                } else if (ce instanceof Jumpship) {
                                    potentialJumpship.addElement(id);
                                } else if (ce instanceof Dropship) {
                                    potentialDropship.addElement(id);
                                } else if (ce instanceof SmallCraft) {
                                    potentialSmallCraft.addElement(id);
                                } else {
                                    // ASF can actually include anything,
                                    // because we might
                                    // have combat dropping troops
                                    potentialASF.addElement(id);
                                }
                            }

                            // ok now go through and see if these have anybody
                            // in them
                            if (potentialSpaceStation.size() > 0) {
                                int chosen = Compute
                                        .randomInt(potentialSpaceStation.size());
                                Entity target = game
                                        .getEntity(potentialSpaceStation
                                                           .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            } else if (potentialWarship.size() > 0) {
                                int chosen = Compute.randomInt(potentialWarship
                                                                       .size());
                                Entity target = game.getEntity(potentialWarship
                                                                       .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            } else if (potentialJumpship.size() > 0) {
                                int chosen = Compute
                                        .randomInt(potentialJumpship.size());
                                Entity target = game
                                        .getEntity(potentialJumpship
                                                           .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            } else if (potentialDropship.size() > 0) {
                                int chosen = Compute
                                        .randomInt(potentialDropship.size());
                                Entity target = game
                                        .getEntity(potentialDropship
                                                           .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            } else if (potentialSmallCraft.size() > 0) {
                                int chosen = Compute
                                        .randomInt(potentialSmallCraft.size());
                                Entity target = game
                                        .getEntity(potentialSmallCraft
                                                           .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            } else if (potentialASF.size() > 0) {
                                int chosen = Compute.randomInt(potentialASF
                                                                       .size());
                                Entity target = game.getEntity(potentialASF
                                                                       .elementAt(chosen));
                                Coords dest = target.getPosition();
                                if (processCollision(entity, target, lastPos)) {
                                    curPos = dest;
                                    break;
                                }
                            }

                        }
                    }
                }

                // if in the atmosphere, check for a potential crash

                if (checkCrash(entity, step.getPosition(), step.getAltitude())) {
                    addReport(processCrash(entity, md.getFinalVelocity(),
                                           curPos));
                    crashedDuringMovement = true;
                    // don't do the rest
                    break;
                }

                // handle fighter launching
                if (step.getType() == MoveStepType.LAUNCH) {
                    TreeMap<Integer, Vector<Integer>> launched = step
                            .getLaunched();
                    Set<Integer> bays = launched.keySet();
                    Iterator<Integer> bayIter = bays.iterator();
                    Bay currentBay;
                    while (bayIter.hasNext()) {
                        int bayId = bayIter.next();
                        currentBay = entity.getFighterBays().elementAt(bayId);
                        Vector<Integer> launches = launched.get(bayId);
                        int nLaunched = launches.size();
                        // need to make some decisions about how to handle the
                        // distribution
                        // of fighters to doors beyond the launch rate. The most
                        // sensible thing
                        // is probably to distribut them evenly.
                        int doors = currentBay.getDoors();
                        int[] distribution = new int[doors];
                        for (int l = 0; l < nLaunched; l++) {
                            distribution[l % doors] = distribution[l % doors] + 1;
                        }
                        // ok, now lets launch them
                        r = new Report(9380);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nLaunched);
                        r.add("bay " + currentBay.getBayNumber() + " (" + doors
                              + " doors)");
                        addReport(r);
                        int currentDoor = 0;
                        int fighterCount = 0;
                        boolean doorDamage = false;
                        for (int fighterId : launches) {
                            // check to see if we are in the same door
                            fighterCount++;

                            // check for door damage
                            Report doorReport = null;
                            if (!doorDamage && (distribution[currentDoor] > 2)
                                && (fighterCount > 2)) {
                                doorReport = new Report(9378);
                                doorReport.subject = entity.getId();
                                doorReport.indent(2);
                                int roll = Compute.d6(2);
                                doorReport.add(roll);
                                if (roll == 2) {
                                    doorDamage = true;
                                    doorReport.choose(true);
                                    currentBay.destroyDoorNext();
                                } else {
                                    doorReport.choose(false);
                                }
                                doorReport.newlines++;
                            }

                            if (fighterCount > distribution[currentDoor]) {
                                // move to a new door
                                currentDoor++;
                                fighterCount = 0;
                                doorDamage = false;
                            }
                            int bonus = Math.max(0,
                                                 distribution[currentDoor] - 2);

                            Entity fighter = game.getEntity(fighterId);
                            if (!launchUnit(entity, fighter, curPos, curFacing,
                                            step.getVelocity(), step.getAltitude(),
                                            step.getVectors(), bonus)) {
                                System.err
                                        .println("Error! Server was told to unload "
                                                 + fighter.getDisplayName()
                                                 + " from "
                                                 + entity.getDisplayName()
                                                 + " into "
                                                 + curPos.getBoardNum());
                            }
                            if (doorReport != null) {
                                addReport(doorReport);
                            }
                        }
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                }

                // handle dropship undocking
                if (step.getType() == MoveStepType.UNDOCK) {
                    TreeMap<Integer, Vector<Integer>> launched = step
                            .getLaunched();
                    Set<Integer> collars = launched.keySet();
                    Iterator<Integer> collarIter = collars.iterator();
                    while (collarIter.hasNext()) {
                        int collarId = collarIter.next();
                        Vector<Integer> launches = launched.get(collarId);
                        int nLaunched = launches.size();
                        // ok, now lets launch them
                        r = new Report(9380);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nLaunched);
                        r.add("collar " + collarId);
                        addReport(r);
                        for (int dropshipId : launches) {
                            // check to see if we are in the same door
                            Entity ds = game.getEntity(dropshipId);
                            if (!launchUnit(entity, ds, curPos, curFacing,
                                            step.getVelocity(), step.getAltitude(),
                                            step.getVectors(), 0)) {
                                System.err
                                        .println("Error! Server was told to unload "
                                                 + ds.getDisplayName()
                                                 + " from "
                                                 + entity.getDisplayName()
                                                 + " into "
                                                 + curPos.getBoardNum());
                            }
                        }
                    }
                }

                // handle combat drops
                if (step.getType() == MoveStepType.DROP) {
                    TreeMap<Integer, Vector<Integer>> dropped = step
                            .getLaunched();
                    Set<Integer> bays = dropped.keySet();
                    Iterator<Integer> bayIter = bays.iterator();
                    Bay currentBay;
                    while (bayIter.hasNext()) {
                        int bayId = bayIter.next();
                        currentBay = entity.getTransportBays().elementAt(bayId);
                        Vector<Integer> drops = dropped.get(bayId);
                        int nDropped = drops.size();
                        // ok, now lets drop them
                        r = new Report(9386);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        r.add(nDropped);
                        addReport(r);
                        for (int unitId : drops) {
                            if (Compute.d6(2) == 2) {
                                r = new Report(9390);
                                r.subject = entity.getId();
                                r.indent(1);
                                r.add(currentBay.getType());
                                addReport(r);
                                currentBay.destroyDoorNext();
                            }
                            Entity drop = game.getEntity(unitId);
                            dropUnit(drop, entity, curPos, step.getAltitude());
                        }
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                }
            }

            // check piloting skill for getting up
            rollTarget = entity.checkGetUp(step, overallMoveType);

            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Unless we're an ICE- or fuel cell-powered IndustrialMech,
                // standing up builds heat.
                if ((entity instanceof Mech)
                    && !(((Mech) entity).isIndustrial()
                        && ((entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)
                            || (entity.getEngine().getEngineType() == Engine.FUEL_CELL)))) {
                    entity.heatBuildup += 1;
                }
                entity.setProne(false);
                // entity.setHullDown(false);
                wasProne = false;
                game.resetPSRs(entity);
                entityFellWhileAttemptingToStand = !doSkillCheckInPlace(entity,
                        rollTarget);
            }
            // did the entity just fall?
            if (entityFellWhileAttemptingToStand) {
                moveType = stepMoveType;
                curFacing = entity.getFacing();
                curPos = entity.getPosition();
                mpUsed = step.getMpUsed();
                fellDuringMovement = true;
                if (!entity.isCarefulStand()) {
                    break;
                }
            } else if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                entity.setHullDown(false);
            }

            if (step.getType() == MoveStepType.UNJAM_RAC) {
                entity.setUnjammingRAC(true);
                game.addAction(new UnjamAction(entity.getId()));

                // for Aeros this will end movement prematurely
                // if we break
                if (!(entity.isAirborne())) {
                    break;
                }
            }

            if (step.getType() == MoveStepType.LAY_MINE) {
                layMine(entity, step.getMineToLay(), step.getPosition());
                continue;
            }

            if (step.getType() == MoveStepType.CLEAR_MINEFIELD) {
                ClearMinefieldAction cma = new ClearMinefieldAction(
                        entity.getId(), step.getMinefield());
                entity.setClearingMinefield(true);
                game.addAction(cma);
                break;
            }

            if ((step.getType() == MoveStepType.SEARCHLIGHT)
                && entity.hasSpotlight()) {
                final boolean SearchOn = !entity.isUsingSpotlight();
                entity.setSpotlightState(SearchOn);
                if (doBlind()) { // if doubleblind, we may need to filter the
                    // players that receive this messgae
                    Vector<IPlayer> playersVector = game.getPlayersVector();
                    Vector<IPlayer> vCanSee = whoCanSee(entity);
                    for (IPlayer p : playersVector) {
                        if (vCanSee.contains(p)) { // Player sees the unit
                            sendServerChat(p.getId(), entity.getDisplayName()
                                                      + " switched searchlight "
                                                      + (SearchOn ? "on" : "off") + '.');
                        } else {
                            sendServerChat(p.getId(), "An unseen unit"
                                                      + " switched searchlight "
                                                      + (SearchOn ? "on" : "off") + '.');
                        }
                    }
                } else { // No double blind, everyone can see this
                    sendServerChat(entity.getDisplayName()
                                   + " switched searchlight "
                                   + (SearchOn ? "on" : "off") + '.');
                }
            }

            // set most step parameters
            moveType = stepMoveType;
            distance = step.getDistance();
            mpUsed = step.getMpUsed();

            if (cachedGravityLimit < 0) {
                cachedGravityLimit = EntityMovementType.MOVE_JUMP == moveType ? entity
                        .getJumpMP(false) : entity.getRunningGravityLimit();
            }
            // check for charge
            if (step.getType() == MoveStepType.CHARGE) {
                if (entity.canCharge()) {
                    checkExtremeGravityMovement(entity, step, lastStepMoveType,
                            curPos, cachedGravityLimit);
                    Targetable target = step.getTarget(game);
                    if (target != null) {
                        ChargeAttackAction caa = new ChargeAttackAction(
                                entity.getId(), target.getTargetType(),
                                target.getTargetId(), target.getPosition());
                        entity.setDisplacementAttack(caa);
                        game.addCharge(caa);
                        charge = caa;
                    } else {
                        System.out.println("Illegal charge!! "
                                + entity.getDisplayName() + " is attempting to "
                                + "charge a null target!");
                        sendServerChat("Illegal charge!! "
                                + entity.getDisplayName() + " is attempting to "
                                + "charge a null target!");
                        return;
                    }
                } else {
                    sendServerChat("Illegal charge!! I don't think "
                                   + entity.getDisplayName()
                                   + " should be allowed to charge,"
                                   + " but the client of "
                                   + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                                   + entity.getOwner().getName()
                                   + " is running MegaMek "
                                   + MegaMek.VERSION
                                   + ", or if that is already the case, submit a bug report at http://megamek.sf.net/");
                    return;
                }
                break;
            }

            // check for dfa
            if (step.getType() == MoveStepType.DFA) {
                if (entity.canDFA()) {
                    checkExtremeGravityMovement(entity, step, lastStepMoveType,
                            curPos, cachedGravityLimit);
                    Targetable target = step.getTarget(game);
                    DfaAttackAction daa = new DfaAttackAction(entity.getId(),
                                                              target.getTargetType(), target.getTargetId(),
                                                              target.getPosition());
                    entity.setDisplacementAttack(daa);
                    entity.setElevation(step.getElevation());
                    game.addCharge(daa);
                    charge = daa;
                } else {
                    sendServerChat("Illegal DFA!! I don't think "
                                   + entity.getDisplayName()
                                   + " should be allowed to DFA,"
                                   + " but the client of "
                                   + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                                   + entity.getOwner().getName()
                                   + " is running MegaMek "
                                   + MegaMek.VERSION
                                   + ", or if that is already the case, submit a bug report at http://megamek.sf.net/");
                    return;
                }
                break;
            }

            // check for ram
            if (step.getType() == MoveStepType.RAM) {
                if (entity.canRam()) {
                    Targetable target = step.getTarget(game);
                    RamAttackAction raa = new RamAttackAction(entity.getId(),
                                                              target.getTargetType(), target.getTargetId(),
                                                              target.getPosition());
                    entity.setRamming(true);
                    game.addRam(raa);
                    ram = raa;
                } else {
                    sendServerChat("Illegal ram!! I don't think "
                                   + entity.getDisplayName()
                                   + " should be allowed to charge,"
                                   + " but the client of "
                                   + entity.getOwner().getName() + " disagrees.");
                    sendServerChat("Please make sure "
                                   + entity.getOwner().getName()
                                   + " is running MegaMek "
                                   + MegaMek.VERSION
                                   + ", or if that is already the case, submit a bug report at http://megamek.sf.net/");
                    return;
                }
                break;
            }

            if ((step.getType() == MoveStepType.ACC)
                || (step.getType() == MoveStepType.ACCN)) {
                if (entity instanceof Aero) {
                    Aero a = (Aero) entity;
                    if (step.getType() == MoveStepType.ACCN) {
                        a.setAccLast(true);
                        a.setNextVelocity(a.getNextVelocity() + 1);
                    } else {
                        a.setAccDecNow(true);
                        a.setCurrentVelocity(a.getCurrentVelocity() + 1);
                        a.setNextVelocity(a.getNextVelocity() + 1);
                    }
                }
            }

            if ((step.getType() == MoveStepType.DEC)
                || (step.getType() == MoveStepType.DECN)) {
                if (entity instanceof Aero) {
                    Aero a = (Aero) entity;
                    if (step.getType() == MoveStepType.DECN) {
                        a.setAccLast(true);
                        a.setNextVelocity(a.getNextVelocity() - 1);
                    } else {
                        a.setAccDecNow(true);
                        a.setCurrentVelocity(a.getCurrentVelocity() - 1);
                        a.setNextVelocity(a.getNextVelocity() - 1);
                    }
                }
            }

            if (step.getType() == MoveStepType.EVADE) {
                entity.setEvading(true);
            }

            if (step.getType() == MoveStepType.SHUTDOWN) {
                entity.performManualShutdown();
                sendServerChat(entity.getDisplayName() + " has shutdown.");
            }

            if (step.getType() == MoveStepType.STARTUP) {
                entity.performManualStartup();
                sendServerChat(entity.getDisplayName() + " has started up.");
            }

            if (step.getType() == MoveStepType.SELF_DESTRUCT) {
                entity.setSelfDestructing(true);
            }

            if (step.getType() == MoveStepType.ROLL) {
                if (entity instanceof Aero) {
                    Aero a = (Aero) entity;
                    if (a.isRolled()) {
                        a.setRolled(false);
                    } else {
                        a.setRolled(true);
                    }

                }
            }

            // check for dig in or fortify
            if (entity instanceof Infantry) {
                Infantry inf = (Infantry) entity;
                if (step.getType() == MoveStepType.DIG_IN) {
                    inf.setDugIn(Infantry.DUG_IN_WORKING);
                    continue;
                } else if (step.getType() == MoveStepType.FORTIFY) {
                    if (!entity.hasWorkingMisc(MiscType.F_TOOLS,
                                               MiscType.S_VIBROSHOVEL)) {
                        sendServerChat(entity.getDisplayName()
                                       + " failed to fortify because it is missing suitable equipment");
                    }
                    inf.setDugIn(Infantry.DUG_IN_FORTIFYING1);
                    continue;
                } else if ((step.getType() != MoveStepType.TURN_LEFT)
                           && (step.getType() != MoveStepType.TURN_RIGHT)) {
                    // other movement clears dug in status
                    inf.setDugIn(Infantry.DUG_IN_NONE);
                }

                if (step.getType() == MoveStepType.TAKE_COVER) {
                    if (Infantry.hasValidCover(game, step.getPosition(),
                            step.getElevation())) {
                        inf.setTakingCover(true);
                    } else {
                        sendServerChat(entity.getDisplayName()
                                + " failed to take cover: "
                                + "no valid unit found in "
                                + step.getPosition());
                    }
                }
            }

            // set last step parameters
            curPos = step.getPosition();
            if (!((entity.getJumpType() == Mech.JUMP_BOOSTER)
                    && step.isJumping())) {
                curFacing = step.getFacing();
            }
            // check if a building PSR will be needed later, before setting the
            // new elevation
            int buildingMove = entity.checkMovementInBuilding(step, prevStep,
                    curPos, lastPos);
            curVTOLElevation = step.getElevation();
            curAltitude = step.getAltitude();
            curElevation = step.getElevation();
            // set elevation in case of collapses
            entity.setElevation(step.getElevation());

            IHex curHex = game.getBoard().getHex(curPos);

            // when first entering a building, we need to roll what type
            // of basement it has
            if (isOnGround && curHex.containsTerrain(Terrains.BUILDING)) {
                Building bldg = game.getBoard().getBuildingAt(curPos);
                if (bldg.rollBasement(curPos, game.getBoard(), vPhaseReport)) {
                    sendChangedHex(curPos);
                    Vector<Building> buildings = new Vector<Building>();
                    buildings.add(bldg);
                    sendChangedBuildings(buildings);
                }
            }

            // check for automatic unstick
            if (entity.canUnstickByJumping() && entity.isStuck()
                && (moveType == EntityMovementType.MOVE_JUMP)) {
                entity.setStuck(false);
                entity.setCanUnstickByJumping(false);
            }

            // check for leap
            if (!lastPos.equals(curPos)
                && (stepMoveType != EntityMovementType.MOVE_JUMP)
                && (entity instanceof Mech)
                && game.getOptions().booleanOption("tacops_leaping")) {
                int leapDistance = (lastElevation + game.getBoard()
                                                        .getHex(lastPos).getLevel())
                                   - (curElevation + curHex.getLevel());
                if (leapDistance > 2) {
                    // skill check for leg damage
                    PilotingRollData roll = entity.getBasePilotingRoll(stepMoveType);
                    entity.addPilotingModifierForTerrain(roll, curPos);
                    roll.append(new PilotingRollData(entity.getId(),
                                                     2 * leapDistance, "leaping (leg damage)"));
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                                                    lastPos, curPos, roll, false)) {
                        // do leg damage
                        addReport(damageEntity(entity, new HitData(
                                Mech.LOC_LLEG), leapDistance));
                        addReport(damageEntity(entity, new HitData(
                                Mech.LOC_RLEG), leapDistance));
                        addNewLines();
                        addReport(criticalEntity(entity, Mech.LOC_LLEG, false,
                                                 0, 0));
                        addNewLines();
                        addReport(criticalEntity(entity, Mech.LOC_RLEG, false,
                                                 0, 0));
                        if (entity instanceof QuadMech) {
                            addReport(damageEntity(entity, new HitData(
                                    Mech.LOC_LARM), leapDistance));
                            addReport(damageEntity(entity, new HitData(
                                    Mech.LOC_RARM), leapDistance));
                            addNewLines();
                            addReport(criticalEntity(entity, Mech.LOC_LARM,
                                                     false, 0, 0));
                            addNewLines();
                            addReport(criticalEntity(entity, Mech.LOC_RARM,
                                                     false, 0, 0));
                        }
                    }
                    // skill check for fall
                    roll = entity.getBasePilotingRoll(stepMoveType);
                    entity.addPilotingModifierForTerrain(roll, curPos);
                    roll.append(new PilotingRollData(entity.getId(),
                                                     leapDistance, "leaping (fall)"));
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                                                    lastPos, curPos, roll, false)) {
                        entity.setElevation(lastElevation);
                        addReport(doEntityFallsInto(entity, lastElevation,
                                                    lastPos, curPos,
                                                    entity.getBasePilotingRoll(overallMoveType),
                                                    false));
                    }
                }
            }

            // Check for skid.
            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,
                                          prevStep, prevFacing, curFacing, lastPos, curPos,
                                          isInfantry, distance - 1);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Have an entity-meaningful PSR message.
                boolean psrFailed = true;
                int startingfacing = entity.getFacing();
                if (entity instanceof Mech) {
                    // We need to ensure that falls will happen from the proper
                    // facing
                    entity.setFacing(curFacing);
                    psrFailed = (0 < doSkillCheckWhileMoving(entity,
                                                             lastElevation, lastPos, lastPos, rollTarget, true));
                } else {
                    psrFailed = (0 < doSkillCheckWhileMoving(entity,
                                                             lastElevation, lastPos, lastPos, rollTarget, false));
                }
                // Does the entity skid?
                if (psrFailed) {

                    if (entity instanceof Tank) {
                        addReport(vehicleMotiveDamage((Tank) entity, 0));
                    }

                    curPos = lastPos;
                    int skidDistance = (int) Math
                            .round((double) (distance - 1) / 2);
                    int skidDirection = prevFacing;

                    // All charge damage is based upon
                    // the pre-skid move distance.
                    entity.delta_distance = distance - 1;

                    // Attacks against a skidding target have additional +2.
                    moveType = EntityMovementType.MOVE_SKID;

                    // What is the first hex in the skid?
                    if (step.isThisStepBackwards()) {
                        skidDirection = (skidDirection + 3) % 6;
                    }

                    if (processSkid(entity, curPos, prevStep.getElevation(),
                            skidDirection, skidDistance, prevStep,
                            lastStepMoveType)) {
                        return;
                    }

                    // set entity parameters
                    curFacing = entity.getFacing();
                    curPos = entity.getPosition();
                    entity.setSecondaryFacing(curFacing);

                    // skid consumes all movement
                    if (md.hasActiveMASC()) {
                        mpUsed = entity.getRunMP();
                    } else {
                        mpUsed = entity.getRunMPwithoutMASC();
                    }

                    entity.moved = moveType;
                    fellDuringMovement = true;
                    turnOver = true;
                    distance = entity.delta_distance;
                    break;

                } else { // End failed-skid-psr
                    // If the checke succeeded, restore the facing we had before
                    // if it failed, the fall will have changed facing
                    entity.setFacing(startingfacing);
                }

            } // End need-skid-psr

            // check sideslip
            if ((entity instanceof VTOL)
                || (entity.getMovementMode() == EntityMovementMode.HOVER)
                || (entity.getMovementMode() == EntityMovementMode.WIGE)) {
                rollTarget = entity.checkSideSlip(moveType, prevHex,
                                                  overallMoveType, prevStep, prevFacing, curFacing,
                                                  lastPos, curPos, distance);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    int moF = doSkillCheckWhileMoving(entity, lastElevation,
                                                      lastPos, curPos, rollTarget, false);
                    if (moF > 0) {
                        // maximum distance is hexes moved / 2
                        int sideslipDistance = Math.min(moF, distance - 1);
                        if (sideslipDistance > 0) {
                            int skidDirection = prevFacing;
                            // report sideslip
                            sideslipped = true;
                            r = new Report(2100);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(sideslipDistance);
                            addReport(r);

                            if (processSkid(entity, lastPos,
                                    prevStep.getElevation(), skidDirection,
                                    sideslipDistance, prevStep,
                                    lastStepMoveType)) {
                                return;
                            }

                            if (!entity.isDestroyed() && !entity.isDoomed()
                                && (mpUsed < entity.getRunMP())) {
                                fellDuringMovement = true; // No, but it should
                                // work...
                            }

                            if ((entity.getElevation() == 0)
                                && ((entity.getMovementMode() == EntityMovementMode.VTOL) || (entity
                                                                                                      .getMovementMode() == EntityMovementMode.WIGE))) {
                                turnOver = true;
                            }
                            // set entity parameters
                            curFacing = step.getFacing();
                            curPos = entity.getPosition();
                            entity.setSecondaryFacing(curFacing);
                            break;
                        }
                    }
                }
            }

            // check if we've moved into rubble
            boolean isLastStep = step.equals(md.getLastStep());
            rollTarget = entity.checkRubbleMove(step, overallMoveType, curHex,
                    lastPos, curPos, isLastStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos,
                                        rollTarget, true);
            }

            // check if we are using reckless movement
            rollTarget = entity.checkRecklessMove(step, overallMoveType,
                    curHex, lastPos, curPos, prevHex);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                if (entity instanceof Mech) {
                    doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                                            curPos, rollTarget, true);
                } else if (entity instanceof Tank) {
                    if (0 < doSkillCheckWhileMoving(entity, lastElevation,
                                                    lastPos, curPos, rollTarget, false)) {
                        // assume VTOLs in flight are always in clear terrain
                        if ((0 == curHex.terrainsPresent())
                            || (step.getElevation() > 0)) {
                            if (entity instanceof VTOL) {
                                r = new Report(2208);
                            } else {
                                r = new Report(2206);
                            }
                            r.addDesc(entity);
                            r.subject = entity.getId();
                            addReport(r);
                            mpUsed = step.getMpUsed() + 1;
                            fellDuringMovement = true;
                            break;
                        }
                        r = new Report(2207);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        addReport(r);
                        // until we get a rules clarification assume that the
                        // entity is both giver and taker
                        // for charge damage
                        HitData hit = entity.rollHitLocation(
                                ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                        addReport(damageEntity(entity, hit,
                                               ChargeAttackAction.getDamageTakenBy(entity,
                                                                                   entity)));
                        turnOver = true;
                        break;
                    }
                }
            }

            // check for breaking magma crust
            if ((curHex.terrainLevel(Terrains.MAGMA) == 1)
                && (step.getElevation() == 0)
                && (stepMoveType != EntityMovementType.MOVE_JUMP)) {
                int roll = Compute.d6(1);
                r = new Report(2395);
                r.addDesc(entity);
                r.add(roll);
                r.subject = entity.getId();
                addReport(r);
                if (roll == 6) {
                    curHex.removeTerrain(Terrains.MAGMA);
                    curHex.addTerrain(Terrains.getTerrainFactory()
                                              .createTerrain(Terrains.MAGMA, 2));
                    sendChangedHex(curPos);
                    for (Entity en : game.getEntitiesVector(curPos)) {
                        if (en != entity) {
                            doMagmaDamage(en, false);
                        }
                    }
                }
            }

            // check for entering liquid magma
            if ((curHex.terrainLevel(Terrains.MAGMA) == 2)
                && (step.getElevation() == 0)
                && (stepMoveType != EntityMovementType.MOVE_JUMP)) {
                doMagmaDamage(entity, false);
            }

            // check if we've moved into a swamp
            rollTarget = entity.checkBogDown(step, lastStepMoveType, curHex,
                    lastPos, curPos, lastElevation, isPavementStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                if (0 < doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                                                curPos, rollTarget, false)) {
                    entity.setStuck(true);
                    entity.setCanUnstickByJumping(true);
                    r = new Report(2081);
                    r.add(entity.getDisplayName());
                    r.subject = entity.getId();
                    addReport(r);
                    // check for quicksand
                    addReport(checkQuickSand(curPos));
                    // check for accidental stacking violation
                    Entity violation = Compute.stackingViolation(game,
                                                                 entity.getId(), curPos);
                    if (violation != null) {
                        // target gets displaced, because of low elevation
                        int direction = lastPos.direction(curPos);
                        Coords targetDest = Compute.getValidDisplacement(game,
                                                                         entity.getId(), curPos, direction);
                        addReport(doEntityDisplacement(violation, curPos,
                                                       targetDest,
                                                       new PilotingRollData(violation.getId(), 0,
                                                                            "domino effect")));
                        // Update the violating entity's postion on the client.
                        entityUpdate(violation.getId());
                    }
                    break;
                }
            }

            // check to see if we are a mech and we've moved OUT of fire
            IHex lastHex = game.getBoard().getHex(lastPos);
            if (entity instanceof Mech) {
                if (!lastPos.equals(curPos)
                    && (prevStep != null)
                        && ((lastHex.containsTerrain(Terrains.FIRE)
                                && (prevStep.getElevation() <= 1))
                                || (lastHex.containsTerrain(Terrains.MAGMA)
                                        && (prevStep.getElevation() == 0)))
                        && ((stepMoveType != EntityMovementType.MOVE_JUMP)
                        // Bug #828741 -- jumping bypasses fire, but not on the
                        // first step
                        // getMpUsed -- total MP used to this step
                        // getMp -- MP used in this step
                        // the difference will always be 0 on the "first step"
                        // of a jump,
                        // and >0 on a step in the midst of a jump
                        || (0 == (step.getMpUsed() - step.getMp())))) {
                    int heat = 0;
                    if (lastHex.containsTerrain(Terrains.FIRE)) {
                        heat += 2;
                    }
                    if (lastHex.terrainLevel(Terrains.MAGMA) == 1) {
                        heat += 2;
                    } else if (lastHex.terrainLevel(Terrains.MAGMA) == 2) {
                        heat += 5;
                    }
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heat /= 2;
                    }
                    entity.heatFromExternal += heat;
                    r = new Report(2115);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(heat);
                    addReport(r);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
            }

            // check to see if we are not a mech and we've moved INTO fire
            if (!(entity instanceof Mech)) {
                boolean underwater = game.getBoard().getHex(curPos)
                                         .containsTerrain(Terrains.WATER)
                                     && (game.getBoard().getHex(curPos).depth() > 0)
                                     && (step.getElevation() < game.getBoard()
                                                                   .getHex(curPos).surface());
                if (game.getBoard().getHex(curPos)
                        .containsTerrain(Terrains.FIRE)
                    && !lastPos.equals(curPos)
                    && (stepMoveType != EntityMovementType.MOVE_JUMP)
                    && (step.getElevation() <= 1) && !underwater) {
                    doFlamingDamage(entity);
                }
            }
            // check for extreme gravity movement
            if (!i.hasMoreElements() && !firstStep) {
                checkExtremeGravityMovement(entity, step, lastStepMoveType,
                        curPos, cachedGravityLimit);
            }
            // check for minefields. have to check both new hex and new
            // elevation
            // VTOLs may land and submarines may rise or lower into a minefield
            if (!lastPos.equals(curPos) || (lastElevation != curElevation)) {
                boolean boom = false;
                if (isOnGround) {
                    boom = checkVibrabombs(entity, curPos, false, lastPos,
                                           curPos, vPhaseReport);
                }
                if (game.containsMinefield(curPos)) {
                    // set the new position temporarily, because
                    // infantry otherwise would get double damage
                    // when moving from clear into mined woods
                    entity.setPosition(curPos);
                    if (enterMinefield(entity, curPos, step.getElevation(),
                                       isOnGround, vPhaseReport)) {
                        // resolve any piloting rolls from damage unless unit
                        // was jumping
                        if (stepMoveType != EntityMovementType.MOVE_JUMP) {
                            addReport(resolvePilotingRolls(entity));
                            game.resetPSRs(entity);
                        }
                        boom = true;
                    }
                    if (wasProne || !entity.isProne()) {
                        entity.setPosition(lastPos);
                    }
                }
                // did anything go boom?
                if (boom) {
                    // set fell during movement so that entity will get another
                    // chance to move with any motive damage
                    // taken account of (functions the same as MASC failure)
                    // only do this if they had more steps (and they were not
                    // jumping
                    if (i.hasMoreElements()
                        && (stepMoveType != EntityMovementType.MOVE_JUMP)) {
                        md.clear();
                        fellDuringMovement = true;
                    }
                    // reset mines if anything detonated
                    resetMines();
                }
            }

            // infantry discovers minefields if they end their move
            // in a minefield.
            if (!lastPos.equals(curPos) && !i.hasMoreElements() && isInfantry) {
                if (game.containsMinefield(curPos)) {
                    IPlayer owner = entity.getOwner();
                    for (Minefield mf : game.getMinefields(curPos)) {
                        if (!owner.containsMinefield(mf)) {
                            r = new Report(2120);
                            r.subject = entity.getId();
                            r.add(entity.getShortName(), true);
                            addReport(r);
                            revealMinefield(game.getTeamForPlayer(owner), mf);
                        }
                    }
                }
            }

            // check if we've moved into water
            rollTarget = entity.checkWaterMove(step, lastStepMoveType, curHex,
                    lastPos, curPos, isPavementStep);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                // Swarmers need special handling.
                final int swarmerId = entity.getSwarmAttackerId();
                boolean swarmerDone = true;
                Entity swarmer = null;
                if (Entity.NONE != swarmerId) {
                    swarmer = game.getEntity(swarmerId);
                    swarmerDone = swarmer.isDone();
                }

                // Now do the skill check.
                entity.setFacing(curFacing);
                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos,
                                        rollTarget, true);

                // Swarming infantry platoons may drown.
                if (curHex.terrainLevel(Terrains.WATER) > 1) {
                    drownSwarmer(entity, curPos);
                }

                // Do we need to remove a game turn for the swarmer
                if (!swarmerDone && (swarmer != null)
                    && (swarmer.isDoomed() || swarmer.isDestroyed())) {
                    // We have to diddle with the swarmer's
                    // status to get its turn removed.
                    swarmer.setDone(false);
                    swarmer.setUnloaded(false);

                    // Dead entities don't take turns.
                    game.removeTurnFor(swarmer);
                    send(createTurnVectorPacket());

                    // Return the original status.
                    swarmer.setDone(true);
                    swarmer.setUnloaded(true);
                }

                // check for inferno wash-off
                checkForWashedInfernos(entity, curPos);
            }

            // In water, may or may not be a new hex, neccessary to
            // check during movement, for breach damage, and always
            // set dry if appropriate
            // TODO: possibly make the locations local and set later
            addReport(doSetLocationsExposure(entity, curHex,
                    stepMoveType == EntityMovementType.MOVE_JUMP,
                    step.getElevation()));

            // check for breaking ice by breaking through from below
            if ((lastElevation < 0) && (step.getElevation() == 0)
                && lastHex.containsTerrain(Terrains.ICE)
                && lastHex.containsTerrain(Terrains.WATER)
                && (stepMoveType != EntityMovementType.MOVE_JUMP)
                && !lastPos.equals(curPos)) {
                // need to temporarily reset entity's position so it doesn't
                // fall in the ice
                entity.setPosition(curPos);
                r = new Report(2410);
                r.addDesc(entity);
                addReport(r);
                addReport(resolveIceBroken(lastPos));
                // ok now set back
                entity.setPosition(lastPos);
            }
            // check for breaking ice by stepping on it
            if (curHex.containsTerrain(Terrains.ICE)
                && curHex.containsTerrain(Terrains.WATER)
                && (stepMoveType != EntityMovementType.MOVE_JUMP)
                && !lastPos.equals(curPos)
                && !(entity instanceof Infantry)
                && !(step.isPavementStep() && curHex
                    .containsTerrain(Terrains.BRIDGE))) {
                if (step.getElevation() == 0) {
                    int roll = Compute.d6(1);
                    r = new Report(2118);
                    r.addDesc(entity);
                    r.add(roll);
                    r.subject = entity.getId();
                    addReport(r);
                    if (roll == 6) {
                        entity.setPosition(curPos);
                        addReport(resolveIceBroken(curPos));
                        curPos = entity.getPosition();
                    }
                }
                // or intersecting it
                else if ((step.getElevation() + entity.height()) == 0) {
                    r = new Report(2410);
                    r.addDesc(entity);
                    addReport(r);
                    addReport(resolveIceBroken(curPos));
                }
            }

            // Handle loading units.
            if (step.getType() == MoveStepType.LOAD) {

                // Find the unit being loaded.
                Entity loaded = null;
                Iterator<Entity> entities = game.getEntities(curPos);
                while (entities.hasNext()) {

                    // Is the other unit friendly and not the current entity?
                    loaded = entities.next();

                    // This should never ever happen, but just in case...
                    if (loaded.equals(null)) {
                        continue;
                    }

                    if (!entity.isEnemyOf(loaded) && !entity.equals(loaded)) {

                        // The moving unit should be able to load the other
                        // unit and the other should be able to have a turn.
                        if (!entity.canLoad(loaded)
                            || !loaded.isLoadableThisTurn()) {
                            // Something is fishy in Denmark.
                            System.err.println(entity.getShortName()
                                               + " can not load " + loaded.getShortName());
                            loaded = null;
                        } else {
                            // Have the deployed unit load the indicated unit.
                            loadUnit(entity, loaded, loaded.getTargetBay());

                            // Stop looking.
                            break;
                        }

                    } else {
                        // Nope. Discard it.
                        loaded = null;
                    }

                } // Handle the next entity in this hex.

                // We were supposed to find someone to load.
                if (loaded == null) {
                    System.err.println("Could not find unit for "
                                       + entity.getShortName() + " to load in " + curPos);
                }

            } // End STEP_LOAD

            // Handle mounting units to small craft/dropship
            if (step.getType() == MoveStepType.MOUNT) {
                Targetable mountee = step.getTarget(game);
                if ((null != mountee) && (mountee instanceof Entity)) {
                    Entity dropship = (Entity) mountee;
                    if (!dropship.canLoad(entity)) {
                        // Something is fishy in Denmark.
                        System.err.println(dropship.getShortName()
                                           + " can not load " + entity.getShortName());
                    } else {
                        // Have the indicated unit load this unit.
                        entity.setDone(true);
                        loadUnit(dropship, entity, entity.getTargetBay());
                        Bay currentBay = dropship.getBay(entity);
                        if ((null != currentBay) && (Compute.d6(2) == 2)) {
                            r = new Report(9390);
                            r.subject = entity.getId();
                            r.indent(1);
                            r.add(currentBay.getType());
                            addReport(r);
                            currentBay.destroyDoorNext();
                        }
                        // Stop looking.
                        entityUpdate(dropship.getId());
                        return;
                    }
                }
            } // End STEP_MOUNT

            // handle fighter recovery
            if (step.getType() == MoveStepType.RECOVER) {

                loader = game.getEntity(step.getRecoveryUnit());
                boolean isDS = (entity instanceof Dropship);

                PilotingRollData psr = entity
                        .getBasePilotingRoll(overallMoveType);
                if (loader.mpUsed > 0) {
                    psr.addModifier(5, "carrier used thrust");
                }
                int ctrlroll = Compute.d6(2);
                if (isDS) {
                    r = new Report(9388);
                } else {
                    r = new Report(9381);
                }
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                r.add(loader.getDisplayName());
                r.add(psr.getValue());
                r.add(ctrlroll);
                r.newlines = 0;
                r.indent(1);
                if (ctrlroll < psr.getValue()) {
                    r.choose(false);
                    addReport(r);
                    // damage unit
                    Aero a = (Aero) entity;
                    HitData hit = a.rollHitLocation(ToHitData.HIT_NORMAL,
                                                    ToHitData.SIDE_FRONT);
                    addReport(damageEntity(entity, hit,
                                           2 * (psr.getValue() - ctrlroll)));
                } else {
                    r.choose(true);
                    addReport(r);
                    recovered = true;
                }
                // check for door damage
                if (ctrlroll == 2) {
                    loader.damageDoorRecovery(entity);
                    r = new Report(9384);
                    r.subject = entity.getId();
                    r.indent(0);
                    r.add(loader.getDisplayName());
                    addReport(r);
                }
            }

            // handle fighter squadron joining
            if (step.getType() == MoveStepType.JOIN) {
                loader = game.getEntity(step.getRecoveryUnit());
                recovered = true;
            }

            // Handle unloading units.
            if (step.getType() == MoveStepType.UNLOAD) {
                Targetable unloaded = step.getTarget(game);
                Coords unloadPos = curPos;
                int unloadFacing = curFacing;
                if (null != step.getTargetPosition()) {
                    unloadPos = step.getTargetPosition();
                    unloadFacing = curPos.direction(unloadPos);
                }
                if (!unloadUnit(entity, unloaded, unloadPos, unloadFacing,
                                step.getElevation())) {
                    System.err.println("Error! Server was told to unload "
                                       + unloaded.getDisplayName() + " from "
                                       + entity.getDisplayName() + " into "
                                       + curPos.getBoardNum());
                }
                // some additional stuff to take care of for small
                // craft/dropship unloading
                if ((entity instanceof SmallCraft)
                    && (unloaded instanceof Entity)) {
                    Bay currentBay = entity.getBay((Entity) unloaded);
                    if ((null != currentBay) && (Compute.d6(2) == 2)) {
                        r = new Report(9390);
                        r.subject = entity.getId();
                        r.indent(1);
                        r.add(currentBay.getType());
                        addReport(r);
                        currentBay.destroyDoorNext();
                    }
                    // now apply any damage to bay doors
                    entity.resetBayDoors();
                    entityUpdate(entity.getId());
                    // ok now add another turn for the transport so it can
                    // continue to unload units
                    if (entity.getUnitsUnloadableFromBays().size() > 0) {
                        dropshipStillUnloading = true;
                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(
                                entity.getOwner().getId(), entity.getId());
                        // Need to set the new turn's multiTurn state
                        newTurn.setMultiTurn(true);
                        game.insertNextTurn(newTurn);
                    }
                    // ok add another turn for the unloaded entity so that it
                    // can move
                    if (!(unloaded instanceof Infantry)) {
                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(
                                ((Entity) unloaded).getOwner().getId(),
                                ((Entity) unloaded).getId());
                        // Need to set the new turn's multiTurn state
                        newTurn.setMultiTurn(true);
                        game.insertNextTurn(newTurn);
                    }
                    // brief everybody on the turn update
                    send(createTurnVectorPacket());
                }
            }
            // moving backwards over elevation change
            if (((step.getType() == MoveStepType.BACKWARDS)
                    || (step.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS)
                    || (step.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS))
                    && !(md.isJumping() && (entity.getJumpType() == Mech.JUMP_BOOSTER))
                    && ((lastHex.getLevel() + entity.calcElevation(curHex,
                            lastHex, step.getElevation(),
                            md.getFinalClimbMode(), false)) != (curHex
                            .getLevel() + entity.getElevation()))
                    && !(entity instanceof VTOL)
                    && !(md.getFinalClimbMode()
                            && curHex.containsTerrain(Terrains.BRIDGE) && ((curHex
                            .terrainLevel(Terrains.BRIDGE_ELEV) + curHex
                            .getLevel()) == (prevHex.getLevel() + (prevHex
                            .containsTerrain(Terrains.BRIDGE) ? prevHex
                            .terrainLevel(Terrains.BRIDGE_ELEV) : 0))))) {

                if ((entity instanceof Mech)
                    && (curHex.getLevel() < game.getBoard()
                                                    .getHex(lastPos).getLevel())) {
                    PilotingRollData psr = entity
                            .getBasePilotingRoll(overallMoveType);
                    psr.addModifier(0,
                                    "moving backwards over an elevation change");
                    doSkillCheckWhileMoving(entity, entity.getElevation(),
                                            curPos, curPos, psr, true);
                } else if (entity instanceof Mech) {
                    PilotingRollData psr = entity
                            .getBasePilotingRoll(overallMoveType);
                    psr.addModifier(0,
                                    "moving backwards over an elevation change");
                    doSkillCheckWhileMoving(entity, lastElevation, lastPos,
                                            lastPos, psr, true);
                } else if (entity instanceof Tank) {
                    PilotingRollData psr = entity
                            .getBasePilotingRoll(overallMoveType);
                    psr.addModifier(0,
                                    "moving backwards over an elevation change");
                    if (doSkillCheckWhileMoving(entity, entity.getElevation(),
                                                curPos, lastPos, psr, false) < 0) {
                        curPos = lastPos;
                    }
                }

            }

            // Handle non-infantry moving into a building.
            if (buildingMove > 0) {

                // Get the building being exited.
                Building bldgExited = null;
                if ((buildingMove & 1) == 1) {
                    bldgExited = game.getBoard().getBuildingAt(lastPos);
                }

                // Get the building being entered.
                Building bldgEntered = null;
                if ((buildingMove & 2) == 2) {
                    bldgEntered = game.getBoard().getBuildingAt(curPos);
                }

                // Protomechs changing levels within a building cause damage
                if (((buildingMove & 8) == 8) && (entity instanceof Protomech)) {
                    Building bldg = game.getBoard().getBuildingAt(curPos);
                    Vector<Report> vBuildingReport = damageBuilding(bldg, 1,
                                                                    curPos);
                    for (Report report : vBuildingReport) {
                        report.subject = entity.getId();
                    }
                    addReport(vBuildingReport);
                }

                boolean collapsed = false;
                if ((bldgEntered != null)) {
                    // If we're not leaving a building, just handle the
                    // "entered".
                    String reason;
                    if (bldgExited == null) {
                        reason = "entering";
                    }
                    // If we're moving within the same building, just handle
                    // the "within".
                    else if (bldgExited.equals(bldgEntered)
                             && !(entity instanceof Protomech)
                             && !(entity instanceof Infantry)) {
                        reason = "moving in";
                    }
                    // If we have different buildings, roll for each.
                    else {
                        reason = "entering";
                    }
                    passBuildingWall(entity, bldgEntered, lastPos, curPos,
                            distance, reason, step.isThisStepBackwards(),
                            lastStepMoveType, true);
                    addAffectedBldg(bldgEntered, collapsed);
                }

                // Clean up the entity if it has been destroyed.
                if (entity.isDoomed()) {
                    entity.setDestroyed(true);
                    game.moveToGraveyard(entity.getId());
                    send(createRemoveEntityPacket(entity.getId()));

                    // The entity's movement is completed.
                    return;
                }

                // TODO: what if a building collapses into rubble?
            }

            if ((isOnGround || ((((stepMoveType != EntityMovementType.MOVE_JUMP) && (curElevation <= curHex
                    .terrainLevel(Terrains.BLDG_ELEV))) || (curElevation == curHex
                    .terrainLevel(Terrains.BRIDGE_ELEV))) && curHex
                    .containsTerrain(Terrains.BLDG_ELEV)))) {
                Building bldg = game.getBoard().getBuildingAt(curPos);
                if ((bldg != null) && (entity.getElevation() >= 0)) {
                    addAffectedBldg(
                            bldg,
                            checkBuildingCollapseWhileMoving(bldg, entity,
                                                             curPos));
                }

            }

            // did the entity just fall?
            if (!wasProne && entity.isProne()) {
                curFacing = entity.getFacing();
                curPos = entity.getPosition();
                mpUsed = step.getMpUsed();
                fellDuringMovement = true;
                break;
            }

            // dropping prone intentionally?
            if (step.getType() == MoveStepType.GO_PRONE) {
                mpUsed = step.getMpUsed();
                rollTarget = entity.checkDislodgeSwarmers(step, overallMoveType);
                if (rollTarget.getValue() == TargetRoll.CHECK_FALSE) {
                    // Not being swarmed
                    entity.setProne(true);
                    // check to see if we washed off infernos
                    checkForWashedInfernos(entity, curPos);
                } else {
                    // Being swarmed
                    entity.setPosition(curPos);
                    if (doDislodgeSwarmerSkillCheck(entity, rollTarget, curPos)) {
                        // Entity falls
                        curFacing = entity.getFacing();
                        curPos = entity.getPosition();
                        fellDuringMovement = true;
                        break;
                    }
                    // roll failed, go prone but don't dislodge swarmers
                    entity.setProne(true);
                    // check to see if we washed off infernos
                    checkForWashedInfernos(entity, curPos);
                    break;
                }
            }

            // going hull down
            if (step.getType() == MoveStepType.HULL_DOWN) {
                mpUsed = step.getMpUsed();
                entity.setHullDown(true);
            }

            // Check for crushing buildings by Dropships/Mobile Structures
            for (Coords pos : step.getCrushedBuildingLocs()) {
                Building bldg = game.getBoard().getBuildingAt(pos);
                IHex hex = game.getBoard().getHex(pos);

                r = new Report(3443);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(bldg.getName());
                vPhaseReport.add(r);

                final int cf = bldg.getCurrentCF(pos);
                final int numFloors = Math.max(0,
                                               hex.terrainLevel(Terrains.BLDG_ELEV));
                vPhaseReport.addAll(damageBuilding(bldg, 150,
                                                   " is crushed for ", pos));
                int damage = (int) Math.round((cf / 10.0) * numFloors);
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                vPhaseReport.addAll(damageEntity(entity, hit, damage));
            }

            // Track this step's location.
            movePath.addElement(new UnitLocation(entity.getId(), curPos,
                                                 curFacing, step.getElevation()));

            // if the lastpos is not the same as the current position
            // then add the current position to the list of places passed
            // through
            if (!curPos.equals(lastPos)) {
                passedThrough.add(curPos);
                passedThroughFacing.add(curFacing);
            }

            // update lastPos, prevStep, prevFacing & prevHex
            if (!curPos.equals(lastPos)) {
                prevFacing = curFacing;
            }
            lastPos = new Coords(curPos);
            lastElevation = curElevation;
            prevStep = step;
            prevHex = curHex;

            firstStep = false;
        }

        // set entity parameters
        entity.setPosition(curPos);
        entity.setFacing(curFacing);
        entity.setSecondaryFacing(curFacing);
        entity.delta_distance = distance;
        entity.moved = moveType;
        entity.mpUsed = mpUsed;
        if (!sideslipped && !fellDuringMovement && !crashedDuringMovement
            && (entity.getMovementMode() == EntityMovementMode.VTOL)) {
            entity.setElevation(curVTOLElevation);
        }
        entity.setAltitude(curAltitude);
        entity.setClimbMode(md.getFinalClimbMode());

        // add a list of places passed through
        entity.setPassedThrough(passedThrough);
        entity.setPassedThroughFacing(passedThroughFacing);

        // if we ran with destroyed hip or gyro, we need a psr
        rollTarget = entity.checkRunningWithDamage(overallMoveType);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
            doSkillCheckInPlace(entity, rollTarget);
        }

        // if we sprinted with MASC or a supercharger, then we need a PSR
        rollTarget = entity.checkSprintingWithMASC(overallMoveType,
                                                   entity.mpUsed);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
            doSkillCheckInPlace(entity, rollTarget);
        }

        // if we used protmech myomer booster, roll 2d6
        // pilot damage on a 2
        if ((entity instanceof Protomech)
            && ((Protomech) entity).hasMyomerBooster()
            && (md.getMpUsed() > ((Protomech) entity)
                .getRunMPwithoutMyomerBooster(true, false, false))) {
            r = new Report(2373);
            r.addDesc(entity);
            r.subject = entity.getId();
            int roll = Compute.d6(2);
            r.add(roll);
            if (roll > 2) {
                r.choose(true);
                addReport(r);
            } else {
                r.choose(false);
                addReport(r);
                addReport(damageCrew(entity, 1));
            }
        }

        rollTarget = entity.checkSprintingWithSupercharger(overallMoveType,
                                                           entity.mpUsed);
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
            doSkillCheckInPlace(entity, rollTarget);
        }
        if ((md.getLastStepMovementType() == EntityMovementType.MOVE_SPRINT)
            && md.hasActiveMASC()) {
            doSkillCheckInPlace(entity,
                                entity.getBasePilotingRoll(EntityMovementType.MOVE_SPRINT));
        }

        if (entity.isAirborne() && (entity instanceof Aero)) {

            Aero a = (Aero) entity;
            int thrust = md.getMpUsed();

            // consume fuel
            if (((entity instanceof Aero) && game.getOptions().booleanOption(
                    "fuel_consumption"))
                || (entity instanceof TeleMissile)) {
                int fuelUsed = ((Aero) entity).getFuelUsed(thrust);
                a.useFuel(fuelUsed);
            }

            // jumpships and space stations need to reduce accumulated thrust if
            // they spend some
            if (entity instanceof Jumpship) {
                Jumpship js = (Jumpship) entity;
                double penalty = 0.0;
                // jumpships do not accumulate thrust when they make a turn or
                // change velocity
                if (md.contains(MoveStepType.TURN_LEFT)
                    || md.contains(MoveStepType.TURN_RIGHT)) {
                    // I need to subtract the station keeping thrust from their
                    // accumulated thrust
                    // because they did not actually use it
                    penalty = js.getStationKeepingThrust();
                }
                if (thrust > 0) {
                    penalty = thrust;
                }
                if (penalty > 0.0) {
                    js.setAccumulatedThrust(Math.max(0,
                                                     js.getAccumulatedThrust() - penalty));
                }
            }

            // check to see if thrust exceeded SI

            rollTarget = a.checkThrustSITotal(thrust, overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                         "Thrust spent during turn exceeds SI"));
            }

            if (!game.getBoard().inSpace()) {
                rollTarget = a.checkVelocityDouble(md.getFinalVelocity(),
                                                   overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                             "Velocity greater than 2x safe thrust"));
                }

                rollTarget = a.checkDown(md.getFinalNDown(), overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(a.getId(), md
                            .getFinalNDown(),
                                                             "descended more than two altitudes"));
                }

                // check for hovering
                rollTarget = a.checkHover(md);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                             "hovering"));
                }

                // check for aero stall
                rollTarget = a.checkStall(md);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    r = new Report(9391);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    game.addControlRoll(new PilotingRollData(entity.getId(), 0,
                                                             "stalled out"));
                    a.setAltitude(a.getAltitude() - 1);
                    // check for crash
                    if (checkCrash(entity, entity.getPosition(),
                                   entity.getAltitude())) {
                        addReport(processCrash(entity, 0, entity.getPosition()));
                    }
                }

                // check to see if spheroids should lose one altitude
                if (a.isSpheroid() && !game.getBoard().inSpace()
                    && a.isAirborne() && (md.getFinalNDown() == 0)
                    && (md.getMpUsed() == 0)) {
                    r = new Report(9392);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    a.setAltitude(a.getAltitude() - 1);
                    // check for crash
                    if (checkCrash(entity, entity.getPosition(),
                                   entity.getAltitude())) {
                        addReport(processCrash(entity, 0, entity.getPosition()));
                    }
                }
            }
        }

        // We need to check for the removal of hull-down for tanks.
        // Tanks can just drive out of hull-down: if the tank was hull-down
        // and doesn't end hull-down we can remove the hull-down status
        if ((entity instanceof Tank) && entity.isHullDown()
            && !md.getFinalHullDown()) {
            entity.setHullDown(false);
        }

        // If the entity is being swarmed, erratic movement may dislodge the
        // fleas.
        final int swarmerId = entity.getSwarmAttackerId();
        if ((Entity.NONE != swarmerId)
            && md.contains(MoveStepType.SHAKE_OFF_SWARMERS)) {
            final Entity swarmer = game.getEntity(swarmerId);
            final PilotingRollData roll = entity
                    .getBasePilotingRoll(overallMoveType);

            entity.addPilotingModifierForTerrain(roll);

            // Add a +4 modifier.
            if (md.getLastStepMovementType() == EntityMovementType.MOVE_VTOL_RUN) {
                roll.addModifier(2,
                                 "dislodge swarming infantry with VTOL movement");
            } else {
                roll.addModifier(4, "dislodge swarming infantry");
            }

            // If the swarmer has Assault claws, give a 1 modifier.
            // We can stop looking when we find our first match.
            for (Mounted mount : swarmer.getMisc()) {
                EquipmentType equip = mount.getType();
                if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {
                    roll.addModifier(1, "swarmer has magnetic claws");
                    break;
                }
            }

            // okay, print the info
            r = new Report(2125);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);

            // roll
            final int diceRoll = Compute.d6(2);
            r = new Report(2130);
            r.subject = entity.getId();
            r.add(roll.getValueAsString());
            r.add(roll.getDesc());
            r.add(diceRoll);
            if (diceRoll < roll.getValue()) {
                r.choose(false);
                addReport(r);
            } else {
                // Dislodged swarmers don't get turns.
                game.removeTurnFor(swarmer);
                send(createTurnVectorPacket());

                // Update the report and the swarmer's status.
                r.choose(true);
                addReport(r);
                entity.setSwarmAttackerId(Entity.NONE);
                swarmer.setSwarmTargetId(Entity.NONE);

                IHex curHex = game.getBoard().getHex(curPos);

                // Did the infantry fall into water?
                if (curHex.terrainLevel(Terrains.WATER) > 0) {
                    // Swarming infantry die.
                    swarmer.setPosition(curPos);
                    r = new Report(2135);
                    r.subject = entity.getId();
                    r.indent();
                    r.addDesc(swarmer);
                    addReport(r);
                    addReport(destroyEntity(swarmer, "a watery grave", false));
                } else {
                    // Swarming infantry take a 3d6 point hit.
                    // ASSUMPTION : damage should not be doubled.
                    r = new Report(2140);
                    r.subject = entity.getId();
                    r.indent();
                    r.addDesc(swarmer);
                    r.add("3d6");
                    addReport(r);
                    addReport(damageEntity(swarmer, swarmer.rollHitLocation(
                                                   ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
                                           Compute.d6(3)));
                    addNewLines();
                    swarmer.setPosition(curPos);
                }
                entityUpdate(swarmerId);
            } // End successful-PSR

        } // End try-to-dislodge-swarmers

        // but the danger isn't over yet! landing from a jump can be risky!
        if ((overallMoveType == EntityMovementType.MOVE_JUMP)
            && !entity.isMakingDfa()) {
            final IHex curHex = game.getBoard().getHex(curPos);
            // check for damaged criticals
            rollTarget = entity.checkLandingWithDamage(overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, rollTarget);
            }
            // check for prototype JJs
            rollTarget = entity.checkLandingWithPrototypeJJ(overallMoveType);
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, rollTarget);
            }
            // check for jumping into heavy woods
            if (game.getOptions().booleanOption("psr_jump_heavy_woods")) {
                rollTarget = entity.checkLandingInHeavyWoods(overallMoveType,
                                                             curHex);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    doSkillCheckInPlace(entity, rollTarget);
                }
            }
            // Mechanical jump boosters fall damage
            if (md.shouldMechanicalJumpCauseFallDamage()) {
                vPhaseReport.addAll(doEntityFallsInto(entity,
                                                      entity.getElevation(), md.getJumpPathHighestPoint(),
                                                      curPos, entity.getBasePilotingRoll(overallMoveType),
                                                      false, entity.getJumpMP()));
            }
            // jumped into water?
            int waterLevel = curHex.terrainLevel(Terrains.WATER);
            if (curHex.containsTerrain(Terrains.ICE) && (waterLevel > 0)) {
                if (!(entity instanceof Infantry)) {
                    waterLevel = 0;
                    // check for breaking ice
                    int roll = Compute.d6(1);
                    r = new Report(2122);
                    r.add(entity.getDisplayName(), true);
                    r.add(roll);
                    r.subject = entity.getId();
                    addReport(r);
                    if (roll >= 4) {
                        // oops!
                        entity.setPosition(curPos);
                        addReport(resolveIceBroken(curPos));
                        curPos = entity.getPosition();
                    } else {
                        // TacOps: immediate PSR with +4 for terrain. If you
                        // fall then may break the ice after all
                        rollTarget = entity.checkLandingOnIce(overallMoveType,
                                                              curHex);
                        if (!doSkillCheckInPlace(entity, rollTarget)) {
                            // apply damage now, or it will show up as a
                            // possible breach, if ice is broken
                            entity.applyDamage();
                            roll = Compute.d6(1);
                            r = new Report(2118);
                            r.addDesc(entity);
                            r.add(roll);
                            r.subject = entity.getId();
                            addReport(r);
                            if (roll == 6) {
                                entity.setPosition(curPos);
                                addReport(resolveIceBroken(curPos));
                                curPos = entity.getPosition();
                            }
                        }
                    }
                }
            } else if (!(prevStep.climbMode() && curHex
                    .containsTerrain(Terrains.BRIDGE))
                       && !(entity.getMovementMode() == EntityMovementMode.HOVER)) {
                rollTarget = entity.checkWaterMove(waterLevel, overallMoveType);
                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {
                    doSkillCheckInPlace(entity, rollTarget);
                }
                if (waterLevel > 1) {
                    // Any swarming infantry will be destroyed.
                    drownSwarmer(entity, curPos);
                }
            }

            // check for building collapse
            Building bldg = game.getBoard().getBuildingAt(curPos);
            if (bldg != null) {
                checkForCollapse(bldg, game.getPositionMap(), curPos, true,
                                 vPhaseReport);
            }

            // check for breaking magma crust
            if (curHex.terrainLevel(Terrains.MAGMA) == 1) {
                int roll = Compute.d6(1);
                r = new Report(2395);
                r.addDesc(entity);
                r.add(roll);
                r.subject = entity.getId();
                addReport(r);
                if (roll == 6) {
                    curHex.removeTerrain(Terrains.MAGMA);
                    curHex.addTerrain(Terrains.getTerrainFactory()
                                              .createTerrain(Terrains.MAGMA, 2));
                    sendChangedHex(curPos);
                    for (Entity en : game.getEntitiesVector(curPos)) {
                        if (en != entity) {
                            doMagmaDamage(en, false);
                        }
                    }
                }
            }

            // check for entering liquid magma
            if (curHex.terrainLevel(Terrains.MAGMA) == 2) {
                doMagmaDamage(entity, false);
            }

            // jumped into swamp? maybe stuck!
            if (curHex.getBogDownModifier(entity.getMovementMode(),
                                          entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
                if (entity instanceof Mech) {
                    entity.setStuck(true);
                    r = new Report(2121);
                    r.add(entity.getDisplayName(), true);
                    r.subject = entity.getId();
                    addReport(r);
                    // check for quicksand
                    addReport(checkQuickSand(curPos));
                } else {
                    PilotingRollData roll = new PilotingRollData(
                            entity.getId(), 5, "entering boggy terrain");
                    roll.append(new PilotingRollData(entity.getId(), curHex
                            .getBogDownModifier(entity.getMovementMode(),
                                                entity instanceof LargeSupportTank),
                                                     "avoid bogging down"));
                    if (0 < doSkillCheckWhileMoving(entity,
                                                    entity.getElevation(), curPos, curPos, roll, false)) {
                        entity.setStuck(true);
                        r = new Report(2081);
                        r.add(entity.getDisplayName());
                        r.subject = entity.getId();
                        addReport(r);
                        // check for quicksand
                        addReport(checkQuickSand(curPos));
                    }
                }
            }

            // If the entity is being swarmed, jumping may dislodge the fleas.
            if (Entity.NONE != swarmerId) {
                final Entity swarmer = game.getEntity(swarmerId);
                final PilotingRollData roll = entity
                        .getBasePilotingRoll(overallMoveType);

                entity.addPilotingModifierForTerrain(roll);

                // Add a +4 modifier.
                roll.addModifier(4, "dislodge swarming infantry");

                // If the swarmer has Assault claws, give a 1 modifier.
                // We can stop looking when we find our first match.
                if (swarmer.hasWorkingMisc(MiscType.F_MAGNET_CLAW, -1)) {
                    roll.addModifier(1, "swarmer has magnetic claws");
                }

                // okay, print the info
                r = new Report(2125);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);

                // roll
                final int diceRoll = Compute.d6(2);
                r = new Report(2130);
                r.subject = entity.getId();
                r.add(roll.getValueAsString());
                r.add(roll.getDesc());
                r.add(diceRoll);
                if (diceRoll < roll.getValue()) {
                    r.choose(false);
                    addReport(r);
                } else {
                    // Dislodged swarmers don't get turns.
                    game.removeTurnFor(swarmer);
                    send(createTurnVectorPacket());

                    // Update the report and the swarmer's status.
                    r.choose(true);
                    addReport(r);
                    entity.setSwarmAttackerId(Entity.NONE);
                    swarmer.setSwarmTargetId(Entity.NONE);

                    // Did the infantry fall into water?
                    if (curHex.terrainLevel(Terrains.WATER) > 0) {
                        // Swarming infantry die.
                        swarmer.setPosition(curPos);
                        r = new Report(2135);
                        r.subject = entity.getId();
                        r.indent();
                        r.addDesc(swarmer);
                        addReport(r);
                        addReport(destroyEntity(swarmer, "a watery grave",
                                                false));
                    } else {
                        // Swarming infantry take a 3d6 point hit.
                        // ASSUMPTION : damage should not be doubled.
                        r = new Report(2140);
                        r.subject = entity.getId();
                        r.indent();
                        r.addDesc(swarmer);
                        r.add("3d6");
                        addReport(r);
                        addReport(damageEntity(swarmer,
                                               swarmer.rollHitLocation(ToHitData.HIT_NORMAL,
                                                                       ToHitData.SIDE_FRONT), Compute.d6(3)));
                        addNewLines();
                        swarmer.setPosition(curPos);
                    }
                    entityUpdate(swarmerId);
                } // End successful-PSR

            } // End try-to-dislodge-swarmers

            // one more check for inferno wash-off
            checkForWashedInfernos(entity, curPos);

            // a jumping tank needs to roll for movement damage
            if (entity instanceof Tank) {
                int modifier = 0;
                if (curHex.containsTerrain(Terrains.ROUGH)
                    || curHex.containsTerrain(Terrains.WOODS)
                    || curHex.containsTerrain(Terrains.JUNGLE)) {
                    modifier = 1;
                }
                r = new Report(2126);
                r.subject = entity.getId();
                r.addDesc(entity);
                vPhaseReport.add(r);
                vPhaseReport.addAll(vehicleMotiveDamage((Tank) entity,
                                                        modifier, false, -1, true));
                Report.addNewline(vPhaseReport);
            }

        } // End entity-is-jumping
        // update entity's locations' exposure
        vPhaseReport.addAll(doSetLocationsExposure(entity, game.getBoard()
                                                               .getHex(curPos), false, entity.getElevation()));

        // Check the falls_end_movement option to see if it should be able to
        // move on.
        // Need to check here if the 'Mech actually went from non-prone to prone
        // here because 'fellDuringMovement' is sometimes abused just to force
        // another turn and so doesn't reliably tell us.
        if (!(game.getOptions().booleanOption("falls_end_movement")
              && (entity instanceof Mech) && !wasProne && entity.isProne())
            && (fellDuringMovement && !entity.isCarefulStand()) // Careful standing takes up the whole turn
            && !turnOver
            && (entity.mpUsed < entity.getRunMP())
            && entity.isSelectableThisTurn() && !entity.isDoomed()) {
            entity.applyDamage();
            entity.setDone(false);
            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity
                    .getOwner().getId(), entity.getId());
            // Need to set the new turn's multiTurn state
            newTurn.setMultiTurn(true);
            game.insertNextTurn(newTurn);
            // brief everybody on the turn update
            send(createTurnVectorPacket());
            // let everyone know about what just happened
            send(entity.getOwner().getId(), createSpecialReportPacket());
        } else {
            if ((entity.getMovementMode() == EntityMovementMode.WIGE)
                && (entity.getElevation() > 0)) {
                if (!wigeStartedLanded && (entity.delta_distance < 5)) {
                    // try to land safely
                    r = new Report(2123);
                    r.addDesc(entity);
                    r.subject = entity.getId();
                    vPhaseReport.add(r);
                    // when no clear or pavement, crash
                    IHex hex = game.getBoard().getHex(curPos);
                    if (!hex.hasPavement() && (hex.terrainsPresent() > 0)) {
                        // crash
                        r = new Report(2124);
                        r.addDesc(entity);
                        r.subject = entity.getId();
                        vPhaseReport.add(r);
                        vPhaseReport.addAll(crashVTOLorWiGE((Tank) entity));
                    } else {
                        entity.setElevation(0);
                    }
                } else {
                    // we didn't land, so we go to elevation 1 above the terrain
                    // features
                    // it might have been higher than one due to the extra MPs
                    // it can spend to stay higher during movement, but should
                    // end up at one
                    IHex hex = game.getBoard().getHex(curPos);
                    entity.setElevation(1 + hex.maxTerrainFeatureElevation(game
                            .getBoard().inAtmosphere()));
                }
            }
            entity.setDone(true);
        }

        if (dropshipStillUnloading) {
            // turns should have already been inserted but we need to set the
            // entity as not done
            entity.setDone(false);
        }

        // If the entity is being swarmed, update the attacker's position.
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            swarmer.setPosition(curPos);
            // If the hex is on fire, and the swarming infantry is
            // *not* Battle Armor, it drops off.
            if (!(swarmer instanceof BattleArmor)
                && game.getBoard().getHex(curPos)
                       .containsTerrain(Terrains.FIRE)) {
                swarmer.setSwarmTargetId(Entity.NONE);
                entity.setSwarmAttackerId(Entity.NONE);
                r = new Report(2145);
                r.subject = entity.getId();
                r.indent();
                r.add(swarmer.getShortName(), true);
                addReport(r);
            }
            entityUpdate(swarmerId);
        }

        // Update the entitiy's position,
        // unless it is off the game map.
        if (!game.isOutOfGame(entity)) {
            entityUpdate(entity.getId(), movePath, true, losCache);
            if (entity.isDoomed()) {
                send(createRemoveEntityPacket(entity.getId(),
                                              entity.getRemovalCondition()));
            }
        }

        // recovered units should now be recovered and dealt with
        if ((entity instanceof Aero) && recovered && (loader != null)) {

            if (loader.isCapitalFighter()) {
                if (!(loader instanceof FighterSquadron)) {
                    // this is a solo capital fighter so we need to add a new
                    // squadron and load both the loader and loadee
                    FighterSquadron fs = new FighterSquadron();
                    fs.setDeployed(true);
                    fs.setId(getFreeEntityId());
                    fs.setCurrentVelocity(((Aero) loader).getCurrentVelocity());
                    fs.setNextVelocity(((Aero) loader).getNextVelocity());
                    fs.setVectors(loader.getVectors());
                    fs.setFacing(loader.getFacing());
                    fs.setOwner(entity.getOwner());
                    // set velocity and heading the same as parent entity
                    game.addEntity(fs);
                    send(createAddEntityPacket(fs.getId()));
                    // make him not get a move this turn
                    fs.setDone(true);
                    // place on board
                    fs.setPosition(loader.getPosition());
                    loadUnit(fs, loader, -1);
                    loader = fs;
                    entityUpdate(fs.getId());
                }
                loader.load(entity);
            } else {
                loader.recover(entity);
                entity.setRecoveryTurn(5);
            }

            // The loaded unit is being carried by the loader.
            entity.setTransportId(loader.getId());

            // Remove the loaded unit from the screen.
            entity.setPosition(null);

            // Update the loaded unit.
            entityUpdate(entity.getId());
        }

        // even if load was unsuccessful, I may need to update the loader
        if (null != loader) {
            entityUpdate(loader.getId());
        }

        // if using double blind, update the player on new units he might see
        if (doBlind()) {
            send(entity.getOwner().getId(),
                 createFilteredEntitiesPacket(entity.getOwner(), losCache));
        }

        // if we generated a charge attack, report it now
        if (charge != null) {
            send(createAttackPacket(charge, 1));
        }

        // if we generated a ram attack, report it now
        if (ram != null) {
            send(createAttackPacket(ram, 1));
        }
        if ((entity instanceof Mech)
            && ((Mech) entity).isIndustrial()
            && !((Mech) entity).hasEnvironmentalSealing()
            && (entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)) {
            if ((!entity.isProne() && (game.getBoard()
                                           .getHex(entity.getPosition()).terrainLevel(Terrains.WATER) >= 2))
                || (entity.isProne() && (game.getBoard()
                                             .getHex(entity.getPosition())
                                             .terrainLevel(Terrains.WATER) == 1))) {
                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(true);

            } else {
                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(false);
            }
        }
    }

    /**
     * If an aero unit takes off in the same turn that other units loaded, then
     * it risks damage to itself and those units
     *
     * @param a - The <code>Aero</code> taking off
     */
    private void checkForTakeoffDamage(Aero a) {

        boolean unsecured = false;
        for (Entity loaded : a.getLoadedUnits()) {
            if (loaded.wasLoadedThisTurn() && !(loaded instanceof Infantry)) {
                unsecured = true;
                // uh-oh, you forgot your seatbelt
                Report r = new Report(6800);
                r.subject = loaded.getId();
                r.addDesc(loaded);
                addReport(r);
                int damage = 25;
                ToHitData toHit = new ToHitData();
                while (damage > 0) {
                    HitData hit = loaded.rollHitLocation(toHit.getHitTable(),
                                                         ToHitData.SIDE_FRONT);
                    addReport(damageEntity(loaded, hit, 5, false,
                                           DamageType.NONE, false, true, false));
                    damage -= 5;
                }
            }
        }
        if (unsecured) {
            // roll hit location to get a new critical
            HitData hit = a.rollHitLocation(ToHitData.HIT_ABOVE,
                                            ToHitData.SIDE_FRONT);
            addReport(applyCriticalHit(a, hit.getLocation(), new CriticalSlot(
                    0, a.getPotCrit()), true, 1, false));
        }

    }

    /**
     * Delivers a thunder-aug shot to the targetted hex area. Thunder-Augs are 7
     * hexes, though, so...
     *
     * @param damage
     *            The per-hex density of the incoming minefield; that is, the
     *            final value with any modifiers (such as halving and rounding
     *            just for <em>being</em> T-Aug) already applied.
     */
    public void deliverThunderAugMinefield(Coords coords, int playerId,
            int damage, int entityId) {
        Coords mfCoord = null;
        for (int dir = 0; dir < 7; dir++) {
            // May need to reset here for each new hex.
            int hexDamage = damage;
            switch (dir) {
                case 6:
                    // The targeted hex.
                    mfCoord = new Coords(coords);
                    break;
                default:
                    // The hex in the dir direction from the targeted hex.
                    mfCoord = coords.translated(dir);
                    break;
            }

            // Only if this is on the board...
            if (game.getBoard().contains(mfCoord)) {
                Minefield minefield = null;
                Enumeration<Minefield> minefields = game.getMinefields(mfCoord)
                        .elements();
                // Check if there already are Thunder minefields in the hex.
                while (minefields.hasMoreElements()) {
                    Minefield mf = minefields.nextElement();
                    if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                        minefield = mf;
                        break;
                    }
                }

                // Did we find a Thunder minefield in the hex?
                // N.B. damage Thunder minefields equals the number of
                // missiles, divided by two, rounded up.
                if (minefield == null) {
                    // Nope. Create a new Thunder minefield
                    minefield = Minefield.createMinefield(mfCoord, playerId,
                            Minefield.TYPE_CONVENTIONAL, hexDamage);
                    game.addMinefield(minefield);
                    checkForRevealMinefield(minefield, game.getEntity(entityId));
                } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
                    // Yup. Replace the old one.
                    removeMinefield(minefield);
                    hexDamage += minefield.getDensity();

                    // Damage from Thunder minefields are capped.
                    if (hexDamage > Minefield.MAX_DAMAGE) {
                        hexDamage = Minefield.MAX_DAMAGE;
                    }
                    minefield.setDensity(hexDamage);
                    game.addMinefield(minefield);
                    checkForRevealMinefield(minefield, game.getEntity(entityId));
                }
            } // End coords-on-board

        } // Handle the next coords

    }

    /**
     * Adds a Thunder minefield to the hex.
     *
     * @param coords
     * @param playerId
     * @param damage
     */
    public void deliverThunderMinefield(Coords coords, int playerId,
            int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords)
                .elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId,
                    Minefield.TYPE_CONVENTIONAL, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = damage > Minefield.MAX_DAMAGE ? Minefield.MAX_DAMAGE
                    : damage;
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Adds a Thunder Inferno minefield to the hex.
     *
     * @param coords
     * @param playerId
     * @param damage
     */
    public void deliverThunderInfernoMinefield(Coords coords, int playerId,
            int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords)
                .elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_INFERNO) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder Inferno minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId,
                    Minefield.TYPE_INFERNO, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = damage > Minefield.MAX_DAMAGE ? Minefield.MAX_DAMAGE
                    : damage;
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Delivers an artillery FASCAM shot to the targetted hex area.
     */
    public void deliverFASCAMMinefield(Coords coords, int playerId, int damage,
            int entityId) {
        // Only if this is on the board...
        if (game.getBoard().contains(coords)) {
            Minefield minefield = null;
            Enumeration<Minefield> minefields = game.getMinefields(coords)
                    .elements();
            // Check if there already are Thunder minefields in the hex.
            while (minefields.hasMoreElements()) {
                Minefield mf = minefields.nextElement();
                if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                    minefield = mf;
                    break;
                }
            }
            // Did we find a Thunder minefield in the hex?
            if (minefield == null) {
                minefield = Minefield.createMinefield(coords, playerId,
                        Minefield.TYPE_CONVENTIONAL, damage);
                game.addMinefield(minefield);
                checkForRevealMinefield(minefield, game.getEntity(entityId));
            } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
                // Add to the old one.
                removeMinefield(minefield);
                int oldDamage = minefield.getDensity();
                damage += oldDamage;
                damage = damage > Minefield.MAX_DAMAGE ? Minefield.MAX_DAMAGE
                        : damage;
                minefield.setDensity(damage);
                game.addMinefield(minefield);
                checkForRevealMinefield(minefield, game.getEntity(entityId));
            }
        } // End coords-on-board
    }

    /**
     * Adds a Thunder-Active minefield to the hex.
     */
    public void deliverThunderActiveMinefield(Coords coords, int playerId,
            int damage, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords)
                .elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_ACTIVE) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder-Active minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId,
                    Minefield.TYPE_ACTIVE, damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = damage > Minefield.MAX_DAMAGE ? Minefield.MAX_DAMAGE
                    : damage;
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Adds a Thunder-Vibrabomb minefield to the hex.
     */
    public void deliverThunderVibraMinefield(Coords coords, int playerId,
            int damage, int sensitivity, int entityId) {
        Minefield minefield = null;
        Enumeration<Minefield> minefields = game.getMinefields(coords)
                .elements();
        // Check if there already are Thunder minefields in the hex.
        while (minefields.hasMoreElements()) {
            Minefield mf = minefields.nextElement();
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                minefield = mf;
                break;
            }
        }

        // Create a new Thunder-Vibra minefield
        if (minefield == null) {
            minefield = Minefield.createMinefield(coords, playerId,
                    Minefield.TYPE_VIBRABOMB, damage, sensitivity);
            game.addMinefield(minefield);
            game.addVibrabomb(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        } else if (minefield.getDensity() < Minefield.MAX_DAMAGE) {
            // Add to the old one
            removeMinefield(minefield);
            int oldDamage = minefield.getDensity();
            damage += oldDamage;
            damage = damage > Minefield.MAX_DAMAGE ? Minefield.MAX_DAMAGE
                    : damage;
            minefield.setDensity(damage);
            game.addMinefield(minefield);
            game.addVibrabomb(minefield);
            checkForRevealMinefield(minefield, game.getEntity(entityId));
        }
    }

    /**
     * Creates an artillery flare of the given radius above the target
     */
    public void deliverArtilleryFlare(Coords coords, int radius) {
        Flare flare = new Flare(coords, 5, radius, Flare.F_DRIFTING);
        game.addFlare(flare);
    }

    public void deliverMortarFlare(Coords coords, int duration) {
        Flare flare = new Flare(coords, duration, 1, Flare.F_IGNITED);
        game.addFlare(flare);
    }

    /**
     * deliver missile smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */

    public void deliverMissileSmoke(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, 3);
        sendChangedHex(coords);
    }

    public void deliverSmokeGrenade(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_LIGHT, 3);
        sendChangedHex(coords);
    }

    public void deliverSmokeMortar(Coords coords, Vector<Report> vPhaseReport,
            int duration) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, duration);
        sendChangedHex(coords);
    }

    public void deliverChaffGrenade(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5186, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_CHAFF_LIGHT, 1);
        sendChangedHex(coords);
    }

    /**
     * deliver artillery smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */
    public void deliverArtillerySmoke(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5185, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, 3);
        sendChangedHex(coords);
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            r = new Report(5185, Report.PUBLIC);
            r.indent(2);
            r.add(tempcoords.getBoardNum());
            vPhaseReport.add(r);
            createSmoke(tempcoords, 2, 3);
            sendChangedHex(tempcoords);
        }
    }

    /**
     * deliver LASER inhibiting smoke
     *
     * @param coords the <code>Coords</code> where to deliver
     */
    public void deliverLIsmoke(Coords coords, Vector<Report> vPhaseReport) {
        Report r = new Report(5186, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        createSmoke(coords, SmokeCloud.SMOKE_LI_HEAVY, 2);
        sendChangedHex(coords);
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            r = new Report(5186, Report.PUBLIC);
            r.indent(2);
            r.add(tempcoords.getBoardNum());
            vPhaseReport.add(r);
            createSmoke(tempcoords, SmokeCloud.SMOKE_LI_HEAVY, 2);
            sendChangedHex(tempcoords);
        }
    }

    /**
     * deliver artillery inferno
     *
     * @param coords    the <code>Coords</code> where to deliver
     * @param ae        the attacking <code>entity<code>
     * @param subjectId the <code>int</code> id of the target
     */
    public void deliverArtilleryInferno(Coords coords, Entity ae,
                                        int subjectId, Vector<Report> vPhaseReport) {
        IHex h = game.getBoard().getHex(coords);
        Report r;
        // Unless there is a fire in the hex already, start one.
        if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_IV) {
            ignite(coords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);
        }
        // possibly melt ice and snow
        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {
            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));
        }
        for (Entity entity : game.getEntitiesVector(coords)) {
            // TacOps, p. 356 - treat as if hit by 5 inferno missiles
            r = new Report(6695);
            r.indent(3);
            r.add(entity.getDisplayName());
            r.subject = entity.getId();
            r.newlines = 0;
            vPhaseReport.add(r);
            if (entity instanceof Tank) {
                Report.addNewline(vPhaseReport);
            }
            Vector<Report> vDamageReport = deliverInfernoMissiles(ae, entity, 5);
            Report.indentAll(vDamageReport, 2);
            vPhaseReport.addAll(vDamageReport);
        }
        for (int dir = 0; dir <= 5; dir++) {
            Coords tempcoords = coords.translated(dir);
            if (!game.getBoard().contains(tempcoords)) {
                continue;
            }
            if (coords.equals(tempcoords)) {
                continue;
            }
            h = game.getBoard().getHex(tempcoords);
            // Unless there is a fire in the hex already, start one.
            if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_IV) {
                ignite(tempcoords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);
            }
            // possibly melt ice and snow
            if (h.containsTerrain(Terrains.ICE)
                || h.containsTerrain(Terrains.SNOW)) {
                vPhaseReport.addAll(meltIceAndSnow(tempcoords, subjectId));
            }
            for (Entity entity : game.getEntitiesVector(tempcoords)) {
                r = new Report(6695);
                r.indent(3);
                r.add(entity.getDisplayName());
                r.newlines = 0;
                r.subject = entity.getId();
                vPhaseReport.add(r);
                if (entity instanceof Tank) {
                    Report.addNewline(vPhaseReport);
                }
                Vector<Report> vDamageReport = deliverInfernoMissiles(ae,
                        entity, 5);
                Report.indentAll(vDamageReport, 2);
                vPhaseReport.addAll(vDamageReport);
            }
        }
    }

    public void deliverScreen(Coords coords, Vector<Report> vPhaseReport) {
        IHex h = game.getBoard().getHex(coords);
        Report r;
        Report.addNewline(vPhaseReport);
        r = new Report(9070, Report.PUBLIC);
        r.indent(2);
        r.add(coords.getBoardNum());
        vPhaseReport.add(r);
        // use level to count the number of screens (since level does not matter
        // in space)
        int nscreens = h.terrainLevel(Terrains.SCREEN);
        if (nscreens > 0) {
            h.removeTerrain(Terrains.SCREEN);
            h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                    Terrains.SCREEN, nscreens + 1));
        } else {
            h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                    Terrains.SCREEN, 1));
        }
        sendChangedHex(coords);
    }

    /**
     * deploys a new tele-missile entity onto the map
     */
    public void deployTeleMissile(Entity ae, AmmoType atype, int wId,
                                  int capMisMod, Vector<Report> vPhaseReport) {
        Report r = new Report(9080);
        r.subject = ae.getId();
        r.addDesc(ae);
        r.indent(2);
        r.newlines = 0;
        r.add(atype.getName());
        vPhaseReport.add(r);
        TeleMissile tele = new TeleMissile(ae, atype.getDamagePerShot(),
                                           atype.getTonnage(ae), atype.getAmmoType(), capMisMod);
        tele.setDeployed(true);
        tele.setId(getFreeEntityId());
        if (ae instanceof Aero) {
            Aero a = (Aero) ae;
            tele.setCurrentVelocity(a.getCurrentVelocity());
            tele.setNextVelocity(a.getNextVelocity());
            tele.setVectors(a.getVectors());
            tele.setFacing(a.getFacing());
        }
        // set velocity and heading the same as parent entity
        game.addEntity(tele);
        send(createAddEntityPacket(tele.getId()));
        // make him not get a move this turn
        tele.setDone(true);
        // place on board
        tele.setPosition(ae.getPosition());
        // Update the entity
        entityUpdate(tele.getId());
        // check to see if the launching of this missile removes control of any
        // prior missiles
        if (ae.getTMTracker().containsLauncher(wId)) {
            Entity priorMissile = game.getEntity(ae.getTMTracker().getMissile(
                    wId));
            if ((null != priorMissile) && (priorMissile instanceof TeleMissile)) {
                ((TeleMissile) priorMissile).setOutContact(true);
                // remove this from the tracker for good measure
                ae.getTMTracker().removeMissile(wId);
            }
        }
        // track this missile on the entity
        ae.getTMTracker().addMissile(wId, tele.getId());
    }

    /**
     * deliver inferno missiles
     *
     * @param ae       the <code>Entity</code> that fired the missiles
     * @param t        the <code>Targetable</code> that is the target
     * @param missiles the <code>int</code> amount of missiles
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t,
                                                 int missiles) {
        return deliverInfernoMissiles(ae, t, missiles, CalledShot.CALLED_NONE);
    }

    /**
     * deliver inferno missiles
     *
     * @param ae       the <code>Entity</code> that fired the missiles
     * @param t        the <code>Targetable</code> that is the target
     * @param missiles the <code>int</code> amount of missiles
     * @param called   an <code>int</code> indicated the aiming mode used to fire the
     *                 inferno missiles (for called shots)
     */
    public Vector<Report> deliverInfernoMissiles(Entity ae, Targetable t,
                                                 int missiles, int called) {
        IHex hex = game.getBoard().getHex(t.getPosition());
        Report r;
        Vector<Report> vPhaseReport = new Vector<Report>();
        switch (t.getTargetType()) {
            case Targetable.TYPE_HEX_ARTILLERY:
                // used for BA inferno explosion
                for (Entity e : game.getEntitiesVector(t.getPosition())) {
                    if (e.getElevation() > hex.terrainLevel(Terrains.BLDG_ELEV)) {
                        r = new Report(6685);
                        r.subject = e.getId();
                        r.addDesc(e);
                        vPhaseReport.add(r);
                        vPhaseReport.addAll(deliverInfernoMissiles(ae, e, missiles,
                                                                   called));
                    } else {
                        int roll = Compute.d6();
                        r = new Report(3570);
                        r.subject = e.getId();
                        r.addDesc(e);
                        r.add(roll);
                        vPhaseReport.add(r);
                        if (roll >= 5) {
                            vPhaseReport.addAll(deliverInfernoMissiles(ae, e,
                                                                       missiles, called));
                        }
                    }
                }
                if (game.getBoard().getBuildingAt(t.getPosition()) != null) {
                    Vector<Report> vBuildingReport = damageBuilding(game.getBoard()
                                                                        .getBuildingAt(t.getPosition()), 2 * missiles,
                                                                    t.getPosition());
                    for (Report report : vBuildingReport) {
                        report.subject = ae.getId();
                    }
                    vPhaseReport.addAll(vBuildingReport);
                }
                // fall through
            case Targetable.TYPE_HEX_CLEAR:
            case Targetable.TYPE_HEX_IGNITE:
                // Report that damage applied to terrain, if there's TF to damage
                IHex h = game.getBoard().getHex(t.getPosition());
                if ((h != null) && h.hasTerrainfactor()) {
                    r = new Report(3384);
                    r.indent(2);
                    r.subject = ae.getId();
                    r.add(t.getPosition().getBoardNum());
                    r.add(missiles * 4);
                    vPhaseReport.addElement(r);
                }
                vPhaseReport.addAll(tryClearHex(t.getPosition(), missiles * 4,
                                                ae.getId()));
                tryIgniteHex(t.getPosition(), ae.getId(), false, true,
                             new TargetRoll(0, "inferno"), -1, vPhaseReport);
                break;
            case Targetable.TYPE_BLDG_IGNITE:
            case Targetable.TYPE_BUILDING:
                Vector<Report> vBuildingReport = damageBuilding(game.getBoard()
                                                                    .getBuildingAt(t.getPosition()), 2 * missiles,
                                                                t.getPosition());
                for (Report report : vBuildingReport) {
                    report.subject = ae.getId();
                }
                vPhaseReport.addAll(vBuildingReport);

                // For each missile, check to see if it hits a unit in this hex
                for (Entity e : game.getEntitiesVector(t.getPosition())) {
                    if (e.getElevation() > hex.terrainLevel(Terrains.BLDG_ELEV)) {
                        continue;
                    }
                    for (int m = 0; m < missiles; m++) {
                        int roll = Compute.d6();
                        r = new Report(3570);
                        r.subject = e.getId();
                        r.indent(3);
                        r.addDesc(e);
                        r.add(roll);
                        vPhaseReport.add(r);
                        if (roll >= 5) {
                            Vector<Report> dmgReports = deliverInfernoMissiles(ae,
                                    e, 1, called);
                            for (Report rep : dmgReports) {
                                rep.indent(4);
                            }
                            vPhaseReport.addAll(dmgReports);
                        }
                    }
                }

                break;
            case Targetable.TYPE_ENTITY:
                Entity te = (Entity) t;
                if (te instanceof Mech) {
                    // Bug #1585497: Check for partial cover
                    int m = missiles;
                    LosEffects le = LosEffects.calculateLos(game, ae.getId(), t);
                    int cover = le.getTargetCover();
                    Vector<Report> coverDamageReports = new Vector<Report>();
                    int heatDamage = 0;
                    boolean heatReduced = false;
                    String reductionCause = "";
                    for (int i = 0; i < m; i++) {
                        int side = Compute.targetSideTable(ae, t, called);
                        HitData hit = te
                                .rollHitLocation(ToHitData.HIT_NORMAL, side);
                        if (te.removePartialCoverHits(hit.getLocation(), cover,
                                                      side)) {
                            missiles--;
                            // Determine if damagable cover is hit
                            int damagableCoverType = LosEffects.DAMAGABLE_COVER_NONE;
                            Entity coverDropship = null;
                            Coords coverLoc = null;

                            // Determine if there is primary and secondary
                            // cover,
                            // and then determine which one gets hit
                            if (((cover == LosEffects.COVER_75RIGHT) || (cover == LosEffects.COVER_75LEFT))
                                ||
                                // 75% cover has a primary and secondary
                                ((cover == LosEffects.COVER_HORIZONTAL) && (le
                                                                                    .getDamagableCoverTypeSecondary()
                                                                            != LosEffects.DAMAGABLE_COVER_NONE))) {
                                // Horiztonal cover provided by two 25%'s,
                                // so primary and secondary
                                int hitLoc = hit.getLocation();
                                // Primary stores the left side, from the
                                // perspective of the attacker
                                if ((hitLoc == Mech.LOC_RLEG)
                                    || (hitLoc == Mech.LOC_RT)
                                    || (hitLoc == Mech.LOC_RARM)) {
                                    // Left side is primary
                                    damagableCoverType = le
                                            .getDamagableCoverTypePrimary();
                                    coverDropship = le.getCoverDropshipPrimary();
                                    coverLoc = le.getCoverLocPrimary();
                                } else {
                                    // If not left side, then right side,
                                    // which is secondary
                                    damagableCoverType = le
                                            .getDamagableCoverTypeSecondary();
                                    coverDropship = le.getCoverDropshipSecondary();
                                    coverLoc = le.getCoverLocSecondary();
                                }
                            } else { // Only primary cover exists
                                damagableCoverType = le
                                        .getDamagableCoverTypePrimary();
                                coverDropship = le.getCoverDropshipPrimary();
                                coverLoc = le.getCoverLocPrimary();
                            }

                            // Check if we need to damage the cover that
                            // absorbed
                            // the hit.
                            Vector<Report> coverDamageReport = new Vector<Report>();
                            if (damagableCoverType == LosEffects.DAMAGABLE_COVER_DROPSHIP) {
                                r = new Report(3465);
                                r.addDesc(coverDropship);
                                r.indent(1);
                                coverDamageReport = deliverInfernoMissiles(ae,
                                                                           coverDropship, 1, CalledShot.CALLED_NONE);
                                coverDamageReport.insertElementAt(r, 0);
                                for (Report report : coverDamageReport) {
                                    report.indent(1);
                                }
                            } else if (damagableCoverType == LosEffects.DAMAGABLE_COVER_BUILDING) {
                                BuildingTarget bldgTrgt = new BuildingTarget(
                                        coverLoc, game.getBoard(), false);
                                coverDamageReport = deliverInfernoMissiles(ae,
                                                                           bldgTrgt, 1, CalledShot.CALLED_NONE);
                            }
                            for (Report report : coverDamageReport) {
                                report.indent(1);
                            }
                            coverDamageReports.addAll(coverDamageReport);
                        } else { // No partial cover, missile hits
                            if ((te.getArmor(hit) > 0)
                                && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAT_DISSIPATING)) {
                                heatDamage += 1;
                                heatReduced = true;
                                reductionCause = EquipmentType.armorNames[te
                                        .getArmorType(hit.getLocation())];
                            } else {
                                heatDamage += 2;
                            }
                        }
                    }
                    if (heatReduced) {
                        r = new Report(3406);
                        r.add(heatDamage);
                        r.subject = te.getId();
                        r.indent(2);
                        r.choose(true);
                        r.add(missiles * 2);
                        r.add(reductionCause);
                    } else {
                        r = new Report(3400);
                        r.add(heatDamage);
                        r.subject = te.getId();
                        r.indent(2);
                        r.choose(true);
                    }
                    vPhaseReport.add(r);
                    Report.addNewline(vPhaseReport);
                    te.heatFromExternal += heatDamage;

                    if (missiles != m) {
                        r = new Report(3403);
                        r.add(m - missiles);
                        r.indent(2);
                        r.subject = te.getId();
                        vPhaseReport.add(r);
                    }
                    vPhaseReport.addAll(coverDamageReports);
                    Report.addNewline(vPhaseReport);
                } else if (te instanceof Aero) {
                    r = new Report(3400);
                    r.add(2 * missiles);
                    r.subject = te.getId();
                    r.indent(2);
                    r.choose(true);
                    vPhaseReport.add(r);
                    te.heatFromExternal += 2 * missiles;
                    Report.addNewline(vPhaseReport);
                } else if (te instanceof Tank) {
                    boolean targetIsSupportVee = (te instanceof SupportTank)
                                                 || (te instanceof LargeSupportTank)
                                                 || (te instanceof SupportVTOL);
                    int direction = Compute.targetSideTable(ae, te, called);
                    while (missiles-- > 0) {
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         direction);
                        int critRollMod = 0;
                        if (!targetIsSupportVee
                            || (te.hasArmoredChassis() && (te.getBARRating(hit
                                                                                   .getLocation()) > 9))) {
                            critRollMod -= 2;
                        }
                        if ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED)
                            && (te.getArmor(hit.getLocation()) > 0)) {
                            critRollMod -= 2;
                        }
                        vPhaseReport.addAll(criticalEntity(te, hit.getLocation(),
                                                           hit.isRear(), critRollMod, 0, true));
                    }
                } else if (te instanceof Protomech) {
                    te.heatFromExternal += missiles;
                    while (te.heatFromExternal >= 3) {
                        te.heatFromExternal -= 3;
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         ToHitData.SIDE_FRONT);
                        if (hit.getLocation() == Protomech.LOC_NMISS) {
                            r = new Report(6035);
                            r.subject = te.getId();
                            r.indent(2);
                            vPhaseReport.add(r);
                        } else {
                            r = new Report(6690);
                            r.subject = te.getId();
                            r.indent(2);
                            r.add(te.getLocationName(hit));
                            vPhaseReport.add(r);
                            te.destroyLocation(hit.getLocation());
                            // Handle Protomech pilot damage
                            // due to location destruction
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit
                                    .getLocation()]
                                       - ((Protomech) te).getPilotDamageTaken(hit
                                                                                      .getLocation());
                            if (hits > 0) {
                                vPhaseReport.addAll(damageCrew(te, hits));
                                ((Protomech) te).setPilotDamageTaken(hit
                                                                             .getLocation(),
                                                                     Protomech.POSSIBLE_PILOT_DAMAGE[hit
                                                                             .getLocation()]);
                            }
                            if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                                vPhaseReport.addAll(destroyEntity(te,
                                                                  "flaming inferno death", false, true));
                                Report.addNewline(vPhaseReport);
                            }
                        }
                    }
                } else if (te instanceof BattleArmor) {
                    if (((BattleArmor) te).isFireResistant()) {
                        r = new Report(3395);
                        r.indent(2);
                        r.subject = te.getId();
                        r.addDesc(te);
                        vPhaseReport.add(r);
                        return vPhaseReport;
                    }
                    te.heatFromExternal += missiles;
                    while (te.heatFromExternal >= 3) {
                        te.heatFromExternal -= 3;
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         ToHitData.SIDE_FRONT);
                        hit.setEffect(HitData.EFFECT_CRITICAL);
                        vPhaseReport.addAll(damageEntity(te, hit, 1));
                        Report.addNewline(vPhaseReport);
                    }
                } else if (te instanceof Infantry) {
                    HitData hit = new HitData(Infantry.LOC_INFANTRY);
                    if (te.getInternal(hit) > (3 * missiles)) {
                        // internal structure absorbs all damage
                        te.setInternal(te.getInternal(hit) - (3 * missiles), hit);
                        r = new Report(6065);
                        r.addDesc(te);
                        r.add(3 * missiles);
                        r.indent(2);
                        r.add(te.getLocationAbbr(hit));
                        r.newlines = 0;
                        r.subject = te.getId();
                        vPhaseReport.add(r);
                        Report.addNewline(vPhaseReport);
                        r = new Report(6095);
                        r.add(te.getInternal(hit));
                        r.subject = te.getId();
                        r.indent(3);
                        vPhaseReport.add(r);
                    } else {
                        vPhaseReport.addAll(destroyEntity(te, "damage", false));
                        Report.addNewline(vPhaseReport);
                    }
                } else {
                    // gun emplacements
                    int direction = Compute.targetSideTable(ae, te, called);
                    while (missiles-- > 0) {
                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         direction);
                        vPhaseReport.addAll(damageEntity(te, hit, 2));
                    }
                }
        }
        return vPhaseReport;
    }

    /**
     * Check for any detonations when an entity enters a minefield, except a
     * vibrabomb.
     *
     * @param entity
     *            - the <code>entity</code> who entered the minefield
     * @param c
     *            - the <code>Coords</code> of the minefield
     * @param curElev
     *            - an <code>int</code> for the elevation of the entity entering
     *            the minefield (used for underwater sea mines)
     * @param isOnGround
     *            - <code>true</code> if the entity is not in the middle of a
     *            jump
     * @param vMineReport
     *            - the report vector that reports will be added to
     * @return - <code>true</code> if the entity set off any mines
     */
    private boolean enterMinefield(Entity entity, Coords c, int curElev,
            boolean isOnGround, Vector<Report> vMineReport) {
        return enterMinefield(entity, c, curElev, isOnGround, vMineReport, -1);
    }

    /**
     * Check for any detonations when an entity enters a minefield, except a
     * vibrabomb.
     *
     * @param entity
     *            - the <code>entity</code> who entered the minefield
     * @param c
     *            - the <code>Coords</code> of the minefield
     * @param curElev
     *            - an <code>int</code> for the elevation of the entity entering
     *            the minefield (used for underwater sea mines)
     * @param isOnGround
     *            - <code>true</code> if the entity is not in the middle of a
     *            jump
     * @param vMineReport
     *            - the report vector that reports will be added to
     * @param target
     *            - the <code>int</code> target number for detonation. If this
     *            will be determined by density, it should be -1
     * @return - <code>true</code> if the entity set off any mines
     */
    private boolean enterMinefield(Entity entity, Coords c, int curElev,
            boolean isOnGround, Vector<Report> vMineReport, int target) {
        Report r;
        boolean trippedMine = false;
        // flying units cannot trip a mine
        if (curElev > 0) {
            return false;
        }

        // Check for Mine sweepers
        Mounted minesweeper = null;
        for (Mounted m : entity.getMisc()) {
            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) && m.isReady()
                    && (m.getArmorValue() > 0)) {
                minesweeper = m;
                break; // Can only have one minesweeper
            }
        }

        Vector<Minefield> fieldsToRemove = new Vector<>();
        // loop through mines in this hex
        for (Minefield mf : game.getMinefields(c)) {

            // vibrabombs are handled differently
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                continue;
            }

            // if we are in the water, then the sea mine will only blow up if at
            // the right depth
            if (game.getBoard().getHex(mf.getCoords())
                    .containsTerrain(Terrains.WATER)) {
                if ((Math.abs(curElev) != mf.getDepth())
                    && (Math.abs(curElev + entity.getHeight()) != mf
                        .getDepth())) {
                    continue;
                }
            }

            // Check for mine-sweeping.  Vibra mines handled elsewhere
            if ((minesweeper != null)
                    && ((mf.getType() == Minefield.TYPE_CONVENTIONAL)
                            || (mf.getType() == Minefield.TYPE_ACTIVE)
                            || (mf.getType() == Minefield.TYPE_INFERNO))) {
                // Check to see if the minesweeper clears
                int roll = Compute.d6(2);

                // Report minefield roll
                if (doBlind()) { // only report if DB, otherwise all players see
                r = new Report(2152);
                r.player = mf.getPlayerId();
                r.add(Minefield.getDisplayableName(mf.getType()));
                r.add(mf.getCoords().getBoardNum());
                r.add(roll);
                r.newlines = 0;
                vMineReport.add(r);
                }

                if (roll >= 6) {
                    // Report hit
                    if (doBlind()) {
                        r = new Report(5543);
                        r.player = mf.getPlayerId();
                        vMineReport.add(r);
                    }

                    // Clear the minefield
                    r = new Report(2158);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(Minefield.getDisplayableName(mf.getType()), true);
                    r.add(mf.getCoords().getBoardNum(), true);
                    r.indent();
                    vMineReport.add(r);
                    fieldsToRemove.add(mf);

                    // Handle armor value damage
                    int remainingAV = minesweeper.getArmorValue() - 6;
                    minesweeper.setArmorValue(Math.max(remainingAV, 0));

                    r = new Report(2161);
                    r.indent(2);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(6);
                    r.add(Math.max(remainingAV, 0));
                    vMineReport.add(r);

                    if (remainingAV <= 0) {
                        minesweeper.setDestroyed(true);
                    }
                    // Check for damage transfer
                    if (remainingAV < 0) {
                        int damage = Math.abs(remainingAV);
                        r = new Report(2162);
                        r.indent(2);
                        r.subject = entity.getId();
                        r.add(damage, true);
                        vMineReport.add(r);

                        // Damage is dealt to the location of minesweeper
                        HitData hit = new HitData(minesweeper.getLocation());
                        Vector<Report> damageReports = damageEntity(entity,
                                hit, damage);
                        for (Report r1 : damageReports) {
                            r1.indent(1);
                        }
                        vMineReport.addAll(damageReports);
                    }
                    Report.addNewline(vMineReport);
                    // If the minefield is cleared, we're done processing it
                    continue;
                } else {
                    // Report miss
                    if (doBlind()) {
                        r = new Report(5542);
                        r.player = mf.getPlayerId();
                        vMineReport.add(r);
                    }
                }
            }

            // check whether we have an active mine
            if ((mf.getType() == Minefield.TYPE_ACTIVE) && isOnGround) {
                continue;
            }
            if ((mf.getType() != Minefield.TYPE_ACTIVE) && !isOnGround) {
                continue;
            }

            // set the target number
            if (target == -1) {
                target = mf.getTrigger();
                if (mf.getType() == Minefield.TYPE_ACTIVE) {
                    target = 9;
                }
                if (entity instanceof Infantry) {
                    target += 1;
                }
                if ((entity.getMovementMode() == EntityMovementMode.HOVER)
                    || (entity.getMovementMode() == EntityMovementMode.WIGE)) {
                    target = 12;
                }
            }

            int roll = Compute.d6(2);

            // Report minefield roll
            if (doBlind()) { // Only do if DB, otherwise all players will see
                r = new Report(2151);
                r.player = mf.getPlayerId();
                r.add(Minefield.getDisplayableName(mf.getType()));
                r.add(mf.getCoords().getBoardNum());
                r.add(target);
                r.add(roll);
                r.newlines = 0;
                vMineReport.add(r);
            }

            if (roll < target) {
                // Report miss
                if (doBlind()) {
                    r = new Report(2217);
                    r.player = mf.getPlayerId();
                    vMineReport.add(r);
                }
                continue;
            }

            // Report hit
            if (doBlind()) {
                r = new Report(2270);
                r.player = mf.getPlayerId();
                vMineReport.add(r);
            }

            // apply damage
            trippedMine = true;
            // explodedMines.add(mf);
            mf.setDetonated(true);
            if (mf.getType() == Minefield.TYPE_INFERNO) {
                // report hitting an inferno mine
                r = new Report(2155);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                r.indent();
                vMineReport.add(r);
                vMineReport.addAll(deliverInfernoMissiles(entity, entity,
                        mf.getDensity() / 2));
            } else {
                r = new Report(2150);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                r.indent();
                vMineReport.add(r);
                int damage = mf.getDensity();
                while (damage > 0) {
                    int cur_damage = Math.min(5, damage);
                    damage = damage - cur_damage;
                    HitData hit;
                    if (minesweeper == null) {
                        hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE,
                                Minefield.TO_HIT_SIDE);
                    } else { // Minesweepers cause mines to hit minesweeper loc
                        hit = new HitData(minesweeper.getLocation());
                    }
                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));
                }
                if (entity instanceof Tank) {
                    // Tanks check for motive system damage from minefields as
                    // from a side hit even though the damage proper hits the
                    // front above; exact side doesn't matter, though.
                    Tank tank = (Tank) entity;
                    vMineReport.addAll(vehicleMotiveDamage(tank,
                            tank.getMotiveSideMod(ToHitData.SIDE_LEFT)));
                }
                Report.addNewline(vMineReport);
            }

            // check the direct reduction
            mf.checkReduction(0, true);
            revealMinefield(mf);
        }

        for (Minefield mf : fieldsToRemove) {
            removeMinefield(mf);
        }

        return trippedMine;
    }

    /**
     * cycle through all mines on the board, check to see whether they should do
     * collateral damage to other mines due to detonation, resets detonation to
     * false, and removes any mines whose density has been reduced to zero.
     */
    private void resetMines() {

        Enumeration<Coords> mineLoc = game.getMinedCoords();
        while (mineLoc.hasMoreElements()) {
            Coords c = mineLoc.nextElement();
            Enumeration<Minefield> minefields = game.getMinefields(c)
                                                    .elements();
            while (minefields.hasMoreElements()) {
                Minefield minefield = minefields.nextElement();
                if (minefield.hasDetonated()) {
                    minefield.setDetonated(false);
                    Enumeration<Minefield> otherMines = game.getMinefields(c)
                                                            .elements();
                    while (otherMines.hasMoreElements()) {
                        Minefield otherMine = otherMines.nextElement();
                        if (otherMine.equals(minefield)) {
                            continue;
                        }
                        int bonus = 0;
                        if (otherMine.getDensity() > minefield.getDensity()) {
                            bonus = 1;
                        }
                        if (otherMine.getDensity() < minefield.getDensity()) {
                            bonus = -1;
                        }
                        otherMine.checkReduction(bonus, false);
                    }
                }
            }
            // cycle through a second time to see if any mines at these coords
            // need to be removed
            ArrayList<Minefield> mfRemoved = new ArrayList<Minefield>();
            Enumeration<Minefield> mines = game.getMinefields(c).elements();
            while (mines.hasMoreElements()) {
                Minefield mine = mines.nextElement();
                if (mine.getDensity() < 5) {
                    mfRemoved.add(mine);
                }
            }
            // we have to do it this way to avoid a concurrent error problem
            for (Minefield mf : mfRemoved) {
                removeMinefield(mf);
            }
            // update the mines at these coords
            sendChangedMines(c);
        }
    }

    /**
     * attempt to clear a minefield
     *
     * @param mf     - a <code>Minefield</code> to clear
     * @param en     - <code>entity</code> doing the clearing
     * @param target - <code>int</code> needed to roll for a successful clearance
     * @return <code>true</code> if clearance successful
     */
    public boolean clearMinefield(Minefield mf, Entity en, int target,
                                  Vector<Report> vClearReport) {
        return clearMinefield(mf, en, target, -1, vClearReport, 2);
    }

    public boolean clearMinefield(Minefield mf, Entity en, int target,
                                  int botch, Vector<Report> vClearReport) {
        return clearMinefield(mf, en, target, botch, vClearReport, 1);
    }

    /**
     * attempt to clear a minefield We don't actually remove the minefield here,
     * because if this is called up from within a loop, that will cause problems
     *
     * @param mf
     *            - a <code>Minefield</code> to clear
     * @param en
     *            - <code>entity</code> doing the clearing
     * @param target
     *            - <code>int</code> needed to roll for a successful clearance
     * @param botch
     *            - <code>int</code> that indicates an accidental detonation
     * @param vClearReport
     *            - The report collection to report to
     * @param indent
     *            - The nubmer of indents for the report
     * @return <code>true</code> if clearance successful
     */
    public boolean clearMinefield(Minefield mf, Entity en, int target,
            int botch, Vector<Report> vClearReport, int indent) {
        Report r;
        int roll = Compute.d6(2);
        if (roll >= target) {
            r = new Report(2250);
            r.subject = en.getId();
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            r.indent(indent);
            vClearReport.add(r);
            return true;
        } else if (roll <= botch) {
            // TODO: detonate the minefield
            r = new Report(2255);
            r.subject = en.getId();
            r.indent(indent);
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            vClearReport.add(r);
            // The detonation damages any units that were also attempting to
            // clear mines in the same hex
            for (Entity victim : game.getEntitiesVector(mf.getCoords())) {
                Report rVictim;
                if (victim.isClearingMinefield()) {
                    rVictim = new Report(2265);
                    rVictim.subject = victim.getId();
                    rVictim.add(victim.getShortName(), true);
                    rVictim.indent(indent + 1);
                    vClearReport.add(rVictim);
                    int damage = mf.getDensity();
                    while (damage > 0) {
                        int cur_damage = Math.min(5, damage);
                        damage = damage - cur_damage;
                        HitData hit = victim.rollHitLocation(
                                Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
                        vClearReport.addAll(damageEntity(victim, hit,
                                                         cur_damage));
                    }
                }
            }
            // reduction works differently here
            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {
                mf.setDensity(Math.max(5, mf.getDensity() - 5));
            } else {
                // congratulations, you cleared the mine by blowing yourself up
                return true;
            }
        } else {
            // failure
            r = new Report(2260);
            r.subject = en.getId();
            r.indent(indent);
            r.add(Minefield.getDisplayableName(mf.getType()));
            r.add(target);
            r.add(roll);
            vClearReport.add(r);
        }
        return false;
    }

    /**
     * Clear any detonated mines at these coords
     */
    private void clearDetonatedMines(Coords c, int target) {

        Enumeration<Minefield> minefields = game.getMinefields(c).elements();
        ArrayList<Minefield> mfRemoved = new ArrayList<Minefield>();
        while (minefields.hasMoreElements()) {
            Minefield minefield = minefields.nextElement();
            if (minefield.hasDetonated() && (Compute.d6(2) >= target)) {
                mfRemoved.add(minefield);
            }
        }
        // we have to do it this way to avoid a concurrent error problem
        for (Minefield mf : mfRemoved) {
            removeMinefield(mf);
        }
    }

    /**
     * Checks to see if an entity sets off any vibrabombs.
     */
    private boolean checkVibrabombs(Entity entity, Coords coords,
                                    boolean displaced, Vector<Report> vMineReport) {
        return checkVibrabombs(entity, coords, displaced, null, null,
                               vMineReport);
    }

    /**
     * Checks to see if an entity sets off any vibrabombs.
     */
    private boolean checkVibrabombs(Entity entity, Coords coords,
            boolean displaced, Coords lastPos, Coords curPos,
            Vector<Report> vMineReport) {
        int mass = (int) entity.getWeight();

        // Check for Mine sweepers
        Mounted minesweeper = null;
        for (Mounted m : entity.getMisc()) {
            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) && m.isReady()
                    && (m.getArmorValue() > 0)) {
                minesweeper = m;
                break; // Can only have one minesweeper
            }
        }

        // Check for minesweepers sweeping VB minefields
        if (minesweeper != null) {
            Vector<Minefield> fieldsToRemove = new Vector<>();
            for (Minefield mf : game.getVibrabombs()) {
                // Ignore mines if they aren't in this position
                if (!mf.getCoords().equals(coords)) {
                    continue;
                }

                // Minesweepers on units within 9 tons of the vibrafield setting
                // automatically clear the minefield
                if (Math.abs(mass - mf.getSetting()) < 10) {
                    // Clear the minefield
                    Report r;
                    r = new Report(2158);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(Minefield.getDisplayableName(mf.getType()), true);
                    r.add(mf.getCoords().getBoardNum(), true);
                    r.indent();
                    vMineReport.add(r);
                    fieldsToRemove.add(mf);

                    // Handle armor value damage
                    int remainingAV = minesweeper.getArmorValue() - 10;
                    minesweeper.setArmorValue(Math.max(remainingAV, 0));

                    r = new Report(2161);
                    r.indent(2);
                    r.subject = entity.getId();
                    r.add(entity.getShortName(), true);
                    r.add(10);
                    r.add(Math.max(remainingAV, 0));
                    vMineReport.add(r);

                    if (remainingAV <= 0) {
                        minesweeper.setDestroyed(true);
                    }
                    // Check for damage transfer
                    if (remainingAV < 0) {
                        int damage = Math.abs(remainingAV);
                        r = new Report(2162);
                        r.indent(2);
                        r.subject = entity.getId();
                        r.add(damage, true);
                        vMineReport.add(r);

                        // Damage is dealt to the location of minesweeper
                        HitData hit = new HitData(minesweeper.getLocation());
                        Vector<Report> damageReports = damageEntity(entity,
                                hit, damage);
                        for (Report r1 : damageReports) {
                            r1.indent(1);
                        }
                        vMineReport.addAll(damageReports);
                        entity.applyDamage();
                    }
                    Report.addNewline(vMineReport);
                }
            }
            for (Minefield mf : fieldsToRemove) {
                removeMinefield(mf);
            }
        }


        boolean boom = false;
        // Only mechs can set off vibrabombs.
        if (!(entity instanceof Mech)) {
            return boom;
        }

        Enumeration<Minefield> e = game.getVibrabombs().elements();

        while (e.hasMoreElements()) {
            Minefield mf = e.nextElement();

            // Bug 954272: Mines shouldn't work underwater, and BMRr says
            // Vibrabombs are mines
            if (game.getBoard().getHex(mf.getCoords())
                    .containsTerrain(Terrains.WATER)
                && !game.getBoard().getHex(mf.getCoords())
                        .containsTerrain(Terrains.PAVEMENT)
                && !game.getBoard().getHex(mf.getCoords())
                        .containsTerrain(Terrains.ICE)) {
                continue;
            }

            // Mech weighing 10 tons or less can't set off the bomb
            if (mass <= (mf.getSetting() - 10)) {
                continue;
            }

            int effectiveDistance = (mass - mf.getSetting()) / 10;
            int actualDistance = coords.distance(mf.getCoords());

            if (actualDistance <= effectiveDistance) {
                Report r = new Report(2156);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                r.add(mf.getCoords().getBoardNum(), true);
                vMineReport.add(r);
                explodeVibrabomb(mf, vMineReport, false);
            }

            // Hack; when moving, the Mech isn't in the hex during
            // the movement.
            if (!displaced && (actualDistance == 0)) {
                // report getting hit by vibrabomb
                Report r = new Report(2160);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vMineReport.add(r);
                int damage = mf.getDensity();
                while (damage > 0) {
                    int cur_damage = Math.min(5, damage);
                    damage = damage - cur_damage;
                    HitData hit = entity.rollHitLocation(
                            Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));
                }
                vMineReport.addAll(resolvePilotingRolls(entity, true, lastPos,
                                                        curPos));
                // we need to apply Damage now, in case the entity lost a leg,
                // otherwise it won't get a leg missing mod if it hasn't yet
                // moved and lost a leg, see bug 1071434 for an example
                entity.applyDamage();
            }

            // don't check for reduction until the end or units in the same hex
            // through
            // movement will get the reduced damage
            if (mf.hasDetonated()) {
                boom = true;
                mf.checkReduction(0, true);
            }

        }
        return boom;
    }

    /**
     * Remove all minefields in the specified coords from the game
     *
     * @param coords
     *            The <code>Coords</code> from which to remove minefields
     */
    /*
     * public void removeMinefieldsFrom(Coords coords) { Vector<Minefield> v =
     * game.getMinefields(coords); while (v.elements().hasMoreElements()) {
     * Minefield mf = v.elements().nextElement(); removeMinefield(mf); }
     *
     * }
     */

    /**
     * Removes the minefield from the game.
     *
     * @param mf The <code>Minefield</code> to remove
     */
    public void removeMinefield(Minefield mf) {
        if (game.containsVibrabomb(mf)) {
            game.removeVibrabomb(mf);
        }
        game.removeMinefield(mf);

        Enumeration<IPlayer> players = game.getPlayers();
        while (players.hasMoreElements()) {
            IPlayer player = players.nextElement();
            removeMinefield(player, mf);
        }
    }

    /**
     * Removes the minfield from a player.
     *
     * @param player The <code>Player</code> who's minefield should be removed
     * @param mf     The <code>Minefield</code> to be removed
     */
    private void removeMinefield(IPlayer player, Minefield mf) {
        if (player.containsMinefield(mf)) {
            player.removeMinefield(mf);
            send(player.getId(),
                 new Packet(Packet.COMMAND_REMOVE_MINEFIELD, mf));
        }
    }

    /**
     * Reveals a minefield for all players.
     *
     * @param mf The <code>Minefield</code> to be revealed
     */
    private void revealMinefield(Minefield mf) {
        Enumeration<Team> teams = game.getTeams();
        while (teams.hasMoreElements()) {
            Team team = teams.nextElement();
            revealMinefield(team, mf);
        }
    }

    /**
     * Reveals a minefield for all players on a team.
     *
     * @param team The <code>team</code> who's minefiled should be revealed
     * @param mf   The <code>Minefield</code> to be revealed
     */
    private void revealMinefield(Team team, Minefield mf) {
        Enumeration<IPlayer> players = team.getPlayers();
        while (players.hasMoreElements()) {
            IPlayer player = players.nextElement();
            if (!player.containsMinefield(mf)) {
                player.addMinefield(mf);
                send(player.getId(), new Packet(
                        Packet.COMMAND_REVEAL_MINEFIELD, mf));
            }
        }
    }

    /**
     * checks whether a newly set mine should be revealed to players based on
     * LOS. If so, then it reveals the mine
     */
    private void checkForRevealMinefield(Minefield mf, Entity layer) {
        Enumeration<Team> teams = game.getTeams();
        // loop through each team and determine if they can see the mine, then
        // loop through players on team
        // and reveal the mine
        while (teams.hasMoreElements()) {
            Team team = teams.nextElement();
            boolean canSee = false;

            // the players own team can always see the mine
            if (team.equals(game.getTeamForPlayer(game.getPlayer(mf
                                                                         .getPlayerId())))) {
                canSee = true;
            } else {
                // need to loop through all entities on this team and find the
                // one with the best shot of seeing
                // the mine placement
                int target = Integer.MAX_VALUE;
                Iterator<Entity> entities = game.getEntities();
                while (entities.hasNext()) {
                    Entity en = entities.next();
                    // are we on the right team?
                    if (!team.equals(game.getTeamForPlayer(en.getOwner()))) {
                        continue;
                    }
                    if (LosEffects.calculateLos(
                            game,
                            en.getId(),
                            new HexTarget(mf.getCoords(), game.getBoard(),
                                          Targetable.TYPE_HEX_CLEAR)).canSee()) {
                        target = 0;
                        break;
                    }
                    LosEffects los = LosEffects.calculateLos(game, en.getId(),
                                                             layer);
                    if (los.canSee()) {
                        // TODO: need to add mods
                        ToHitData current = new ToHitData(4, "base");
                        current.append(Compute.getAttackerMovementModifier(
                                game, en.getId()));
                        current.append(Compute.getTargetMovementModifier(game,
                                                                         layer.getId()));
                        current.append(los.losModifiers(game));
                        if (current.getValue() < target) {
                            target = current.getValue();
                        }
                    }
                }

                if (Compute.d6(2) >= target) {
                    canSee = true;
                }
            }
            if (canSee) {
                revealMinefield(team, mf);
            }
        }
    }

    /**
     * Explodes a vibrabomb.
     *
     * @param mf The <code>Minefield</code> to explode
     */
    private void explodeVibrabomb(Minefield mf, Vector<Report> vBoomReport,
                                  boolean reduce) {
        Iterator<Entity> targets = game.getEntities(mf.getCoords());
        Report r;

        while (targets.hasNext()) {
            Entity entity = targets.next();

            // Airborne entities wont get hit by the mines...
            if (entity.isAirborne()) {
                continue;
            }

            // check for the "no_premove_vibra" option
            // If it's set, and the target has not yet moved,
            // it doesn't get damaged.
            if (!entity.isDone()
                && game.getOptions().booleanOption("no_premove_vibra")) {
                r = new Report(2157);
                r.subject = entity.getId();
                r.add(entity.getShortName(), true);
                vBoomReport.add(r);
                continue;
            }
            // report hitting vibrabomb
            r = new Report(2160);
            r.subject = entity.getId();
            r.add(entity.getShortName(), true);
            vBoomReport.add(r);

            int damage = mf.getDensity();
            while (damage > 0) {
                int cur_damage = Math.min(5, damage);
                damage = damage - cur_damage;
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE,
                                                     Minefield.TO_HIT_SIDE);
                vBoomReport.addAll(damageEntity(entity, hit, cur_damage));
            }
            Report.addNewline(vBoomReport);

            if (entity instanceof Tank) {
                vBoomReport.addAll(vehicleMotiveDamage((Tank) entity, 2));
            }
            vBoomReport.addAll(resolvePilotingRolls(entity, true,
                                                    entity.getPosition(), entity.getPosition()));
            // we need to apply Damage now, in case the entity lost a leg,
            // otherwise it won't get a leg missing mod if it hasn't yet
            // moved and lost a leg, see bug 1071434 for an example
            game.resetPSRs(entity);
            entity.applyDamage();
            Report.addNewline(vBoomReport);
            entityUpdate(entity.getId());
        }

        // check the direct reduction of mine
        if (reduce) {
            mf.checkReduction(0, true);
        }
        mf.setDetonated(true);
    }

    /**
     * drowns any units swarming the entity
     *
     * @param entity The <code>Entity</code> that is being swarmed
     * @param pos    The <code>Coords</code> the entity is at
     */
    private void drownSwarmer(Entity entity, Coords pos) {
        // Any swarming infantry will be destroyed.
        final int swarmerId = entity.getSwarmAttackerId();
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            // Only *platoons* drown while swarming.
            if (!(swarmer instanceof BattleArmor)) {
                swarmer.setSwarmTargetId(Entity.NONE);
                entity.setSwarmAttackerId(Entity.NONE);
                swarmer.setPosition(pos);
                Report r = new Report(2165);
                r.subject = entity.getId();
                r.indent();
                r.add(entity.getShortName(), true);
                addReport(r);
                addReport(destroyEntity(swarmer, "a watery grave", false));
                entityUpdate(swarmerId);
            }
        }
    }

    /**
     * Checks to see if we may have just washed off infernos. Call after a step
     * which may have done this.
     *
     * @param entity The <code>Entity</code> that is being checked
     * @param coords The <code>Coords</code> the entity is at
     */
    void checkForWashedInfernos(Entity entity, Coords coords) {
        IHex hex = game.getBoard().getHex(coords);
        int waterLevel = hex.terrainLevel(Terrains.WATER);
        // Mech on fire with infernos can wash them off.
        if (!(entity instanceof Mech) || !entity.infernos.isStillBurning()) {
            return;
        }
        // Check if entering depth 2 water or prone in depth 1.
        if ((waterLevel > 0) && (entity.relHeight() < 0)) {
            washInferno(entity, coords);
        }
    }

    /**
     * Washes off an inferno from a mech and adds it to the (water) hex.
     *
     * @param entity The <code>Entity</code> that is taking a bath
     * @param coords The <code>Coords</code> the entity is at
     */
    void washInferno(Entity entity, Coords coords) {
        game.getBoard().addInfernoTo(coords, InfernoTracker.STANDARD_ROUND, 1);
        entity.infernos.clear();

        // Start a fire in the hex?
        IHex hex = game.getBoard().getHex(coords);
        Report r = new Report(2170);
        r.subject = entity.getId();
        r.addDesc(entity);
        if (!hex.containsTerrain(Terrains.FIRE)) {
            r.messageId = 2175;
            ignite(coords, Terrains.FIRE_LVL_INFERNO, null);
        }
        addReport(r);
    }

    /**
     * Add heat from the movement phase
     */
    public void addMovementHeat() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();

            if (entity.hasDamagedRHS()) {
                entity.heatBuildup += 1;
            }

            if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)
                || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {
                // UMU heat
                entity.heatBuildup += 1;
                continue;
            }

            // build up heat from movement
            if (entity.isEvading() && !(entity instanceof Aero)) {
                entity.heatBuildup += entity.getRunHeat() + 2;
            } else if (entity.moved == EntityMovementType.MOVE_NONE) {
                entity.heatBuildup += entity.getStandingHeat();
            } else if ((entity.moved == EntityMovementType.MOVE_WALK)
                       || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                       || (entity.moved == EntityMovementType.MOVE_CAREFUL_STAND)) {
                entity.heatBuildup += entity.getWalkHeat();
            } else if ((entity.moved == EntityMovementType.MOVE_RUN)
                       || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                       || (entity.moved == EntityMovementType.MOVE_SKID)) {
                entity.heatBuildup += entity.getRunHeat();
            } else if (entity.moved == EntityMovementType.MOVE_JUMP) {
                entity.heatBuildup += entity.getJumpHeat(entity.delta_distance);
            } else if (entity.moved == EntityMovementType.MOVE_SPRINT) {
                entity.heatBuildup += entity.getSprintHeat();
            }
        }
    }

    /**
     * Set the locationsexposure of an entity
     *
     * @param entity
     *            The <code>Entity</code> who's exposure is being set
     * @param hex
     *            The <code>IHex</code> the entity is in
     * @param isJump
     *            a <code>boolean</code> value wether the entity is jumping
     * @param elevation
     *            the elevation the entity should be at.
     */
    public Vector<Report> doSetLocationsExposure(Entity entity, IHex hex,
            boolean isJump, int elevation) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        if (hex == null) {
            return vPhaseReport;
        }
        if ((hex.terrainLevel(Terrains.WATER) > 0) && !isJump
            && (elevation < 0)) {
            int partialWaterLevel = 1;
            if ((entity instanceof Mech) && ((Mech) entity).isSuperHeavy()) {
                partialWaterLevel = 2;
            }
            if ((entity instanceof Mech) && !entity.isProne()
                && (hex.terrainLevel(Terrains.WATER) <= partialWaterLevel)) {
                for (int loop = 0; loop < entity.locations(); loop++) {
                    if (game.getPlanetaryConditions().isVacuum()) {
                        entity.setLocationStatus(loop,
                                                 ILocationExposureStatus.VACUUM);
                    } else {
                        entity.setLocationStatus(loop,
                                                 ILocationExposureStatus.NORMAL);
                    }
                }
                entity.setLocationStatus(Mech.LOC_RLEG,
                                         ILocationExposureStatus.WET);
                entity.setLocationStatus(Mech.LOC_LLEG,
                                         ILocationExposureStatus.WET);
                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_RLEG, hex));
                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_LLEG, hex));
                if (entity instanceof QuadMech) {
                    entity.setLocationStatus(Mech.LOC_RARM,
                                             ILocationExposureStatus.WET);
                    entity.setLocationStatus(Mech.LOC_LARM,
                                             ILocationExposureStatus.WET);
                    vPhaseReport
                            .addAll(breachCheck(entity, Mech.LOC_RARM, hex));
                    vPhaseReport
                            .addAll(breachCheck(entity, Mech.LOC_LARM, hex));
                }
                if (entity instanceof TripodMech) {
                    entity.setLocationStatus(Mech.LOC_CLEG,
                            ILocationExposureStatus.WET);
                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_CLEG, hex));
                }
            } else {
                for (int loop = 0; loop < entity.locations(); loop++) {
                    entity.setLocationStatus(loop, ILocationExposureStatus.WET);
                    vPhaseReport.addAll(breachCheck(entity, loop, hex));
                }
            }
        } else {
            for (int loop = 0; loop < entity.locations(); loop++) {
                if (game.getPlanetaryConditions().isVacuum()) {
                    entity.setLocationStatus(loop,
                                             ILocationExposureStatus.VACUUM);
                } else {
                    entity.setLocationStatus(loop,
                                             ILocationExposureStatus.NORMAL);
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * Do a roll to avoid pilot damage from g-forces
     *
     * @param entity     The <code>Entity</code> that should make the PSR
     * @param targetroll The <code>int</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private void resistGForce(Entity entity, int targetroll) {

        // okay, print the info
        Report r = new Report(9330);
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9335);
        r.subject = entity.getId();
        r.add(Integer.toString(targetroll));
        r.add(diceRoll);
        if (diceRoll < targetroll) {
            r.choose(false);
            addReport(r);
            addReport(damageCrew(entity, 1));
        } else {
            r.choose(true);
            addReport(r);
        }
    }

    /**
     * Do a piloting skill check in space to avoid structural damage
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckInSpace(Entity entity, PilotingRollData roll) {

        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9320);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9325);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            suc = false;
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check to take off vertically
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doVerticalTakeOffCheck(Entity entity, PilotingRollData roll) {

        if (!(entity instanceof Aero)) {
            return false;
        }

        Aero a = (Aero) entity;

        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9320);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9321);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        r.newlines = 0;
        addReport(r);
        boolean suc = false;
        if (diceRoll < roll.getValue()) {
            int mof = roll.getValue() - diceRoll;
            if (mof < 3) {
                r = new Report(9322);
                r.subject = entity.getId();
                addReport(r);
                suc = true;
            } else if (mof < 5) {
                PilotingRollData newRoll = entity.getBasePilotingRoll();
                if (Compute.d6(2) >= newRoll.getValue()) {
                    r = new Report(9322);
                    r.subject = entity.getId();
                    addReport(r);
                    suc = true;
                } else {
                    r = new Report(9323);
                    r.subject = entity.getId();
                    addReport(r);
                    int damage = 20;
                    while (damage > 0) {
                        addReport(damageEntity(entity, entity.rollHitLocation(
                                                       ToHitData.HIT_NORMAL, ToHitData.SIDE_REAR),
                                               Math.min(5, damage)));
                        damage -= 5;
                    }
                }
            } else if (mof < 6) {
                r = new Report(9323);
                r.subject = entity.getId();
                addReport(r);
                int damage = 50;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(
                                                   ToHitData.HIT_NORMAL, ToHitData.SIDE_REAR),
                                           Math.min(5, damage)));
                    damage -= 5;
                }
            } else {
                r = new Report(9323);
                r.subject = entity.getId();
                addReport(r);
                int damage = 100;
                while (damage > 0) {
                    addReport(damageEntity(entity, entity.rollHitLocation(
                                                   ToHitData.HIT_NORMAL, ToHitData.SIDE_REAR),
                                           Math.min(5, damage)));
                    damage -= 5;
                }
            }
            a.setGearHit(true);
            r = new Report(9125);
            r.subject = entity.getId();
            addReport(r);
        } else {
            r = new Report(9322);
            r.subject = entity.getId();
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check in space to do a successful maneuver Failure
     * means moving forward half velocity
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckManeuver(Entity entity, PilotingRollData roll) {

        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        // okay, print the info
        Report r = new Report(9600);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(9601);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            suc = false;
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a piloting skill check while standing still (during the movement
     * phase).
     *
     * @param entity The <code>Entity</code> that should make the PSR
     * @param roll   The <code>PilotingRollData</code> to be used for this PSR.
     * @return true if check succeeds, false otherwise.
     */
    private boolean doSkillCheckInPlace(Entity entity, PilotingRollData roll) {
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            return true;
        }

        if (entity.isProne()) {
            return true;
        }

        // okay, print the info
        Report r = new Report(2180);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = entity.getCrew().rollPilotingSkill();
        r = new Report(2185);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        boolean suc;
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            if ((entity instanceof Mech)
                && game.getOptions().booleanOption(
                    "tacops_falling_expanded")
                && (entity.getCrew().getPiloting() < 6)
                && !entity.isHullDown() && entity.canGoHullDown()) {
                if ((entity.getCrew().getPiloting() > 1)
                    && ((roll.getValue() - diceRoll) < 2)) {
                    entity.setHullDown(true);
                } else if ((entity.getCrew().getPiloting() <= 1)
                           && ((roll.getValue() - diceRoll) < 3)) {
                    entity.setHullDown(true);
                }
            }
            if (!entity.isHullDown()
                || (entity.isHullDown() && !entity.canGoHullDown())) {
                addReport(doEntityFall(entity, roll));
            } else {
                r = new Report(2317);
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                addReport(r);
            }

            suc = false;
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
        } else {
            r.choose(true);
            addReport(r);
            suc = true;
        }

        return suc;
    }

    /**
     * Do a Piloting Skill check to dislogde swarming infantry.
     *
     * @param entity The <code>Entity</code> that is doing the dislodging.
     * @param roll   The <code>PilotingRollData</code> for this PSR.
     * @param curPos The <code>Coords</code> the entity is at.
     * @return <code>true</code> if the dislodging is successful.
     */
    private boolean doDislodgeSwarmerSkillCheck(Entity entity,
                                                PilotingRollData roll, Coords curPos) {
        // okay, print the info
        Report r = new Report(2180);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = Compute.d6(2);
        r = new Report(2190);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        if (diceRoll < roll.getValue()) {
            r.choose(false);
            addReport(r);
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return false;
        }
        // Dislodged swarmers don't get turns.
        int swarmerId = entity.getSwarmAttackerId();
        final Entity swarmer = game.getEntity(swarmerId);
        if (!swarmer.isDone()) {
            game.removeTurnFor(swarmer);
            swarmer.setDone(true);
            send(createTurnVectorPacket());
        }

        // Update the report and cause a fall.
        r.choose(true);
        addReport(r);
        entity.setPosition(curPos);
        addReport(doEntityFallsInto(entity, curPos, roll, false));
        return true;
    }

    /**
     * Do a piloting skill check while moving.
     *
     * @param entity          - the <code>Entity</code> that must roll.
     * @param entityElevation The elevation of the supplied Entity above the surface of the
     *                        src hex. This is necessary as the state of the Entity may
     *                        represent the elevation of the entity about the surface of the
     *                        dest hex.
     * @param src             - the <code>Coords</code> the entity is moving from.
     * @param dest            - the <code>Coords</code> the entity is moving to. This value
     *                        can be the same as src for in-place checks.
     * @param roll            - the <code>PilotingRollData</code> that is causing this
     *                        check.
     * @param isFallRoll      - a <code>boolean</code> flag that indicates that failure will
     *                        result in a fall or not. Falls will be processed.
     * @return Margin of Failure if the pilot fails the skill check, 0 if they
     * pass.
     */
    private int doSkillCheckWhileMoving(Entity entity, int entityElevation,
            Coords src, Coords dest, PilotingRollData roll, boolean isFallRoll) {
        boolean fallsInPlace;

        // Start the info for this roll.
        Report r = new Report(1210);
        r.subject = entity.getId();
        r.addDesc(entity);

        // Will the entity fall in the source or destination hex?
        if (src.equals(dest)) {
            fallsInPlace = true;
            r.messageId = 2195;
            r.add(src.getBoardNum(), true);
        } else {
            fallsInPlace = false;
            r.messageId = 2200;
            r.add(src.getBoardNum(), true);
            r.add(dest.getBoardNum(), true);
        }

        // Finish the info.
        r.add(roll.getLastPlainDesc(), true);
        addReport(r);

        // roll
        final int diceRoll = entity.getCrew().rollPilotingSkill();
        r = new Report(2185);
        r.subject = entity.getId();
        r.add(roll.getValueAsString());
        r.add(roll.getDesc());
        r.add(diceRoll);
        if (diceRoll < roll.getValue()) {
            // Does failing the PSR result in a fall.
            if (isFallRoll) {
                r.choose(false);
                addReport(r);
                addReport(doEntityFallsInto(entity, entityElevation,
                                            fallsInPlace ? dest : src, fallsInPlace ? src : dest,
                                            roll, true));
            } else {
                r.messageId = 2190;
                r.choose(false);
                addReport(r);
                entity.setPosition(fallsInPlace ? src : dest);
            }
            // failed a PSR, possibly check for engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return roll.getValue() - diceRoll;
        }
        r.choose(true);
        r.newlines = 2;
        addReport(r);
        return 0;
    }

    /**
     * Process a fall when the source and destination hexes are the same.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller. Note: the elevation of the entity is used to
     * determine fall distance, so it is important to ensure the Entity's
     * elevation is correct.
     *
     * @param entity    The <code>Entity</code> that is falling.
     * @param src       The <code>Coords</code> of the source hex.
     * @param roll      The <code>PilotingRollData</code> to be used for PSRs induced
     *                  by the falling.
     * @param causeAffa The <code>boolean</code> value wether this fall should be able
     *                  to cause an accidental fall from above
     */
    private Vector<Report> doEntityFallsInto(Entity entity, Coords src,
                                             PilotingRollData roll, boolean causeAffa) {
        return doEntityFallsInto(entity, entity.getElevation(), src, src, roll,
                                 causeAffa);
    }

    /**
     * Process a fall when moving from the source hex to the destination hex.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller. Note: the elevation of the entity is used to
     * determine fall distance, so it is important to ensure the Entity's
     * elevation is correct.
     *
     * @param entity             The <code>Entity</code> that is falling.
     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
     *                           src hex. This is necessary as the state of the Entity may
     *                           represent the elevation of the entity about the surface of the
     *                           dest hex.
     * @param src                The <code>Coords</code> of the source hex.
     * @param dest               The <code>Coords</code> of the destination hex.
     * @param roll               The <code>PilotingRollData</code> to be used for PSRs induced
     *                           by the falling.
     * @param causeAffa          The <code>boolean</code> value wether this fall should be able
     *                           to cause an accidental fall from above
     */
    private Vector<Report> doEntityFallsInto(Entity entity,
                                             int entitySrcElevation, Coords src, Coords dest,
                                             PilotingRollData roll, boolean causeAffa) {
        return doEntityFallsInto(entity, entitySrcElevation, src, dest, roll,
                                 causeAffa, 0);
    }

    /**
     * Process a fall when moving from the source hex to the destination hex.
     * Depending on the elevations of the hexes, the Entity could land in the
     * source or destination hexes. Check for any conflicts and resolve them.
     * Deal damage to faller.
     *
     * @param entity             The <code>Entity</code> that is falling.
     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
     *                           src hex. This is necessary as the state of the Entity may
     *                           represent the elevation of the entity about the surface of the
     *                           dest hex.
     * @param origSrc            The <code>Coords</code> of the original source hex.
     * @param origDest           The <code>Coords</code> of the original destination hex.
     * @param roll               The <code>PilotingRollData</code> to be used for PSRs induced
     *                           by the falling.
     * @param causeAffa          The <code>boolean</code> value wether this fall should be able
     *                           to cause an accidental fall from above
     * @param fallReduction      An integer value to reduce the fall distance by
     */
    private Vector<Report> doEntityFallsInto(Entity entity,
                                             int entitySrcElevation, Coords origSrc, Coords origDest,
                                             PilotingRollData roll, boolean causeAffa, int fallReduction) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        IHex srcHex = game.getBoard().getHex(origSrc);
        IHex destHex = game.getBoard().getHex(origDest);
        Coords src, dest;
        // We need to fall into the lower of the two hexes, TW pg 68
        if (srcHex.getLevel() < destHex.getLevel()) {
            IHex swapHex = destHex;
            destHex = srcHex;
            srcHex = swapHex;
            src = origDest;
            dest = origSrc;
            // Adjust elevation, since it's relative to the surface of srcHex
            entitySrcElevation -= (destHex.getLevel() - srcHex.getLevel());
        } else {
            src = origSrc;
            dest = origDest;
        }
        final int srcHeightAboveFloor = entitySrcElevation + srcHex.depth(true);
        int fallElevation = Math.abs((srcHex.floor() + srcHeightAboveFloor)
                - (destHex.containsTerrain(Terrains.ICE) ? destHex.surface()
                        : destHex.floor()))
                - fallReduction;
        if (destHex.containsTerrain(Terrains.BLDG_ELEV)) {
            fallElevation -= destHex.terrainLevel(Terrains.BLDG_ELEV);
        }
        if (destHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {
            if (entity.getElevation() == 0) { // floor 0 falling into basement
                fallElevation = destHex.depth(true);
            }
        }

        int direction;
        if (src.equals(dest)) {
            direction = Compute.d6() - 1;
        } else {
            direction = src.direction(dest);
        }
        Report r;
        // check entity in target hex
        Entity affaTarget = game.getAffaTarget(dest, entity);
        // falling mech falls
        r = new Report(2205);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(fallElevation);
        r.add(dest.getBoardNum(), true);
        r.newlines = 0;

        // if hex was empty, deal damage and we're done
        if (affaTarget == null) {
            r.newlines = 1;
            vPhaseReport.add(r);
            // If we rolled for the direction, we want to use that for the fall
            if (src.equals(dest)) {
                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation,
                                                 direction, roll, false));
            } else {
                // Otherwise, we'll roll for the direction after the fall
                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation,
                                                 roll));
            }

            return vPhaseReport;
        }
        vPhaseReport.add(r);

        // hmmm... somebody there... problems.
        if ((fallElevation >= 2) && causeAffa) {
            // accidental fall from above: havoc!
            r = new Report(2210);
            r.subject = entity.getId();
            r.addDesc(affaTarget);
            vPhaseReport.add(r);

            // determine to-hit number
            ToHitData toHit = new ToHitData(7, "base");
            if ((affaTarget instanceof Tank)
                || (affaTarget instanceof Dropship)) {
                toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS,
                                      "Target is a Tank");
            } else {
                toHit.append(Compute.getTargetMovementModifier(game,
                                                               affaTarget.getId()));
                toHit.append(Compute.getTargetTerrainModifier(game, affaTarget));
            }

            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL) {
                // collision roll
                final int diceRoll = Compute.d6(2);
                if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
                    r = new Report(2212);
                    r.add(toHit.getValue());
                    r.indent();
                } else {
                    r = new Report(2215);
                    r.subject = entity.getId();
                    r.add(toHit.getValue());
                    r.add(diceRoll);
                    r.newlines = 0;
                    r.indent();
                }
                vPhaseReport.add(r);
                if (diceRoll >= toHit.getValue()) {
                    // deal damage to target
                    int damage = Compute.getAffaDamageFor(entity);
                    r = new Report(2220);
                    r.subject = affaTarget.getId();
                    r.addDesc(affaTarget);
                    r.add(damage);
                    vPhaseReport.add(r);
                    while (damage > 0) {
                        int cluster = Math.min(5, damage);
                        HitData hit = affaTarget.rollHitLocation(
                                ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);
                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                        vPhaseReport.addAll(damageEntity(affaTarget, hit,
                                                         cluster));
                        damage -= cluster;
                    }

                    // attacker falls as normal, on his back
                    // only given a modifier, so flesh out into a full piloting
                    // roll
                    PilotingRollData pilotRoll = entity.getBasePilotingRoll();
                    pilotRoll.append(roll);
                    vPhaseReport.addAll(doEntityFall(entity, dest,
                                                     fallElevation, 3, pilotRoll, false));
                    vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(
                            entity, src, dest, entity.getElevation()));

                    // defender pushed away, or destroyed, if there is a
                    // stacking violation
                    Entity violation = Compute.stackingViolation(game,
                                                                 entity.getId(), dest);
                    if (violation != null) {
                        PilotingRollData prd = new PilotingRollData(
                                violation.getId(), 2, "fallen on");
                        if (violation instanceof Dropship) {
                            violation = entity;
                            prd = null;
                        }
                        Coords targetDest = Compute.getValidDisplacement(game,
                                                                         violation.getId(), dest, direction);
                        if (targetDest != null) {
                            vPhaseReport.addAll(doEntityDisplacement(violation,
                                                                     dest, targetDest, prd));
                            // Update the violating entity's postion on the
                            // client.
                            entityUpdate(violation.getId());
                        } else {
                            // ack! automatic death! Tanks
                            // suffer an ammo/power plant hit.
                            // TODO : a Mech suffers a Head Blown Off crit.
                            vPhaseReport.addAll(destroyEntity(violation,
                                                              "impossible displacement",
                                                              violation instanceof Mech,
                                                              violation instanceof Mech));
                        }
                    }
                    return vPhaseReport;
                }
            } else {
                // automatic miss
                r = new Report(2213);
                r.add(toHit.getDesc());
                vPhaseReport.add(r);
            }
            // ok, we missed, let's fall into a valid other hex and not cause an
            // AFFA while doing so
            Coords targetDest = Compute.getValidDisplacement(game,
                                                             entity.getId(), dest, direction);
            if (targetDest != null) {
                vPhaseReport.addAll(doEntityFallsInto(entity,
                                                      entitySrcElevation, src, targetDest,
                                                      new PilotingRollData(entity.getId(),
                                                                           TargetRoll.IMPOSSIBLE, "pushed off a cliff"),
                                                      false));
                // Update the entity's postion on the client.
                entityUpdate(entity.getId());
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                vPhaseReport.addAll(destroyEntity(entity,
                                                  "impossible displacement", entity instanceof Mech,
                                                  entity instanceof Mech));
            }
        } else {
            // damage as normal
            vPhaseReport
                    .addAll(doEntityFall(entity, dest, fallElevation, roll));
            Entity violation = Compute.stackingViolation(game, entity.getId(),
                                                         dest);
            if (violation != null) {
                PilotingRollData prd = new PilotingRollData(violation.getId(),
                                                            0, "domino effect");
                if (violation instanceof Dropship) {
                    violation = entity;
                    prd = null;
                }
                // target gets displaced, because of low elevation
                Coords targetDest = Compute.getValidDisplacement(game,
                                                                 violation.getId(), dest, direction);
                vPhaseReport.addAll(doEntityDisplacement(violation, dest,
                                                         targetDest, prd));
                // Update the violating entity's position on the client.
                if (!game.getOutOfGameEntitiesVector().contains(violation)) {
                    entityUpdate(violation.getId());
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * Displace a unit in the direction specified. The unit moves in that
     * direction, and the piloting skill roll is used to determine if it falls.
     * The roll may be unnecessary as certain situations indicate an automatic
     * fall. Rolls are added to the piloting roll list.
     */
    private Vector<Report> doEntityDisplacement(Entity entity, Coords src,
            Coords dest, PilotingRollData roll) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        Report r;
        if (!game.getBoard().contains(dest)) {
            // set position anyway, for pushes moving through, stuff like that
            entity.setPosition(dest);
            if (!entity.isDoomed()) {
                // Make sure there aren't any specific entity turns for entity
                int turnsRemoved = game.removeSpecificEntityTurnsFor(entity);
                // May need to remove a turn for this Entity
                if ((game.getPhase() == Phase.PHASE_MOVEMENT)
                        && !entity.isDone() && (turnsRemoved == 0)) {
                    game.removeTurnFor(entity);
                    send(createTurnVectorPacket());
                } else if (turnsRemoved > 0) {
                    send(createTurnVectorPacket());
                }
                game.removeEntity(entity.getId(),
                        IEntityRemovalConditions.REMOVE_PUSHED);
                send(createRemoveEntityPacket(entity.getId(),
                        IEntityRemovalConditions.REMOVE_PUSHED));
                // entity forced from the field
                r = new Report(2230);
                r.subject = entity.getId();
                r.addDesc(entity);
                vPhaseReport.add(r);
                // TODO: remove passengers and swarmers.
            }
            return vPhaseReport;
        }
        final IHex srcHex = game.getBoard().getHex(src);
        final IHex destHex = game.getBoard().getHex(dest);
        final int direction = src.direction(dest);

        // Handle null hexes.
        if ((srcHex == null) || (destHex == null)) {
            System.err.println("Can not displace " + entity.getShortName()
                               + " from " + src + " to " + dest + '.');
            return vPhaseReport;
        }
        int bldgElev = destHex.containsTerrain(Terrains.BLDG_ELEV) ? destHex
                .terrainLevel(Terrains.BLDG_ELEV) : 0;
        int fallElevation = entity.elevationOccupied(srcHex)
                            - (entity.elevationOccupied(destHex) + bldgElev);
        if (fallElevation > 1) {
            if (roll == null) {
                roll = entity.getBasePilotingRoll();
            }
            if (!(entity.isAirborneVTOLorWIGE())) {
                vPhaseReport.addAll(doEntityFallsInto(entity,
                        entity.getElevation(), src, dest, roll, true));
            } else {
                entity.setPosition(dest);
            }
            return vPhaseReport;
        }
        // unstick the entity if it was stuck in swamp
        boolean wasStuck = entity.isStuck();
        entity.setStuck(false);
        int oldElev = entity.getElevation();
        // move the entity into the new location gently
        entity.setPosition(dest);
        entity.setElevation(entity.calcElevation(srcHex, destHex));
        Building bldg = game.getBoard().getBuildingAt(dest);
        if (bldg != null) {
            if (destHex.terrainLevel(Terrains.BLDG_ELEV) > oldElev) {
                // woops, into the building we go
                passBuildingWall(
                        entity,
                        game.getBoard().getBuildingAt(dest),
                        src,
                        dest,
                        1,
                        "displaced into",
                        Math.abs(entity.getFacing() - src.direction(dest)) == 3,
                        entity.moved, true);
            }
            checkBuildingCollapseWhileMoving(bldg, entity, dest);
        }
        if (destHex.containsTerrain(Terrains.MAGMA, 1)) {
            int d6 = Compute.d6(1);
            r = new Report(2395);
            r.addDesc(entity);
            r.add(d6);
            r.subject = entity.getId();
            addReport(r);
            if (d6 == 6) {
                destHex.removeTerrain(Terrains.MAGMA);
                destHex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.MAGMA, 2));
                sendChangedHex(dest);
                for (Entity en : game.getEntitiesVector(dest)) {
                    if (en != entity) {
                        doMagmaDamage(en, false);
                    }
                }
            }
        }
        Entity violation = Compute
                .stackingViolation(game, entity.getId(), dest);
        if (violation == null) {
            // move and roll normally
            r = new Report(2235);
            r.indent();
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(dest.getBoardNum(), true);
            vPhaseReport.add(r);
        } else {
            // domino effect: move & displace target
            r = new Report(2240);
            r.indent();
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(dest.getBoardNum(), true);
            r.addDesc(violation);
            vPhaseReport.add(r);
        }
        // trigger any special things for moving to the new hex
        vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(entity, src,
                                                               dest, entity.getElevation()));
        vPhaseReport.addAll(doSetLocationsExposure(entity, destHex, false,
                                                   entity.getElevation()));
        if (destHex.containsTerrain(Terrains.BLDG_ELEV)
            && (entity.getElevation() == 0)) {
            bldg = game.getBoard().getBuildingAt(dest);
            if (bldg.rollBasement(dest, game.getBoard(), vPhaseReport)) {
                sendChangedHex(dest);
                Vector<Building> buildings = new Vector<Building>();
                buildings.add(bldg);
                sendChangedBuildings(buildings);
            }
        }
        int waterDepth = destHex.terrainLevel(Terrains.WATER);
        // Falling into water instantly destroys most non-mechs
        if ((waterDepth > 0)
            && !(entity instanceof Mech)
            && !(entity instanceof Protomech)
            && !((entity.getRunMP() > 0) && (entity.getMovementMode() == EntityMovementMode.HOVER))
            && (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)
            && (entity.getMovementMode() != EntityMovementMode.NAVAL)
            && (entity.getMovementMode() != EntityMovementMode.SUBMARINE)
            && (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {
            vPhaseReport.addAll(destroyEntity(entity, "a watery grave", false));
        }
        // mechs that were stuck will automatically fall in their new hex
        if (wasStuck && (entity instanceof Mech) && !entity.isProne()) {
            if (roll == null) {
                roll = entity.getBasePilotingRoll();
            }
            vPhaseReport.addAll(doEntityFall(entity, dest, 0, roll));
        }
        // check bog-down conditions
        vPhaseReport.addAll(doEntityDisplacementBogDownCheck(entity, dest,
                                                             entity.getElevation()));

        if (roll != null) {
            game.addPSR(roll);
        }

        if ((waterDepth > 0)
                && !(entity.getMovementMode() == EntityMovementMode.HOVER)) {
            PilotingRollData waterRoll = entity.checkWaterMove(waterDepth,
                    entity.moved);
            if (waterRoll.getValue() != TargetRoll.CHECK_FALSE) {
                doSkillCheckInPlace(entity, waterRoll);
            }
        }
        // Update the entity's postion on the client.
        entityUpdate(entity.getId());

        if (violation != null) {
            // Can the violating unit move out of the way?
            // if the direction comes from a side, Entity didn't jump, and it
            // has MP left to use, it can try to move.
            MovePath stepForward = new MovePath(game, violation);
            MovePath stepBackwards = new MovePath(game, violation);
            stepForward.addStep(MoveStepType.FORWARDS);
            stepBackwards.addStep(MoveStepType.BACKWARDS);
            if ((direction != violation.getFacing())
                && (direction != ((violation.getFacing() + 3) % 6))
                && !entity.getIsJumpingNow()
                && (stepForward.isMoveLegal() || stepBackwards
                    .isMoveLegal())) {
                // First, we need to make a PSR to see if we can step out
                int result = Compute.d6(2);
                roll = entity.getBasePilotingRoll();

                r = new Report(2351);
                r.indent(2);
                r.subject = violation.getId();
                r.addDesc(violation);
                r.add(roll.getValue());
                r.add(result);
                vPhaseReport.add(r);
                if (result < roll.getValue()) {
                    r.choose(false);
                    Vector<Report> newReports = doEntityDisplacement(violation,
                            dest, dest.translated(direction),
                            new PilotingRollData(violation.getId(),
                                    TargetRoll.AUTOMATIC_FAIL,
                                    "failed to step out of a "
                                            + "domino effect"));
                    for (Report newReport : newReports) {
                        newReport.indent(3);
                    }
                    vPhaseReport.addAll(newReports);
                } else {
                    r.choose(true);
                    sendDominoEffectCFR(violation);
                    synchronized (cfrPacketQueue) {
                        try {
                            cfrPacketQueue.wait();
                        } catch (InterruptedException e) {
                            // Do nothing
                        }
                        if (cfrPacketQueue.size() > 0) {
                            ReceivedPacket rp = cfrPacketQueue.poll();
                            int cfrType = (int) rp.packet.getData()[0];
                            // Make sure we got the right type of response
                            if (cfrType != Packet.COMMAND_CFR_DOMINO_EFFECT) {
                                System.err
                                        .println("Excepted a "
                                                + "COMMAND_CFR_DOMINO_EFFECT CFR packet, "
                                                + "received: " + cfrType);
                                throw new IllegalStateException();
                            }
                            MovePath mp = (MovePath) rp.packet.getData()[1];
                            // Move based on the feedback
                            if (mp != null) {
                                // Report
                                r = new Report(2352);
                                r.indent(3);
                                r.subject = violation.getId();
                                r.addDesc(violation);
                                if (mp.getLastStep().getType() == MoveStepType.FORWARDS) {
                                    r.choose(false);
                                } else {
                                    r.choose(true);
                                }
                                r.add(mp.getLastStep().getPosition()
                                        .getBoardNum());
                                vPhaseReport.add(r);
                                // Move unit
                                violation.setPosition(mp.getFinalCoords());
                                violation.mpUsed += mp.getMpUsed();
                                violation.moved = mp.getLastStepMovementType();
                            } else { // User decided to do nothing
                                r = new Report(2358);
                                r.indent(3);
                                r.subject = violation.getId();
                                r.addDesc(violation);
                                vPhaseReport.add(r);
                                vPhaseReport.addAll(doEntityDisplacement(
                                        violation, dest,
                                        dest.translated(direction), null));
                            }
                        } else { // If no responses, treat as no action
                            vPhaseReport.addAll(doEntityDisplacement(violation,
                                    dest, dest.translated(direction),
                                    new PilotingRollData(violation.getId(), 0,
                                            "domino effect")));
                        }
                    }
                }
            } else { // Nope
                r = new Report(2359);
                r.indent(2);
                r.subject = violation.getId();
                r.addDesc(violation);
                vPhaseReport.add(r);
                vPhaseReport.addAll(doEntityDisplacement(violation, dest, dest
                        .translated(direction),
                        new PilotingRollData(violation.getId(), 0,
                                "domino effect")));

            }
            // Update the violating entity's postion on the client,
            // if it didn't get displaced off the board.
            if (!game.isOutOfGame(violation)) {
                entityUpdate(violation.getId());
            }
        }
        return vPhaseReport;
    }

    private void sendDominoEffectCFR(Entity e) {
        send(e.getOwnerId(), new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
                new Object[] { Packet.COMMAND_CFR_DOMINO_EFFECT, e.getId() }));
    }

    private void sendAMSAssignCFR(Entity e, Mounted ams,
            ArrayList<WeaponAttackAction> waas) {
        send(e.getOwnerId(),
                new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
                        new Object[] { Packet.COMMAND_CFR_AMS_ASSIGN,
                                e.getId(), e.getEquipmentNum(ams), waas }));
    }

    private void sendAPDSAssignCFR(Entity e, List<Integer> apdsDists,
            List<WeaponAttackAction> waas) {
        send(e.getOwnerId(), new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
                new Object[] { Packet.COMMAND_CFR_APDS_ASSIGN, e.getId(),
                apdsDists, waas }));
    }

    private Vector<Report> doEntityDisplacementMinefieldCheck(Entity entity,
            Coords src, Coords dest, int elev) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        boolean boom = checkVibrabombs(entity, dest, true, vPhaseReport);
        if (game.containsMinefield(dest)) {
            boom = enterMinefield(entity, dest, elev, true, vPhaseReport)
                    || boom;
        }
        if (boom) {
            resetMines();
        }

        return vPhaseReport;
    }

    private Vector<Report> doEntityDisplacementBogDownCheck(Entity entity,
            Coords c, int elev) {
        Vector<Report> vReport = new Vector<Report>();
        Report r;
        IHex destHex = game.getBoard().getHex(c);
        int bgMod = destHex.getBogDownModifier(entity.getMovementMode(),
                entity instanceof LargeSupportTank);
        if ((bgMod != TargetRoll.AUTOMATIC_SUCCESS)
                && (entity.getMovementMode() != EntityMovementMode.HOVER)
                && (entity.getMovementMode() != EntityMovementMode.WIGE)
                && (elev == 0)) {
            PilotingRollData roll = entity.getBasePilotingRoll();
            roll.append(new PilotingRollData(entity.getId(), bgMod,
                    "avoid bogging down"));
            int stuckroll = Compute.d6(2);
            if (stuckroll < roll.getValue()) {
                entity.setStuck(true);
                r = new Report(2081);
                r.subject = entity.getId();
                r.add(entity.getDisplayName(), true);
                vReport.add(r);
                // check for quicksand
                vReport.addAll(checkQuickSand(c));
            }

        }
        return vReport;
    }

    /**
     * Receive a deployment packet. If valid, execute it and end the current
     * turn.
     */
    private void receiveDeployment(Packet packet, int connId) {
        Entity entity = game.getEntity(packet.getIntValue(0));
        Coords coords = (Coords) packet.getObject(1);
        int nFacing = packet.getIntValue(2);
        int elevation = packet.getIntValue(3);

        // Handle units that deploy loaded with other units.
        int loadedCount = packet.getIntValue(4);
        Vector<Entity> loadVector = new Vector<Entity>();
        for (int i = 0; i < loadedCount; i++) {
            int loadedId = packet.getIntValue(6 + i);
            loadVector.addElement(game.getEntity(loadedId));
        }

        // is this the right phase?
        if (game.getPhase() != IGame.Phase.PHASE_DEPLOYMENT) {
            System.err
                    .println("error: server got deployment packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        final boolean assaultDrop = packet.getBooleanValue(5);
        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (game.isPhaseSimultaneous()) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null)
                || !turn.isValid(connId, entity, game)
                || !(game.getBoard().isLegalDeployment(coords,
                        entity.getStartingPos()) || (assaultDrop
                        && game.getOptions().booleanOption("assault_drop") && entity
                            .canAssaultDrop()))) {
            String msg = "error: server got invalid deployment packet from "
                         + "connection " + connId;
            if (entity != null) {
                msg += ", Entity: " + entity.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            System.err.println(msg);
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket());
            return;
        }

        // looks like mostly everything's okay
        processDeployment(entity, coords, nFacing, elevation, loadVector,
                          assaultDrop);

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(null);
        }

        endCurrentTurn(entity);
    }

    /**
     * Used when an Entity that was loaded in another Entity in the Lounge is
     * unloaded during deployment.
     * @param packet
     * @param connId
     */
    private void receiveDeploymentUnload(Packet packet, int connId) {
        Entity loader = game.getEntity(packet.getIntValue(0));
        Entity loaded = game.getEntity(packet.getIntValue(1));

        if (game.getPhase() != Phase.PHASE_DEPLOYMENT) {
            String msg = "error: server received deployment unload packet "
                    + "outside of deployment phase from connection " + connId;
            if (loader != null) {
                msg += ", Entity: " + loader.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            System.err.println(msg);
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (game.isPhaseSimultaneous()) {
            turn = game.getTurnForPlayer(connId);
        }

        if ((turn == null)
                || !turn.isValid(connId, loader, game)) {
            String msg = "error: server got invalid deployment unload packet "
                    + "from connection " + connId;
            if (loader != null) {
                msg += ", Entity: " + loader.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            System.err.println(msg);
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket());
            return;
        }

        // Unload and call entityUpdate
        unloadUnit(loader, loaded, null, 0, 0, false, true);

        // Need to update the loader
        entityUpdate(loader.getId());

        // Now need to add a turn for the unloaded unit, to be taken immediately
        // Turn forced to be immediate to avoid messy turn ordering issues
        // (aka, how do we add the turn with individual initiative?)
        game.insertTurnAfter(new GameTurn.SpecificEntityTurn(
                loaded.getOwnerId(), loaded.getId()), game.getTurnIndex() - 1);
        //game.insertNextTurn(new GameTurn.SpecificEntityTurn(
        //        loaded.getOwnerId(), loaded.getId()));
        send(createTurnVectorPacket());
    }


    /**
     * Process a deployment packet by... deploying the entity! We load any other
     * specified entities inside of it too. Also, check that the deployment is
     * valid.
     */
    private void processDeployment(Entity entity, Coords coords, int nFacing,
                                   int elevation, Vector<Entity> loadVector, boolean assaultDrop) {

        for (Entity loaded : loadVector) {
            if (loaded.getTransportId() != Entity.NONE) {
                // we probably already loaded this unit in the chat lounge
                continue;
            }
            if (loaded.getPosition() != null) {
                // Something is fishy in Denmark.
                System.err.println("error: " + entity
                                   + " can not load entity #" + loaded);
                break;
            }
            // Have the deployed unit load the indicated unit.
            loadUnit(entity, loaded, loaded.getTargetBay());
        }

        /*
         * deal with starting velocity for advanced movement. Probably not the
         * best place to do it, but what are you going to do
         */
        if ((entity instanceof Aero) && game.useVectorMove()) {
            Aero a = (Aero) entity;
            if (a.getCurrentVelocityActual() > 0) {
                int[] v = {0, 0, 0, 0, 0, 0};
                v[nFacing] = a.getCurrentVelocityActual();
                entity.setVectors(v);
            }
        }

        entity.setPosition(coords);
        entity.setFacing(nFacing);
        entity.setSecondaryFacing(nFacing);
        IHex hex = game.getBoard().getHex(coords);
        if (assaultDrop) {
            entity.setAltitude(1);
            // from
            // the
            // sky!
            entity.setAssaultDropInProgress(true);
        } else if ((entity instanceof VTOL)
                && (entity.getExternalUnits().size() <= 0)) {
            // We should let players pick, but this simplifies a lot.
            // Only do it for VTOLs, though; assume everything else is on the
            // ground.
            entity.setElevation((hex.ceiling() - hex.surface()) + 1);
            while ((Compute.stackingViolation(game, entity, coords, null) != null)
                   && (entity.getElevation() <= 50)) {
                entity.setElevation(entity.getElevation() + 1);
            }
            if (entity.getElevation() > 50) {
                throw new IllegalStateException(
                        "Entity #"
                        + entity.getId()
                        + " appears to be in an infinite loop trying to get a legal elevation.");
            }
        } else if (entity instanceof Aero) {
            // if the entity is airborne, then we don't want to set its
            // elevation below, because that will
            // default to 999
            if (entity.isAirborne()) {
                entity.setElevation(0);
                elevation = 0;
            }
            if (!game.getBoard().inSpace()) {
                // all spheroid craft should have velocity of zero in atmosphere
                // regardless of what was entered
                Aero a = (Aero) entity;
                if (a.isSpheroid() || game.getPlanetaryConditions().isVacuum()) {
                    a.setCurrentVelocity(0);
                    a.setNextVelocity(0);
                }
                // make sure that entity is above the level of the hex if in
                // atmosphere
                if (game.getBoard().inAtmosphere()
                    && (a.getAltitude() <= hex.ceiling(true))) {
                    // you can't be grounded on low atmosphere map
                    a.setAltitude(hex.ceiling(true) + 1);
                }
            }
        } else if (entity.getMovementMode() == EntityMovementMode.SUBMARINE) {
            // TODO: Submarines should have a selectable height.
            // For now, pretend they're regular naval.
            entity.setElevation(0);
        } else if ((entity.getMovementMode() == EntityMovementMode.HOVER)
                   || (entity.getMovementMode() == EntityMovementMode.WIGE)
                   || (entity.getMovementMode() == EntityMovementMode.NAVAL)
                   || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)) {
            // For now, assume they're on the surface.
            // entity elevation is relative to hex surface
            entity.setElevation(0);
        } else if (hex.containsTerrain(Terrains.ICE)) {
            entity.setElevation(0);
        } else {
            Building bld = game.getBoard().getBuildingAt(entity.getPosition());
            if ((bld != null) && (bld.getType() == Building.WALL)) {
                entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));
            }

        }
        // add the elevation that was passed into this method
        // TODO: currently only used for building placement, we should do this
        // more systematically with
        // up/down buttons in the deployment display
        entity.setElevation(entity.getElevation() + elevation);

        // when first entering a building, we need to roll what type
        // of basement it has
        Building bldg = game.getBoard().getBuildingAt(entity.getPosition());
        if ((bldg != null)) {
            if (bldg.rollBasement(entity.getPosition(), game.getBoard(),
                                  vPhaseReport)) {
                sendChangedHex(entity.getPosition());
                Vector<Building> buildings = new Vector<Building>();
                buildings.add(bldg);
                sendChangedBuildings(buildings);
            }
            boolean collapse = checkBuildingCollapseWhileMoving(bldg, entity,
                                                                entity.getPosition());
            if (collapse) {
                addAffectedBldg(bldg, collapse);
            }
        }

        entity.setDone(true);
        entity.setDeployed(true);
        entityUpdate(entity.getId());
    }

    /**
     * receive a packet that contains hexes that are automatically hit by
     * artillery
     *
     * @param packet
     * @param connId
     */
    @SuppressWarnings("unchecked")
    private void receiveArtyAutoHitHexes(Packet packet, int connId) {
        PlayerIDandList<Coords> artyAutoHitHexes = (PlayerIDandList<Coords>) packet
                .getObject(0);

        int playerId = artyAutoHitHexes.getPlayerID();

        // is this the right phase?
        if (game.getPhase() != IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {
            System.err
                    .println("error: server got set artyautohithexespacket in wrong phase");
            return;
        }
        game.getPlayer(playerId).setArtyAutoHitHexes(artyAutoHitHexes);

        for (Coords coord : artyAutoHitHexes) {
            game.getBoard().addSpecialHexDisplay(
                    coord,
                    new SpecialHexDisplay(
                            SpecialHexDisplay.Type.ARTILLERY_AUTOHIT,
                            SpecialHexDisplay.NO_ROUND, getPlayer(playerId),
                            "Artillery auto hit hex, for "
                            + getPlayer(playerId).getName(),
                            SpecialHexDisplay.SHD_OBSCURED_TEAM));
        }
        endCurrentTurn(null);
    }

    /**
     * receive a packet that contains minefields
     *
     * @param packet
     * @param connId
     */
    @SuppressWarnings("unchecked")
    private void receiveDeployMinefields(Packet packet, int connId) {
        Vector<Minefield> minefields = (Vector<Minefield>) packet.getObject(0);

        // is this the right phase?
        if (game.getPhase() != IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {
            System.err
                    .println("error: server got deploy minefields packet in wrong phase");
            return;
        }

        // looks like mostly everything's okay
        processDeployMinefields(minefields);
        endCurrentTurn(null);
    }

    /**
     * process deployment of minefields
     *
     * @param minefields
     */
    private void processDeployMinefields(Vector<Minefield> minefields) {
        int playerId = IPlayer.PLAYER_NONE;
        for (int i = 0; i < minefields.size(); i++) {
            Minefield mf = minefields.elementAt(i);
            playerId = mf.getPlayerId();

            game.addMinefield(mf);
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {
                game.addVibrabomb(mf);
            }
        }

        IPlayer player = game.getPlayer(playerId);
        if (null != player) {
            int teamId = player.getTeam();

            if (teamId != IPlayer.TEAM_NONE) {
                Enumeration<Team> teams = game.getTeams();
                while (teams.hasMoreElements()) {
                    Team team = teams.nextElement();
                    if (team.getId() == teamId) {
                        Enumeration<IPlayer> players = team.getPlayers();
                        while (players.hasMoreElements()) {
                            IPlayer teamPlayer = players.nextElement();
                            if (teamPlayer.getId() != player.getId()) {
                                send(teamPlayer.getId(), new Packet(
                                        Packet.COMMAND_DEPLOY_MINEFIELDS,
                                        minefields));
                            }
                            teamPlayer.addMinefields(minefields);
                        }
                        break;
                    }
                }
            } else {
                player.addMinefields(minefields);
            }
        }
    }

    /**
     * Client has sent an update indicating that a ground unit is firing at
     * an airborne unit and is overriding the default select for the position
     * in the flight path.
     * @param packet
     * @param connId
     */
    private void receiveGroundToAirHexSelectPacket(Packet packet, int connId) {
        Integer targetId = (Integer)packet.getObject(0);
        Integer attackerId = (Integer)packet.getObject(1);
        Coords pos = (Coords)packet.getObject(2);
        game.getEntity(targetId).setPlayerPickedPassThrough(attackerId, pos);
    }

    /**
     * Gets a bunch of entity attacks from the packet. If valid, processess them
     * and ends the current turn.
     */
    @SuppressWarnings("unchecked")
    private void receiveAttack(Packet packet, int connId) {
        Entity entity = game.getEntity(packet.getIntValue(0));
        Vector<EntityAction> vector = (Vector<EntityAction>) packet
                .getObject(1);

        // is this the right phase?
        if ((game.getPhase() != IGame.Phase.PHASE_FIRING)
            && (game.getPhase() != IGame.Phase.PHASE_PHYSICAL)
            && (game.getPhase() != IGame.Phase.PHASE_TARGETING)
            && (game.getPhase() != IGame.Phase.PHASE_OFFBOARD)) {
            System.err
                    .println("error: server got attack packet in wrong phase");
            return;
        }

        // can this player/entity act right now?
        GameTurn turn = game.getTurn();
        if (game.isPhaseSimultaneous()) {
            turn = game.getTurnForPlayer(connId);
        }
        if ((turn == null) || !turn.isValid(connId, entity, game)) {
            String msg = "error: server got invalid attack packet from "
                         + "connection " + connId;
            if (entity != null) {
                msg += ", Entity: " + entity.getShortName();
            } else {
                msg += ", Entity was null!";
            }
            System.err.println(msg);
            send(connId, createTurnVectorPacket());
            send(connId, createTurnIndexPacket());
            return;
        }

        // looks like mostly everything's okay
        processAttack(entity, vector);

        // Update visibility indications if using double blind.
        if (doBlind()) {
            updateVisibilityIndicator(null);
        }

        endCurrentTurn(entity);
    }

    /**
     * Process a batch of entity attack (or twist) actions by adding them to the
     * proper list to be processed later.
     */
    private void processAttack(Entity entity, Vector<EntityAction> vector) {

        // Convert any null vectors to empty vectors to avoid NPEs.
        if (vector == null) {
            vector = new Vector<EntityAction>(0);
        }

        // Not **all** actions take up the entity's turn.
        boolean setDone = !((game.getTurn() instanceof GameTurn.TriggerAPPodTurn) || (game
                .getTurn() instanceof GameTurn.TriggerBPodTurn));
        for (EntityAction ea : vector) {
            // is this the right entity?
            if (ea.getEntityId() != entity.getId()) {
                System.err.println("error: attack packet has wrong attacker");
                continue;
            }
            if (ea instanceof PushAttackAction) {
                // push attacks go the end of the displacement attacks
                PushAttackAction paa = (PushAttackAction) ea;
                entity.setDisplacementAttack(paa);
                game.addCharge(paa);
            } else if (ea instanceof DodgeAction) {
                entity.dodging = true;
            } else if (ea instanceof SpotAction) {
                entity.setSpotting(true);
                entity.setSpotTargetId(((SpotAction) ea).getTargetId());
            } else {
                // add to the normal attack list.
                game.addAction(ea);
            }

            // Anti-mech and pointblank attacks from
            // hiding may allow the target to respond.
            if (ea instanceof WeaponAttackAction) {
                final WeaponAttackAction waa = (WeaponAttackAction) ea;
                final String weaponName = entity
                        .getEquipment(waa.getWeaponId()).getType()
                        .getInternalName();

                if (Infantry.SWARM_MEK.equals(weaponName)
                    || Infantry.LEG_ATTACK.equals(weaponName)) {

                    // Does the target have any AP Pods available?
                    final Entity target = game.getEntity(waa.getTargetId());
                    for (Mounted equip : target.getMisc()) {
                        if (equip.getType().hasFlag(MiscType.F_AP_POD)
                            && equip.canFire()) {

                            // Yup. Insert a game turn to handle AP pods.
                            // ASSUMPTION : AP pod declarations come
                            // immediately after the attack declaration.
                            game.insertNextTurn(new GameTurn.TriggerAPPodTurn(
                                    target.getOwnerId(), target.getId()));
                            send(createTurnVectorPacket());

                            // We can stop looking.
                            break;

                        } // end found-available-ap-pod

                    } // Check the next piece of equipment on the target.

                    for (Mounted weapon : target.getWeaponList()) {
                        if (weapon.getType().hasFlag(WeaponType.F_B_POD)
                            && weapon.canFire()) {

                            // Yup. Insert a game turn to handle B pods.
                            // ASSUMPTION : B pod declarations come
                            // immediately after the attack declaration.
                            game.insertNextTurn(new GameTurn.TriggerBPodTurn(
                                    target.getOwnerId(), target.getId(),
                                    weaponName));
                            send(createTurnVectorPacket());

                            // We can stop looking.
                            break;

                        } // end found-available-b-pod
                    } // Check the next piece of equipment on the target.
                } // End check-for-available-ap-pod

                // Keep track of altitude loss for weapon attacks
                if (entity instanceof Aero) {
                    Aero aero = (Aero) entity;
                    if (waa.getAltitudeLoss(game) > aero.getAltLoss()) {
                        aero.setAltLoss(waa.getAltitudeLoss(game));
                    }
                }
            }

            // If attacker breaks grapple, defender may counter
            if (ea instanceof BreakGrappleAttackAction) {
                final BreakGrappleAttackAction bgaa = (BreakGrappleAttackAction) ea;
                final Entity att = (game.getEntity(bgaa.getEntityId()));
                if (att.isGrappleAttacker()) {
                    final Entity def = (game.getEntity(bgaa.getTargetId()));
                    // Remove existing break grapple by defender (if exists)
                    if (def.isDone()) {
                        game.removeActionsFor(def.getId());
                    } else {
                        game.removeTurnFor(def);
                        def.setDone(true);
                    }
                    // Add a turn to declare counterattack
                    game.insertNextTurn(new GameTurn.CounterGrappleTurn(def
                                                                                .getOwnerId(), def.getId()));
                    send(createTurnVectorPacket());
                }
            }
            if (ea instanceof ArtilleryAttackAction) {
                boolean firingAtNewHex = false;
                final ArtilleryAttackAction aaa = (ArtilleryAttackAction) ea;
                final Entity firingEntity = game.getEntity(aaa.getEntityId());
                for (Enumeration<AttackHandler> j = game.getAttacks(); !firingAtNewHex
                                                                       && j.hasMoreElements(); ) {
                    WeaponHandler wh = (WeaponHandler) j.nextElement();
                    if (wh.waa instanceof ArtilleryAttackAction) {
                        ArtilleryAttackAction oaaa = (ArtilleryAttackAction) wh.waa;
                        if ((oaaa.getEntityId() == aaa.getEntityId())
                            && !oaaa.getTarget(game)
                                    .getPosition()
                                    .equals(aaa.getTarget(game)
                                               .getPosition())) {
                            firingAtNewHex = true;
                        }
                    }
                }
                if (firingAtNewHex) {
                    clearArtillerySpotters(firingEntity.getId(),
                                           aaa.getWeaponId());
                }
                Iterator<Entity> spotters = game
                        .getSelectedEntities(new EntitySelector() {
                            public int player = firingEntity.getOwnerId();
                            public Targetable target = aaa.getTarget(game);

                            public boolean accept(Entity entity) {
                                LosEffects los = LosEffects.calculateLos(game,
                                                                         entity.getId(), target);
                                return ((player == entity.getOwnerId())
                                        && !(los.isBlocked()) && entity
                                        .isActive());
                            }
                        });
                Vector<Integer> spotterIds = new Vector<Integer>();
                while (spotters.hasNext()) {
                    Integer id = new Integer(spotters.next().getId());
                    spotterIds.addElement(id);
                }
                aaa.setSpotterIds(spotterIds);
            }

            // The equipment type of a club needs to be restored.
            if (ea instanceof ClubAttackAction) {
                ClubAttackAction caa = (ClubAttackAction) ea;
                Mounted club = caa.getClub();
                club.restore();
            }

            // Mark any AP Pod as used in this turn.
            if (ea instanceof TriggerAPPodAction) {
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;
                Mounted pod = entity.getEquipment(tapa.getPodId());
                pod.setUsedThisRound(true);
            }
            // Mark any B Pod as used in this turn.
            if (ea instanceof TriggerBPodAction) {
                TriggerBPodAction tba = (TriggerBPodAction) ea;
                Mounted pod = entity.getEquipment(tba.getPodId());
                pod.setUsedThisRound(true);
            }

            // Mark illuminated hexes, so they can be displayed
            if (ea instanceof SearchlightAttackAction) {
                boolean hexesAdded =
                        ((SearchlightAttackAction) ea).setHexesIlluminated(game);
                // If we added new hexes, send them to all players.
                // These are spotlights at night, you know they're there.
                if (hexesAdded) {
                    send(createIlluminatedHexesPacket());
                }
            }
        }

        // Apply altitude loss
        if (entity instanceof Aero) {
            Aero aero = (Aero) entity;
            if (aero.getAltLoss() > 0) {
                Report r = new Report(9095);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(aero.getAltLoss());
                addReport(r);
                aero.setAltitude(aero.getAltitude() - aero.getAltLoss());
                aero.resetAltLoss();
                entityUpdate(entity.getId());
            }
        }

        // Unless otherwise stated,
        // this entity is done for the round.
        if (setDone) {
            entity.setDone(true);
        }
        entityUpdate(entity.getId());

        Packet p = createAttackPacket(vector, 0);
        if (game.isPhaseSimultaneous()) {
            // Update attack only to player who declared it & observers
            for (IPlayer player : game.getPlayersVector()) {
                if (player.canSeeAll() || player.isObserver()
                    || (entity.getOwnerId() == player.getId())) {
                    send(player.getId(), p);
                }
            }
        } else {
            // update all players on the attacks. Don't worry about pushes being
            // a "charge" attack. It doesn't matter to the client.
            send(p);
        }
    }

    /**
     * Determine which missile attack actions could be affected by AMS, and
     * assign AMS (and APDS) to those attacks.
     */
    private void assignAMS() {

        // Get all of the coords that would be protected by APDS
        Hashtable<Coords, List<Mounted>> apdsCoords = getAPDSProtectedCoords();

        // Map target to a list of missile attacks directed at it
        Hashtable<Entity, Vector<WeaponHandler>> htAttacks = new Hashtable<>();
        // Keep track of each APDS, and which attacks it could affect
        Hashtable<Mounted, Vector<WeaponHandler>> apdsTargets = new Hashtable<>();
        for (AttackHandler ah : game.getAttacksVector()) {
            WeaponHandler wh = (WeaponHandler) ah;
            WeaponAttackAction waa = wh.waa;
            // ignore artillery attacks, here the attacking entity
            // might no longer be in the game
            if (waa instanceof ArtilleryAttackAction) {
                continue;
            }
            Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(
                    waa.getWeaponId());

            // Only entities can have AMS.
            if (Targetable.TYPE_ENTITY != waa.getTargetType()) {
                continue;
            }

            // AMS is only used against attacks that hit (TW p129)
            if (wh.roll < wh.toHit.getValue()) {
                continue;
            }

            // Can only use AMS versus missles.
            if (weapon.getType().hasFlag(WeaponType.F_MISSILE)) {
                Entity target = game.getEntity(waa.getTargetId());
                Vector<WeaponHandler> v = htAttacks.get(target);
                if (v == null) {
                    v = new Vector<WeaponHandler>();
                    htAttacks.put(target, v);
                }
                v.addElement(wh);
                // Keep track of what weapon attacks could be affected by APDS
                if (apdsCoords.containsKey(target.getPosition())) {
                    for (Mounted apds : apdsCoords.get(target.getPosition())) {
                        // APDS only affects attacks against friendly units
                        if (target.isEnemyOf(apds.getEntity())) {
                            continue;
                        }
                        Vector<WeaponHandler> handlerList = apdsTargets
                                .get(apds);
                        if (handlerList == null) {
                            handlerList = new Vector<>();
                            apdsTargets.put(apds, handlerList);
                        }
                        handlerList.add(wh);
                    }
                }
            }
        }


        // Let each target assign its AMS
        for (Entity e : htAttacks.keySet()) {
            Vector<WeaponHandler> vAttacks = htAttacks.get(e);
            // Allow MM to automatically assign AMS targets
            if (game.getOptions().booleanOption("auto_ams")) {
                e.assignAMS(vAttacks);
            } else { // Allow user to manually assign targets
                manuallyAssignAMSTarget(e, vAttacks);
            }
        }

        // Let each APDS assign itself to an attack
        Set<WeaponAttackAction> targetedAttacks = new HashSet<>();
        for (Mounted apds : apdsTargets.keySet()) {
            List<WeaponHandler> potentialTargets = apdsTargets.get(apds);
            // Ensure we only target each attack once
            List<WeaponHandler> targetsToRemove = new ArrayList<>();
            for (WeaponHandler wh : potentialTargets) {
                if (targetedAttacks.contains(wh.getWaa())) {
                    targetsToRemove.add(wh);
                }
            }
            potentialTargets.removeAll(targetsToRemove);
            WeaponAttackAction targetedWAA;
            // Assign APDS to an attack
            if (game.getOptions().booleanOption("auto_ams")) {
                targetedWAA = apds.assignAPDS(potentialTargets);
            } else { // Allow user to manually assign targets
                targetedWAA = manuallyAssignAPDSTarget(apds, potentialTargets);
            }
            if (targetedWAA != null) {
                targetedAttacks.add(targetedWAA);
            }
        }
    }

    /**
     * Convenience method for determining which missile attack will be targeted
     * with AMS on the supplied Entity
     *
     * @param e
     *            The Entity with AMS
     * @param vAttacks
     *            List of missile attacks directed at e
     */
    private WeaponAttackAction manuallyAssignAPDSTarget(Mounted apds,
            List<WeaponHandler> vAttacks) {
        Entity e = apds.getEntity();
        if (e == null) {
            return null;
        }

        // Create a list of valid assignments for this APDS
        List<WeaponAttackAction> vAttacksInArc = new ArrayList<>(
                vAttacks.size());
        for (WeaponHandler wr : vAttacks) {
            boolean isInArc = Compute.isInArc(e.getGame(), e.getId(),
                    e.getEquipmentNum(apds),
                    game.getEntity(wr.waa.getEntityId()));
            boolean isInRange = e.getPosition().distance(
                    wr.getWaa().getTarget(game).getPosition()) <= 3;
            if (isInArc && isInRange) {
                vAttacksInArc.add(wr.waa);
            }
        }

        // If there are no valid attacks left, don't bother
        if (vAttacksInArc.size() < 1) {
            return null;
        }

        WeaponAttackAction targetedWAA = null;

        if (apds.curMode().equals("Automatic")) {
            targetedWAA = Compute.getHighestExpectedDamage(game,
                    vAttacksInArc, true);
        } else {
            // Send a client feedback request
            List<Integer> apdsDists = new ArrayList<>();
            for (WeaponAttackAction waa : vAttacksInArc) {
                apdsDists.add(waa.getTarget(game).getPosition()
                        .distance(e.getPosition()));
            }
            sendAPDSAssignCFR(e, apdsDists, vAttacksInArc);
            synchronized (cfrPacketQueue) {
                try {
                    cfrPacketQueue.wait();
                } catch (InterruptedException ex) {
                    // Do nothing
                }
                if (cfrPacketQueue.size() > 0) {
                    ReceivedPacket rp = cfrPacketQueue.poll();
                    int cfrType = (int) rp.packet.getData()[0];
                    // Make sure we got the right type of response
                    if (cfrType != Packet.COMMAND_CFR_APDS_ASSIGN) {
                        System.err.println("Expected a "
                                + "COMMAND_CFR_AMS_ASSIGN CFR "
                                + "packet, received: " + cfrType);
                        throw new IllegalStateException();
                    }
                    Integer waaIndex =
                            (Integer)rp.packet.getData()[1];
                    if (waaIndex != null) {
                        targetedWAA = vAttacksInArc.get(waaIndex);
                    }
                }
            }
        }

        if (targetedWAA != null) {
            targetedWAA.addCounterEquipment(apds);
            return targetedWAA;
        } else {
            return null;
        }
    }

    /**
     * Convenience method for determining which missile attack will be targeted
     * with AMS on the supplied Entity
     *
     * @param e
     *            The Entity with AMS
     * @param vAttacks
     *            List of missile attacks directed at e
     */
    private void manuallyAssignAMSTarget(Entity e,
            Vector<WeaponHandler> vAttacks) {
        // Current AMS targets: each attack can only be targeted once
        HashSet<WeaponAttackAction> amsTargets =
                new HashSet<WeaponAttackAction>();
        // Pick assignment for each active AMS
        for (Mounted ams : e.getActiveAMS()) {
            // Skip APDS
            if (ams.isAPDS()) {
                continue;
            }
            // Create a list of valid assignments for this AMS
            ArrayList<WeaponAttackAction> vAttacksInArc =
                    new ArrayList<WeaponAttackAction>(vAttacks.size());
            for (WeaponHandler wr : vAttacks) {
                if (!amsTargets.contains(wr.waa)
                        && Compute.isInArc(game, e.getId(),
                                e.getEquipmentNum(ams),
                                game.getEntity(wr.waa.getEntityId()))) {
                    vAttacksInArc.add(wr.waa);
                }
            }

            // If there are no valid attacks left, don't bother
            if (vAttacksInArc.size() < 1) {
                continue;
            }

            WeaponAttackAction targetedWAA = null;

            if (ams.curMode().equals("Automatic")) {
                targetedWAA = Compute.getHighestExpectedDamage(game,
                        vAttacksInArc, true);
            } else {
                // Send a client feedback request
                sendAMSAssignCFR(e, ams, vAttacksInArc);
                synchronized (cfrPacketQueue) {
                    try {
                        cfrPacketQueue.wait();
                    } catch (InterruptedException ex) {
                        // Do nothing
                    }
                    if (cfrPacketQueue.size() > 0) {
                        ReceivedPacket rp = cfrPacketQueue.poll();
                        int cfrType = (int) rp.packet.getData()[0];
                        // Make sure we got the right type of response
                        if (cfrType != Packet.COMMAND_CFR_AMS_ASSIGN) {
                            System.err.println("Expected a "
                                    + "COMMAND_CFR_AMS_ASSIGN CFR "
                                    + "packet, received: " + cfrType);
                            throw new IllegalStateException();
                        }
                        Integer waaIndex =
                                (Integer)rp.packet.getData()[1];
                        if (waaIndex != null) {
                            targetedWAA = vAttacksInArc.get(waaIndex);
                        }
                    }
                }
            }

            if (targetedWAA != null) {
                targetedWAA.addCounterEquipment(ams);
                amsTargets.add(targetedWAA);
            }
        }
    }

    /**
     * Convenience method for computing a mapping of which Coords are
     * "protected" by an APDS. Protection implies that the coords is within the
     * range/arc of an active APDS.
     *
     * @return
     */
    private Hashtable<Coords, List<Mounted>> getAPDSProtectedCoords() {
        // Get all of the coords that would be protected by APDS
        Hashtable<Coords, List<Mounted>> apdsCoords = new Hashtable<>();
        for (Entity e : game.getEntitiesVector()) {
            // Ignore Entitys without positions
            if (e.getPosition() == null) {
                continue;
            }
            Coords origPos = e.getPosition();
            for (Mounted ams : e.getActiveAMS()) {
                // Ignore non-APDS AMS
                if (!ams.isAPDS()) {
                    continue;
                }
                // Add the current hex as a defended location
                List<Mounted> apdsList = apdsCoords.get(origPos);
                if (apdsList == null) {
                    apdsList = new ArrayList<>();
                    apdsCoords.put(origPos, apdsList);
                }
                apdsList.add(ams);
                // Add each coords that is within arc/range as protected
                int maxDist = 3;
                if (e instanceof BattleArmor) {
                    int numTroopers = ((BattleArmor) e)
                            .getNumberActiverTroopers();
                    switch (numTroopers) {
                        case 1:
                            maxDist = 1;
                            break;
                        case 2:
                        case 3:
                            maxDist = 2;
                            break;
                    // Anything above is the same as the default
                    }
                }
                for (int dist = 1; dist <= maxDist; dist++) {
                    for (int dir = 0; dir <= 5; dir++) {
                        Coords pos = e.getPosition().translated(dir, dist);
                        // Check that we're in the right arc
                        if (Compute.isInArc(game, e.getId(), e
                                .getEquipmentNum(ams),
                                new HexTarget(pos, game.getBoard(),
                                        HexTarget.TYPE_HEX_CLEAR))) {
                            apdsList = apdsCoords.get(pos);
                            if (apdsList == null) {
                                apdsList = new ArrayList<>();
                                apdsCoords.put(pos, apdsList);
                            }
                            apdsList.add(ams);
                        }
                    }
                }

            }
        }
        return apdsCoords;
    }

    /**
     * Called to what players can see what units. This is used to determine who
     * can see what in double blind reports.
     */
    private void resolveWhatPlayersCanSeeWhatUnits() {
        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption("tacops_sensors")) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }
        Map<EntityTargetPair, LosEffects> losCache = new HashMap<>();
        for (Entity entity : game.getEntitiesVector()) {
            // We are hidden once again!
            entity.clearSeenBy();
            entity.clearDetectedBy();
            // Handle visual spotting
            for (IPlayer p : whoCanSee(entity, false, losCache)) {
                entity.addBeenSeenBy(p);
            }
            // Handle detection by sensors
            for (IPlayer p : whoCanDetect(entity, allECMInfo, losCache)) {
                    entity.addBeenDetectedBy(p);
            }
        }
    }

    /**
     * Called during the weapons fire phase. Resolves anything other than
     * weapons fire that happens. Torso twists, for example.
     */
    private void resolveAllButWeaponAttacks() {

        Vector<EntityAction> triggerPodActions = new Vector<EntityAction>();
        // loop thru actions and handle everything we expect except attacks
        for (Enumeration<EntityAction> i = game.getActions(); i
                .hasMoreElements(); ) {
            EntityAction ea = i.nextElement();
            Entity entity = game.getEntity(ea.getEntityId());
            if (ea instanceof TorsoTwistAction) {
                TorsoTwistAction tta = (TorsoTwistAction) ea;
                if (entity.canChangeSecondaryFacing()) {
                    entity.setSecondaryFacing(tta.getFacing());
                }
            } else if (ea instanceof FlipArmsAction) {
                FlipArmsAction faa = (FlipArmsAction) ea;
                entity.setArmsFlipped(faa.getIsFlipped());
            } else if (ea instanceof FindClubAction) {
                resolveFindClub(entity);
            } else if (ea instanceof UnjamAction) {
                resolveUnjam(entity);
            } else if (ea instanceof ClearMinefieldAction) {
                resolveClearMinefield(entity,
                                      ((ClearMinefieldAction) ea).getMinefield());
            } else if (ea instanceof TriggerAPPodAction) {
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;

                // Don't trigger the same pod twice.
                if (!triggerPodActions.contains(tapa)) {
                    triggerAPPod(entity, tapa.getPodId());
                    triggerPodActions.addElement(tapa);
                } else {
                    System.err.print("AP Pod #");
                    System.err.print(tapa.getPodId());
                    System.err.print(" on ");
                    System.err.print(entity.getDisplayName());
                    System.err.println(" was already triggered this round!!");
                }
            } else if (ea instanceof TriggerBPodAction) {
                TriggerBPodAction tba = (TriggerBPodAction) ea;

                // Don't trigger the same pod twice.
                if (!triggerPodActions.contains(tba)) {
                    triggerBPod(entity, tba.getPodId(),
                                game.getEntity(tba.getTargetId()));
                    triggerPodActions.addElement(tba);
                } else {
                    System.err.print("B Pod #");
                    System.err.print(tba.getPodId());
                    System.err.print(" on ");
                    System.err.print(entity.getDisplayName());
                    System.err.println(" was already triggered this round!!");
                }
            } else if (ea instanceof SearchlightAttackAction) {
                SearchlightAttackAction saa = (SearchlightAttackAction) ea;
                addReport(saa.resolveAction(game));
            } else if (ea instanceof UnjamTurretAction) {
                if (entity instanceof Tank) {
                    ((Tank) entity).unjamTurret(((Tank) entity).getLocTurret());
                    ((Tank) entity)
                            .unjamTurret(((Tank) entity).getLocTurret2());
                    Report r = new Report(3033);
                    r.addDesc(entity);
                    addReport(r);
                } else {
                    System.err.println("Non-Tank tried to unjam turret");
                }
            } else if (ea instanceof RepairWeaponMalfunctionAction) {
                if (entity instanceof Tank) {
                    Mounted m = entity
                            .getEquipment(((RepairWeaponMalfunctionAction) ea)
                                                  .getWeaponId());
                    m.setJammed(false);
                    ((Tank) entity).getJammedWeapons().remove(m);
                    Report r = new Report(3034);
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                } else {
                    System.err
                            .println("Non-Tank tried to repair weapon malfunction");
                }
            }
        }
    }

    /*
     * Called during the weapons firing phase to initiate self destructions.
     */
    private void resolveSelfDestructions() {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        for (Entity e : game.getEntitiesVector()) {
            if (e.getSelfDestructInitiated()) {
                r = new Report(6166, Report.PUBLIC);
                int target = e.getCrew().getPiloting();
                int roll = e.getCrew().rollPilotingSkill();
                r.subject = e.getId();
                r.addDesc(e);
                r.indent();
                r.add(target);
                r.add(roll);
                if (roll >= target) {
                    r.choose(true);
                } else {
                    r.choose(false);
                }
                vDesc.add(r);

                // Blow it up...
                if (roll >= target) {
                    int engineRating = e.getEngine().getRating();
                    r = new Report(5400, Report.PUBLIC);
                    r.subject = e.getId();
                    r.indent(2);
                    vDesc.add(r);

                    if (e instanceof Mech) {
                        Mech mech = (Mech) e;
                        if (mech.isAutoEject()
                            && (!game.getOptions().booleanOption(
                                "conditional_ejection") || (game
                                                                    .getOptions().booleanOption(
                                        "conditional_ejection") && mech
                                                                    .isCondEjectEngine()))) {
                            vDesc.addAll(ejectEntity(e, true));
                        }
                    }

                    doFusionEngineExplosion(engineRating, e.getPosition(),
                                            vDesc, null);
                    Report.addNewline(vDesc);
                    r = new Report(5410, Report.PUBLIC);
                    r.subject = e.getId();
                    r.indent(2);
                    Report.addNewline(vDesc);
                    vDesc.add(r);
                }
                e.setSelfDestructInitiated(false);
            }
        }
        addReport(vDesc);
    }

    private void reportGhostTargetRolls() {
        // run through an enumeration of deployed game entities. If they have
        // ghost targets, then check the roll
        // and report it
        Report r;
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            if (ent.isDeployed() && ent.hasGhostTargets(false)) {
                r = new Report(3630);
                r.subject = ent.getId();
                r.addDesc(ent);
                int target = ent.getCrew().getPiloting() + 2;
                int roll = ent.getGhostTargetRoll();
                r.add(target);
                r.add(roll);
                if (roll >= target) {
                    r.choose(true);
                } else {
                    r.choose(false);
                }
                addReport(r);
            }
        }
    }

    private void reportLargeCraftECCMRolls() {
        // run through an enumeration of deployed game entities. If they are
        // large craft in space, then check the roll
        // and report it
        if (!game.getBoard().inSpace()
            || !game.getOptions().booleanOption("stratops_ecm")) {
            return;
        }
        Report r;
        for (Iterator<Entity> e = game.getEntities(); e.hasNext(); ) {
            Entity ent = e.next();
            if (ent.isDeployed() && ent.isLargeCraft()) {
                r = new Report(3635);
                r.addDesc(ent);
                int target = ((Aero) ent).getECCMTarget();
                int roll = ((Aero) ent).getECCMRoll();
                r.add(roll);
                r.add(target);
                int mod = ((Aero) ent).getECCMBonus();
                r.add(mod);
                addReport(r);
            }
        }
    }

    private void resolveClearMinefield(Entity ent, Minefield mf) {

        if ((null == mf) || (null == ent) || ent.isDoomed()
            || ent.isDestroyed()) {
            return;
        }

        Coords pos = mf.getCoords();
        int clear = Minefield.CLEAR_NUMBER_INFANTRY;
        int boom = Minefield.CLEAR_NUMBER_INFANTRY_ACCIDENT;

        Report r;
        // Does the entity has a minesweeper?
        if ((ent instanceof BattleArmor)) {
            BattleArmor ba = (BattleArmor)ent;
            String mcmName = BattleArmor.MANIPULATOR_TYPE_STRINGS
                    [BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE];
            if (ba.getLeftManipulatorName().equals(mcmName)) {
                clear = Minefield.CLEAR_NUMBER_BA_SWEEPER;
                boom = Minefield.CLEAR_NUMBER_BA_SWEEPER_ACCIDENT;
            }
            r = new Report(2246);
        } else {
            r = new Report(2245);
        }
        // mine clearing roll
        r.subject = ent.getId();
        r.add(ent.getShortName(), true);
        r.add(Minefield.getDisplayableName(mf.getType()));
        r.add(pos.getBoardNum(), true);
        addReport(r);

        if (clearMinefield(mf, ent, clear, boom, vPhaseReport)) {
            removeMinefield(mf);
        }
        // some mines might have blown up
        resetMines();
    }

    /**
     * Called during the fire phase to resolve all (and only) weapon attacks
     */
    private void resolveOnlyWeaponAttacks() {
        // loop thru received attack actions, getting attack handlers
        for (Enumeration<EntityAction> i = game.getActions(); i
                .hasMoreElements(); ) {
            EntityAction ea = i.nextElement();
            if (ea instanceof WeaponAttackAction) {
                WeaponAttackAction waa = (WeaponAttackAction) ea;
                Entity ae = game.getEntity(waa.getEntityId());
                Mounted m = ae.getEquipment(waa.getWeaponId());
                Weapon w = (Weapon) m.getType();
                // Track attacks original target, for things like swarm LRMs
                waa.setOriginalTargetId(waa.getTargetId());
                waa.setOriginalTargetType(waa.getTargetType());
                AttackHandler ah = w.fire(waa, game, this);
                if (ah != null) {
                    ah.setStrafing(waa.isStrafing());
                    ah.setStrafingFirstShot(waa.isStrafingFirstShot());
                    game.addAttack(ah);
                }
            }
        }
        // and clear the attacks Vector
        game.resetActions();
    }

    /**
     * Trigger the indicated AP Pod of the entity.
     *
     * @param entity the <code>Entity</code> triggering the AP Pod.
     * @param podId  the <code>int</code> ID of the AP Pod.
     */
    private void triggerAPPod(Entity entity, int podId) {

        // Get the mount for this pod.
        Mounted mount = entity.getEquipment(podId);

        // Confirm that this is, indeed, an AP Pod.
        if (null == mount) {
            System.err.print("Expecting to find an AP Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.println(" but found NO equipment at all!!!");
            return;
        }
        EquipmentType equip = mount.getType();
        if (!(equip instanceof MiscType) || !equip.hasFlag(MiscType.F_AP_POD)) {
            System.err.print("Expecting to find an AP Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.print(" but found ");
            System.err.print(equip.getName());
            System.err.println(" instead!!!");
            return;
        }

        // Now confirm that the entity can trigger the pod.
        // Ignore the "used this round" flag.
        boolean oldFired = mount.isUsedThisRound();
        mount.setUsedThisRound(false);
        boolean canFire = mount.canFire();
        mount.setUsedThisRound(oldFired);
        if (!canFire) {
            System.err.print("Can not trigger the AP Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.println("!!!");
            return;
        }

        Report r;

        // Mark the pod as fired and log the action.
        mount.setFired(true);
        r = new Report(3010);
        r.newlines = 0;
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // Walk through ALL entities in the triggering entity's hex.
        for (Entity target : game.getEntitiesVector(entity.getPosition())) {

            // Is this an unarmored infantry platoon?
            if ((target instanceof Infantry)
                && !(target instanceof BattleArmor)) {

                // Roll d6-1 for damage.
                final int damage = Math.max(1, Compute.d6() - 1);

                // Damage the platoon.
                addReport(damageEntity(target, new HitData(
                        Infantry.LOC_INFANTRY), damage));

                // Damage from AP Pods is applied immediately.
                target.applyDamage();

            } // End target-is-unarmored

            // Nope, the target is immune.
            // Don't make a log entry for the triggering entity.
            else if (!entity.equals(target)) {
                r = new Report(3020);
                r.indent(2);
                r.subject = target.getId();
                r.addDesc(target);
                addReport(r);
            }

        } // Check the next entity in the triggering entity's hex.
    }

    /**
     * Trigger the indicated B Pod of the entity.
     *
     * @param entity the <code>Entity</code> triggering the B Pod.
     * @param podId  the <code>int</code> ID of the B Pod.
     */
    private void triggerBPod(Entity entity, int podId, Entity target) {

        // Get the mount for this pod.
        Mounted mount = entity.getEquipment(podId);

        // Confirm that this is, indeed, an Anti-BA Pod.
        if (null == mount) {
            System.err.print("Expecting to find an B Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.println(" but found NO equipment at all!!!");
            return;
        }
        EquipmentType equip = mount.getType();
        if (!(equip instanceof WeaponType)
            || !equip.hasFlag(WeaponType.F_B_POD)) {
            System.err.print("Expecting to find an B Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.print(" but found ");
            System.err.print(equip.getName());
            System.err.println(" instead!!!");
            return;
        }

        // Now confirm that the entity can trigger the pod.
        // Ignore the "used this round" flag.
        boolean oldFired = mount.isUsedThisRound();
        mount.setUsedThisRound(false);
        boolean canFire = mount.canFire();
        mount.setUsedThisRound(oldFired);
        if (!canFire) {
            System.err.print("Can not trigger the B Pod at ");
            System.err.print(podId);
            System.err.print(" on the unit, ");
            System.err.print(entity.getDisplayName());
            System.err.println("!!!");
            return;
        }

        Report r;

        // Mark the pod as fired and log the action.
        mount.setFired(true);
        r = new Report(3011);
        r.newlines = 0;
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);

        // Is this an unarmored infantry platoon?
        if ((target instanceof Infantry) && !(target instanceof BattleArmor)) {

            // Roll d6 for damage.
            final int damage = Compute.d6();

            // Damage the platoon.
            addReport(damageEntity(target, new HitData(Infantry.LOC_INFANTRY),
                                   damage));

            // Damage from AP Pods is applied immediately.
            target.applyDamage();

            // End target-is-unarmored
        } else if (target instanceof BattleArmor) {
            // 20 damage in 5 point clusters
            final int damage = 5;

            // Damage the squad.
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));
            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));

            // Damage from B Pods is applied immediately.
            target.applyDamage();
        }

        // Nope, the target is immune.
        // Don't make a log entry for the triggering entity.
        else if (!entity.equals(target)) {
            r = new Report(3020);
            r.indent(2);
            r.subject = target.getId();
            r.addDesc(target);
            addReport(r);
        }
    }

    /**
     * Resolve an Unjam Action object
     */
    private void resolveUnjam(Entity entity) {
        Report r;
        final int TN = entity.getCrew().getGunnery() + 3;
        if (game.getOptions().booleanOption("unjam_uac")) {
            r = new Report(3026);
        } else {
            r = new Report(3025);
        }
        r.subject = entity.getId();
        r.addDesc(entity);
        addReport(r);
        for (Mounted mounted : entity.getTotalWeaponList()) {
            if (mounted.isJammed() && !mounted.isDestroyed()) {
                WeaponType wtype = (WeaponType) mounted.getType();
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {
                    int roll = Compute.d6(2);
                    r = new Report(3030);
                    r.indent();
                    r.subject = entity.getId();
                    r.add(wtype.getName());
                    r.add(TN);
                    r.add(roll);
                    if (roll >= TN) {
                        r.choose(true);
                        mounted.setJammed(false);
                    } else {
                        r.choose(false);
                    }
                    addReport(r);
                }
                // Unofficial option to unjam UACs, ACs, and LACs like Rotary
                // Autocannons
                if (((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)
                     || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)
                     || (wtype.getAmmoType() == AmmoType.T_AC) || (wtype
                                                                           .getAmmoType() == AmmoType.T_LAC))
                    && game.getOptions().booleanOption("unjam_uac")) {
                    int roll = Compute.d6(2);
                    r = new Report(3030);
                    r.indent();
                    r.subject = entity.getId();
                    r.add(wtype.getName());
                    r.add(TN);
                    r.add(roll);
                    if (roll >= TN) {
                        r.choose(true);
                        mounted.setJammed(false);
                    } else {
                        r.choose(false);
                    }
                    addReport(r);
                }
            }
        }
    }

    private void resolveFindClub(Entity entity) {
        EquipmentType clubType = null;

        entity.setFindingClub(true);

        // Get the entity's current hex.
        Coords coords = entity.getPosition();
        IHex curHex = game.getBoard().getHex(coords);

        Report r;

        // Is there a blown off arm in the hex?
        if (curHex.terrainLevel(Terrains.ARMS) > 0) {
            clubType = EquipmentType.get("Limb Club");
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                    Terrains.ARMS, curHex.terrainLevel(Terrains.ARMS) - 1));
            sendChangedHex(entity.getPosition());
            r = new Report(3035);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }
        // Is there a blown off leg in the hex?
        else if (curHex.terrainLevel(Terrains.LEGS) > 0) {
            clubType = EquipmentType.get("Limb Club");
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                    Terrains.LEGS, curHex.terrainLevel(Terrains.LEGS) - 1));
            sendChangedHex(entity.getPosition());
            r = new Report(3040);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }

        // Is there the rubble of a medium, heavy,
        // or hardened building in the hex?
        else if (Building.LIGHT < curHex.terrainLevel(Terrains.RUBBLE)) {

            // Finding a club is not guaranteed. The chances are
            // based on the type of building that produced the
            // rubble.
            boolean found = false;
            int roll = Compute.d6(2);
            switch (curHex.terrainLevel(Terrains.RUBBLE)) {
                case Building.MEDIUM:
                    if (roll >= 7) {
                        found = true;
                    }
                    break;
                case Building.HEAVY:
                    if (roll >= 6) {
                        found = true;
                    }
                    break;
                case Building.HARDENED:
                    if (roll >= 5) {
                        found = true;
                    }
                    break;
                case Building.WALL:
                    if (roll >= 13) {
                        found = true;
                    }
                    break;
                default:
                    // we must be in ultra
                    if (roll >= 4) {
                        found = true;
                    }
            }

            // Let the player know if they found a club.
            if (found) {
                clubType = EquipmentType.get("Girder Club");
                r = new Report(3045);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
            } else {
                // Sorry, no club for you.
                r = new Report(3050);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
            }
        }

        // Are there woods in the hex?
        else if (curHex.containsTerrain(Terrains.WOODS)
                 || curHex.containsTerrain(Terrains.JUNGLE)) {
            clubType = EquipmentType.get("Tree Club");
            r = new Report(3055);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }

        // add the club
        try {
            if (clubType != null) {
                entity.addEquipment(clubType, Entity.LOC_NONE);
            }
        } catch (LocationFullException ex) {
            // unlikely...
            r = new Report(3060);
            r.subject = entity.getId();
            r.addDesc(entity);
            addReport(r);
        }
    }

    /**
     * Try to ignite the hex, taking into account exisiting fires and the
     * effects of Inferno rounds.
     *
     * @param c              - the <code>Coords</code> of the hex being lit.
     * @param entityId       - the <code>int</code> id of the entity involved.
     * @param bInferno       - <code>true</code> if the weapon igniting the hex is an
     *                       Inferno round. If some other weapon or ammo is causing the
     *                       roll, this should be <code>false</code>.
     * @param bHotGun        - <code>true</code> if the weapon is plasma/flamer/incendiary
     *                       LRM/etc
     * @param nTargetRoll    - the <code>TargetRoll</code> for the ignition roll.
     * @param bReportAttempt - <code>true</code> if the attempt roll should be added to the
     *                       report.
     * @param accidentTarget - <code>int</code> the target number below which a roll has to
     *                       be made in order to try igniting a hex accidently. -1 for
     *                       intentional
     */
    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun,
                                boolean bInferno, TargetRoll nTargetRoll, boolean bReportAttempt,
                                int accidentTarget, Vector<Report> vPhaseReport) {

        IHex hex = game.getBoard().getHex(c);
        Report r;

        // Ignore bad coordinates.
        if (hex == null) {
            return false;
        }

        // Ignore if fire is not enabled as a game option
        if (!game.getOptions().booleanOption("tacops_start_fire")) {
            return false;
        }

        // is the hex ignitable (how are infernos handled?)
        if (!hex.isIgnitable()) {
            return false;
        }

        // first for accidental ignitions, make the necessary roll
        if (accidentTarget > -1) {
            // if this hex is in snow, then accidental ignitions are not
            // possible
            if (hex.containsTerrain(Terrains.SNOW)) {
                return false;
            }
            nTargetRoll.addModifier(2, "accidental");
            int accidentRoll = Compute.d6(2);
            r = new Report(3066);
            r.subject = entityId;
            r.add(accidentTarget);
            r.add(accidentRoll);
            r.indent(2);
            if (accidentRoll > accidentTarget) {
                r.choose(false);
                vPhaseReport.add(r);
                return false;
            }
            r.choose(true);
            vPhaseReport.add(r);
        }

        int terrainMod = hex.getIgnitionModifier();
        if (terrainMod != 0) {
            nTargetRoll.addModifier(terrainMod, "terrain");
        }

        // building modifiers
        Building bldg = game.getBoard().getBuildingAt(c);
        if (null != bldg) {
            nTargetRoll.addModifier(bldg.getType() - 1, "building");
        }

        // add in any modifiers for planetary conditions
        int weatherMod = game.getPlanetaryConditions().getIgniteModifiers();
        if (weatherMod != 0) {
            nTargetRoll.addModifier(weatherMod, "conditions");
        }

        // if there is snow on the ground and this a hotgun or inferno, it may
        // melt the snow instead
        if ((hex.containsTerrain(Terrains.SNOW) || hex
                .containsTerrain(Terrains.ICE)) && (bHotGun || bInferno)) {
            boolean melted = false;
            int meltCheck = Compute.d6(2);
            if ((hex.terrainLevel(Terrains.SNOW) > 1) && (meltCheck == 12)) {
                melted = true;
            } else if (hex.containsTerrain(Terrains.ICE) && (meltCheck > 9)) {
                melted = true;
            } else if (hex.containsTerrain(Terrains.SNOW) && (meltCheck > 7)) {
                melted = true;
            }
            if (bInferno) {
                melted = true;
            }
            if (melted) {
                vPhaseReport.addAll(meltIceAndSnow(c, entityId));
                return false;
            }

        }

        // inferno always ignites
        // ERRATA not if targeting clear hexes for ignition is disabled.
        if (bInferno && !game.getOptions().booleanOption("no_ignite_clear")) {
            nTargetRoll = new TargetRoll(0, "inferno");
        }

        // no lighting fires in tornados
        if (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_STORM) {
            nTargetRoll = new TargetRoll(TargetRoll.AUTOMATIC_FAIL, "tornado");
        }

        // The hex may already be on fire.
        if (hex.containsTerrain(Terrains.FIRE)) {
            if (bReportAttempt) {
                r = new Report(3065);
                r.indent(2);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
        } else if (checkIgnition(c, nTargetRoll, bInferno, entityId,
                                 vPhaseReport)) {
            return true;
        }
        return false;
    }

    /**
     * Try to ignite the hex, taking into account exisiting fires and the
     * effects of Inferno rounds. This version of the method will not report the
     * attempt roll.
     *
     * @param c           - the <code>Coords</code> of the hex being lit.
     * @param entityId    - the <code>int</code> id of the entity involved.
     * @param bInferno    - <code>true</code> if the weapon igniting the hex is an
     *                    Inferno round. If some other weapon or ammo is causing the
     *                    roll, this should be <code>false</code>.
     * @param nTargetRoll - the <code>int</code> roll target for the attempt.
     */
    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun,
                                boolean bInferno, TargetRoll nTargetRoll, int accidentTarget,
                                Vector<Report> vPhaseReport) {
        return tryIgniteHex(c, entityId, bHotGun, bInferno, nTargetRoll, false,
                            accidentTarget, vPhaseReport);
    }

    public Vector<Report> tryClearHex(Coords c, int nDamage, int entityId) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        IHex h = game.getBoard().getHex(c);
        if (h == null) {
            return vPhaseReport;
        }
        ITerrain woods = h.getTerrain(Terrains.WOODS);
        ITerrain jungle = h.getTerrain(Terrains.JUNGLE);
        ITerrain ice = h.getTerrain(Terrains.ICE);
        ITerrain magma = h.getTerrain(Terrains.MAGMA);
        Report r;
        int reportType = Report.HIDDEN;
        if (entityId == Entity.NONE) {
            reportType = Report.PUBLIC;
        }
        if (woods != null) {
            int tf = woods.getTerrainFactor() - nDamage;
            int level = woods.getLevel();
            if (tf <= 0) {
                h.removeTerrain(Terrains.WOODS);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.ROUGH, 1));
                // light converted to rough
                r = new Report(3090, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 50) && (level > 1)) {
                h.removeTerrain(Terrains.WOODS);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.WOODS, 1));
                woods = h.getTerrain(Terrains.WOODS);
                // heavy converted to light
                r = new Report(3085, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 90) && (level > 2)) {
                h.removeTerrain(Terrains.WOODS);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.WOODS, 2));
                woods = h.getTerrain(Terrains.WOODS);
                // ultra heavy converted to heavy
                r = new Report(3082, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
            woods.setTerrainFactor(tf);
        }
        if (jungle != null) {
            int tf = jungle.getTerrainFactor() - nDamage;
            int level = jungle.getLevel();
            if (tf < 0) {
                h.removeTerrain(Terrains.JUNGLE);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.ROUGH, 1));
                // light converted to rough
                r = new Report(3091, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 50) && (level > 1)) {
                h.removeTerrain(Terrains.JUNGLE);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.JUNGLE, 1));
                jungle = h.getTerrain(Terrains.JUNGLE);
                // heavy converted to light
                r = new Report(3086, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            } else if ((tf <= 90) && (level > 2)) {
                h.removeTerrain(Terrains.JUNGLE);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.JUNGLE, 2));
                jungle = h.getTerrain(Terrains.JUNGLE);
                // ultra heavy converted to heavy
                r = new Report(3083, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
            }
            jungle.setTerrainFactor(tf);
        }
        if (ice != null) {
            int tf = ice.getTerrainFactor() - nDamage;
            if (tf <= 0) {
                // ice melted
                r = new Report(3092, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
                vPhaseReport.addAll(resolveIceBroken(c));
            } else {
                ice.setTerrainFactor(tf);
            }
        }
        if ((magma != null) && (magma.getLevel() == 1)) {
            int tf = magma.getTerrainFactor() - nDamage;
            if (tf <= 0) {
                // magma crust destroyed
                r = new Report(3093, reportType);
                r.subject = entityId;
                vPhaseReport.add(r);
                h.removeTerrain(Terrains.MAGMA);
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.MAGMA, 2));
                for (Entity en : game.getEntitiesVector(c)) {
                    doMagmaDamage(en, false);
                }
            } else {
                magma.setTerrainFactor(tf);
            }
        }
        sendChangedHex(c);

        // any attempt to clear an heavy industrial hex may cause an exposion
        checkExplodeIndustrialZone(c, vPhaseReport);

        return vPhaseReport;
    }

    /**
     * Handle all physical attacks for the round
     */
    private void resolvePhysicalAttacks() {
        // Physical phase header
        addReport(new Report(4000, Report.PUBLIC));

        // add any pending charges
        for (Enumeration<AttackAction> i = game.getCharges(); i
                .hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetCharges();

        // add any pending rams
        for (Enumeration<AttackAction> i = game.getRams(); i.hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetRams();

        // add any pending Tele Missile Attacks
        for (Enumeration<AttackAction> i = game.getTeleMissileAttacks(); i
                .hasMoreElements(); ) {
            game.addAction(i.nextElement());
        }
        game.resetTeleMissileAttacks();

        // remove any duplicate attack declarations
        cleanupPhysicalAttacks();

        // loop thru received attack actions
        for (Enumeration<EntityAction> i = game.getActions(); i
                .hasMoreElements(); ) {
            Object o = i.nextElement();
            // verify that the attacker is still active
            AttackAction aa = (AttackAction) o;
            if (!game.getEntity(aa.getEntityId()).isActive()
                && !(o instanceof DfaAttackAction)) {
                continue;
            }
            AbstractAttackAction aaa = (AbstractAttackAction) o;
            // do searchlights immediately
            if (aaa instanceof SearchlightAttackAction) {
                SearchlightAttackAction saa = (SearchlightAttackAction) aaa;
                addReport(saa.resolveAction(game));
            } else {
                physicalResults.addElement(preTreatPhysicalAttack(aaa));
            }
        }
        int cen = Entity.NONE;
        for (PhysicalResult pr : physicalResults) {
            resolvePhysicalAttack(pr, cen);
            cen = pr.aaa.getEntityId();
        }
        physicalResults.removeAllElements();
    }

    /**
     * Cleans up the attack declarations for the physical phase by removing all
     * attacks past the first for any one mech. Also clears out attacks by dead
     * or disabled mechs.
     */
    private void cleanupPhysicalAttacks() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            removeDuplicateAttacks(entity.getId());
        }
        removeDeadAttacks();
    }

    /**
     * Removes any actions in the attack queue beyond the first by the specified
     * entity, unless that entity has melee master in which case it allows two
     * attacks.
     */
    private void removeDuplicateAttacks(int entityId) {
        int allowed = 1;
        Entity en = game.getEntity(entityId);
        if (null != en) {
            allowed = en.getAllowedPhysicalAttacks();
        }
        Vector<EntityAction> toKeep = new Vector<EntityAction>(/*
                                                                * game.actionsSize
                                                                * ()
                                                                */);

        for (Enumeration<EntityAction> i = game.getActions(); i
                .hasMoreElements(); ) {
            EntityAction action = i.nextElement();
            if (action.getEntityId() != entityId) {
                toKeep.addElement(action);
            } else if (allowed > 0) {
                toKeep.addElement(action);
                if (!(action instanceof SearchlightAttackAction)) {
                    allowed--;
                }
            } else {
                System.err
                        .println("server: removing duplicate phys attack for id#"
                                 + entityId);
                System.err.println("        action was " + action.toString());
            }
        }

        // reset actions and re-add valid elements
        game.resetActions();
        for (EntityAction entityAction : toKeep) {
            game.addAction(entityAction);
        }
    }

    /**
     * Removes all attacks by any dead entities. It does this by going through
     * all the attacks and only keeping ones from active entities. DFAs are kept
     * even if the pilot is unconscious, so that he can fail.
     */
    private void removeDeadAttacks() {
        Vector<EntityAction> toKeep = new Vector<EntityAction>(
                game.actionsSize());

        for (Enumeration<EntityAction> i = game.getActions(); i
                .hasMoreElements(); ) {
            EntityAction action = i.nextElement();
            Entity entity = game.getEntity(action.getEntityId());
            if ((entity != null)
                && !entity.isDestroyed()
                && (entity.isActive() || (action instanceof DfaAttackAction))) {
                toKeep.addElement(action);
            }
        }

        // reset actions and re-add valid elements
        game.resetActions();
        for (EntityAction entityAction : toKeep) {
            game.addAction(entityAction);
        }
    }

    /**
     * Handle a punch attack
     */
    private void resolvePunchAttack(PhysicalResult pr, int lastEntityId) {
        final PunchAttackAction paa = (PunchAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        final Targetable target = game.getTarget(paa.getTargetType(),
                                                 paa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final String armName = paa.getArm() == PunchAttackAction.LEFT ? "Left Arm"
                                                                      : "Right Arm";
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = paa.getArm() == PunchAttackAction.LEFT ? pr.damage
                                                            : pr.damageRight;
        final ToHitData toHit = paa.getArm() == PunchAttackAction.LEFT ? pr.toHit
                                                                       : pr.toHitRight;
        int roll = paa.getArm() == PunchAttackAction.LEFT ? pr.roll
                                                          : pr.rollRight;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        Report r;
        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != paa.getEntityId()) {
            // report who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4010);
        r.subject = ae.getId();
        r.indent();
        r.add(armName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4015);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4020);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // nope
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {

                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }

            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                         toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, toBldg,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO: this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.indent();
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                    damage = (int) Math.ceil(damage / 2.0);
                } else {
                    damage = (int) Math.floor(damage / 2.0);
                }
            }
            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            if ((damage >= 1)
                && te.hasWorkingMisc(MiscType.F_SPIKES, -1,
                                     hit.getLocation())) {
                r = new Report(4330);
                r.indent(2);
                r.newlines = 0;
                r.subject = ae.getId();
                addReport(r);
                checkBreakSpikes(te, hit.getLocation());
                damage = Math.max(1, damage - 4);
                HitData ahit;
                if (paa.getArm() == PunchAttackAction.LEFT) {
                    ahit = new HitData(Mech.LOC_LARM);
                } else {
                    ahit = new HitData(Mech.LOC_RARM);
                }
                addReport(damageEntity(ae, ahit, 2, false, DamageType.NONE,
                                       false, false, false));
            }
            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                                   false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                                           new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                                            VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
            }
            // check for extending retractable blades
            if (paa.isBladeExtended(paa.getArm())) {
                addNewLines();
                r = new Report(4455);
                r.indent(2);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
                // conventional infantry don't take crits and battle armor need
                // to be handled differently
                if (!(target instanceof Infantry)) {
                    addNewLines();
                    addReport(criticalEntity(te, hit.getLocation(),
                                             hit.isRear(), 0, true, false, damage));
                }
                if ((target instanceof BattleArmor)
                    && (hit.getLocation() < te.locations())
                    && (te.getInternal(hit.getLocation()) > 0)) {
                    // TODO: we should really apply BA criticals through the
                    // critical
                    // hits methods. Right now they are applied in damageentity
                    HitData bahit = new HitData(hit.getLocation(), false,
                                                HitData.EFFECT_CRITICAL);
                    addReport(damageEntity(te, bahit, 0));
                }
                // extend the blade
                // since retracting/extending is a freebie in the movement
                // phase, lets assume that the
                // blade retracts to its original mode
                // ae.extendBlade(paa.getArm());
                // check for breaking a nail
                if (Compute.d6(2) > 9) {
                    int armLoc = (paa.getArm() == PunchAttackAction.RIGHT) ? Mech.LOC_RARM
                                                                           : Mech.LOC_LARM;
                    addNewLines();
                    r = new Report(4456);
                    r.indent(2);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);
                    ae.destroyRetractableBlade(armLoc);
                }
            }
        }
        addNewLines();

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a kick attack
     */
    private void resolveKickAttack(PhysicalResult pr, int lastEntityId) {
        KickAttackAction kaa = (KickAttackAction) pr.aaa;
        final Entity ae = game.getEntity(kaa.getEntityId());
        final Targetable target = game.getTarget(kaa.getTargetType(),
                                                 kaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        String legName = (kaa.getLeg() == KickAttackAction.LEFT)
                         || (kaa.getLeg() == KickAttackAction.LEFTMULE) ? "Left "
                                                                        : "Right ";
        if ((kaa.getLeg() == KickAttackAction.LEFTMULE)
            || (kaa.getLeg() == KickAttackAction.RIGHTMULE)) {
            legName = legName.concat("rear ");
        } else if (ae instanceof QuadMech) {
            legName = legName.concat("front ");
        }
        legName = legName.concat("leg");
        Report r;

        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4055);
        r.subject = ae.getId();
        r.indent();
        r.add(legName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4060);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4065);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {

                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }

            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                         toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO: this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                    damage = (int) Math.ceil(damage / 2.0);
                } else {
                    damage = (int) Math.floor(damage / 2.0);
                }
            }
            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            if ((damage >= 1)
                && te.hasWorkingMisc(MiscType.F_SPIKES, -1,
                                     hit.getLocation())) {
                r = new Report(4330);
                r.indent(2);
                r.newlines = 0;
                r.subject = ae.getId();
                addReport(r);
                checkBreakSpikes(te, hit.getLocation());
                damage = Math.max(1, damage - 4);
                HitData ahit;
                switch (kaa.getLeg()) {
                    case KickAttackAction.LEFT:
                        if (ae instanceof QuadMech) {
                            ahit = new HitData(Mech.LOC_LARM);
                        } else {
                            ahit = new HitData(Mech.LOC_LLEG);
                        }
                        break;
                    case KickAttackAction.RIGHT:
                        if (ae instanceof QuadMech) {
                            ahit = new HitData(Mech.LOC_RARM);
                        } else {
                            ahit = new HitData(Mech.LOC_RLEG);
                        }
                        break;
                    case KickAttackAction.LEFTMULE:
                        ahit = new HitData(Mech.LOC_LLEG);
                        break;
                    case KickAttackAction.RIGHTMULE:
                    default:
                        ahit = new HitData(Mech.LOC_RLEG);
                        break;
                }
                addReport(damageEntity(ae, ahit, 2, false, DamageType.NONE,
                                       false, false, false));
            }
            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                                   false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                                           new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                                            VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
            }
            if (te.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {
                addNewLines();
                addReport(criticalEntity(te, hit.getLocation(), hit.isRear(),
                                         0, 0));
            }
        }

        if ((te.getMovementMode() == EntityMovementMode.BIPED)
            || (te.getMovementMode() == EntityMovementMode.QUAD)) {
            PilotingRollData kickPRD = getKickPushPSR(te, ae, te, "was kicked");
            game.addPSR(kickPRD);
        }

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }

        addNewLines();
    }

    /**
     * Handle a kick attack
     */
    private void resolveJumpJetAttack(PhysicalResult pr, int lastEntityId) {
        JumpJetAttackAction kaa = (JumpJetAttackAction) pr.aaa;
        final Entity ae = game.getEntity(kaa.getEntityId());
        final Targetable target = game.getTarget(kaa.getTargetType(),
                                                 kaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        String legName = null;
        switch (kaa.getLeg()) {
            case JumpJetAttackAction.LEFT:
                legName = "Left leg";
                break;
            case JumpJetAttackAction.RIGHT:
                legName = "Right leg";
                break;
            default:
                legName = "Both legs";
                break;
        }

        Report r;

        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4290);
        r.subject = ae.getId();
        r.indent();
        r.add(legName);
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {

                damage += pr.damageRight;
                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }

            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            damage += pr.damageRight;
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        r = new Report(4040);
        r.subject = ae.getId();
        r.newlines = 0;
        addReport(r);

        for (int leg = 0; leg < 2; leg++) {
            if (leg == 1) {
                damage = pr.damageRight;
                if (damage == 0) {
                    break;
                }
            }
            HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                             toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_ENERGY);

            // The building shields all units from a certain amount of damage.
            // The amount is based upon the building's CF at the phase's start.
            if (targetInBuilding && (bldg != null)) {
                int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
                int toBldg = Math.min(bldgAbsorbs, damage);
                damage -= toBldg;
                addNewLines();
                Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                               target.getPosition());
                for (Report report : buildingReport) {
                    report.subject = ae.getId();
                }
                addReport(buildingReport);

                // some buildings scale remaining damage that is not absorbed
                // TODO: this isn't quite right for castles brian
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
            }

            // A building may absorb the entire shot.
            if (damage == 0) {
                r = new Report(4050);
                r.subject = ae.getId();
                r.add(te.getShortName());
                r.add(te.getOwner().getName());
                r.newlines = 0;
                addReport(r);
            } else {
                if (glancing) {
                    // Round up glancing blows against conventional infantry
                    if ((te instanceof Infantry)
                        && !(te instanceof BattleArmor)) {
                        damage = (int) Math.ceil(damage / 2.0);
                    } else {
                        damage = (int) Math.floor(damage / 2.0);
                    }
                }
                if (directBlow) {
                    damage += toHit.getMoS() / 3;
                    hit.makeDirectBlow(toHit.getMoS() / 3);
                }
                addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                                       false, false, throughFront));
            }
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a Protomech physicalattack
     */

    private void resolveProtoAttack(PhysicalResult pr, int lastEntityId) {
        final ProtomechPhysicalAttackAction ppaa = (ProtomechPhysicalAttackAction) pr.aaa;
        final Entity ae = game.getEntity(ppaa.getEntityId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final Targetable target = game.getTarget(ppaa.getTargetType(),
                                                 ppaa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());
        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        if (lastEntityId != ae.getId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4070);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {

                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }

            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                         toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);

        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO: this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                    damage = (int) Math.ceil(damage / 2.0);
                } else {
                    damage = (int) Math.floor(damage / 2.0);
                }
            }
            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }
            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                                   false, false, throughFront));
            if (((Protomech) ae).isEDPCharged()) {
                r = new Report(3701);
                int taserRoll = Compute.d6(2) - 2;
                r.add(taserRoll);
                r.newlines = 0;
                vPhaseReport.add(r);

                if (te instanceof BattleArmor) {
                    r = new Report(3706);
                    r.addDesc(te);
                    // shut down for rest of scenario, so we actually kill it
                    // TODO: fix for salvage purposes
                    HitData targetTrooper = te.rollHitLocation(
                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                    r.add(te.getLocationAbbr(targetTrooper));
                    vPhaseReport.add(r);
                    vPhaseReport.addAll(criticalEntity(ae,
                                                       targetTrooper.getLocation(),
                                                       targetTrooper.isRear(), 0, false, false, 0));
                } else if (te instanceof Mech) {
                    if (((Mech) te).isIndustrial()) {
                        if (taserRoll >= 8) {
                            r = new Report(3705);
                            r.addDesc(te);
                            r.add(4);
                            te.taserShutdown(4, false);
                        } else {
                            // suffer +2 to piloting and gunnery for 4 rounds
                            r = new Report(3710);
                            r.addDesc(te);
                            r.add(2);
                            r.add(4);
                            te.setTaserInterference(2, 4, true);
                        }
                    } else {
                        if (taserRoll >= 11) {
                            r = new Report(3705);
                            r.addDesc(te);
                            r.add(3);
                            vPhaseReport.add(r);
                            te.taserShutdown(3, false);
                        } else {
                            r = new Report(3710);
                            r.addDesc(te);
                            r.add(2);
                            r.add(3);
                            vPhaseReport.add(r);
                            te.setTaserInterference(2, 3, true);
                        }
                    }
                } else if ((te instanceof Protomech) || (te instanceof Tank)
                           || (te instanceof Aero)) {
                    if (taserRoll >= 8) {
                        r = new Report(3705);
                        r.addDesc(te);
                        r.add(4);
                        vPhaseReport.add(r);
                        te.taserShutdown(4, false);
                    } else {
                        r = new Report(3710);
                        r.addDesc(te);
                        r.add(2);
                        r.add(4);
                        vPhaseReport.add(r);
                        te.setTaserInterference(2, 4, false);
                    }
                }

            }
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a brush off attack
     */
    private void resolveBrushOffAttack(PhysicalResult pr, int lastEntityId) {
        final BrushOffAttackAction baa = (BrushOffAttackAction) pr.aaa;
        final Entity ae = game.getEntity(baa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target
        // of a "brush off", but iNarc pods **are**.
        Targetable target = game.getTarget(baa.getTargetType(),
                                           baa.getTargetId());
        Entity te = null;
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT ? "Left Arm"
                                                                         : "Right Arm";
        Report r;

        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = game.getEntity(baa.getTargetId());
        }

        // get damage, ToHitData and roll from the PhysicalResult
        // ASSUMPTION: buildings can't absorb *this* damage.
        int damage = baa.getArm() == BrushOffAttackAction.LEFT ? pr.damage
                                                               : pr.damageRight;
        final ToHitData toHit = baa.getArm() == BrushOffAttackAction.LEFT ? pr.toHit
                                                                          : pr.toHitRight;
        int roll = baa.getArm() == BrushOffAttackAction.LEFT ? pr.roll
                                                             : pr.rollRight;

        if (lastEntityId != baa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4085);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.add(armName);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4090);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit.getValue());
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);

            // Missed Brush Off attacks cause punch damage to the attacker.
            toHit.setHitTable(ToHitData.HIT_PUNCH);
            toHit.setSideTable(ToHitData.SIDE_FRONT);
            HitData hit = ae.rollHitLocation(toHit.getHitTable(),
                                             toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4095);
            r.subject = ae.getId();
            r.addDesc(ae);
            r.add(ae.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(ae, hit, damage));
            addNewLines();
            // if this is an industrial mech, it needs to check for crits
            // at the end of turn
            if ((ae instanceof Mech) && ((Mech) ae).isIndustrial()) {
                ((Mech) ae).setCheckForCrit(true);
            }
            return;
        }

        // Different target types get different handling.
        switch (target.getTargetType()) {
            case Targetable.TYPE_ENTITY:
                // Handle Entity targets.
                HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                                 toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                r = new Report(4045);
                r.subject = ae.getId();
                r.add(toHit.getTableDesc());
                r.add(te.getLocationAbbr(hit));
                addReport(r);
                addReport(damageEntity(te, hit, damage));
                addNewLines();

                // Dislodge the swarming infantry.
                ae.setSwarmAttackerId(Entity.NONE);
                te.setSwarmTargetId(Entity.NONE);
                r = new Report(4100);
                r.subject = ae.getId();
                r.add(te.getDisplayName());
                addReport(r);
                break;
            case Targetable.TYPE_INARC_POD:
                // Handle iNarc pod targets.
                // TODO : check the return code and handle false appropriately.
                ae.removeINarcPod((INarcPod) target);
                // // TODO : confirm that we don't need to update the attacker.
                // //killme
                // entityUpdate( ae.getId() ); // killme
                r = new Report(4105);
                r.subject = ae.getId();
                r.add(target.getDisplayName());
                addReport(r);
                break;
            // TODO : add a default: case and handle it appropriately.
        }
    }

    /**
     * Handle a thrash attack
     */
    private void resolveThrashAttack(PhysicalResult pr, int lastEntityId) {
        final ThrashAttackAction taa = (ThrashAttackAction) pr.aaa;
        final Entity ae = game.getEntity(taa.getEntityId());

        // get damage, ToHitData and roll from the PhysicalResult
        int hits = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        // PLEASE NOTE: buildings are *never* the target of a "thrash".
        final Entity te = game.getEntity(taa.getTargetId());
        Report r;

        if (lastEntityId != taa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4110);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4115);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // Thrash attack may hit automatically
        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4120);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                return;
            }
            r = new Report(4125);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        // Standard damage loop in 5 point clusters.
        if (glancing) {
            hits = (int) Math.floor(hits / 2.0);
        }
        if (directBlow) {
            hits += toHit.getMoS() / 3;
        }

        r = new Report(4130);
        r.subject = ae.getId();
        r.add(hits);
        r.newlines = 0;
        addReport(r);
        if (glancing) {
            r = new Report(4030);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }
        if (directBlow) {
            r = new Report(4032);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }

        while (hits > 0) {
            int damage = Math.min(5, hits);
            hits -= damage;
            HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                             toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4135);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(te, hit, damage));
        }

        addNewLines();

        // Thrash attacks cause PSRs. Failed PSRs cause falling damage.
        // This fall damage applies even though the Thrashing Mek is prone.
        PilotingRollData rollData = ae.getBasePilotingRoll();
        ae.addPilotingModifierForTerrain(rollData);
        rollData.addModifier(0, "thrashing at infantry");
        r = new Report(4140);
        r.subject = ae.getId();
        r.addDesc(ae);
        addReport(r);
        final int diceRoll = Compute.d6(2);
        r = new Report(2190);
        r.subject = ae.getId();
        r.add(rollData.getValueAsString());
        r.add(rollData.getDesc());
        r.add(diceRoll);
        if (diceRoll < rollData.getValue()) {
            r.choose(false);
            addReport(r);
            addReport(doEntityFall(ae, rollData));
        } else {
            r.choose(true);
            addReport(r);
        }
    }

    /**
     * Handle a thrash attack
     */
    private void resolveBAVibroClawAttack(PhysicalResult pr, int lastEntityId) {
        final BAVibroClawAttackAction bvaa = (BAVibroClawAttackAction) pr.aaa;
        final Entity ae = game.getEntity(bvaa.getEntityId());

        // get damage, ToHitData and roll from the PhysicalResult
        int hits = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        // PLEASE NOTE: buildings are *never* the target of a BA vibroclaw
        // attack.
        final Entity te = game.getEntity(bvaa.getTargetId());
        Report r;

        if (lastEntityId != bvaa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4146);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4147);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // we may hit automatically
        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4120);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                return;
            }
        }

        // Standard damage loop
        if (glancing) {
            hits = (int) Math.floor(hits / 2.0);
        }
        if (directBlow) {
            hits += toHit.getMoS() / 3;
        }
        if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
            r = new Report(4149);
            r.subject = ae.getId();
            r.add(hits);
        } else {
            r = new Report(4148);
            r.subject = ae.getId();
            r.add(hits);
            r.add(ae.getVibroClaws());
        }
        r.newlines = 0;
        addReport(r);
        if (glancing) {
            r = new Report(4030);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }
        if (directBlow) {
            r = new Report(4032);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
        }
        while (hits > 0) {
            // BA get hit seperately by each attacking BA trooper
            int damage = Math.min(ae.getVibroClaws(), hits);
            // conv infantry get hit in one lump
            if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                damage = hits;
            }
            hits -= damage;
            HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                             toHit.getSideTable());
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            r = new Report(4135);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.newlines = 0;
            addReport(r);
            addReport(damageEntity(te, hit, damage));
        }
        addNewLines();
    }

    /**
     * Handle a club attack
     */
    private void resolveClubAttack(PhysicalResult pr, int lastEntityId) {
        final ClubAttackAction caa = (ClubAttackAction) pr.aaa;
        final Entity ae = game.getEntity(caa.getEntityId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        final Targetable target = game.getTarget(caa.getTargetType(),
                                                 caa.getTargetId());
        Entity te = null;
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean targetInBuilding = Compute.isInBuilding(game, te);
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        // Make sure the MoS is zero for *automatic* hits in case direct blows
        // are in force.
        toHit.setMoS((roll == Integer.MAX_VALUE) ? 0 : roll
                                                       - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(target.getPosition());

        // restore club attack
        caa.getClub().restore();

        // Shield bash causes 1 point of damage to the shield
        if (((MiscType) caa.getClub().getType()).isShield()) {
            ((Mech) ae).shieldAbsorptionDamage(1, caa.getClub().getLocation(),
                                               false);
        }

        if (lastEntityId != caa.getEntityId()) {
            // who is making the attacks
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4145);
        r.subject = ae.getId();
        r.indent();
        r.add(caa.getClub().getName());
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // Flail/Wrecking Ball auto misses on a 2 and hits themself.
        if ((((MiscType) caa.getClub().getType()).hasSubType(MiscType.S_FLAIL) || ((MiscType) caa
                .getClub().getType()).hasSubType(MiscType.S_WRECKING_BALL))
            && (roll == 2)) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            ToHitData newToHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS,
                                               "hit with own flail/wrecking ball");
            pr.damage = ClubAttackAction.getDamageFor(ae, caa.getClub(), false);
            pr.damage = (pr.damage / 2) + (pr.damage % 2);
            newToHit.setHitTable(ToHitData.HIT_NORMAL);
            newToHit.setSideTable(ToHitData.SIDE_FRONT);
            pr.toHit = newToHit;
            pr.aaa.setTargetId(ae.getId());
            pr.aaa.setTargetType(Targetable.TYPE_ENTITY);
            pr.roll = Integer.MAX_VALUE;
            resolveClubAttack(pr, ae.getId());
            game.addPSR(new PilotingRollData(ae.getId(), 0,
                                             "missed a flail/wrecking ball attack"));
            return;
        }

        // Need to compute 2d6 damage. and add +3 heat build up.
        if (((MiscType) (caa.getClub().getType()))
                .hasSubType(MiscType.S_BUZZSAW)) {

            damage = Compute.d6(2);
            ae.heatBuildup += 3;

            // Buzzsaw's blade will shatter on a roll of 2.
            if (roll == 2) {

                Mounted club = caa.getClub();

                for (Mounted eq : ae.getWeaponList()) {
                    if ((eq.getLocation() == club.getLocation())
                        && (eq.getType() instanceof MiscType)
                        && ((MiscType) eq.getType())
                            .hasFlag(MiscType.F_CLUB)
                        && ((MiscType) eq.getType())
                            .hasSubType(MiscType.S_BUZZSAW)) {
                        eq.setHit(true);
                        break;
                    }
                }
                r = new Report(4037);
                r.subject = ae.getId();
                addReport(r);
                damage = 0;
                return;
            }
        }

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4075);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            if (((MiscType) caa.getClub().getType())
                    .hasSubType(MiscType.S_MACE_THB)) {
                game.addPSR(new PilotingRollData(ae.getId(), 0,
                                                 "missed a mace attack"));
            }
            if (((MiscType) caa.getClub().getType())
                    .hasSubType(MiscType.S_MACE)) {
                game.addPSR(new PilotingRollData(ae.getId(), 2,
                                                 "missed a mace attack"));
            }
            return;
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4080);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines = 0;
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            if (((MiscType) caa.getClub().getType())
                    .hasSubType(MiscType.S_MACE_THB)) {
                game.addPSR(new PilotingRollData(ae.getId(), 0,
                                                 "missed a mace attack"));
            }
            if (((MiscType) caa.getClub().getType())
                    .hasSubType(MiscType.S_MACE)) {
                game.addPSR(new PilotingRollData(ae.getId(), 2,
                                                 "missed a mace attack"));
            }

            // If the target is in a building, the building absorbs the damage.
            if (targetInBuilding && (bldg != null)) {

                // Only report if damage was done to the building.
                if (damage > 0) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damage, target.getPosition());
                    for (Report report : buildingReport) {
                        report.subject = ae.getId();
                    }
                    addReport(buildingReport);
                }

            }
            return;
        }

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // And we're done!
            return;
        }

        HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                         toHit.getSideTable());
        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
        r = new Report(4045);
        r.subject = ae.getId();
        r.add(toHit.getTableDesc());
        r.add(te.getLocationAbbr(hit));
        addReport(r);

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        if (targetInBuilding && (bldg != null)) {
            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());
            int toBldg = Math.min(bldgAbsorbs, damage);
            damage -= toBldg;
            addNewLines();
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // some buildings scale remaining damage that is not absorbed
            // TODO: this isn't quite right for castles brian
            damage = (int) Math.floor(bldg.getDamageToScale() * damage);
        }

        // A building may absorb the entire shot.
        if (damage == 0) {
            r = new Report(4050);
            r.subject = ae.getId();
            r.add(te.getShortName());
            r.add(te.getOwner().getName());
            r.newlines = 0;
            addReport(r);
        } else {
            if (glancing) {
                // Round up glancing blows against conventional infantry
                if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                    damage = (int) Math.ceil(damage / 2.0);
                } else {
                    damage = (int) Math.floor(damage / 2.0);
                }
            }
            if (directBlow) {
                damage += toHit.getMoS() / 3;
                hit.makeDirectBlow(toHit.getMoS() / 3);
            }

            if ((damage >= 1)
                && te.hasWorkingMisc(MiscType.F_SPIKES, -1,
                                     hit.getLocation())) {
                r = new Report(4331);
                r.indent(2);
                r.newlines = 0;
                r.subject = ae.getId();
                addReport(r);
                checkBreakSpikes(te, hit.getLocation());
                damage = Math.max(1, damage - 4);
            }

            DamageType damageType = DamageType.NONE;
            addReport(damageEntity(te, hit, damage, false, damageType, false,
                                   false, throughFront));
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                                           new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                                            VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
            }
        }

        // On a roll of 10+ a lance hitting a mech/Vehicle can cause 1 point of
        // internal damage
        if (((MiscType) caa.getClub().getType()).hasSubType(MiscType.S_LANCE)
            && (te.getArmor(hit) > 0)
            && (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_HARDENED)
            && (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_FERRO_LAMELLOR)) {
            roll = Compute.d6(2);
            // Pierce checking report
            r = new Report(4021);
            r.indent(2);
            r.subject = ae.getId();
            r.add(te.getLocationAbbr(hit));
            r.add(roll);
            addReport(r);
            if (roll >= 10) {
                hit.makeGlancingBlow();
                addReport(damageEntity(te, hit, 1, false, DamageType.NONE,
                                       true, false, throughFront));
            }
        }

        if (((MiscType) caa.getClub().getType())
                    .hasSubType(MiscType.S_WRECKING_BALL)
            && (ae instanceof SupportTank) && (te instanceof Mech)) {
            // forces a PSR like a charge
            game.addPSR(new PilotingRollData(te.getId(), 2,
                                             "was hit by wrecking ball"));
        }

        // Chain whips can entangle 'Mech and ProtoMech limbs. This
        // implementation assumes that in order to do so the limb must still
        // have some structure left, so if the whip hits and destroys a
        // location in the same attack no special effects take place.
        if (((MiscType) caa.getClub().getType())
                .hasSubType(MiscType.S_CHAIN_WHIP)
                && ((te instanceof Mech) || (te instanceof Protomech))) {
            addNewLines();

            int loc = hit.getLocation();
            int toHitNumber = toHit.getValue();

            boolean mightTrip = (te instanceof Mech)
                    && ((Mech) te).locationIsLeg(loc)
                    && !te.isLocationBad(loc)
                    && !te.isLocationDoomed(loc)
                    && !te.hasActiveShield(loc)
                    && !te.hasPassiveShield(loc);

            boolean mightGrapple = ((te instanceof Mech)
                    && ((loc == Mech.LOC_LARM) || (loc == Mech.LOC_RARM))
                    && !te.isLocationBad(loc)
                    && !te.isLocationDoomed(loc)
                    && !te.hasActiveShield(loc)
                    && !te.hasPassiveShield(loc)
                    && !te.hasNoDefenseShield(loc))
                    || ((te instanceof Protomech)
                        && ((loc == Protomech.LOC_LARM) || (loc == Protomech.LOC_RARM)
                            || (loc == Protomech.LOC_LEG))
                        // Only check location status after confirming we did
                        // hit a limb -- Protos have no actual near-miss
                        // "location" and will throw an exception if it's
                        // referenced here.
                        && !te.isLocationBad(loc)
                        && !te.isLocationDoomed(loc));

            if (mightTrip) {

                roll = Compute.d6(2);

                if ((((Mech) ae).hasTSM() && (ae.heat >= 9))
                        && (!((Mech) te).hasTSM() || ((((Mech) te).hasTSM()) && (te.heat < 9)))) {
                    toHitNumber -= 2;
                }

                r = new Report(4450);
                r.subject = ae.getId();
                r.add(ae.getShortName());
                r.add(te.getShortName());
                r.add(toHitNumber);
                r.add(roll);
                r.indent(2);
                r.newlines = 0;
                addReport(r);

                if (roll >= toHit.getValue()) {
                    r = new Report(2270);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);

                    game.addPSR(new PilotingRollData(te.getId(), 3,
                            "Snared by chain whip"));
                } else {
                    r = new Report(2357);
                    r.subject = ae.getId();
                    r.newlines = 0;
                    addReport(r);
                }
            } else if (mightGrapple) {
                GrappleAttackAction gaa = new GrappleAttackAction(ae.getId(),
                        te.getId());
                int grappleSide;
                if (caa.getClub().getLocation() == Mech.LOC_RARM) {
                    grappleSide = Entity.GRAPPLE_RIGHT;
                } else {
                    grappleSide = Entity.GRAPPLE_LEFT;
                }
                ToHitData grappleHit = GrappleAttackAction.toHit(game,
                        ae.getId(), target, grappleSide, true);
                PhysicalResult grappleResult = new PhysicalResult();
                grappleResult.aaa = gaa;
                grappleResult.toHit = grappleHit;
                grappleResult.roll = Compute.d6(2);
                resolveGrappleAttack(
                        grappleResult,
                        lastEntityId,
                        grappleSide,
                        hit.getLocation() == Mech.LOC_RARM ? Entity.GRAPPLE_RIGHT
                                : Entity.GRAPPLE_LEFT);
            }
        }

        addNewLines();

        if (((MiscType) caa.getClub().getType())
                .hasSubType(MiscType.S_TREE_CLUB)) {
            // the club breaks
            r = new Report(4150);
            r.subject = ae.getId();
            r.add(caa.getClub().getName());
            addReport(r);
            ae.removeMisc(caa.getClub().getName());
        }

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Handle a push attack
     */
    private void resolvePushAttack(PhysicalResult pr, int lastEntityId) {
        final PushAttackAction paa = (PushAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        // was this push resolved earlier?
        if (pr.pushBackResolved) {
            return;
        }
        // don't try this one again
        pr.pushBackResolved = true;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4155);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4160);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit.getValue());
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // check if our target has a push against us, too, and get it
        PhysicalResult targetPushResult = null;
        for (PhysicalResult tpr : physicalResults) {
            if ((tpr.aaa.getEntityId() == te.getId())
                && (tpr.aaa instanceof PushAttackAction)
                && (tpr.aaa.getTargetId() == ae.getId())) {
                targetPushResult = tpr;
            }
        }
        // if our target has a push against us,
        // and we are hitting, we need to resolve both now
        if ((targetPushResult != null) && !targetPushResult.pushBackResolved
            && (roll >= toHit.getValue())) {
            targetPushResult.pushBackResolved = true;
            // do they hit?
            if (targetPushResult.roll >= targetPushResult.toHit.getValue()) {
                r = new Report(4165);
                r.subject = ae.getId();
                r.addDesc(te);
                r.addDesc(te);
                r.addDesc(ae);
                r.add(targetPushResult.toHit.getValue());
                r.add(targetPushResult.roll);
                r.addDesc(ae);
                addReport(r);
                PilotingRollData targetPushPRD = getKickPushPSR(te, ae, te,
                                                                "was pushed");
                PilotingRollData pushPRD = getKickPushPSR(ae, ae, te,
                                                          "was pushed");
                game.addPSR(pushPRD);
                game.addPSR(targetPushPRD);
                return;
            }
            // report the miss
            r = new Report(4166);
            r.subject = ae.getId();
            r.addDesc(te);
            r.addDesc(ae);
            r.add(targetPushResult.toHit.getValue());
            r.add(targetPushResult.roll);
            addReport(r);
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        int direction = ae.getFacing();

        Coords src = te.getPosition();
        Coords dest = src.translated(direction);

        PilotingRollData pushPRD = getKickPushPSR(te, ae, te, "was pushed");

        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(),
                                        direction)) {
            r = new Report(4170);
            r.subject = ae.getId();
            r.newlines = 0;
            addReport(r);
            if (game.getBoard().contains(dest)) {
                r = new Report(4175);
                r.subject = ae.getId();
                r.add(dest.getBoardNum(), true);
                addReport(r);
            } else {
                // uh-oh, pushed off board
                r = new Report(4180);
                r.subject = ae.getId();
                addReport(r);
            }

            addReport(doEntityDisplacement(te, src, dest, pushPRD));

            // if push actually moved the target, attacker follows thru
            if (!te.getPosition().equals(src)) {
                ae.setPosition(src);
            }
        } else {
            // targe imovable
            r = new Report(4185);
            r.subject = ae.getId();
            addReport(r);
            game.addPSR(pushPRD);
        }

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }

        addNewLines();
    }

    /**
     * Handle a trip attack
     */
    private void resolveTripAttack(PhysicalResult pr, int lastEntityId) {
        final TripAttackAction paa = (TripAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "trip".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4280);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4285);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit.getValue());
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        PilotingRollData pushPRD = getKickPushPSR(te, ae, te, "was tripped");

        game.addPSR(pushPRD);

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);
        addNewLines();
        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }
    }

    /**
     * Handle a grapple attack
     */
    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId) {
        resolveGrappleAttack(pr, lastEntityId, Entity.GRAPPLE_BOTH,
                Entity.GRAPPLE_BOTH);
    }

    /**
     * Resolves a grapple attack.
     *
     * @param pr
     * @param lastEntityId
     * @param aeGrappleSide
     *            The side that the attacker is grappling with. For normal
     *            grapples this will be both, for chain whip grapples this will
     *            be the arm with the chain whip in it.
     * @param teGrappleSide
     *            The that the the target is grappling with. For normal grapples
     *            this will be both, for chain whip grapples this will be the
     *            arm that is being whipped.
     */
    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId,
                                      int aeGrappleSide, int teGrappleSide) {
        final GrappleAttackAction paa = (GrappleAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        // same method as push, for counterattacks
        if (pr.pushBackResolved) {
            return;
        }

        if ((te.getGrappled() != Entity.NONE)
            || (ae.getGrappled() != Entity.NONE)) {
            toHit.addModifier(TargetRoll.IMPOSSIBLE, "Already Grappled");
        }

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4295);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4300);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        // report the roll
        r = new Report(4025);
        r.subject = ae.getId();
        r.add(toHit.getValue());
        r.add(roll);
        r.newlines = 0;
        addReport(r);

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            return;
        }

        // we hit...
        ae.setGrappled(te.getId(), true);
        te.setGrappled(ae.getId(), false);
        ae.setGrappledThisRound(true);
        te.setGrappledThisRound(true);
        // For normal grapples, AE moves into targets hex.
        if (aeGrappleSide == Entity.GRAPPLE_BOTH) {
            Coords pos = te.getPosition();
            ae.setPosition(pos);
            ae.setElevation(te.getElevation());
            te.setFacing((ae.getFacing() + 3) % 6);
            addReport(doSetLocationsExposure(ae, game.getBoard().getHex(pos),
                    false, ae.getElevation()));
        }

        ae.setGrappleSide(aeGrappleSide);
        te.setGrappleSide(teGrappleSide);

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);
        addNewLines();

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }
    }

    /**
     * Handle a break grapple attack
     */
    private void resolveBreakGrappleAttack(PhysicalResult pr, int lastEntityId) {
        final BreakGrappleAttackAction paa = (BreakGrappleAttackAction) pr.aaa;
        final Entity ae = game.getEntity(paa.getEntityId());
        // PLEASE NOTE: buildings are *never* the target of a "push".
        final Entity te = game.getEntity(paa.getTargetId());
        // get roll and ToHitData from the PhysicalResult
        int roll = pr.roll;
        final ToHitData toHit = pr.toHit;
        Report r;

        if (lastEntityId != paa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        r = new Report(4305);
        r.subject = ae.getId();
        r.indent();
        r.addDesc(te);
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            r = new Report(4310);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            return;
        }

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4320);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
                return;
            }

            // hit
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
        }

        // is there a counterattack?
        PhysicalResult targetGrappleResult = null;
        for (PhysicalResult tpr : physicalResults) {
            if ((tpr.aaa.getEntityId() == te.getId())
                && (tpr.aaa instanceof GrappleAttackAction)
                && (tpr.aaa.getTargetId() == ae.getId())) {
                targetGrappleResult = tpr;
                break;
            }
        }

        if (targetGrappleResult != null) {
            targetGrappleResult.pushBackResolved = true;
            // counterattack
            r = new Report(4315);
            r.subject = te.getId();
            r.newlines = 0;
            r.addDesc(te);
            addReport(r);

            // report the roll
            r = new Report(4025);
            r.subject = te.getId();
            r.add(targetGrappleResult.toHit.getValue());
            r.add(targetGrappleResult.roll);
            r.newlines = 0;
            addReport(r);

            // do we hit?
            if (roll < toHit.getValue()) {
                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);
            } else {
                // hit
                r = new Report(4040);
                r.subject = ae.getId();
                addReport(r);

                // exchange attacker and defender
                ae.setGrappled(te.getId(), false);
                te.setGrappled(ae.getId(), true);

                return;
            }
        }

        // score the adjacent hexes
        Coords hexes[] = new Coords[6];
        int scores[] = new int[6];

        IHex curHex = game.getBoard().getHex(ae.getPosition());
        for (int i = 0; i < 6; i++) {
            hexes[i] = ae.getPosition().translated(i);
            scores[i] = 0;
            IHex hex = game.getBoard().getHex(hexes[i]);
            if (hex.containsTerrain(Terrains.MAGMA)) {
                scores[i] += 10;
            }
            if (hex.containsTerrain(Terrains.WATER)) {
                scores[i] += hex.terrainLevel(Terrains.WATER);
            }
            if ((curHex.surface() - hex.surface()) >= 2) {
                scores[i] += 2 * (curHex.surface() - hex.surface());
            }
        }

        int bestScore = 99999;
        int best = 0;
        int worstScore = -99999;
        int worst = 0;

        for (int i = 0; i < 6; i++) {
            if (bestScore > scores[i]) {
                best = i;
                bestScore = scores[i];
            }
            if (worstScore < scores[i]) {
                worst = i;
                worstScore = scores[i];
            }
        }

        // attacker doesnt fall, unless off a cliff
        if (ae.isGrappleAttacker()) {
            // move self to least dangerous hex
            PilotingRollData psr = ae.getBasePilotingRoll();
            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, "break grapple");
            addReport(doEntityDisplacement(ae, ae.getPosition(), hexes[best],
                                           psr));
            ae.setFacing(hexes[best].direction(te.getPosition()));
        } else {
            // move enemy to most dangerous hex
            PilotingRollData psr = te.getBasePilotingRoll();
            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, "break grapple");
            addReport(doEntityDisplacement(te, te.getPosition(), hexes[worst],
                                           psr));
            te.setFacing(hexes[worst].direction(ae.getPosition()));
        }

        // grapple is broken
        ae.setGrappled(Entity.NONE, false);
        te.setGrappled(Entity.NONE, false);

        addNewLines();
    }

    /**
     * Handle a charge attack
     */
    private void resolveChargeAttack(PhysicalResult pr, int lastEntityId) {
        final ChargeAttackAction caa = (ChargeAttackAction) pr.aaa;
        final Entity ae = game.getEntity(caa.getEntityId());
        final Targetable target = game.getTarget(caa.getTargetType(),
                                                 caa.getTargetId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;

        Entity te = null;
        if ((target != null)
            && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());

        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(caa.getTargetPos());

        // is the attacker dead? because that sure messes up the calculations
        if (ae == null) {
            return;
        }

        final int direction = ae.getFacing();

        // entity isn't charging any more
        ae.setDisplacementAttack(null);

        if (lastEntityId != caa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
            || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te
                                                                               .isDestroyed() || te.isDoomed() || te
                                                                               .getCrew()
                                                                               .isDead()))) {
            r = new Report(4190);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            // doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(),
            // null);
            // Randall said that if a charge fails because of target
            // destruction,
            // the attacker stays in the hex he was in at the end of the
            // movement phase
            // See Bug 912094
            return;
        }

        // attacker fell down?
        if (ae.isProne()) {
            r = new Report(4195);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // attacker immobile?
        if (ae.isImmobile()) {
            r = new Report(4200);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // target fell down, only for attacking Mechs, though
        if ((te != null) && (te.isProne()) && (ae instanceof Mech)) {
            r = new Report(4205);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(4210);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // target still in the same position?
        if (!target.getPosition().equals(caa.getTargetPos())) {
            r = new Report(4215);
            r.subject = ae.getId();
            addReport(r);
            addReport(doEntityDisplacement(ae, ae.getPosition(),
                                           caa.getTargetPos(), null));
            return;
        }

        // if the attacker's prone, fudge the roll
        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            roll = -12;
            r = new Report(4220);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4225);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            Coords src = ae.getPosition();
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(),
                                                              src, direction);

            // TODO: handle movement into/out of/through a building. Do it here?

            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            // move attacker to side hex
            addReport(doEntityDisplacement(ae, src, dest, null));
        } else if ((target.getTargetType() == Targetable.TYPE_BUILDING)
                   || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) { // Targeting
            // a building.
            // The building takes the full brunt of the attack.
            r = new Report(4040);
            r.subject = ae.getId();
            addReport(r);
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // Apply damage to the attacker.
            int toAttacker = ChargeAttackAction.getDamageTakenBy(ae, bldg,
                                                                 target.getPosition());
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL,
                                             ae.sideTable(target.getPosition()));
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(ae, hit, toAttacker, false, DamageType.NONE,
                                   false, false, throughFront));
            addNewLines();
            entityUpdate(ae.getId());

            // TODO: Does the attacker enter the building?
            // TODO: What if the building collapses?
        } else {
            // Resolve the damage.
            resolveChargeDamage(ae, te, toHit, direction, glancing,
                                throughFront);
        }
    }

    /**
     * Handle a telemissile attack
     */
    private void resolveTeleMissileAttack(PhysicalResult pr, int lastEntityId) {
        final TeleMissileAttackAction taa = (TeleMissileAttackAction) pr.aaa;
        final Entity ae = game.getEntity(taa.getEntityId());
        if (!(ae instanceof TeleMissile)) {
            return;
        }
        TeleMissile tm = (TeleMissile) ae;
        final Targetable target = game.getTarget(taa.getTargetType(),
                                                 taa.getTargetId());
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        Entity te = null;
        if ((target != null)
            && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }

        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }

        Report r;

        if (lastEntityId != taa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
            || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te
                                                                               .isDestroyed() || te.isDoomed() || te
                                                                               .getCrew()
                                                                               .isDead()))) {
            r = new Report(4190);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(9031);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // add some stuff to the to hit value
        // need to add damage done modifier
        if (ae.damageThisRound > 10) {
            toHit.addModifier((int) (Math.floor(ae.damageThisRound / 10.0)),
                              "damage taken");
        }

        // add modifiers for the originating unit missing CIC, FCS, or sensors
        Entity ride = game.getEntity(tm.getOriginalRideId());
        if ((null != ride) && (ride instanceof Aero)) {
            Aero aride = (Aero) ride;
            int cic = aride.getCICHits();
            if (cic > 0) {
                toHit.addModifier(cic * 2, "CIC damage");
            }

            // sensor hits
            int sensors = aride.getSensorHits();
            if ((sensors > 0) && (sensors < 3)) {
                toHit.addModifier(sensors, "sensor damage");
            }
            if (sensors > 2) {
                toHit.addModifier(+5, "sensors destroyed");
            }

            // FCS hits
            int fcs = aride.getFCSHits();
            if (fcs > 0) {
                toHit.addModifier(fcs * 2, "fcs damage");
            }
        }

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4225);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(9032);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(toHit.getDesc());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
        } else {
            // Resolve the damage.
            HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,
                                             te.sideTable(ae.getPosition(), true));
            hit.setCapital(true);
            hit.setCapMisCritMod(tm.getCritMod());
            addReport(damageEntity(te, hit,
                                   TeleMissileAttackAction.getDamageFor(ae), false,
                                   DamageType.NONE, false, false, throughFront));
            destroyEntity(ae, "successful attack");
        }

    }

    /**
     * Handle a ramming attack
     */
    private void resolveRamAttack(PhysicalResult pr, int lastEntityId) {
        final RamAttackAction raa = (RamAttackAction) pr.aaa;
        final Entity ae = game.getEntity(raa.getEntityId());
        final Targetable target = game.getTarget(raa.getTargetType(),
                                                 raa.getTargetId());
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        Entity te = null;
        if ((target != null)
            && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            te = (Entity) target;
        }

        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }

        Report r;

        boolean glancing = Compute.d6(1) == 6;

        // entity isn't ramming any more
        ae.setRamming(false);

        if (lastEntityId != raa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
            || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te
                                                                               .isDestroyed() || te.isDoomed() || te
                                                                               .getCrew()
                                                                               .isDead()))) {
            r = new Report(4190);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        // steel yourself for attack
        int steelroll = Compute.d6(2);
        r = new Report(9020);
        r.subject = ae.getId();
        r.add(steelroll);

        if (steelroll >= 11) {
            r.choose(true);
            addReport(r);
        } else {
            r.choose(false);
            addReport(r);
            return;
        }

        // attacker immobile?
        if (ae.isImmobile()) {
            r = new Report(4200);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            return;
        }

        r = new Report(9030);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            roll = Integer.MAX_VALUE;
            r = new Report(4225);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
        }

        // do we hit?
        if (roll < toHit.getValue()) {
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
        } else {
            // Resolve the damage.
            resolveRamDamage((Aero) ae, (Aero) te, toHit, glancing,
                             throughFront);
        }

    }

    /**
     * Handle a ramming attack's damage
     */
    private void resolveRamDamage(Aero ae, Entity te, ToHitData toHit,
                                  boolean glancing, boolean throughFront) {

        int damage = RamAttackAction.getDamageFor(ae, te);
        int damageTaken = RamAttackAction.getDamageTakenBy(ae, te);
        if (glancing) {
            // Round up glancing blows against conventional infantry
            if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                damage = (int) Math.ceil(damage / 2.0);
            } else {
                damage = (int) Math.floor(damage / 2.0);
            }
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        // are they capital scale?
        if (te.isCapitalScale()
            && !game.getOptions().booleanOption("aero_sanity")) {
            damage = (int) Math.floor(damage / 10.0);
        }
        if (ae.isCapitalScale()
            && !game.getOptions().booleanOption("aero_sanity")) {
            damageTaken = (int) Math.floor(damageTaken / 10.0);
        }

        Report r;

        if (glancing) {
            r = new Report(9015);
            r.subject = ae.getId();
            r.indent(1);
            addReport(r);
        }

        // damage to attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent();
        addReport(r);

        HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL,
                                         ae.sideTable(te.getPosition(), true));
        // if the damage is greater than the initial armor then destroy the
        // entity
        if ((2 * ae.getOArmor(hit)) < damageTaken) {
            addReport(destroyEntity(ae, "by massive ramming damage", false));
        } else {
            addReport(damageEntity(ae, hit, damageTaken, false,
                                   DamageType.NONE, false, false, throughFront));
        }

        r = new Report(4230);
        r.subject = ae.getId();
        r.add(damage);
        r.add(toHit.getTableDesc());
        r.indent();
        addReport(r);

        hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());
        if ((2 * te.getOArmor(hit)) < damage) {
            addReport(destroyEntity(te, "by massive ramming damage", false));
        } else {
            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,
                                   false, false, throughFront));
        }
    }

    /**
     * Handle a charge's damage
     */
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit,
                                     int direction) {
        resolveChargeDamage(ae, te, toHit, direction, false, true);
    }

    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit,
                                     int direction, boolean glancing, boolean throughFront) {

        // we hit...

        PilotingRollData chargePSR = null;
        // If we're upright, we may fall down.
        if (!ae.isProne()) {
            chargePSR = new PilotingRollData(ae.getId(), 2, "charging");
        }

        // Damage To Target
        int damage = ChargeAttackAction.getDamageFor(ae, te, game.getOptions()
                                                                 .booleanOption("tacops_charge_damage"),
                                                     toHit.getMoS());

        // Damage to Attacker
        int damageTaken = ChargeAttackAction.getDamageTakenBy(ae, te, game
                .getOptions().booleanOption("tacops_charge_damage"));
        if (glancing) {
            // Glancing Blow rule doesn't state whether damage to attacker on
            // charge
            // or DFA is halved as well, assume yes. TODO: Check with PM
            if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                damage = (int) Math.ceil(damage / 2.0);
            } else {
                damage = (int) Math.floor(damage / 2.0);
            }
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }
        boolean bDirect = false;
        int directBlowCritMod = toHit.getMoS() / 3;
        if (game.getOptions().booleanOption("tacops_direct_blow")
            && ((toHit.getMoS() / 3) >= 1)) {
            damage += toHit.getMoS() / 3;
            bDirect = false;
        }

        // Is the target inside a building?
        final boolean targetInBuilding = Compute.isInBuilding(game, te);

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(te.getPosition());

        // The building shields all units from a certain amount of damage.
        // The amount is based upon the building's CF at the phase's start.
        int bldgAbsorbs = 0;
        if (targetInBuilding && (bldg != null)) {
            bldgAbsorbs = bldg.getAbsorbtion(te.getPosition());
        }

        Report r;

        // damage to attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent();
        addReport(r);

        // Charging vehicles check for possible motive system hits.
        if (ae instanceof Tank) {
            r = new Report(4241);
            r.indent();
            addReport(r);
            int side = Compute.targetSideTable(te, ae);
            int mod = ((Tank) ae).getMotiveSideMod(side);
            addReport(vehicleMotiveDamage((Tank) ae, mod));
        }

        // work out which locations have spikes
        int[] spikes = new int[ae.locations()];
        for (int i = 0; i < ae.locations(); i++) {
            spikes[i] = 0;
        }
        for (Mounted m : ae.getMisc()) {
            if ((m.getLocation() != Entity.LOC_NONE)
                && m.getType().hasFlag(MiscType.F_SPIKES)) {
                spikes[m.getLocation()] = 1;
            }
        }
        int spikeDamage = 0;

        while (damageTaken > 0) {
            int cluster = Math.min(5, damageTaken);
            HitData hit = ae.rollHitLocation(toHit.getHitTable(),
                                             ae.sideTable(te.getPosition()));
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            if (spikes[hit.getLocation()] == 1) {
                r = new Report(4335);
                r.indent(2);
                r.subject = ae.getId();
                addReport(r);
                spikes[hit.getLocation()] = 0;
                checkBreakSpikes(ae, hit.getLocation());
                spikeDamage += 2;
            }
            addReport(damageEntity(ae, hit, cluster, false, DamageType.NONE,
                                   false, false, throughFront));
            damageTaken -= cluster;
        }

        // Damage to target
        damage += spikeDamage;
        r = new Report(4230);
        r.subject = ae.getId();
        r.add(damage);
        r.add(toHit.getTableDesc());
        r.indent();
        addReport(r);

        // Vehicles that have *been* charged check for motive system damage,
        // too...
        // ...though VTOLs don't use that table and should lose their rotor
        // instead,
        // which would be handled as part of the damage already.
        if ((te instanceof Tank) && !(te instanceof VTOL)) {
            r = new Report(4242);
            r.indent();
            addReport(r);

            int side = Compute.targetSideTable(ae, te);
            int mod = ((Tank) te).getMotiveSideMod(side);
            addReport(vehicleMotiveDamage((Tank) te, mod));
        }

        // work out which locations have spikes
        spikes = new int[te.locations()];
        for (int i = 0; i < te.locations(); i++) {
            spikes[i] = 0;
        }
        for (Mounted m : te.getMisc()) {
            if ((m.getLocation() != Entity.LOC_NONE)
                && m.getType().hasFlag(MiscType.F_SPIKES)) {
                spikes[m.getLocation()] = 1;
            }
        }
        spikeDamage = 0;

        while (damage > 0) {
            int cluster = Math.min(5, damage);
            damage -= cluster;
            if (bldgAbsorbs > 0) {
                int toBldg = Math.min(bldgAbsorbs, cluster);
                cluster -= toBldg;
                addNewLines();
                Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                               te.getPosition());
                for (Report report : buildingReport) {
                    report.subject = ae.getId();
                }
                addReport(buildingReport);

                // some buildings scale remaining damage that is not absorbed
                // TODO: this isn't quite right for castles brian
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
            }

            // A building may absorb the entire shot.
            if (cluster == 0) {
                r = new Report(4235);
                r.subject = ae.getId();
                r.addDesc(te);
                r.indent();
                addReport(r);
            } else {
                HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                                 toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                if (bDirect) {
                    hit.makeDirectBlow(directBlowCritMod);
                }
                if (spikes[hit.getLocation()] == 1) {
                    r = new Report(4330);
                    r.indent(2);
                    r.subject = ae.getId();
                    addReport(r);
                    spikes[hit.getLocation()] = 0;
                    checkBreakSpikes(te, hit.getLocation());
                    cluster = 1;
                    spikeDamage += 2;
                }
                addReport(damageEntity(te, hit, cluster, false,
                                       DamageType.NONE, false, false, throughFront));
            }
        }
        // finally apply spike damage to attacker
        if (ae instanceof Mech) {
            addReport(damageEntity(ae, new HitData(Mech.LOC_CT), spikeDamage,
                                   false, DamageType.NONE, false, false, throughFront));
        } else if (ae instanceof Tank) {
            addReport(damageEntity(ae, new HitData(Tank.LOC_FRONT),
                                   spikeDamage, false, DamageType.NONE, false, false,
                                   throughFront));
        }

        // move attacker and target, if possible
        Coords src = te.getPosition();
        Coords dest = src.translated(direction);

        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(),
                                        direction)) {
            addNewLines();
            addReport(doEntityDisplacement(te, src, dest, new PilotingRollData(
                    te.getId(), 2, "was charged")));
            addReport(doEntityDisplacement(ae, ae.getPosition(), src, chargePSR));
        }

        addNewLines();

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((te instanceof Mech) && ((Mech) te).isIndustrial()) {
            ((Mech) te).setCheckForCrit(true);
        }

    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )

    private void resolveLayExplosivesAttack(PhysicalResult pr, int lastEntityId) {
        final LayExplosivesAttackAction laa = (LayExplosivesAttackAction) pr.aaa;
        final Entity ae = game.getEntity(laa.getEntityId());
        if (ae instanceof Infantry) {
            Infantry inf = (Infantry) ae;
            if (inf.turnsLayingExplosives < 0) {
                inf.turnsLayingExplosives = 0;
                Report r = new Report(4270);
                r.subject = inf.getId();
                r.addDesc(inf);
                addReport(r);
            } else {
                Building building = game.getBoard().getBuildingAt(
                        ae.getPosition());
                if (building != null) {
                    building.addDemolitionCharge(ae.getOwner().getId(),
                                                 pr.damage);
                    Report r = new Report(4275);
                    r.subject = inf.getId();
                    r.addDesc(inf);
                    r.add(pr.damage);
                    addReport(r);
                }
                inf.turnsLayingExplosives = -1;
            }
        }
    }

    /**
     * Handle a death from above attack
     */
    private void resolveDfaAttack(PhysicalResult pr, int lastEntityId) {
        final DfaAttackAction daa = (DfaAttackAction) pr.aaa;
        final Entity ae = game.getEntity(daa.getEntityId());

        // is the attacker dead? because that sure messes up the calculations
        if (ae == null) {
            return;
        }

        final IHex aeHex = game.getBoard().getHex(ae.getPosition());
        final IHex teHex = game.getBoard().getHex(daa.getTargetPos());
        final Targetable target = game.getTarget(daa.getTargetType(),
                                                 daa.getTargetId());
        // get damage, ToHitData and roll from the PhysicalResult
        int damage = pr.damage;
        final ToHitData toHit = pr.toHit;
        int roll = pr.roll;
        Entity te = null;
        if ((target != null)
            && (target.getTargetType() == Targetable.TYPE_ENTITY)) {
            // Lets re-write around that horrible hack that was here before.
            // So instead of asking if a specific location is wet and praying
            // that it won't cause an NPE...
            // We'll check 1) if the hex has water, and 2) if it's deep enough
            // to cover the unit in question at its current elevation.
            // It's especially important to make sure it's done this way,
            // because some units (Sylph, submarines) can be at ANY elevation
            // underwater, and VTOLs can be well above the surface.
            te = (Entity) target;
            IHex hex = game.getBoard().getHex(te.getPosition());
            if (hex.containsTerrain(Terrains.WATER)) {
                if (te.relHeight() < 0) {
                    damage = (int) Math.ceil(damage * 0.5f);
                }
            }
        }
        boolean throughFront = true;
        if (te != null) {
            throughFront = Compute
                    .isThroughFrontHex(game, ae.getPosition(), te);
        }
        final boolean glancing = game.getOptions().booleanOption(
                "tacops_glancing_blows")
                                 && (roll == toHit.getValue());
        // Set Margin of Success/Failure.
        toHit.setMoS(roll - Math.max(2, toHit.getValue()));
        final boolean directBlow = game.getOptions().booleanOption(
                "tacops_direct_blow")
                                   && ((toHit.getMoS() / 3) >= 1);

        Report r;

        // Which building takes the damage?
        Building bldg = game.getBoard().getBuildingAt(daa.getTargetPos());


        final int direction = ae.getFacing();

        if (lastEntityId != daa.getEntityId()) {
            // who is making the attack
            r = new Report(4005);
            r.subject = ae.getId();
            r.addDesc(ae);
            addReport(r);
        }

        // should we even bother?
        if ((target == null)
                || ((target.getTargetType() == Targetable.TYPE_ENTITY) && (te
                        .isDestroyed() || te.isDoomed() || te.getCrew()
                        .isDead()))) {
            r = new Report(4245);
            r.subject = ae.getId();
            r.indent();
            addReport(r);
            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
            if (ae.isProne()) {
                // attacker prone during weapons phase
                addReport(doEntityFall(ae, daa.getTargetPos(), 2, 3,
                        ae.getBasePilotingRoll(), false));

            } else {
                // same effect as successful DFA
                ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));
                addReport(doEntityDisplacement(ae, ae.getPosition(),
                        daa.getTargetPos(), new PilotingRollData(ae.getId(), 4,
                                "executed death from above")));
            }
            return;
        }

        r = new Report(4246);
        r.subject = ae.getId();
        r.indent();
        r.add(target.getDisplayName());
        r.newlines = 0;
        addReport(r);

        // target still in the same position?
        if (!target.getPosition().equals(daa.getTargetPos())) {
            r = new Report(4215);
            r.subject = ae.getId();
            addReport(r);
            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
            addReport(doEntityFallsInto(ae, ae.getElevation(),
                    ae.getPosition(), daa.getTargetPos(),
                    ae.getBasePilotingRoll(), true));
            return;
        }

        // hack: if the attacker's prone, or incapacitated, fudge the roll
        if (ae.isProne() || !ae.isActive()) {
            roll = -12;
            r = new Report(4250);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            r.newlines--;
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {
            roll = -12;
            r = new Report(4255);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {
            r = new Report(4260);
            r.subject = ae.getId();
            r.add(toHit.getDesc());
            addReport(r);
            roll = Integer.MAX_VALUE;
        } else {
            // report the roll
            r = new Report(4025);
            r.subject = ae.getId();
            r.add(toHit.getValue());
            r.add(roll);
            r.newlines = 0;
            addReport(r);
            if (glancing) {
                r = new Report(4030);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }
            if (directBlow) {
                r = new Report(4032);
                r.subject = ae.getId();
                r.newlines = 0;
                addReport(r);
            }

        }

        // do we hit?
        if (roll < toHit.getValue()) {
            Coords dest = te.getPosition();
            Coords targetDest = Compute.getPreferredDisplacement(game,
                    te.getId(), dest, direction);
            // miss
            r = new Report(4035);
            r.subject = ae.getId();
            addReport(r);
            if (targetDest != null) {
                // move target to preferred hex
                addReport(doEntityDisplacement(te, dest, targetDest, null));
                // attacker falls into destination hex
                r = new Report(4265);
                r.subject = ae.getId();
                r.addDesc(ae);
                r.add(dest.getBoardNum(), true);
                r.indent();
                addReport(r);
                // entity isn't DFAing any more
                ae.setDisplacementAttack(null);
                addReport(
                        doEntityFall(ae, dest, 2, 3, ae.getBasePilotingRoll(),
                                false), 1);
                Entity violation = Compute.stackingViolation(game, ae.getId(),
                        dest);
                if (violation != null) {
                    // target gets displaced
                    targetDest = Compute.getValidDisplacement(game,
                            violation.getId(), dest, direction);
                    vPhaseReport.addAll(doEntityDisplacement(violation, dest,
                            targetDest, new PilotingRollData(violation.getId(),
                                    0, "domino effect")));
                    // Update the violating entity's postion on the client.
                    if (!game.getOutOfGameEntitiesVector().contains(violation)) {
                        entityUpdate(violation.getId());
                    }
                }
            } else {
                // attacker destroyed
                // Tanks suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                addReport(destroyEntity(ae, "impossible displacement",
                        ae instanceof Mech, ae instanceof Mech));
            }
            return;
        }

        // we hit...

        r = new Report(4040);
        r.subject = ae.getId();
        addReport(r);

        Coords dest = target.getPosition();

        // Can't DFA a target inside of a building.
        int damageTaken = DfaAttackAction.getDamageTakenBy(ae);

        // Targeting a building.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {

            // The building takes the full brunt of the attack.
            Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                           target.getPosition());
            for (Report report : buildingReport) {
                report.subject = ae.getId();
            }
            addReport(buildingReport);

            // Damage any infantry in the hex.
            addReport(damageInfantryIn(bldg, damage, target.getPosition()));

            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
        } else { // Target isn't building.

            if (glancing) {
                if ((te instanceof Infantry) && !(te instanceof BattleArmor)) {
                    damage = (int) Math.ceil(damage / 2.0);
                } else {
                    damage = (int) Math.floor(damage / 2.0);
                }
            }
            if (directBlow) {
                damage += toHit.getMoS() / 3;
            }
            // damage target
            r = new Report(4230);
            r.subject = ae.getId();
            r.add(damage);
            r.add(toHit.getTableDesc());
            r.indent(2);
            addReport(r);

            // work out which locations have spikes
            int[] spikes = new int[te.locations()];
            for (int i = 0; i < te.locations(); i++) {
                spikes[i] = 0;
            }
            for (Mounted m : te.getMisc()) {
                if ((m.getLocation() != Entity.LOC_NONE)
                    && m.getType().hasFlag(MiscType.F_SPIKES)) {
                    spikes[m.getLocation()] = 1;
                }
            }
            int spikeDamage = 0;

            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = te.rollHitLocation(toHit.getHitTable(),
                                                 toHit.getSideTable());
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                if (directBlow) {
                    hit.makeDirectBlow(toHit.getMoS() / 3);
                }

                if (spikes[hit.getLocation()] == 1) {
                    r = new Report(4330);
                    r.indent(2);
                    r.newlines = 0;
                    r.subject = ae.getId();
                    addReport(r);
                    cluster = 1;
                    spikes[hit.getLocation()] = 0;
                    checkBreakSpikes(te, hit.getLocation());
                    spikeDamage += 2;
                }
                addReport(damageEntity(te, hit, cluster, false,
                                       DamageType.NONE, false, false, throughFront));
                damage -= 5;
            }

            if (spikeDamage > 0) {
                if (ae instanceof QuadMech) {
                    addReport(damageEntity(ae, new HitData(Mech.LOC_LARM),
                            (spikeDamage + 2) / 4, false, DamageType.NONE,
                            false, false, false));
                    addReport(damageEntity(ae, new HitData(Mech.LOC_RARM),
                            (spikeDamage + 2) / 4, false, DamageType.NONE,
                            false, false, false));
                    if (spikeDamage > 2) {
                        addReport(damageEntity(ae, new HitData(Mech.LOC_LLEG),
                                spikeDamage / 4, false, DamageType.NONE, false,
                                false, false));
                        addReport(damageEntity(ae, new HitData(Mech.LOC_RLEG),
                                spikeDamage / 4, false, DamageType.NONE, false,
                                false, false));
                    }
                } else {
                    addReport(damageEntity(ae, new HitData(Mech.LOC_LLEG),
                            spikeDamage / 2, false, DamageType.NONE, false,
                            false, false));
                    addReport(damageEntity(ae, new HitData(Mech.LOC_RLEG),
                            spikeDamage / 2, false, DamageType.NONE, false,
                            false, false));
                }
            }
            if (target instanceof VTOL) {
                // destroy rotor
                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,
                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
                                VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
            }
            // Target entities are pushed away or destroyed.
            Coords targetDest = Compute.getValidDisplacement(game, te.getId(),
                    dest, direction);
            if (targetDest != null) {
                addReport(doEntityDisplacement(te, dest, targetDest,
                        new PilotingRollData(te.getId(), 2,
                                "hit by death from above")));
            } else {
                // ack! automatic death! Tanks
                // suffer an ammo/power plant hit.
                // TODO : a Mech suffers a Head Blown Off crit.
                addReport(destroyEntity(te, "impossible displacement",
                        te instanceof Mech, te instanceof Mech));
            }

            // entity isn't DFAing any more
            ae.setDisplacementAttack(null);
        }

        if (glancing) {
            // Glancing Blow rule doesn't state whether damage to attacker on
            // charge
            // or DFA is halved as well, assume yes. TODO: Check with PM
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        if (ae.hasQuirk(OptionsConstants.QUIRK_POS_REINFORCED_LEGS)) {
            damageTaken = (int) Math.floor(damageTaken / 2.0);
        }

        // damage attacker
        r = new Report(4240);
        r.subject = ae.getId();
        r.add(damageTaken);
        r.indent(2);
        addReport(r);
        while (damageTaken > 0) {
            int cluster = Math.min(5, damageTaken);
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK,
                                             ToHitData.SIDE_FRONT);
            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
            addReport(damageEntity(ae, hit, cluster));
            damageTaken -= cluster;
        }

        if (ae.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {
            addNewLines();
            addReport(criticalEntity(ae, Mech.LOC_LLEG, false, 0, 0));
            addNewLines();
            addReport(criticalEntity(ae, Mech.LOC_RLEG, false, 0, 0));
            if (ae instanceof QuadMech) {
                addNewLines();
                addReport(criticalEntity(ae, Mech.LOC_LARM, false, 0, 0));
                addNewLines();
                addReport(criticalEntity(ae, Mech.LOC_RARM, false, 0, 0));
            }
        }

        addNewLines();

        // That's it for target buildings.
        if ((target.getTargetType() == Targetable.TYPE_BUILDING)
            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {
            return;
        }
        ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));
        // HACK: to avoid automatic falls, displace from dest to dest
        addReport(doEntityDisplacement(ae, dest, dest, new PilotingRollData(
                ae.getId(), 4, "executed death from above")));

        // if the target is an industrial mech, it needs to check for crits
        // at the end of turn
        if ((target instanceof Mech) && ((Mech) target).isIndustrial()) {
            ((Mech) target).setCheckForCrit(true);
        }
    }

    /**
     * Get the Kick or Push PSR, modified by weight class
     *
     * @param psrEntity The <code>Entity</code> that should make a PSR
     * @param attacker  The attacking <code>Entity></code>
     * @param target    The target <code>Entity</code>
     * @return The <code>PilotingRollData</code>
     */
    private PilotingRollData getKickPushPSR(Entity psrEntity, Entity attacker,
                                            Entity target, String reason) {
        int mod = 0;
        PilotingRollData psr = new PilotingRollData(psrEntity.getId(), mod,
                                                    reason);
        if (psrEntity.hasQuirk(OptionsConstants.QUIRK_POS_STABLE)) {
            psr.addModifier(-1, "stable", false);
        }
        if (game.getOptions().booleanOption("tacops_physical_psr")) {

            switch (target.getWeightClass()) {
                case EntityWeightClass.WEIGHT_LIGHT:
                    mod = 1;
                    break;
                case EntityWeightClass.WEIGHT_MEDIUM:
                    mod = 0;
                    break;
                case EntityWeightClass.WEIGHT_HEAVY:
                    mod = -1;
                    break;
                case EntityWeightClass.WEIGHT_ASSAULT:
                    mod = -2;
                    break;
            }
            String reportStr;
            if (mod > 0) {
                reportStr = ("weight class modifier +") + mod;
            } else {
                reportStr = ("weight class modifier ") + mod;
            }
            psr.addModifier(mod, reportStr, false);
        }
        return psr;
    }

    /**
     * Each mech sinks the amount of heat appropriate to its current heat
     * capacity.
     */
    private void resolveHeat() {
        Report r;
        // Heat phase header
        addReport(new Report(5000, Report.PUBLIC));
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if ((null == entity.getPosition()) && !(entity instanceof Aero)) {
                continue;
            }
            IHex entityHex = game.getBoard().getHex(entity.getPosition());

            int hotDogMod = 0;
            if (entity.getCrew().getOptions().booleanOption("hot_dog")) {
                hotDogMod = 1;
            }
            if (entity.getTaserInterferenceHeat()) {
                entity.heatBuildup += 5;
            }
            if (entity.hasDamagedRHS() && entity.weaponFired()) {
                entity.heatBuildup += 1;
            }
            if ((entity instanceof Mech) && ((Mech)entity).hasDamagedCoolantSystem() && entity.weaponFired()) {
                entity.heatBuildup += 1;
            }

            int radicalHSBonus = 0;
            Vector<Report> rhsReports = new Vector<Report>();
            if (entity.hasActivatedRadicalHS()) {
                entity.setConsecutiveRHSUses(entity.getConsecutiveRHSUses() + 1);
                if (entity instanceof Mech) {
                    radicalHSBonus = ((Mech) entity).getActiveSinks();
                } else if (entity instanceof Aero) {
                    radicalHSBonus = ((Aero) entity).getHeatSinks();
                } else {
                    System.out.println("Server.resolveHeat() Error: "
                                       + "Radical heatsinks mounted on non-mech "
                                       + "non-aero Entity!");
                }
                int rhsRoll = Compute.d6(2);
                int targetNumber = 2;
                switch (entity.getConsecutiveRHSUses()) {
                    case 1:
                        targetNumber = 3;
                        break;
                    case 2:
                        targetNumber = 5;
                        break;
                    case 3:
                        targetNumber = 7;
                        break;
                    case 4:
                        targetNumber = 10;
                        break;
                    case 5:
                        targetNumber = 11;
                        break;
                    case 6:
                    default:
                        targetNumber = 13; // Auto-fail
                }
                // RHS actiavtion report
                r = new Report(5540);
                r.subject = entity.getId();
                r.indent();
                r.addDesc(entity);
                r.add(radicalHSBonus);
                rhsReports.add(r);

                boolean rhsFailure = rhsRoll < targetNumber;
                r = new Report(5541);
                r.indent(2);
                r.subject = entity.getId();
                r.add(targetNumber);
                r.add(rhsRoll);
                r.choose(rhsFailure);
                rhsReports.add(r);

                if (rhsFailure) {
                    entity.setHasDamagedRHS(true);
                    int loc = Entity.LOC_NONE;
                    for (Mounted m : entity.getEquipment()) {
                        if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {
                            loc = m.getLocation();
                            m.setDestroyed(true);
                            break;
                        }
                    }
                    if (loc == Entity.LOC_NONE) {
                        throw new IllegalStateException("Server."
                                                        + "resolveHeat(): Could not find Radical "
                                                        + "Heatsink mount on unit that used RHS!");
                    }
                    for (int s = 0; s < entity.getNumberOfCriticals(loc); s++) {
                        CriticalSlot slot = entity.getCritical(loc, s);
                        if ((slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                            && slot.getMount().getType()
                                   .hasFlag(MiscType.F_RADICAL_HEATSINK)) {
                            slot.setHit(true);
                            break;
                        }
                    }
                }
            }

            // put in ASF heat build-up first because there are few differences
            if ((entity instanceof Aero) && !(entity instanceof ConvFighter)) {
                // If this aero is part of a squadron, we will deal with its
                // heat with the fighter squadron
                if ((game.getEntity(entity.getTransportId()) instanceof FighterSquadron)) {
                    continue;
                }
                Aero a = (Aero) entity;

                // should we even bother?
                if (entity.isDestroyed() || entity.isDoomed()
                    || entity.getCrew().isDoomed()
                    || entity.getCrew().isDead()) {
                    continue;
                }

                // engine hits add a lot of heat, provided the engine is on
                entity.heatBuildup += entity.getEngineCritHeat();

                // If an Aero had an active Stealth suite, add 10 heat.
                if (entity.isStealthOn()) {
                    entity.heatBuildup += 10;
                    r = new Report(5015);
                    r.subject = entity.getId();
                    addReport(r);
                }

                // Combat computers help manage heat
                if (entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {
                    int reduce = Math.min(entity.heatBuildup, 4);
                    r = new Report(5026);
                    r.subject = entity.getId();
                    r.add(reduce);
                    addReport(r);
                    entity.heatBuildup -= reduce;
                }

                // Add heat from external sources to the heat buildup
                int max_ext_heat = game.getOptions().intOption(
                        "max_external_heat"); // Check Game Options
                if (max_ext_heat < 0) {
                    max_ext_heat = 15; // standard value specified in TW p.159
                }
                entity.heatBuildup += Math.min(max_ext_heat,
                                               entity.heatFromExternal);
                entity.heatFromExternal = 0;
                // remove heat we cooled down
                entity.heatBuildup -= Math.min(9, entity.coolFromExternal);
                entity.coolFromExternal = 0;

                // add the heat we've built up so far.
                entity.heat += entity.heatBuildup;

                // how much heat can we sink?
                int tosink = entity.getHeatCapacityWithWater() + radicalHSBonus;

                // should we use a coolant pod?
                int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;
                int possibleSinkage = ((Aero) entity).getHeatSinks()
                                      - entity.getCoolantFailureAmount();
                for (Mounted m : entity.getEquipment()) {
                    if (m.getType() instanceof AmmoType) {
                        AmmoType at = (AmmoType) m.getType();
                        if ((at.getAmmoType() == AmmoType.T_COOLANT_POD)
                            && m.isAmmoUsable()) {
                            EquipmentMode mode = m.curMode();
                            if (mode.equals("dump")) {
                                r = new Report(5260);
                                r.subject = entity.getId();
                                addReport(r);
                                m.setShotsLeft(0);
                                tosink += possibleSinkage;
                                break;
                            }
                            if (mode.equals("safe")
                                && ((entity.heat - tosink) > safeHeat)) {
                                r = new Report(5265);
                                r.subject = entity.getId();
                                addReport(r);
                                m.setShotsLeft(0);
                                tosink += possibleSinkage;
                                break;
                            }
                            if (mode.equals("efficient")
                                && ((entity.heat - tosink) >= possibleSinkage)) {
                                r = new Report(5270);
                                r.subject = entity.getId();
                                addReport(r);
                                m.setShotsLeft(0);
                                tosink += possibleSinkage;
                                break;
                            }
                        }
                    }
                }

                tosink = Math.min(tosink, entity.heat);
                entity.heat -= tosink;
                r = new Report(5035);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(entity.heatBuildup);
                r.add(tosink);
                r.add(entity.heat);
                addReport(r);
                entity.heatBuildup = 0;
                vPhaseReport.addAll(rhsReports);

                // add in the effects of heat

                if ((entity instanceof Dropship)
                    || (entity instanceof Jumpship)) {
                    // only check for a possible control roll
                    if (entity.heat > 0) {
                        int bonus = (int) Math.ceil(entity.heat / 100.0);
                        game.addControlRoll(new PilotingRollData(
                                entity.getId(), bonus, "used too much heat"));
                        entity.heat = 0;
                    }
                    continue;
                }

                // Capital fighters can overheat and require control rolls
                if (entity.isCapitalFighter() && (entity.heat > 0)) {
                    int penalty = (int) Math.ceil(entity.heat / 15.0);
                    game.addControlRoll(new PilotingRollData(entity.getId(),
                                                             penalty, "used too much heat"));
                }

                // Like other large craft, the rest of these rules don't apply
                // to capital fighters
                if (entity.isCapitalFighter()) {
                    continue;
                }

                int autoShutDownHeat = 30;
                boolean mtHeat = game.getOptions().booleanOption("tacops_heat");
                if (mtHeat) {
                    autoShutDownHeat = 50;
                }

                // heat effects: start up
                if ((entity.heat < autoShutDownHeat) && entity.isShutDown()) {
                    // only start up if not shut down by taser or a TSEMP
                    if ((entity.getTaserShutdownRounds() == 0)
                        && (entity.getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {
                        if ((entity.heat < 14) && !(entity.isManualShutdown())) {
                            // automatically starts up again
                            entity.setShutDown(false);
                            r = new Report(5045);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            addReport(r);
                        } else if (!(entity.isManualShutdown())) {
                            // If the pilot is KO and we need to roll, auto-fail.
                            if (!entity.getCrew().isActive()) {
                                r = new Report(5049);
                                r.subject = entity.getId();
                                r.addDesc(entity);
                                addReport(r);
                            } else {
                                // roll for startup
                                int startup = (4 + (((entity.heat - 14) / 4) * 2))
                                              - hotDogMod;
                                if (mtHeat) {
                                    startup -= 5;
                                    switch (entity.getCrew().getPiloting()) {
                                        case 0:
                                        case 1:
                                            startup -= 2;
                                            break;
                                        case 2:
                                        case 3:
                                            startup -= 1;
                                            break;
                                        case 6:
                                        case 7:
                                            startup += 1;
                                            break;
                                    }
                                }
                                int suroll = entity.getCrew().rollPilotingSkill();
                                r = new Report(5050);
                                r.subject = entity.getId();
                                r.addDesc(entity);
                                r.add(startup);
                                r.add(suroll);
                                if (suroll >= startup) {
                                    // start 'er back up
                                    entity.setShutDown(false);
                                    r.choose(true);
                                } else {
                                    r.choose(false);
                                }
                                addReport(r);
                            }
                        }
                    } else {
                        // if we're shutdown by a BA taser, we might activate
                        // again
                        if (entity.isBATaserShutdown()) {
                            int roll = Compute.d6(2);
                            if (roll >= 8) {
                                entity.setTaserShutdownRounds(0);
                                if (!(game.getOptions().booleanOption(
                                        "manual_shutdown") && entity
                                              .isManualShutdown())) {
                                    entity.setShutDown(false);
                                }
                                entity.setBATaserShutdown(false);
                            }
                        }
                    }
                }

                // heat effects: shutdown!
                else if ((entity.heat >= 14) && !entity.isShutDown()) {
                    if (entity.heat >= autoShutDownHeat) {
                        r = new Report(5055);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                        // okay, now mark shut down
                        entity.setShutDown(true);
                    } else if (entity.heat >= 14) {
                        // Again, pilot KO means shutdown is automatic.
                        if (!entity.getCrew().isActive()) {
                            r = new Report(5056);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            addReport(r);
                            entity.setShutDown(true);
                        } else {
                            int shutdown = (4 + (((entity.heat - 14) / 4) * 2))
                                           - hotDogMod;
                            if (mtHeat) {
                                shutdown -= 5;
                                switch (entity.getCrew().getPiloting()) {
                                    case 0:
                                    case 1:
                                        shutdown -= 2;
                                        break;
                                    case 2:
                                    case 3:
                                        shutdown -= 1;
                                        break;
                                    case 6:
                                    case 7:
                                        shutdown += 1;
                                        break;
                                }
                            }
                            int sdroll = Compute.d6(2);
                            r = new Report(5060);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(shutdown);
                            r.add(sdroll);
                            if (sdroll >= shutdown) {
                                // avoided
                                r.choose(true);
                                addReport(r);
                            } else {
                                // shutting down...
                                r.choose(false);
                                addReport(r);
                                // okay, now mark shut down
                                entity.setShutDown(true);
                            }
                        }
                    }
                }

                // heat effects: control effects (must make it unless already
                // random moving)
                if ((entity.heat >= 5) && !a.isRandomMove()) {
                    int controlavoid = (5 + (entity.heat >= 10 ? 1 : 0)
                                        + (entity.heat >= 15 ? 1 : 0)
                                        + (entity.heat >= 20 ? 1 : 0) + (entity.heat >= 25 ? 2
                                                                                           : 0))
                                       - hotDogMod;
                    int controlroll = Compute.d6(2);
                    r = new Report(9210);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(controlavoid);
                    r.add(controlroll);
                    if (controlroll >= controlavoid) {
                        // in control
                        r.choose(true);
                        addReport(r);
                    } else {
                        // out of control
                        r.choose(false);
                        addReport(r);
                        // if not already out of control, this may lead to
                        // elevation decline
                        if (!a.isOutControl() && !game.getBoard().inSpace()
                            && a.isAirborne()) {
                            int loss = Compute.d6(1);
                            r = new Report(9366);
                            r.newlines = 0;
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(loss);
                            addReport(r);
                            a.setAltitude(a.getAltitude() - loss);
                            // check for crash
                            if (checkCrash(a, a.getPosition(), a.getAltitude())) {
                                addReport(processCrash(entity,
                                                       a.getCurrentVelocity(), a.getPosition()));
                            }
                        }
                        // force unit out of control through heat
                        a.setOutCtrlHeat(true);
                        a.setRandomMove(true);
                    }
                } // End of Entity Instance of Aero

                // heat effects: ammo explosion!
                if (entity.heat >= 19) {
                    int boom = (4 + (entity.heat >= 23 ? 2 : 0) + (entity.heat >= 28 ? 2
                                                                                     : 0))
                               - hotDogMod;
                    if (mtHeat) {
                        boom += (entity.heat >= 35 ? 2 : 0)
                                + (entity.heat >= 40 ? 2 : 0)
                                + (entity.heat >= 45 ? 2 : 0);
                        // Last line is a crutch; 45 heat should be no roll
                        // but automatic explosion.
                    }
                    int boomroll = Compute.d6(2);
                    r = new Report(5065);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(boom);
                    r.add(boomroll);
                    if (boomroll >= boom) {
                        // mech is ok
                        r.choose(true);
                        addReport(r);
                    } else {
                        // boom!
                        r.choose(false);
                        addReport(r);
                        addReport(explodeAmmoFromHeat(entity));
                    }
                }

                // heat effects: pilot damage
                if (entity.heat >= 21) {
                    int ouch = (6 + (entity.heat >= 27 ? 3 : 0)) - hotDogMod;
                    int ouchroll = Compute.d6(2);
                    r = new Report(5075);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(ouch);
                    r.add(ouchroll);
                    if (ouchroll >= ouch) {
                        // pilot is ok
                        r.choose(true);
                        addReport(r);
                    } else {
                        // pilot is hurting
                        r.choose(false);
                        addReport(r);
                        addReport(damageCrew(entity, 1));
                    }
                }

                // The pilot may have just expired.
                if ((entity.getCrew().isDead() || entity.getCrew().isDoomed())
                    && !entity.getCrew().isEjected()) {
                    r = new Report(5080);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    addReport(destroyEntity(entity, "pilot death", true));
                }

                continue;
            }

            // heat doesn't matter for non-mechs
            if (!(entity instanceof Mech)) {
                entity.heatBuildup = 0;
                entity.heatFromExternal = 0;
                entity.coolFromExternal = 0;

                if (entity.infernos.isStillBurning()) {
                    doFlamingDamage(entity);
                }
                if (entity.getTaserShutdownRounds() == 0) {
                    entity.setBATaserShutdown(false);
                    if (entity.isShutDown()
                        && !entity.isManualShutdown()
                        && (entity.getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {
                        entity.setShutDown(false);
                        r = new Report(5045);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                    }
                } else if (entity.isBATaserShutdown()) {
                    // if we're shutdown by a BA taser, we might activate
                    // again
                    int roll = Compute.d6(2);
                    if (roll >= 8) {
                        entity.setTaserShutdownRounds(0);
                        if (!(entity.isManualShutdown())) {
                            entity.setShutDown(false);
                        }
                        entity.setBATaserShutdown(false);
                    }
                }

                continue;
            }
            // Meks gain heat from inferno hits.
            if (entity.infernos.isStillBurning()) {
                int infernoHeat = entity.infernos.getHeat();
                entity.heatFromExternal += infernoHeat;
                r = new Report(5010);
                r.subject = entity.getId();
                r.add(infernoHeat);
                addReport(r);
            }

            // should we even bother?
            if (entity.isDestroyed() || entity.isDoomed()
                || entity.getCrew().isDoomed() || entity.getCrew().isDead()) {
                continue;
            }

            // engine hits add a lot of heat, provided the engine is on
            entity.heatBuildup += entity.getEngineCritHeat();

            // If a Mek had an active Stealth suite, add 10 heat.
            if (((entity instanceof Mech)) && entity.isStealthOn()) {
                entity.heatBuildup += 10;
                r = new Report(5015);
                r.subject = entity.getId();
                addReport(r);
            }

            // Greg: Nova CEWS If a Mek had an active Nova suite, add 2 heat.
            if (((entity instanceof Mech) || (entity instanceof Aero))
                && entity.hasActiveNovaCEWS()) {
                entity.heatBuildup += 2;
                r = new Report(5013);
                r.subject = entity.getId();
                addReport(r);
            }

            // void sig adds 10 heat
            if ((entity instanceof Mech) && entity.isVoidSigOn()) {
                entity.heatBuildup += 10;
                r = new Report(5016);
                r.subject = entity.getId();
                addReport(r);
            }

            // null sig adds 10 heat
            if ((entity instanceof Mech) && entity.isNullSigOn()) {
                entity.heatBuildup += 10;
                r = new Report(5017);
                r.subject = entity.getId();
                addReport(r);
            }

            // chameleon polarization field adds 6
            if ((entity instanceof Mech) && entity.isChameleonShieldOn()) {
                entity.heatBuildup += 6;
                r = new Report(5014);
                r.subject = entity.getId();
                addReport(r);
            }

            // If a Mek is in extreme Temperatures, add or subtract one
            // heat per 10 degrees (or fraction of 10 degrees) above or
            // below 50 or -30 degrees Celsius
            if ((entity instanceof Mech)
                && (game.getPlanetaryConditions().getTemperatureDifference(
                    50, -30) != 0)
                && !((Mech) entity).hasLaserHeatSinks()) {
                if (game.getPlanetaryConditions().getTemperature() > 50) {
                    int heatToAdd = game.getPlanetaryConditions()
                                        .getTemperatureDifference(50, -30);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heatToAdd /= 2;
                    }
                    entity.heatFromExternal += heatToAdd;
                    r = new Report(5020);
                    r.subject = entity.getId();
                    r.add(heatToAdd);
                    addReport(r);
                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                } else {
                    entity.heatFromExternal -= game.getPlanetaryConditions()
                                                   .getTemperatureDifference(50, -30);
                    r = new Report(5025);
                    r.subject = entity.getId();
                    r.add(game.getPlanetaryConditions()
                              .getTemperatureDifference(50, -30));
                    addReport(r);
                }
            }

            // Add +5 Heat if the hex you're in is on fire
            // and was on fire for the full round.
            if (entityHex != null) {
                if (entityHex.containsTerrain(Terrains.FIRE)
                    && (entityHex.getFireTurn() > 0)
                    && (entity.getElevation() <= 1)) {
                    int heatToAdd = 5;
                    if ((entity instanceof Mech)
                        && ((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heatToAdd /= 2;
                    }
                    entity.heatFromExternal += heatToAdd;
                    r = new Report(5030);
                    r.add(heatToAdd);
                    r.subject = entity.getId();
                    addReport(r);
                    if ((entity instanceof Mech)
                        && ((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
                int magma = entityHex.terrainLevel(Terrains.MAGMA);
                if ((magma > 0) && (entity.getElevation() == 0)) {
                    int heatToAdd = 5 * magma;
                    if ((entity instanceof Mech)
                        && ((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        heatToAdd /= 2;
                    }
                    entity.heatFromExternal += heatToAdd;
                    r = new Report(5032);
                    r.subject = entity.getId();
                    r.add(heatToAdd);
                    addReport(r);
                    if ((entity instanceof Mech)
                        && ((Mech) entity).hasIntactHeatDissipatingArmor()) {
                        r = new Report(5550);
                        addReport(r);
                    }
                }
            }

            // Check the mech for vibroblades if so then check to see if any
            // are active and what heat they will produce.
            if (entity.hasVibroblades()) {
                int vibroHeat = 0;

                vibroHeat = entity.getActiveVibrobladeHeat(Mech.LOC_RARM);
                vibroHeat += entity.getActiveVibrobladeHeat(Mech.LOC_LARM);

                if (vibroHeat > 0) {
                    r = new Report(5018);
                    r.subject = entity.getId();
                    r.add(vibroHeat);
                    addReport(r);
                    entity.heatBuildup += vibroHeat;
                }
            }

            int capHeat = 0;
            for (Mounted m : entity.getEquipment()) {
                if ((m.hasChargedCapacitor() == 1) && !m.isUsedThisRound()) {
                    capHeat += 5;
                }
                if ((m.hasChargedCapacitor() == 2) && !m.isUsedThisRound()) {
                    capHeat += 10;
                }
            }
            if (capHeat > 0) {
                r = new Report(5019);
                r.subject = entity.getId();
                r.add(capHeat);
                addReport(r);
                entity.heatBuildup += capHeat;
            }

            // Add heat from external sources to the heat buildup
            int max_ext_heat = game.getOptions().intOption("max_external_heat"); // Check
            // Game
            // Options
            if (max_ext_heat < 0) {
                max_ext_heat = 15; // standard value specified in TW p.159
            }
            entity.heatBuildup += Math.min(max_ext_heat,
                                           entity.heatFromExternal);
            entity.heatFromExternal = 0;
            // remove heat we cooled down
            entity.heatBuildup -= Math.min(9, entity.coolFromExternal);
            entity.coolFromExternal = 0;

            // Combat computers help manage heat
            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {
                int reduce = Math.min(entity.heatBuildup, 4);
                r = new Report(5026);
                r.subject = entity.getId();
                r.add(reduce);
                addReport(r);
                entity.heatBuildup -= reduce;
            }

            // if heatbuildup is negative due to temperature, set it to 0
            // for prettier turnreports
            if (entity.heatBuildup < 0) {
                entity.heatBuildup = 0;
            }

            // add the heat we've built up so far.
            entity.heat += entity.heatBuildup;

            // how much heat can we sink?
            int tosink = entity.getHeatCapacityWithWater() + radicalHSBonus;

            if (entity.getCoolantFailureAmount() > 0) {
                int failureAmount = entity.getCoolantFailureAmount();
                r = new Report(5520);
                r.subject = entity.getId();
                r.add(failureAmount);
                tosink -= failureAmount;
            }

            // should we use a coolant pod?
            int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;
            int possibleSinkage = ((Mech) entity).getNumberOfSinks()
                                  - entity.getCoolantFailureAmount();
            for (Mounted m : entity.getEquipment()) {
                if (m.getType() instanceof AmmoType) {
                    AmmoType at = (AmmoType) m.getType();
                    if ((at.getAmmoType() == AmmoType.T_COOLANT_POD)
                        && m.isAmmoUsable()) {
                        EquipmentMode mode = m.curMode();
                        if (mode.equals("dump")) {
                            r = new Report(5260);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            tosink += possibleSinkage;
                            break;
                        }
                        if (mode.equals("safe")
                            && ((entity.heat - tosink) > safeHeat)) {
                            r = new Report(5265);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            tosink += possibleSinkage;
                            break;
                        }
                        if (mode.equals("efficient")
                            && ((entity.heat - tosink) >= possibleSinkage)) {
                            r = new Report(5270);
                            r.subject = entity.getId();
                            addReport(r);
                            m.setShotsLeft(0);
                            tosink += possibleSinkage;
                            break;
                        }
                    }
                }
            }

            tosink = Math.min(tosink, entity.heat);
            entity.heat -= tosink;
            r = new Report(5035);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(entity.heatBuildup);
            r.add(tosink);
            r.add(entity.heat);
            addReport(r);
            entity.heatBuildup = 0;
            vPhaseReport.addAll(rhsReports);

            // Does the unit have inferno ammo?
            if (entity.hasInfernoAmmo()) {

                // Roll for possible inferno ammo explosion.
                if (entity.heat >= 10) {
                    int boom = (4 + (entity.heat >= 14 ? 2 : 0)
                                + (entity.heat >= 19 ? 2 : 0)
                                + (entity.heat >= 23 ? 2 : 0) + (entity.heat >= 28 ? 2
                                                                                   : 0))
                               - hotDogMod;
                    int boomroll = Compute.d6(2);
                    r = new Report(5040);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(boom);
                    r.add(boomroll);

                    if (boomroll >= boom) {
                        // avoided
                        r.choose(true);
                        addReport(r);
                    } else {
                        r.choose(false);
                        addReport(r);
                        addReport(explodeInfernoAmmoFromHeat(entity));
                    }
                }
            } // End avoid-inferno-explosion
            int autoShutDownHeat;
            boolean mtHeat;

            if (game.getOptions().booleanOption("tacops_heat")) {
                autoShutDownHeat = 50;
                mtHeat = true;
            } else {
                autoShutDownHeat = 30;
                mtHeat = false;
            }
            // heat effects: start up
            if ((entity.heat < autoShutDownHeat) && entity.isShutDown()
                && !entity.isStalled()) {
                if ((entity.getTaserShutdownRounds() == 0)
                    && (entity.getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {
                    if ((entity.heat < 14) && !(entity.isManualShutdown())) {
                        // automatically starts up again
                        entity.setShutDown(false);
                        r = new Report(5045);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                    } else if (!(entity.isManualShutdown())) {
                        // If the pilot is KO and we need to roll, auto-fail.
                        if (!entity.getCrew().isActive()) {
                            r = new Report(5049);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            addReport(r);
                        } else {
                            // roll for startup
                            int startup = (4 + (((entity.heat - 14) / 4) * 2))
                                          - hotDogMod;
                            if (mtHeat) {
                                startup -= 5;
                                switch (entity.getCrew().getPiloting()) {
                                    case 0:
                                    case 1:
                                        startup -= 2;
                                        break;
                                    case 2:
                                    case 3:
                                        startup -= 1;
                                        break;
                                    case 6:
                                    case 7:
                                        startup += 1;
                                }
                            }
                            int suroll = Compute.d6(2);
                            r = new Report(5050);
                            r.subject = entity.getId();
                            r.addDesc(entity);
                            r.add(startup);
                            r.add(suroll);
                            if (suroll >= startup) {
                                // start 'er back up
                                entity.setShutDown(false);
                                r.choose(true);
                            } else {
                                r.choose(false);
                            }
                            addReport(r);
                        }
                    }
                } else {
                    // if we're shutdown by a BA taser, we might activate
                    // again
                    if (entity.isBATaserShutdown()) {
                        int roll = Compute.d6(2);
                        if (roll >= 7) {
                            entity.setTaserShutdownRounds(0);
                            if (!(entity.isManualShutdown())) {
                                entity.setShutDown(false);
                            }
                            entity.setBATaserShutdown(false);
                        }
                    }
                }
            }

            // heat effects: shutdown!
            // Don't shut down if you just restarted.
            else if ((entity.heat >= 14) && !entity.isShutDown()) {
                if (entity.heat >= autoShutDownHeat) {
                    r = new Report(5055);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    addReport(r);
                    // add a piloting roll and resolve immediately
                    game.addPSR(new PilotingRollData(entity.getId(), 3,
                                                     "reactor shutdown"));
                    addReport(resolvePilotingRolls());
                    // okay, now mark shut down
                    entity.setShutDown(true);
                } else if (entity.heat >= 14) {
                    // Again, pilot KO means shutdown is automatic.
                    if (!entity.getCrew().isActive()) {
                        r = new Report(5056);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        addReport(r);
                        entity.setShutDown(true);
                    } else {
                        int shutdown = (4 + (((entity.heat - 14) / 4) * 2))
                                       - hotDogMod;
                        if (mtHeat) {
                            shutdown -= 5;
                            switch (entity.getCrew().getPiloting()) {
                                case 0:
                                case 1:
                                    shutdown -= 2;
                                    break;
                                case 2:
                                case 3:
                                    shutdown -= 1;
                                    break;
                                case 6:
                                case 7:
                                    shutdown += 1;
                            }
                        }
                        int sdroll = Compute.d6(2);
                        r = new Report(5060);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(shutdown);
                        r.add(sdroll);
                        if (sdroll >= shutdown) {
                            // avoided
                            r.choose(true);
                            addReport(r);
                        } else {
                            // shutting down...
                            r.choose(false);
                            addReport(r);
                            // add a piloting roll and resolve immediately
                            game.addPSR(new PilotingRollData(entity.getId(), 3,
                                                             "reactor shutdown"));
                            addReport(resolvePilotingRolls());
                            // okay, now mark shut down
                            entity.setShutDown(true);
                        }
                    }
                }
            }

            // heat effects: ammo explosion!
            if (entity.heat >= 19) {
                int boom = (4 + (entity.heat >= 23 ? 2 : 0) + (entity.heat >= 28 ? 2
                                                                                 : 0))
                           - hotDogMod;
                if (mtHeat) {
                    boom += (entity.heat >= 35 ? 2 : 0)
                            + (entity.heat >= 40 ? 2 : 0)
                            + (entity.heat >= 45 ? 2 : 0);
                    // Last line is a crutch; 45 heat should be no roll
                    // but automatic explosion.
                }
                if ((entity instanceof Mech)
                    && ((Mech) entity).hasLaserHeatSinks()) {
                    boom--;
                }
                int boomroll = Compute.d6(2);
                r = new Report(5065);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(boom);
                r.add(boomroll);
                if (boomroll >= boom) {
                    // mech is ok
                    r.choose(true);
                    addReport(r);
                } else {
                    // boom!
                    r.choose(false);
                    addReport(r);
                    addReport(explodeAmmoFromHeat(entity));
                }
            }

            // heat effects: mechwarrior damage
            // N.B. The pilot may already be dead.
            int lifeSupportCritCount = 0;
            boolean torsoMountedCockpit = ((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED;
            if ((entity instanceof Mech) && torsoMountedCockpit) {
                lifeSupportCritCount = entity.getHitCriticals(
                        CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT,
                        Mech.LOC_RT);
                lifeSupportCritCount += entity.getHitCriticals(
                        CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT,
                        Mech.LOC_LT);
            } else {
                lifeSupportCritCount = entity.getHitCriticals(
                        CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT,
                        Mech.LOC_HEAD);
            }
            int damageHeat = entity.heat;
            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_IMP_LIFE_SUPPORT)) {
                damageHeat -= 5;
            }
            if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_LIFE_SUPPORT)) {
                damageHeat += 5;
            }
            if ((lifeSupportCritCount > 0)
                && ((damageHeat >= 15) || (torsoMountedCockpit && (damageHeat > 0)))
                && !entity.getCrew().isDead()
                && !entity.getCrew().isDoomed()
                && !entity.getCrew().isEjected()) {
                int heatLimitDesc = 1;
                int damageToCrew = 0;
                if ((damageHeat >= 47) && mtHeat) {
                    // mechwarrior takes 5 damage
                    heatLimitDesc = 47;
                    damageToCrew = 5;
                } else if ((damageHeat >= 39) && mtHeat) {
                    // mechwarrior takes 4 damage
                    heatLimitDesc = 39;
                    damageToCrew = 4;
                } else if ((damageHeat >= 32) && mtHeat) {
                    // mechwarrior takes 3 damage
                    heatLimitDesc = 32;
                    damageToCrew = 3;
                } else if (damageHeat >= 25) {
                    // mechwarrior takes 2 damage
                    heatLimitDesc = 25;
                    damageToCrew = 2;
                } else if (damageHeat >= 15) {
                    // mechwarrior takes 1 damage
                    heatLimitDesc = 15;
                    damageToCrew = 1;
                }
                if ((damageHeat > 0)
                    && (entity instanceof Mech)
                    && (((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)
                    && !entity.getCrew().getOptions()
                              .booleanOption("pain_shunt")) {
                    damageToCrew += 1;
                }
                r = new Report(5070);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(heatLimitDesc);
                r.add(damageToCrew);
                addReport(r);
                addReport(damageCrew(entity, damageToCrew));
            } else if (mtHeat
                       && (entity.heat >= 32)
                       && !entity.getCrew().isDead()
                       && !entity.getCrew().isDoomed()
                       && !entity.getCrew().getOptions()
                                 .booleanOption("pain_shunt")) {
                // Crew may take damage from heat if MaxTech option is set
                int heatroll = Compute.d6(2);
                int avoidNumber = -1;
                if (entity.heat >= 47) {
                    avoidNumber = 12;
                } else if (entity.heat >= 39) {
                    avoidNumber = 10;
                } else if (entity.heat >= 32) {
                    avoidNumber = 8;
                }
                avoidNumber -= hotDogMod;
                r = new Report(5075);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(avoidNumber);
                r.add(heatroll);
                if (heatroll >= avoidNumber) {
                    // damage avoided
                    r.choose(true);
                    addReport(r);
                } else {
                    r.choose(false);
                    addReport(r);
                    addReport(damageCrew(entity, 1));
                }
            }

            // The pilot may have just expired.
            if ((entity.getCrew().isDead() || entity.getCrew().isDoomed())
                && !entity.getCrew().isEjected()) {
                r = new Report(5080);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity, "crew death", true));
            }

            // With MaxTech Heat Scale, there may occur critical damage
            if (mtHeat) {
                if (entity.heat >= 36) {
                    int damageroll = Compute.d6(2);
                    int damageNumber = -1;
                    if (entity.heat >= 44) {
                        damageNumber = 10;
                    } else if (entity.heat >= 36) {
                        damageNumber = 8;
                    }
                    damageNumber -= hotDogMod;
                    r = new Report(5085);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(damageNumber);
                    r.add(damageroll);
                    r.newlines = 0;
                    if (damageroll >= damageNumber) {
                        r.choose(true);
                        addReport(r);
                    } else {
                        r.choose(false);
                        addReport(r);
                        addReport(oneCriticalEntity(entity,
                                                    Compute.randomInt(8), false, 0));
                        // add an empty report, for linebreaking
                        r = new Report(1210, Report.PUBLIC);
                        addReport(r);
                    }
                }
            }

            if (game.getOptions().booleanOption("tacops_coolant_failure")
                && (entity.getHeatCapacity() > entity
                    .getCoolantFailureAmount()) && (entity.heat >= 5)) {
                int roll = Compute.d6(2);
                int hitNumber = 10;

                hitNumber -= Math
                        .max(0, (int) Math.ceil(entity.heat / 5.0) - 2);

                r = new Report(5525);
                r.subject = entity.getId();
                r.add(entity.getShortName());
                r.add(hitNumber);
                r.add(roll);
                r.newlines = 0;
                addReport(r);
                if (roll >= hitNumber) {
                    r = new Report(5052);
                    r.subject = entity.getId();
                    addReport(r);
                    r = new Report(5526);
                    r.subject = entity.getId();
                    r.add(entity.getShortNameRaw());
                    addReport(r);
                    entity.addCoolantFailureAmount(1);
                } else {
                    r = new Report(5041);
                    r.subject = entity.getId();
                    addReport(r);
                }
            }
        }

        if (vPhaseReport.size() == 1) {
            // I guess nothing happened...
            addReport(new Report(1205, Report.PUBLIC));
        }
    }

    private void resolveEmergencyCoolantSystem() {
        for (Entity e : game.getEntitiesVector()) {
            if ((e instanceof Mech) && e.hasWorkingMisc(MiscType.F_EMERGENCY_COOLANT_SYSTEM)
                    && (e.heat > 13)) {
                Mech mech = (Mech)e;
                Vector<Report> vDesc = new Vector<Report>();
                HashMap<Integer, List<CriticalSlot>> crits = new HashMap<Integer, List<CriticalSlot>>();
                if (!(mech.doRISCEmergencyCoolantCheckFor(vDesc, crits))) {
                    mech.heat -= 6 + mech.getCoolantSystemMOS();
                    Report r = new Report(5027);
                    r.add(6+mech.getCoolantSystemMOS());
                    vDesc.add(r);
                }
                addReport(vDesc);
                for (Integer loc : crits.keySet()) {
                    List<CriticalSlot> lcs = crits.get(loc);
                    for (CriticalSlot cs : lcs) {
                        addReport(applyCriticalHit(mech, loc, cs, true, 0, false));
                    }
                }
            }
        }
    }

    /*
     * Resolve HarJel II/III repairs for Mechs so equipped.
     */
    private void resolveHarjelRepairs() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if (!(entity instanceof Mech)) {
                continue;
            }

            Mech me = (Mech) entity;
            for (int loc = 0; loc < me.locations(); ++loc) {
                boolean harjelII = me.hasHarJelIIIn(loc); // false implies HarJel III
                if ((harjelII || me.hasHarJelIIIIn(loc))
                    && me.isArmorDamagedThisTurn(loc)) {
                    if (me.hasRearArmor(loc)) {
                        // must have at least one remaining armor in location
                        if (!((me.getArmor(loc) > 0)
                            || (me.getArmor(loc, true) > 0))) {
                            continue;
                        }

                        int toRepair = harjelII ? 2 : 4;
                        int frontRepair, rearRepair;
                        int desiredFrontRepair, desiredRearRepair;

                        Mounted harjel = null;
                        // find harjel item
                        // don't need to check ready or worry about null,
                        // we already know there is one, it's ready,
                        // and there can be at most one in a given location
                        for (Mounted m: me.getMisc()) {
                            if ((m.getLocation() == loc)
                                && (m.getType().hasFlag(MiscType.F_HARJEL_II)
                                    || m.getType().hasFlag(MiscType.F_HARJEL_III))) {
                                harjel = m;
                            }
                        }

                        if (harjelII) {
                            if (harjel.curMode().equals(MiscType.S_HARJEL_II_1F1R)) {
                                desiredFrontRepair = 1;
                            } else if (harjel.curMode().equals(MiscType.S_HARJEL_II_2F0R)) {
                                desiredFrontRepair = 2;
                            } else { // 0F2R
                                desiredFrontRepair = 0;
                            }
                        } else { // HarJel III
                            if (harjel.curMode().equals(MiscType.S_HARJEL_III_2F2R)) {
                                desiredFrontRepair = 2;
                            } else if (harjel.curMode().equals(MiscType.S_HARJEL_III_4F0R)) {
                                desiredFrontRepair = 4;
                            } else if (harjel.curMode().equals(MiscType.S_HARJEL_III_3F1R)) {
                                desiredFrontRepair = 3;
                            } else if (harjel.curMode().equals(MiscType.S_HARJEL_III_1F3R)) {
                                desiredFrontRepair = 1;
                            } else { // 0F4R
                                desiredFrontRepair = 0;
                            }
                        }
                        desiredRearRepair = toRepair - desiredFrontRepair;

                        int availableFrontRepair = me.getOArmor(loc) - me.getArmor(loc);
                        int availableRearRepair = me.getOArmor(loc, true)
                                - me.getArmor(loc, true);
                        frontRepair = Math.min(availableFrontRepair, desiredFrontRepair);
                        rearRepair = Math.min(availableRearRepair, desiredRearRepair);
                        int surplus = desiredFrontRepair - frontRepair;
                        if (surplus > 0) { // we couldn't use all the points we wanted in front
                            rearRepair = Math.min(availableRearRepair,
                                    rearRepair + surplus);
                        } else {
                            surplus = desiredRearRepair - rearRepair;
                            // try to move any excess points from rear to front
                            frontRepair = Math.min(availableFrontRepair,
                                    frontRepair + surplus);
                        }

                        if (frontRepair > 0) {
                            me.setArmor(me.getArmor(loc) + frontRepair, loc);
                            r = new Report(harjelII ? 9850 : 9851);
                            r.subject = me.getId();
                            r.addDesc(entity);
                            r.add(frontRepair);
                            r.add(me.getLocationAbbr(loc));
                            addReport(r);
                        }
                        if (rearRepair > 0) {
                            me.setArmor(me.getArmor(loc, true) + rearRepair,
                                    loc, true);
                            r = new Report(harjelII ? 9850 : 9851);
                            r.subject = me.getId();
                            r.addDesc(entity);
                            r.add(rearRepair);
                            r.add(me.getLocationAbbr(loc) + " (R)");
                            addReport(r);
                        }
                    } else {
                        // must have at least one remaining armor in location
                        if (!(me.getArmor(loc) > 0)) {
                            continue;
                        }
                        int toRepair = harjelII ? 2 : 4;
                        toRepair = Math.min(toRepair,
                                me.getOArmor(loc) - me.getArmor(loc));
                        me.setArmor(me.getArmor(loc) + toRepair, loc);
                        r = new Report(harjelII ? 9850 : 9851);
                        r.subject = me.getId();
                        r.addDesc(entity);
                        r.add(toRepair);
                        r.add(me.getLocationAbbr(loc));
                        addReport(r);
                    }
                }
            }
        }
    }

    /**
     * Resolve Flaming Damage for the given Entity Taharqa: This is now updated
     * to TacOps rules which is much more lenient So I have change the name to
     * Flaming Damage rather than flaming death
     *
     * @param entity The <code>Entity</code> that may experience flaming damage.
     */
    private void doFlamingDamage(Entity entity) {
        Report r;
        int boomroll = Compute.d6(2);
        // Infantry are unaffected by fire while they're still swarming.
        if (Entity.NONE != entity.getSwarmTargetId()) {
            return;
        }
        if ((entity.getMovementMode() == EntityMovementMode.VTOL)
            && !entity.infernos.isStillBurning()) {
            // VTOLs don't check as long as they are flying higher than
            // the burning terrain. TODO: Check for rules conformity (ATPM?)
            // according to maxtech, elevation 0 or 1 should be affected,
            // this makes sense for level 2 as well

            if (entity.getElevation() > 1) {
                return;
            }
        }
        // Battle Armor squads equipped with fire protection
        // gear automatically avoid flaming damage
        // TODO: can conv. infantry mount fire-resistant armor?
        if ((entity instanceof BattleArmor)
            && ((BattleArmor) entity).isFireResistant()) {
            r = new Report(5095);
            r.subject = entity.getId();
            r.indent(1);
            r.addDesc(entity);
            addReport(r);
            return;
        }

        // mechs shouldn't be here, but just in case
        if (entity instanceof Mech) {
            return;
        }

        // fire has no effect on dropships
        if (entity instanceof Dropship) {
            return;
        }

        // Must roll 8+ to survive...
        r = new Report(5100);
        r.subject = entity.getId();
        r.newlines = 0;
        r.addDesc(entity);
        r.add(boomroll);
        if (boomroll >= 8) {
            // phew!
            r.choose(true);
            addReport(r);
        } else {
            // eek
            r.choose(false);
            r.newlines = 1;
            addReport(r);
            // Taharqa: TacOps rules, protos and vees no longer die instantly
            // (hurray!)
            if (entity instanceof Tank) {
                int bonus = -2;
                if ((entity instanceof SupportTank)
                    || (entity instanceof SupportVTOL)) {
                    bonus = 0;
                }
                // roll a critical hit
                Report.addNewline(vPhaseReport);
                addReport(criticalTank((Tank) entity, Tank.LOC_FRONT, bonus, 0, true));
            } else if (entity instanceof Protomech) {
                // this code is taken from inferno hits
                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                if (hit.getLocation() == Protomech.LOC_NMISS) {
                    r = new Report(6035);
                    r.subject = entity.getId();
                    r.indent(1);
                    addReport(r);
                } else {
                    r = new Report(6690);
                    r.subject = entity.getId();
                    r.indent(1);
                    r.add(entity.getLocationName(hit));
                    addReport(r);
                    entity.destroyLocation(hit.getLocation());
                    // Handle Protomech pilot damage
                    // due to location destruction
                    int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit
                            .getLocation()]
                               - ((Protomech) entity).getPilotDamageTaken(hit
                                                                                  .getLocation());
                    if (hits > 0) {
                        addReport(damageCrew(entity, hits));
                        ((Protomech) entity).setPilotDamageTaken(hit
                                                                         .getLocation(),
                                                                 Protomech.POSSIBLE_PILOT_DAMAGE[hit
                                                                         .getLocation()]);
                    }
                    if (entity.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                        addReport(destroyEntity(entity, "flaming death", false,
                                                true));
                        Report.addNewline(vPhaseReport);
                    }
                }
            } else {
                // sucks to be you
                addReport(destroyEntity(entity, "fire", false, false));
                Report.addNewline(vPhaseReport);
            }
        }
    }

    private void clearFlawedCoolingFlags(Entity entity) {
        // If we're not using quirks, no need to do this check.
        if (!game.getOptions().booleanOption("stratops_quirks")) {
            return;
        }
        // Only applies to units that track heat.
        if (!((entity instanceof Mech) || ((entity instanceof Aero) && !((entity instanceof SmallCraft) || (entity
                instanceof Jumpship))))) {
            return;
        }

        // Check for existence of flawed cooling quirk.
        if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {
            return;
        }
        entity.setFallen(false);
        entity.setStruck(false);
    }

    private void checkForFlawedCooling() {

        // If we're not using quirks, no need to do this check.
        if (!game.getOptions().booleanOption("stratops_quirks")) {
            return;
        }

        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {

            final Entity entity = i.next();

            // Only applies to units that track heat.
            if (!((entity instanceof Mech)
                    || ((entity instanceof Aero)
                            && !((entity instanceof SmallCraft)
                                    || (entity instanceof Jumpship))))) {
                continue;
            }

            // Check for existence of flawed cooling quirk.
            if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {
                continue;
            }

            // Perform the check.
            if (entity.damageThisPhase >= 20) {
                addReport(doFlawedCoolingCheck("20+ damage", entity));
            }
            if (entity.hasFallen()) {
                addReport(doFlawedCoolingCheck("fall", entity));
            }
            if (entity.wasStruck()) {
                addReport(doFlawedCoolingCheck("being struck", entity));
            }
            clearFlawedCoolingFlags(entity);
        }
    }

    /**
     * Checks to see if Flawed Cooling is triggered and generates a report of
     * the result.
     *
     * @param reason
     * @param entity
     * @return
     */
    private Vector<Report> doFlawedCoolingCheck(String reason, Entity entity) {
        Vector<Report> out = new Vector<Report>();
        Report r = new Report(9800);
        r.addDesc(entity);
        r.add(reason);
        int roll = Compute.d6(2);
        r.add(roll);
        out.add(r);
        if (roll >= 10) {
            Report s = new Report(9805);
            entity.heatBuildup += 5;
            out.add(s);
        }

        return out;
    }

    /**
     * For chain whip grapples, a roll needs to be made at the end of the
     * physical phase to maintain the grapple.
     */
    private void checkForChainWhipGrappleChecks() {
        for (Entity ae : game.getEntitiesVector()) {
            if ((ae.getGrappled() != Entity.NONE) && ae.isChainWhipGrappled()
                    && ae.isGrappleAttacker() && !ae.isGrappledThisRound()) {
                Entity te = game.getEntity(ae.getGrappled());
                ToHitData grappleHit = GrappleAttackAction.toHit(game,
                        ae.getId(), te, ae.getGrappleSide(), true);
                int roll = Compute.d6(2);

                Report r = new Report(4317);
                r.subject = ae.getId();
                r.indent();
                r.addDesc(ae);
                r.addDesc(te);
                r.newlines = 0;
                addReport(r);

                if (grappleHit.getValue() == TargetRoll.IMPOSSIBLE) {
                    r = new Report(4300);
                    r.subject = ae.getId();
                    r.add(grappleHit.getDesc());
                    addReport(r);
                    return;
                }

                // report the roll
                r = new Report(4025);
                r.subject = ae.getId();
                r.add(grappleHit.getValue());
                r.add(roll);
                r.newlines = 0;
                addReport(r);

                // do we hit?
                if (roll >= grappleHit.getValue()) {
                    // hit
                    r = new Report(4040);
                    r.subject = ae.getId();
                    addReport(r);
                    // Nothing else to do
                    return;
                }

                // miss
                r = new Report(4035);
                r.subject = ae.getId();
                addReport(r);

                // Need to break grapple
                ae.setGrappled(Entity.NONE, false);
                te.setGrappled(Entity.NONE, false);
            }
        }
    }

    /**
     * Checks to see if any entity takes enough damage that requires them to
     * make a piloting roll
     */
    private void checkForPSRFromDamage() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if (entity instanceof Mech) {
                if (entity.isAirborne()) {
                    // you can't fall over when you are combat dropping because
                    // you are already falling!
                    continue;
                }
                // if this mech has 20+ damage, add another roll to the list.
                // Hulldown 'mechs ignore this rule, TO Errata
                if ((entity.damageThisPhase >= 20) && !entity.isHullDown()) {
                    if (game.getOptions().booleanOption("tacops_taking_damage")) {
                        PilotingRollData damPRD = new PilotingRollData(
                                entity.getId());
                        int damMod = entity.damageThisPhase / 20;
                        damPRD.addModifier(damMod, (damMod * 20) + "+ damage");
                        int weightMod = 0;
                        if (game.getOptions().booleanOption(
                                "tacops_physical_psr")) {
                            switch (entity.getWeightClass()) {
                                case EntityWeightClass.WEIGHT_LIGHT:
                                    weightMod = 1;
                                    break;
                                case EntityWeightClass.WEIGHT_MEDIUM:
                                    weightMod = 0;
                                    break;
                                case EntityWeightClass.WEIGHT_HEAVY:
                                    weightMod = -1;
                                    break;
                                case EntityWeightClass.WEIGHT_ASSAULT:
                                    weightMod = -2;
                                    break;
                            }
                            if ((entity instanceof Mech)
                                && ((Mech) entity).isSuperHeavy()) {
                                weightMod = -4;
                            }
                            // the weight class PSR modifier is not cumulative
                            damPRD.addModifier(weightMod,
                                               "weight class modifier", false);
                        }
                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                            && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        game.addPSR(damPRD);
                    } else {
                        PilotingRollData damPRD = new PilotingRollData(
                                entity.getId(), 1, "20+ damage");
                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                            && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        game.addPSR(damPRD);
                    }
                }
            }
            if ((entity instanceof Aero) && entity.isAirborne()
                && !game.getBoard().inSpace()) {
                // if this aero has any damage, add another roll to the list.
                if (entity.damageThisPhase > 0) {
                    if (!game.getOptions().booleanOption("atmospheric_control")) {
                        int damMod = entity.damageThisPhase / 20;
                        StringBuffer reportStr = new StringBuffer();
                        reportStr.append(entity.damageThisPhase)
                                 .append(" damage +").append(damMod);
                        PilotingRollData damPRD = new PilotingRollData(
                                entity.getId(), damMod, reportStr.toString());
                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                            && (entity.getCrew().getPiloting() > 3)) {
                            damPRD.addModifier(-1, "easy to pilot");
                        }
                        game.addControlRoll(damPRD);
                    } else {
                        // was the damage threshold exceeded this round?
                        if (((Aero) entity).wasCritThresh()) {
                            PilotingRollData damThresh = new PilotingRollData(
                                    entity.getId(), 0,
                                    "damage threshold exceeded");
                            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)
                                && (entity.getCrew().getPiloting() > 3)) {
                                damThresh.addModifier(-1, "easy to pilot");
                            }
                            game.addControlRoll(damThresh);
                        }
                    }
                }
            }
        }
    }

    /**
     * Checks to see if any non-mech units are standing in fire. Called at the
     * end of the movement phase
     */
    public void checkForFlamingDamage() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || (entity instanceof Mech)
                    || entity.isDoomed() || entity.isDestroyed()
                    || entity.isOffBoard()) {
                continue;
            }
            final IHex curHex = game.getBoard().getHex(entity.getPosition());
            final boolean underwater = curHex.containsTerrain(Terrains.WATER)
                    && (curHex.depth() > 0)
                    && (entity.getElevation() < curHex.surface());
            if (curHex.containsTerrain(Terrains.FIRE)
                    && (entity.getElevation() <= 1) && !underwater) {
                doFlamingDamage(entity);
            }
        }
    }

    /**
     * Checks to see if any tele-missiles are in a hex with enemy units. If so,
     * then attack one.
     */
    private void checkForTeleMissileAttacks() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if (entity instanceof TeleMissile) {
                // check for enemy units
                Vector<Integer> potTargets = new Vector<Integer>();
                for (Entity te : game.getEntitiesVector(entity.getPosition())) {
                    if (te.isEnemyOf(entity)) {
                        // then add it to a vector of potential targets
                        potTargets.add(te.getId());
                    }
                }
                if (potTargets.size() > 0) {
                    // determine randomly
                    Entity target = game.getEntity(potTargets.get(Compute
                            .randomInt(potTargets.size())));
                    // report this and add a new TeleMissileAttackAction
                    Report r = new Report(9085);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.addDesc(target);
                    addReport(r);
                    game.addTeleMissileAttack(new TeleMissileAttackAction(
                            entity, target));
                }
            }
        }
    }

    private void checkForBlueShieldDamage() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if (!(entity instanceof Aero) && entity.hasActiveBlueShield()
                && (entity.getBlueShieldRounds() >= 6)) {
                int roll = Compute.d6(2);
                int target = (3 + entity.getBlueShieldRounds()) - 6;
                r = new Report(1240);
                r.addDesc(entity);
                r.add(target);
                r.add(roll);
                if (roll < target) {
                    for (Mounted m : entity.getMisc()) {
                        if (m.getType().hasFlag(MiscType.F_BLUE_SHIELD)) {
                            m.setBreached(true);
                        }
                    }
                    r.choose(true);
                } else {
                    r.choose(false);
                }
                vPhaseReport.add(r);
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in certain planetary conditions.
     */
    private void checkForConditionDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            String reason = game.getPlanetaryConditions().whyDoomed(entity);
            if (null != reason) {
                r = new Report(6015);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(reason);
                addReport(r);
                addReport(destroyEntity(entity, reason, true, true));
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in atmosphere.
     */
    private void checkForAtmosphereDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if (entity.doomedInAtmosphere() && (entity.getAltitude() == 0)) {
                r = new Report(6016);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity,
                        "being in atmosphere where it can't survive", true,
                        true));
            }
        }
    }

    /**
     * checks if IndustrialMechs should die because they moved into to-deep
     * water last round
     */
    private void checkForIndustrialWaterDeath() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if ((entity instanceof Mech) && ((Mech) entity).isIndustrial()
                    && ((Mech) entity).shouldDieAtEndOfTurnBecauseOfWater()) {
                addReport(destroyEntity(entity,
                        "being in water without environmental shielding", true,
                        true));
            }

        }
    }

    private void checkForIndustrialEndOfTurn() {
        checkForIndustrialWaterDeath();
        checkForIndustrialUnstall();
        checkForIndustrialCrit(); // This might hit an actuator or gyro, so...
        addReport(resolvePilotingRolls());
    }

    private void checkForIndustrialUnstall() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity entity = i.next();
            entity.checkUnstall(vPhaseReport);
        }
    }

    /**
     * industrial mechs might need to check for critical damage
     */
    private void checkForIndustrialCrit() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((entity instanceof Mech) && ((Mech) entity).isIndustrial()) {
                Mech mech = (Mech) entity;
                // should we check for critical damage?
                if (mech.isCheckForCrit()) {
                    Report r = new Report(5530);
                    r.addDesc(mech);
                    r.subject = mech.getId();
                    r.newlines = 0;
                    vPhaseReport.add(r);
                    // for being hit by a physical weapon
                    if (mech.getLevelsFallen() == 0) {
                        r = new Report(5531);
                        r.subject = mech.getId();
                        // or for falling
                    } else {
                        r = new Report(5532);
                        r.subject = mech.getId();
                        r.add(mech.getLevelsFallen());
                    }
                    vPhaseReport.add(r);
                    HitData newHit = mech.rollHitLocation(ToHitData.HIT_NORMAL,
                            ToHitData.SIDE_FRONT);
                    vPhaseReport.addAll(criticalEntity(mech,
                            newHit.getLocation(), newHit.isRear(),
                            mech.getLevelsFallen(), 0));
                }
            }
        }
    }

    /**
     * Check to see if anyone dies due to being in space.
     */
    private void checkForSpaceDeath() {
        Report r;
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                // If it's not on the board - aboard something else, for
                // example...
                continue;
            }
            if (entity.doomedInSpace()) {
                r = new Report(6017);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(destroyEntity(entity,
                        "being in space where it can't survive", true, true));
            }
        }
    }

    /**
     * Checks to see if any entities are underwater (or in vacuum) with damaged
     * life support. Called during the end phase.
     */
    private void checkForSuffocation() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext();) {
            final Entity entity = i.next();
            if ((null == entity.getPosition()) || entity.isOffBoard()) {
                continue;
            }
            final IHex curHex = game.getBoard().getHex(entity.getPosition());
            if ((((entity.getElevation() < 0) && ((curHex
                    .terrainLevel(Terrains.WATER) > 1) || ((curHex
                    .terrainLevel(Terrains.WATER) == 1) && entity.isProne()))) || game
                    .getPlanetaryConditions().isVacuum())
                    && (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                            Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) > 0)) {
                Report r = new Report(6020);
                r.subject = entity.getId();
                r.addDesc(entity);
                addReport(r);
                addReport(damageCrew(entity, 1));

            }
        }
    }

    /**
     * Iterates over all entities and gets rid of Narc pods attached to destroyed
     * or lost locations.
     */
    private void cleanupDestroyedNarcPods() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            i.next().clearDestroyedNarcPods();
        }
    }

    /**
     * Resolves all built up piloting skill rolls. Used at end of weapons,
     * physical phases.
     */
    private Vector<Report> resolvePilotingRolls() {
        Vector<Report> vPhaseReport = new Vector<Report>();
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vPhaseReport.addAll(resolvePilotingRolls(i.next()));
        }
        game.resetPSRs();
        return vPhaseReport;
    }

    /**
     * Resolves and reports all piloting skill rolls for a single mech.
     */
    private Vector<Report> resolvePilotingRolls(Entity entity) {
        return resolvePilotingRolls(entity, false, entity.getPosition(),
                                    entity.getPosition());
    }

    private Vector<Report> resolvePilotingRolls(Entity entity, boolean moving,
                                                Coords src, Coords dest) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        // dead and undeployed and offboard units don't need to.
        if (entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard()
            || !entity.isDeployed()
            || (entity.getTransportId() != Entity.NONE)) {
            return vPhaseReport;
        }

        // airborne units don't make piloting rolls, they make control rolls
        if (entity.isAirborne()) {
            return vPhaseReport;
        }

        Report r;

        // first, do extreme gravity PSR, because non-mechs do these, too
        PilotingRollData rollTarget = null;
        for (Enumeration<PilotingRollData> i = game.getExtremeGravityPSRs(); i
                .hasMoreElements(); ) {
            final PilotingRollData roll = i.nextElement();
            if (roll.getEntityId() != entity.getId()) {
                continue;
            }
            // found a roll, use it (there can be only 1 per entity)
            rollTarget = roll;
            game.resetExtremeGravityPSRs(entity);
        }
        if ((rollTarget != null)
            && (rollTarget.getValue() != TargetRoll.CHECK_FALSE)) {
            // okay, print the info
            r = new Report(2180);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rollTarget.getLastPlainDesc());
            vPhaseReport.add(r);
            // roll
            final int diceRoll = Compute.d6(2);
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            if ((diceRoll < rollTarget.getValue())
                || (game.getOptions().booleanOption("tacops_fumbles") && (diceRoll == 2))) {
                r.choose(false);
                // Report the fumble
                if (game.getOptions().booleanOption("tacops_fumbles")
                    && (diceRoll == 2)) {
                    r.messageId = 2306;
                }
                vPhaseReport.add(r);
                // walking and running, 1 damage per MP used more than we would
                // have normally
                if ((entity.moved == EntityMovementType.MOVE_WALK)
                    || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                    || (entity.moved == EntityMovementType.MOVE_RUN)
                    || (entity.moved == EntityMovementType.MOVE_SPRINT)
                    || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)) {
                    if (entity instanceof Mech) {
                        int j = entity.mpUsed;
                        int damage = 0;
                        while (j > entity.getRunningGravityLimit()) {
                            j--;
                            damage++;
                        }
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                                                   damage));
                    } else if (entity instanceof Tank) {
                        // if we got a pavement bonus, take care of it
                        int k = entity.gotPavementBonus ? 1 : 0;
                        if (!entity.gotPavementBonus) {
                            int j = entity.mpUsed;
                            int damage = 0;
                            while (j > (entity.getRunMP(false, false, false) + k)) {
                                j--;
                                damage++;
                            }
                            vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                                                       damage));
                        }
                    }
                }
                // jumping
                if ((entity.moved == EntityMovementType.MOVE_JUMP)
                    && (entity instanceof Mech)) {
                    // low g, 1 damage for each hex jumped further than
                    // possible normally
                    if (game.getPlanetaryConditions().getGravity() < 1) {
                        int j = entity.mpUsed;
                        int damage = 0;
                        while (j > entity.getJumpMP(false)) {
                            j--;
                            damage++;
                        }
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                                                   damage));
                    }
                    // high g, 1 damage for each MP we have less than normally
                    else if (game.getPlanetaryConditions().getGravity() > 1) {
                        int damage = entity.getWalkMP(false, false)
                                     - entity.getWalkMP();
                        // Wee, direct internal damage
                        vPhaseReport.addAll(doExtremeGravityDamage(entity,
                                                                   damage));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
            } else {
                r.choose(true);
                vPhaseReport.add(r);
            }
        }
        // non mechs and prone mechs can now return
        if (!(entity instanceof Mech) || entity.isProne()
            || (entity.isHullDown() && entity.canGoHullDown())) {
            return vPhaseReport;
        }

        // Mechs with UMU float and don't have to roll???
        if (entity instanceof Mech) {
            IHex hex = game.getBoard().getHex(dest);
            int water = hex.terrainLevel(Terrains.WATER);
            if ((water > 0)
                && (entity.getElevation() != -hex.depth(true))
                && ((entity.getElevation() < 0) || ((entity.getElevation() == 0)
                                                    && (hex.terrainLevel(Terrains.BRIDGE_ELEV) != 0) && !hex
                    .containsTerrain(Terrains.ICE)))
                && !entity.isMakingDfa() && !entity.isDropping()) {
                // mech is floating in water....
                if (entity.hasUMU()) {
                    return vPhaseReport;
                }
                // game.addPSR(new PilotingRollData(entity.getId(),
                // TargetRoll.AUTOMATIC_FAIL, "lost buoyancy"));
            }
        }
        // add all cumulative mods from other rolls to each PSR
        // holds all rolls to make
        Vector<PilotingRollData> rolls = new Vector<PilotingRollData>();
        // holds the initial reason for each roll
        StringBuffer reasons = new StringBuffer();
        PilotingRollData base = entity.getBasePilotingRoll();
        entity.addPilotingModifierForTerrain(base);
        for (Enumeration<PilotingRollData> i = game.getPSRs(); i
                .hasMoreElements(); ) {
            PilotingRollData psr = i.nextElement();
            if (psr.getEntityId() != entity.getId()) {
                continue;
            }
            // found a roll
            if (reasons.length() > 0) {
                reasons.append("; ");
            }
            reasons.append(psr.getPlainDesc());
            PilotingRollData toUse = entity.getBasePilotingRoll();
            entity.addPilotingModifierForTerrain(toUse);
            toUse.append(psr);
            // now, append all other roll's cumulative mods, not the
            // non-cumulative
            // ones
            for (Enumeration<PilotingRollData> j = game.getPSRs(); j
                    .hasMoreElements(); ) {
                final PilotingRollData other = j.nextElement();
                if ((other.getEntityId() != entity.getId())
                    || other.equals(psr)) {
                    continue;
                }
                toUse.append(other, false);
            }
            rolls.add(toUse);
        }
        // any rolls needed?
        if (rolls.size() == 0) {
            return vPhaseReport;
        }
        // is our base roll impossible?
        if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL)
            || (base.getValue() == TargetRoll.IMPOSSIBLE)) {
            r = new Report(2275);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rolls.size());
            r.add(base.getDesc()); // international issue
            vPhaseReport.add(r);
            if (moving) {
                vPhaseReport.addAll(doEntityFallsInto(entity,
                                                      entity.getElevation(), src, dest, base, true));
            } else if ((entity instanceof Mech)
                       && game.getOptions().booleanOption(
                    "tacops_falling_expanded")
                       && (entity.getCrew().getPiloting() < 6)
                       && !entity.isHullDown() && entity.canGoHullDown()) {
                if (entity.isHullDown() && entity.canGoHullDown()) {
                    r = new Report(2317);
                    r.subject = entity.getId();
                    r.add(entity.getDisplayName());
                    vPhaseReport.add(r);
                } else {
                    vPhaseReport.addAll(doEntityFall(entity, base));
                }
            } else {
                vPhaseReport.addAll(doEntityFall(entity, base));
            }
            // failed a PSR, check for ICE engine stalling
            entity.doCheckEngineStallRoll(vPhaseReport);
            return vPhaseReport;
        }
        // loop thru rolls we do have to make...
        r = new Report(2280);
        r.subject = entity.getId();
        r.addDesc(entity);
        r.add(rolls.size());
        r.add(reasons.toString()); // international issue
        vPhaseReport.add(r);
        r = new Report(2285);
        r.subject = entity.getId();
        r.add(base.getValueAsString());
        r.add(base.getDesc()); // international issue
        vPhaseReport.add(r);
        for (int i = 0; i < rolls.size(); i++) {
            PilotingRollData roll = rolls.elementAt(i);
            r = new Report(2290);
            r.subject = entity.getId();
            r.indent();
            r.newlines = 0;
            r.add(i + 1);
            r.add(roll.getDesc()); // international issue
            vPhaseReport.add(r);
            if ((roll.getValue() == TargetRoll.AUTOMATIC_FAIL)
                || (roll.getValue() == TargetRoll.IMPOSSIBLE)) {
                r = new Report(2295);
                r.subject = entity.getId();
                vPhaseReport.add(r);
                if (moving) {
                    vPhaseReport.addAll(doEntityFallsInto(entity,
                                                          entity.getElevation(), src, dest, roll, true));
                } else {
                    if ((entity instanceof Mech)
                        && game.getOptions().booleanOption(
                            "tacops_falling_expanded")
                        && (entity.getCrew().getPiloting() < 6)
                        && !entity.isHullDown() && entity.canGoHullDown()) {
                        if (entity.isHullDown() && entity.canGoHullDown()) {
                            r = new Report(2317);
                            r.subject = entity.getId();
                            r.add(entity.getDisplayName());
                            vPhaseReport.add(r);
                        } else {
                            vPhaseReport.addAll(doEntityFall(entity, roll));
                        }
                    } else {
                        vPhaseReport.addAll(doEntityFall(entity, roll));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
                return vPhaseReport;
            }
            int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2300);
            r.add(roll.getValueAsString());
            r.add(diceRoll);
            r.subject = entity.getId();
            if ((diceRoll < roll.getValue())
                || (game.getOptions().booleanOption("tacops_fumbles") && (diceRoll == 2))) {
                r.choose(false);
                // Report the fumble
                if (game.getOptions().booleanOption("tacops_fumbles")
                    && (diceRoll == 2)) {
                    r.messageId = 2306;
                }
                vPhaseReport.add(r);
                if (moving) {
                    vPhaseReport.addAll(doEntityFallsInto(entity,
                                                          entity.getElevation(), src, dest, roll, true));
                } else {
                    if ((entity instanceof Mech)
                        && game.getOptions().booleanOption(
                            "tacops_falling_expanded")
                        && (entity.getCrew().getPiloting() < 6)
                        && !entity.isHullDown() && entity.canGoHullDown()) {
                        if ((entity.getCrew().getPiloting() > 1)
                            && ((roll.getValue() - diceRoll) < 2)) {
                            entity.setHullDown(true);
                        } else if ((entity.getCrew().getPiloting() <= 1)
                                   && ((roll.getValue() - diceRoll) < 3)) {
                            entity.setHullDown(true);
                        }
                        if (entity.isHullDown() && entity.canGoHullDown()) {
                            r = new Report(2317);
                            r.subject = entity.getId();
                            r.add(entity.getDisplayName());
                            vPhaseReport.add(r);
                        } else {
                            vPhaseReport.addAll(doEntityFall(entity, roll));
                        }
                    } else {
                        vPhaseReport.addAll(doEntityFall(entity, roll));
                    }
                }
                // failed a PSR, check for ICE engine stalling
                entity.doCheckEngineStallRoll(vPhaseReport);
                return vPhaseReport;
            }
            r.choose(true);
            vPhaseReport.add(r);
        }
        return vPhaseReport;
    }

    private Vector<Report> checkForTraitors() {
        Vector<Report> vFullReport = new Vector<Report>();
        // check for traitors
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            Entity entity = i.next();
            if (entity.isDoomed() || entity.isDestroyed()
                || entity.isOffBoard() || !entity.isDeployed()) {
                continue;
            }
            if ((entity.getTraitorId() != -1)
                && (entity.getOwnerId() != entity.getTraitorId())) {
                IPlayer p = game.getPlayer(entity.getTraitorId());
                if (null != p) {
                    Report r = new Report(7305);
                    r.subject = entity.getId();
                    r.add(entity.getDisplayName());
                    r.add(p.getName());
                    entity.setOwner(p);
                    entityUpdate(entity.getId());
                    vFullReport.add(r);
                }
                entity.setTraitorId(-1);
            }
        }
        if (!vFullReport.isEmpty()) {
            vFullReport.add(0, new Report(7300));
        }
        return vFullReport;
    }

    /**
     * Resolves all built up control rolls. Used only during end phase
     */
    private Vector<Report> resolveControlRolls() {
        Vector<Report> vFullReport = new Vector<Report>();
        vFullReport.add(new Report(5001, Report.PUBLIC));
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            vFullReport.addAll(resolveControl(i.next()));
        }
        game.resetControlRolls();
        return vFullReport;
    }

    /**
     * Resolves and reports all control skill rolls for a single aero.
     */
    private Vector<Report> resolveControl(Entity e) {
        Vector<Report> vReport = new Vector<Report>();
        if (e.isDoomed() || e.isDestroyed() || e.isOffBoard()
            || !e.isDeployed()) {
            return vReport;
        }
        Report r;

        /*
         * See forum answers on OOC
         * http://forums.classicbattletech.com/index.php/topic,20424.0.html
         */

        if ((e instanceof Aero) && (e.isAirborne() || e.isSpaceborne())) {
            Aero a = (Aero) e;

            // they should get a shot at a recovery roll at the end of all this
            // if they are already out of control
            boolean canRecover = a.isOutControl();

            // if the unit already is moving randomly then it can't get any
            // worse
            if (!a.isRandomMove()) {

                // find control rolls and make them
                Vector<PilotingRollData> rolls = new Vector<PilotingRollData>();
                StringBuffer reasons = new StringBuffer();
                PilotingRollData base = e.getBasePilotingRoll();
                // maneuvering ace
                // TODO: pending rules query
                // http://www.classicbattletech.com/forums/index.php/topic,63552.new.html#new
                // for now I am assuming Man Ace applies to all out-of-control
                // rolls, but not other
                // uses of control rolls (thus it doesn't go in
                // Entity#addEntityBonuses) and
                // furthermore it doesn't apply to recovery rolls
                if (a.isUsingManAce()) {
                    base.addModifier(-1, "maneuvering ace");
                }
                for (Enumeration<PilotingRollData> j = game.getControlRolls(); j
                        .hasMoreElements(); ) {
                    final PilotingRollData modifier = j.nextElement();
                    if (modifier.getEntityId() != e.getId()) {
                        continue;
                    }
                    // found a roll, add it
                    rolls.addElement(modifier);
                    if (reasons.length() > 0) {
                        reasons.append("; ");
                    }
                    reasons.append(modifier.getCumulativePlainDesc());
                    base.append(modifier);
                }
                // any rolls needed?
                if (rolls.size() > 0) {
                    // loop thru rolls we do have to make...
                    r = new Report(9310);
                    r.subject = e.getId();
                    r.addDesc(e);
                    r.add(rolls.size());
                    r.add(reasons.toString()); // international issue
                    vReport.add(r);
                    r = new Report(2285);
                    r.subject = e.getId();
                    r.add(base.getValueAsString());
                    r.add(base.getDesc()); // international issue
                    vReport.add(r);
                    for (int j = 0; j < rolls.size(); j++) {
                        PilotingRollData modifier = rolls.elementAt(j);
                        PilotingRollData target = base;
                        r = new Report(2290);
                        r.subject = e.getId();
                        r.indent();
                        r.newlines = 0;
                        r.add(j + 1);
                        r.add(modifier.getPlainDesc()); // international issue
                        vReport.add(r);
                        int diceRoll = Compute.d6(2);
                        // different reports depending on out-of-control status
                        if (a.isOutControl()) {
                            r = new Report(9360);
                            r.subject = e.getId();
                            r.add(target.getValueAsString());
                            r.add(diceRoll);
                            if (diceRoll < (target.getValue() - 5)) {
                                r.choose(false);
                                vReport.add(r);
                                a.setRandomMove(true);
                            } else {
                                r.choose(true);
                                vReport.add(r);
                            }
                        } else {
                            r = new Report(9315);
                            r.subject = e.getId();
                            r.add(target.getValueAsString());
                            r.add(diceRoll);
                            r.newlines = 1;
                            if (diceRoll < target.getValue()) {
                                r.choose(false);
                                vReport.add(r);
                                a.setOutControl(true);
                                // do we have random movement?
                                if ((target.getValue() - diceRoll) > 5) {
                                    r = new Report(9365);
                                    r.newlines = 0;
                                    r.subject = e.getId();
                                    vReport.add(r);
                                    a.setRandomMove(true);
                                }
                                // if on the atmospheric map, then lose altitude
                                // and check
                                // for crash
                                if (!game.getBoard().inSpace()
                                    && a.isAirborne()) {
                                    int loss = Compute.d6(1);
                                    r = new Report(9366);
                                    r.newlines = 0;
                                    r.subject = e.getId();
                                    r.addDesc(e);
                                    r.add(loss);
                                    vReport.add(r);
                                    a.setAltitude(a.getAltitude() - loss);
                                    // check for crash
                                    if (checkCrash(a, a.getPosition(),
                                                   a.getAltitude())) {
                                        vReport.addAll(processCrash(e,
                                                                    a.getCurrentVelocity(),
                                                                    a.getPosition()));
                                        break;
                                    }
                                }
                            } else {
                                r.choose(true);
                                vReport.add(r);
                            }
                        }
                    }
                }
            }

            // if they were out-of-control to start with, give them a chance to
            // regain control
            if (canRecover) {
                PilotingRollData base = e.getBasePilotingRoll();
                // is our base roll impossible?
                if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL)
                    || (base.getValue() == TargetRoll.IMPOSSIBLE)) {
                    // report something
                    r = new Report(9340);
                    r.subject = e.getId();
                    r.addDesc(e);
                    r.add(base.getDesc()); // international issue
                    vReport.add(r);
                    return vReport;
                }
                r = new Report(9345);
                r.subject = e.getId();
                r.addDesc(e);
                r.add(base.getDesc()); // international issue
                vReport.add(r);
                int diceRoll = Compute.d6(2);
                r = new Report(9350);
                r.subject = e.getId();
                r.add(base.getValueAsString());
                r.add(diceRoll);
                if (diceRoll < base.getValue()) {
                    r.choose(false);
                    vReport.add(r);
                } else {
                    r.choose(true);
                    vReport.add(r);
                    a.setOutControl(false);
                    a.setOutCtrlHeat(false);
                    a.setRandomMove(false);
                }
            }

        }
        return vReport;
    }

    /**
     * Inflict damage on a pilot
     *
     * @param en     The <code>Entity</code> who's pilot gets damaged.
     * @param damage The <code>int</code> amount of damage.
     */
    public Vector<Report> damageCrew(Entity en, int damage) {
        Vector<Report> vDesc = new Vector<Report>();
        Crew crew = en.getCrew();
        Report r;
        if (!crew.isDead() && !crew.isEjected() && !crew.isDoomed()) {
            crew.setHits(crew.getHits() + damage);
            r = new Report(6025);
            r.subject = en.getId();
            r.indent(2);
            r.addDesc(en);
            r.add(crew.getName());
            r.add(damage);
            r.newlines = 0;
            vDesc.addElement(r);
            if (Crew.DEATH > crew.getHits()) {
                vDesc.addAll(resolveCrewDamage(en, damage));
            } else if (!crew.isDoomed()) {
                crew.setDoomed(true);
                vDesc.addAll(destroyEntity(en, "pilot death", true));
            }
        } else {
            boolean isPilot = (en instanceof Mech)
                              || (en instanceof ConvFighter)
                              || ((en instanceof Aero)
                                  && !(en instanceof Dropship)
                                  && !(en instanceof SmallCraft)
                                  && !(en instanceof Jumpship) && !(en instanceof Warship));
            if (crew.isDead() || crew.isDoomed()) {
                if (isPilot) {
                    r = new Report(6021);
                } else {
                    r = new Report(6022);
                }
            } else {
                if (isPilot) {
                    r = new Report(6023);
                } else {
                    r = new Report(6024);
                }
            }
            r.addDesc(en);
            r.add(crew.getName());
            r.indent(2);
            vDesc.add(r);
        }
        return vDesc;
    }

    /**
     * resolves consciousness rolls for one entity
     */
    private Vector<Report> resolveCrewDamage(Entity e, int damage) {
        Vector<Report> vDesc = new Vector<Report>();
        final int totalHits = e.getCrew().getHits();
        if ((e instanceof MechWarrior) || !e.isTargetable()
            || !e.getCrew().isActive() || (damage == 0)) {
            return vDesc;
        }

        // no consciousness roll for pain-shunted warriors
        if (e.getCrew().getOptions().booleanOption("pain_shunt")) {
            return vDesc;
        }

        // no consciousness roll for capital fighter pilots
        if (e.isCapitalFighter()) {
            return vDesc;
        }

        for (int hit = (totalHits - damage) + 1; hit <= totalHits; hit++) {
            int rollTarget = Compute.getConsciousnessNumber(hit);
            if (game.getOptions().booleanOption("toughness")) {
                rollTarget -= e.getCrew().getToughness();
            }
            boolean edgeUsed = false;
            do {
                if (edgeUsed) {
                    e.getCrew().decreaseEdge();
                }
                int roll = Compute.d6(2);
                if (e.getCrew().getOptions().booleanOption("pain_resistance")) {
                    roll = Math.min(12, roll + 1);
                }
                Report r = new Report(6030);
                r.indent(2);
                r.subject = e.getId();
                r.addDesc(e);
                r.add(e.getCrew().getName());
                r.add(rollTarget);
                r.add(roll);
                if (roll >= rollTarget) {
                    e.getCrew().setKoThisRound(false);
                    r.choose(true);
                } else {
                    e.getCrew().setKoThisRound(true);
                    r.choose(false);
                    if (e.getCrew().hasEdgeRemaining()
                        && e.getCrew().getOptions()
                            .booleanOption("edge_when_ko")) {
                        edgeUsed = true;
                        vDesc.add(r);
                        r = new Report(6520);
                        r.subject = e.getId();
                        r.addDesc(e);
                        r.add(e.getCrew().getName());
                        r.add(e.getCrew().getOptions().intOption("edge"));
                    } // if
                    // return true;
                } // else
                vDesc.add(r);
            } while (e.getCrew().hasEdgeRemaining()
                     && e.getCrew().isKoThisRound()
                     && e.getCrew().getOptions().booleanOption("edge_when_ko"));
            // end of do-while
            if (e.getCrew().isKoThisRound()) {
                e.getCrew().setUnconscious(true);
                return vDesc;
            }
        }
        return vDesc;
    }

    /**
     * Make the rolls indicating whether any unconscious crews wake up
     */
    private void resolveCrewWakeUp() {
        for (Iterator<Entity> i = game.getEntities(); i.hasNext(); ) {
            final Entity e = i.next();

            // only unconscious pilots of mechs and protos, ASF and smallscraft
            // and MechWarriors can roll to wake up
            if (!e.isTargetable()
                || !e.getCrew().isUnconscious()
                || e.getCrew().isKoThisRound()
                || !((e instanceof Mech) || (e instanceof Protomech)
                     || (e instanceof MechWarrior) || ((e instanceof Aero) && !(e instanceof Jumpship)))) {
                continue;
            }
            int roll = Compute.d6(2);

            if (e.getCrew().getOptions().booleanOption("pain_resistance")) {
                roll = Math.min(12, roll + 1);
            }

            int rollTarget = Compute.getConsciousnessNumber(e.getCrew()
                                                             .getHits());
            Report r = new Report(6029);
            r.subject = e.getId();
            r.addDesc(e);
            r.add(e.getCrew().getName());
            r.add(rollTarget);
            r.add(roll);
            if (roll >= rollTarget) {
                r.choose(true);
                e.getCrew().setUnconscious(false);
            } else {
                r.choose(false);
            }
            addReport(r);
        }
    }

    /*
     * Resolve any outstanding self destructions...
     */
    private void resolveSelfDestruct() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.getSelfDestructing()) {
                e.setSelfDestructing(false);
                e.setSelfDestructInitiated(true);
                Report r = new Report(5535, Report.PUBLIC);
                r.subject = e.getId();
                r.addDesc(e);
                addReport(r);
            }
        }
    }

    /*
     * Resolve any outstanding crashes from shutting down and being airborne
     * VTOL or WiGE...
     */
    private void resolveShutdownCrashes() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.isShutDown() && e.isAirborneVTOLorWIGE()
                && !(e.isDestroyed() || e.isDoomed())) {
                Tank t = (Tank) e;
                t.immobilize();
                addReport(forceLandVTOLorWiGE(t));
            }
        }
    }

    /**
     * Resolve any potential fatal damage to Capital Fighter after each
     * individual attacker is finished
     */
    private Vector<Report> checkFatalThresholds(int nextAE, int prevAE) {
        Vector<Report> vDesc = new Vector<Report>();
        for (Iterator<Entity> e = game.getEntities(); e.hasNext();) {
            Entity en = e.next();
            if (!en.isCapitalFighter() || (nextAE == Entity.NONE)) {
                continue;
            }
            Aero ship = (Aero) en;
            int damage = ship.getCurrentDamage();
            double divisor = 2.0;
            if (game.getOptions().booleanOption("aero_sanity")) {
                divisor = 20.0;
            }
            if (damage >= ship.getFatalThresh()) {
                int roll = Compute.d6(2)
                        + (int) Math.floor((damage - ship.getFatalThresh())
                                / divisor);
                if (roll > 9) {
                    vDesc.addAll(destroyEntity(ship, "fatal damage threshold"));
                    if (prevAE != Entity.NONE) {
                        creditKill(ship, game.getEntity(prevAE));
                    }
                }
            }
            ship.setCurrentDamage(0);
        }
        return vDesc;
    }

    /**
     * damage an Entity
     *
     * @param te            the <code>Entity</code> to be damaged
     * @param hit           the corresponding <code>HitData</code>
     * @param damage        the <code>int</code> amount of damage
     * @param ammoExplosion a <code>boolean</code> indicating if this is an ammoexplosion
     * @return a <code>Vector<Report></code> containg the phasereports
     */
    private Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                        boolean ammoExplosion) {
        return damageEntity(te, hit, damage, ammoExplosion, DamageType.NONE,
                            false, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te     the target entity
     * @param hit    the hit data for the location hit
     * @param damage the damage to apply
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage) {
        return damageEntity(te, hit, damage, false, DamageType.NONE, false,
                            false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                            false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    private Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                        boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                        boolean areaSatArty) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                            areaSatArty, true);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                       boolean areaSatArty, boolean throughFront) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                            areaSatArty, throughFront, false, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @param underWater    Is the damage coming from an underwater attack
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
                                       boolean areaSatArty, boolean throughFront, boolean underWater) {
        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,
                            areaSatArty, throughFront, underWater, false);
    }

    /**
     * Deals the listed damage to an entity. Returns a vector of Reports for the
     * phase report
     *
     * @param te            the target entity
     * @param hit           the hit data for the location hit
     * @param damage        the damage to apply
     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
     *                      smithereens
     * @param bFrag         The DamageType of the attack.
     * @param damageIS      Should the target location's internal structure be damaged
     *                      directly?
     * @param areaSatArty   Is the damage from an area saturating artillery attack?
     * @param throughFront  Is the damage coming through the hex the unit is facing?
     * @param underWater    Is the damage coming from an underwater attack?
     * @param nukeS2S       is this a ship-to-ship nuke?
     * @return a <code>Vector</code> of <code>Report</code>s
     */
    public Vector<Report> damageEntity(Entity te, HitData hit, int damage,
            boolean ammoExplosion, DamageType bFrag, boolean damageIS,
            boolean areaSatArty, boolean throughFront, boolean underWater,
            boolean nukeS2S) {

        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        int te_n = te.getId();

        // if this is a fighter squadron then pick an active fighter and pass on
        // the damage
        if (te instanceof FighterSquadron) {
            FighterSquadron fs = (FighterSquadron) te;
            if (fs.getFighters().size() < 1) {
                return vDesc;
            }
            Aero fighter = fs.getFighter(hit.getLocation());
            HitData new_hit = fighter.rollHitLocation(ToHitData.HIT_NORMAL,
                                                      ToHitData.SIDE_FRONT);
            new_hit.setBoxCars(hit.rolledBoxCars());
            new_hit.setGeneralDamageType(hit.getGeneralDamageType());
            new_hit.setCapital(hit.isCapital());
            new_hit.setCapMisCritMod(hit.getCapMisCritMod());
            new_hit.setSingleAV(hit.getSingleAV());
            new_hit.setAttackerId(hit.getAttackerId());
            return damageEntity(fighter, new_hit, damage, ammoExplosion, bFrag,
                                damageIS, areaSatArty, throughFront, underWater, nukeS2S);
        }

        // This is good for shields if a shield absorps the hit it shouldn't
        // effect the pilot.
        // TC SRM's that hit the head do external and internal damage but its
        // one hit and shouldn't cause
        // 2 hits to the pilot.
        boolean isHeadHit = (te instanceof Mech)
                            && (((Mech) te).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED)
                            && (hit.getLocation() == Mech.LOC_HEAD)
                            && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS);

        // booleans to indicate criticals for AT2
        boolean critSI = false;
        boolean critThresh = false;

        // get the relevant damage for damage thresholding
        int threshDamage = damage;
        // weapon groups only get the damage of one weapon
        if ((hit.getSingleAV() > -1)
            && !game.getOptions().booleanOption("aero_sanity")) {
            threshDamage = hit.getSingleAV();
        }

        // is this capital-scale damage
        boolean isCapital = hit.isCapital();

        // check capital/standard damage
        if (isCapital
            && (!te.isCapitalScale() || game.getOptions().booleanOption(
                "aero_sanity"))) {
            damage = 10 * damage;
            threshDamage = 10 * threshDamage;
        }
        if (!isCapital && te.isCapitalScale()
            && !game.getOptions().booleanOption("aero_sanity")) {
            damage = (int) Math.round(damage / 10.0);
            threshDamage = (int) Math.round(threshDamage / 10.0);
        }

        int damage_orig = damage;

        // show Locations which have rerolled with Edge
        HitData undoneLocation = hit.getUndoneLocation();
        while (undoneLocation != null) {
            r = new Report(6500);
            r.subject = te_n;
            r.indent(2);
            r.addDesc(te);
            r.add(te.getLocationAbbr(undoneLocation));
            vDesc.addElement(r);
            undoneLocation = undoneLocation.getUndoneLocation();
        } // while
        // if edge was uses, give at end overview of remainings
        if (hit.getUndoneLocation() != null) {
            r = new Report(6510);
            r.subject = te_n;
            r.indent(2);
            r.addDesc(te);
            r.add(te.getCrew().getOptions().intOption("edge"));
            vDesc.addElement(r);
        } // if

        boolean autoEject = false;
        if (ammoExplosion) {
            if (te instanceof Mech) {
                Mech mech = (Mech) te;
                if (mech.isAutoEject()
                    && (!game.getOptions().booleanOption(
                        "conditional_ejection") || (game.getOptions()
                                                        .booleanOption("conditional_ejection") && mech
                                                            .isCondEjectAmmo()))) {
                    autoEject = true;
                    vDesc.addAll(ejectEntity(te, true));
                }
            }
        }
        boolean isBattleArmor = te instanceof BattleArmor;
        boolean isPlatoon = !isBattleArmor && (te instanceof Infantry);
        boolean isFerroFibrousTarget = false;
        boolean wasDamageIS = false;
        boolean tookInternalDamage = damageIS;
        IHex te_hex = null;

        boolean hardenedArmor = false;
        boolean ferroLamellorArmor = false;
        boolean reflectiveArmor = false;
        boolean reactiveArmor = false;
        boolean ballisticArmor = false;
        boolean impactArmor = false;
        boolean bar5 = te.getBARRating(hit.getLocation()) <= 5;

        if (((te instanceof Mech) || (te instanceof Tank))
            && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED)) {
            hardenedArmor = true;
        }

        if (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
            && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_LAMELLOR)) {
            ferroLamellorArmor = true;
        }

        if ((((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                    && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REFLECTIVE))
            || (isBattleArmor && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REFLECTIVE))) {
            reflectiveArmor = true; // note that BA reflec receives
            // "all of the bonuses but none of the drawbacks"
        }

        if ((((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
                    && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REACTIVE))
            || (isBattleArmor && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REACTIVE))) {
            reactiveArmor = true; // note that BA reactive receives
            // "all of the bonuses but none of the drawbacks"
        }

        if (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))
            && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BALLISTIC_REINFORCED)) {
            ballisticArmor = true;
        }

        if ((te instanceof Mech)
            && (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_IMPACT_RESISTANT)) {
            impactArmor = true;
        }

        // TACs from the hit location table
        int crits;
        if ((hit.getEffect() & HitData.EFFECT_CRITICAL) == HitData.EFFECT_CRITICAL) {
            crits = 1;
        } else {
            crits = 0;
        }

        // this is for special crits, like AP and tandem-charge
        int specCrits = 0;

        // the bonus to the crit roll if using the
        // "advanced determining critical hits rule"
        int critBonus = 0;
        if (game.getOptions().booleanOption("tacops_crit_roll")
            && (damage_orig > 0)
            && ((te instanceof Mech) || (te instanceof Protomech))) {
            critBonus = Math.min((damage_orig - 1) / 5, 4);
        }

        HitData nextHit = null;

        // Some "hits" on a Protomech are actually misses.
        if ((te instanceof Protomech)
            && (hit.getLocation() == Protomech.LOC_NMISS)) {
            r = new Report(6035);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
            return vDesc;
        }

        // check for critical hit/miss vs. a BA
        if ((crits > 0) && (te instanceof BattleArmor)) {
            // possible critical miss if the rerolled location isn't alive
            if ((hit.getLocation() >= te.locations())
                || (te.getInternal(hit.getLocation()) <= 0)) {
                r = new Report(6037);
                r.add(hit.getLocation());
                r.subject = te_n;
                r.indent(2);
                vDesc.addElement(r);
                return vDesc;
            }
            // otherwise critical hit
            r = new Report(6225);
            r.add(te.getLocationAbbr(hit));
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);

            crits = 0;
            damage = Math.max(
                    te.getInternal(hit.getLocation())
                    + te.getArmor(hit.getLocation()), damage);
        }

        if ((te.getArmor(hit) > 0)
            && ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_FIBROUS)
                || (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_LIGHT_FERRO) || (te
                                                                                                         .getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAVY_FERRO))) {
            isFerroFibrousTarget = true;
        }

        // area effect against infantry is double damage
        if (isPlatoon && areaSatArty) {
            // PBI. Double damage.
            damage *= 2;
            r = new Report(6039);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
        }

        // Is the infantry in the open?
        if (isPlatoon && !te.isDestroyed() && !te.isDoomed()
                && !hit.isIgnoreInfantryDoubleDamage()
                && (((Infantry) te).getDugIn() != Infantry.DUG_IN_COMPLETE)
                && !te.getCrew().getOptions().booleanOption("dermal_armor")) {
            te_hex = game.getBoard().getHex(te.getPosition());
            if ((te_hex != null) && !te_hex.containsTerrain(Terrains.WOODS)
                && !te_hex.containsTerrain(Terrains.JUNGLE)
                && !te_hex.containsTerrain(Terrains.ROUGH)
                && !te_hex.containsTerrain(Terrains.RUBBLE)
                && !te_hex.containsTerrain(Terrains.SWAMP)
                && !te_hex.containsTerrain(Terrains.BUILDING)
                && !te_hex.containsTerrain(Terrains.FUEL_TANK)
                && !te_hex.containsTerrain(Terrains.FORTIFIED)
                && !ammoExplosion) {
                // PBI. Damage is doubled.
                damage *= 2;
                r = new Report(6040);
                r.subject = te_n;
                r.indent(2);
                vDesc.addElement(r);
            }
        }
        // Is the infantry in vacuum?
        if ((isPlatoon || isBattleArmor) && !te.isDestroyed() && !te.isDoomed()
            && game.getPlanetaryConditions().isVacuum()) {
            // PBI. Double damage.
            damage *= 2;
            r = new Report(6041);
            r.subject = te_n;
            r.indent(2);
            vDesc.addElement(r);
        }
        // If dealing with fragmentation missiles,
        // it does double damage to infantry...
        // We're actually going to abuse this for AX-head warheads, too, so as
        // to not add another parameter.
        switch (bFrag) {
            case ANTI_INFANTRY:
                if (isPlatoon
                    && te.getCrew().getOptions().booleanOption("dermal_armor")) {
                    int reduce = Math.min(damage - 1, Compute.d6());
                    damage -= reduce;
                    r = new Report(6042);
                    r.subject = te_n;
                    r.add(reduce);
                    r.add(damage);
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case FRAGMENTATION:
                // Fragmentation missiles deal full damage to conventional
                // infantry
                // (only) and no damage to other target types.
                if (!isPlatoon) {
                    damage = 0;
                    r = new Report(6050); // For some reason this report never
                    // actually shows up...
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                } else {
                    r = new Report(6045); // ...but this one displays just fine.
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case NONPENETRATING:
                if (!isPlatoon) {
                    damage = 0;
                    r = new Report(6051);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case FLECHETTE:
                // Flechette ammo deals full damage to conventional infantry and
                // half damage to other targets (including battle armor).
                if (!isPlatoon) {
                    damage /= 2;
                    r = new Report(6060);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                } else {
                    r = new Report(6055);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case ACID:
                if (isFerroFibrousTarget || reactiveArmor || reflectiveArmor
                    || ferroLamellorArmor || bar5) {
                    if (te.getArmor(hit) <= 0) {
                        break; // hitting IS, not acid-affected armor
                    }
                    damage = te.getArmor(hit) >= 3 ? 3 : te.getArmor(hit);
                    r = new Report(6061);
                    r.subject = te_n;
                    r.indent(2);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (isPlatoon) {
                    damage *= 1.5;
                    r = new Report(6062);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case INCENDIARY:
                // Incendiary AC ammo does +2 damage to unarmoured infantry
                if (isPlatoon) {
                    damage += 2;
                    r = new Report(6064);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                }
                break;
            case ANTI_TSM:
                te.hitThisRoundByAntiTSM = true;
                break;
            case NAIL_RIVET:
                // no damage against armor of BAR rating >=5
                if ((te.getBARRating(hit.getLocation()) >= 5)
                    && (te.getArmor(hit.getLocation()) > 0)) {
                    damage = 0;
                    r = new Report(6063);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.add(r);
                }
                break;
            default:
                // We can ignore this.
                break;
        }

        // adjust VTOL rotor damage
        if ((te instanceof VTOL) && (hit.getLocation() == VTOL.LOC_ROTOR)
            && (hit.getGeneralDamageType() != HitData.DAMAGE_PHYSICAL)
            && !game.getOptions().booleanOption("full_rotor_hits")) {
            damage = (damage + 9) / 10;
        }

        // save EI status, in case sensors crit destroys it
        final boolean eiStatus = te.hasActiveEiCockpit();
        // BA using EI implants receive +1 damage from attacks
        if (!(te instanceof Mech) && !(te instanceof Protomech) && eiStatus) {
            damage += 1;
        }

        // check for case on Aeros
        if (te instanceof Aero) {
            Aero a = (Aero) te;
            if (ammoExplosion && a.hasCase()) {
                // damage should be reduced by a factor of 2 for ammo explosions
                // according to p. 161, TW
                damage /= 2;
                r = new Report(9010);
                r.subject = te_n;
                r.add(damage);
                r.indent(3);
                vDesc.addElement(r);
            }
        }

        // infantry armor can reduce damage
        if (isPlatoon && (((Infantry) te).getDamageDivisor() != 1.0)) {
            r = new Report(6074);
            r.subject = te_n;
            r.indent(2);
            r.add(damage);
            damage = (int) Math.ceil((damage)
                                     / ((Infantry) te).getDamageDivisor());
            r.add(damage);
            vDesc.addElement(r);
        }

        // Allocate the damage
        while (damage > 0) {

            // first check for ammo explosions on aeros separately, because it
            // must be done before
            // standard to capital damage conversions
            if ((te instanceof Aero) && (hit.getLocation() == Aero.LOC_AFT)
                && !damageIS) {
                for (Mounted mAmmo : te.getAmmo()) {
                    if (mAmmo.isDumping() && !mAmmo.isDestroyed()
                        && !mAmmo.isHit()
                        && !(mAmmo.getType() instanceof BombType)) {
                        // doh. explode it
                        vDesc.addAll(explodeEquipment(te, mAmmo.getLocation(),
                                                      mAmmo));
                        mAmmo.setHit(true);
                    }
                }
            }

            if (te instanceof Aero) {
                // chance of a critical if damage greater than threshold
                Aero a = (Aero) te;
                if ((threshDamage > a.getThresh(hit.getLocation()))) {
                    critThresh = true;
                    a.setCritThresh(true);
                }
            }

            // Capital fighters receive damage differently
            if (te.isCapitalFighter()) {
                Aero a = (Aero) te;
                a.setCurrentDamage(a.getCurrentDamage() + damage);
                a.setCapArmor(a.getCapArmor() - damage);
                r = new Report(9065);
                r.subject = te_n;
                r.indent(2);
                r.newlines = 0;
                r.addDesc(te);
                r.add(damage);
                vDesc.addElement(r);
                r = new Report(6085);
                r.subject = te_n;
                r.add(Math.max(a.getCapArmor(), 0));
                vDesc.addElement(r);
                // check to see if this detroyed the entity
                if (a.getCapArmor() <= 0) {
                    vDesc.addAll(destroyEntity(te,
                            "Structural Integrity Collapse"));
                    a.setCapArmor(0);
                    if (hit.getAttackerId() != Entity.NONE) {
                        creditKill(a, game.getEntity(hit.getAttackerId()));
                    }
                }
                damage = 0;
                // check for crits
                checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh,
                               critSI, ammoExplosion, nukeS2S);
                return vDesc;
            }

            if (!((te instanceof Aero) && ammoExplosion)) {
                // report something different for Aero ammo explosions
                r = new Report(6065);
                r.subject = te_n;
                r.indent(2);
                r.addDesc(te);
                r.add(damage);
                if (damageIS) {
                    r.messageId = 6070;
                }
                r.add(te.getLocationAbbr(hit));
                vDesc.addElement(r);
            }

            // was the section destroyed earlier this phase?
            if (te.getInternal(hit) == IArmorState.ARMOR_DOOMED) {
                // cannot transfer a through armor crit if so
                crits = 0;
            }

            // here goes the fun :)
            // Shields take damage first then cowls then armor whee
            // Shield does not protect from ammo explosions or falls.
            if (!ammoExplosion
                && !hit.isFallDamage()
                && !damageIS
                && te.hasShield()
                && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                Mech me = (Mech) te;
                int damageNew = me.shieldAbsorptionDamage(damage,
                                                          hit.getLocation(), hit.isRear());
                // if a shield absorbed the damage then lets tell the world
                // about it.
                if (damageNew != damage) {
                    int absorb = damage - damageNew;
                    te.damageThisPhase += absorb;
                    damage = damageNew;

                    r = new Report(3530);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(absorb);
                    vDesc.addElement(r);

                    if (damage <= 0) {
                        crits = 0;
                        specCrits = 0;
                        isHeadHit = false;
                    }
                }
            }

            // Armored Cowl may absorb some damage from hit
            if (te instanceof Mech) {
                Mech me = (Mech) te;
                if (me.hasCowl() && (hit.getLocation() == Mech.LOC_HEAD)
                    && !throughFront) {
                    int damageNew = me.damageCowl(damage);
                    int damageDiff = damage - damageNew;
                    me.damageThisPhase += damageDiff;
                    damage = damageNew;

                    r = new Report(3520);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damageDiff);
                    vDesc.addElement(r);
                }
            }

            // So might modular armor, if the location mounts any.
            if (!ammoExplosion
                && !damageIS
                && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                int damageNew = te.getDamageReductionFromModularArmor(hit,
                        damage, vDesc);
                int damageDiff = damage - damageNew;
                te.damageThisPhase += damageDiff;
                damage = damageNew;
            }

            // Destroy searchlights on 7+ (torso hits on mechs)
            if (te.hasSpotlight()) {
                boolean spotlightHittable = true;
                int loc = hit.getLocation();
                if (te instanceof Mech) {
                    if ((loc != Mech.LOC_CT) && (loc != Mech.LOC_LT)
                        && (loc != Mech.LOC_RT)) {
                        spotlightHittable = false;
                    }
                } else if (te instanceof Tank) {
                    if (te instanceof SuperHeavyTank) {
                        if ((loc != Tank.LOC_FRONT)
                            && (loc != SuperHeavyTank.LOC_FRONTRIGHT)
                            && (loc != SuperHeavyTank.LOC_FRONTLEFT)
                            && (loc != SuperHeavyTank.LOC_REARRIGHT)
                            && (loc != SuperHeavyTank.LOC_REARLEFT)) {
                            spotlightHittable = false;
                        }
                    } else if (te instanceof LargeSupportTank) {
                        if ((loc != Tank.LOC_FRONT)
                            && (loc != LargeSupportTank.LOC_FRONTRIGHT)
                            && (loc != LargeSupportTank.LOC_FRONTLEFT)
                            && (loc != LargeSupportTank.LOC_REARRIGHT)
                            && (loc != LargeSupportTank.LOC_REARLEFT)) {
                            spotlightHittable = false;
                        }
                    } else {
                        if ((loc != Tank.LOC_FRONT) && (loc != Tank.LOC_RIGHT)
                            && (loc != Tank.LOC_LEFT)) {
                            spotlightHittable = false;
                        }
                    }

                }
                if (spotlightHittable) {
                    int spotroll = Compute.d6(2);
                    r = new Report(6072);
                    r.indent(2);
                    r.subject = te_n;
                    r.add("7+");
                    r.add("Searchlight");
                    r.add(spotroll);
                    vDesc.addElement(r);
                    if (spotroll >= 7) {
                        r = new Report(6071);
                        r.subject = te_n;
                        r.indent(2);
                        r.add("Searchlight");
                        vDesc.addElement(r);
                        te.destroyOneSpotlight();
                    }
                }
            }

            // Does an exterior passenger absorb some of the damage?
            if (!damageIS) {
                int nLoc = hit.getLocation();
                Entity passenger = te.getExteriorUnitAt(nLoc, hit.isRear());
                // Does an exterior passenger absorb some of the damage?
                int avoidRoll = Compute.d6();
                if (!ammoExplosion && (null != passenger) && (avoidRoll >= 5)
                    && !passenger.isDoomed()
                    && (bFrag != DamageType.IGNORE_PASSENGER)) {
                    // Yup. Roll up some hit data for that passenger.
                    r = new Report(6075);
                    r.subject = passenger.getId();
                    r.indent(3);
                    r.addDesc(passenger);
                    vDesc.addElement(r);

                    HitData passHit = passenger.getTrooperAtLocation(hit, te);
                    passHit.setGeneralDamageType(hit.getGeneralDamageType());


                    // How much damage will the passenger absorb?
                    int absorb = 0;
                    HitData nextPassHit = passHit;
                    do {
                        int armorType = passenger.getArmorType(nextPassHit
                                                                       .getLocation());
                        boolean armorDamageReduction = false;
                        if (((armorType == EquipmentType.T_ARMOR_BA_REACTIVE)
                             && ((hit.getGeneralDamageType() ==
                                  HitData.DAMAGE_MISSILE)))
                            || (hit.getGeneralDamageType() ==
                                HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {
                            armorDamageReduction = true;
                        }
                        // Check for reflective armor
                        if ((armorType == EquipmentType.T_ARMOR_BA_REFLECTIVE)
                            && (hit.getGeneralDamageType() ==
                                HitData.DAMAGE_ENERGY)) {
                            armorDamageReduction = true;
                        }
                        if (0 < passenger.getArmor(nextPassHit)) {
                            absorb += passenger.getArmor(nextPassHit);
                            if (armorDamageReduction) {
                                absorb *= 2;
                            }
                        }
                        if (0 < passenger.getInternal(nextPassHit)) {
                            absorb += passenger.getInternal(nextPassHit);
                            // Armor damage reduction, like for reflective or
                            // reactive armor will divide the whole damage
                            // total by 2 and round down. If we have an odd
                            // damage total, need to add 1 to make this
                            // evenly divisible by 2
                            if (((absorb % 2) != 0) && armorDamageReduction) {
                                absorb++;
                            }
                        }
                        nextPassHit = passenger
                                .getTransferLocation(nextPassHit);
                    } while ((damage > absorb)
                             && (nextPassHit.getLocation() >= 0));

                    // Damage the passenger.
                    int absorbedDamage = Math.min(damage, absorb);
                    Vector<Report> newReports = damageEntity(passenger,
                                                             passHit, absorbedDamage);
                    for (Report newReport : newReports) {
                        newReport.indent(2);
                    }
                    vDesc.addAll(newReports);

                    // Did some damage pass on?
                    if (damage > absorb) {
                        // Yup. Remove the absorbed damage.
                        damage -= absorb;
                        r = new Report(6080);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        r.addDesc(te);
                        vDesc.addElement(r);
                    } else {
                        // Nope. Return our description.
                        return vDesc;
                    }

                } else if (!ammoExplosion && (null != passenger)
                           && (avoidRoll < 5) && !passenger.isDoomed()
                           && (bFrag != DamageType.IGNORE_PASSENGER)) {
                    // Report that a passenger that could've been missed
                    // narrowly avoids damage
                    r = new Report(6084);
                    r.subject = passenger.getId();
                    r.indent(3);
                    r.addDesc(passenger);
                    vDesc.addElement(r);
                } // End nLoc-has-exterior-passenger

                boolean bTorso = (nLoc == Mech.LOC_CT) || (nLoc == Mech.LOC_RT)
                                 || (nLoc == Mech.LOC_LT);

                // Does a swarming unit absorb damage?
                int swarmer = te.getSwarmAttackerId();
                if ((!(te instanceof Mech) || bTorso)
                    && (swarmer != Entity.NONE)
                    && ((hit.getEffect() & HitData.EFFECT_CRITICAL) == 0)
                    && (Compute.d6() >= 5)
                    && (bFrag != DamageType.IGNORE_PASSENGER)
                    && !ammoExplosion) {
                    Entity swarm = game.getEntity(swarmer);
                    // Yup. Roll up some hit data for that passenger.
                    r = new Report(6076);
                    r.subject = swarmer;
                    r.indent(3);
                    r.addDesc(swarm);
                    vDesc.addElement(r);

                    HitData passHit = swarm.rollHitLocation(
                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);

                    // How much damage will the swarm absorb?
                    int absorb = 0;
                    HitData nextPassHit = passHit;
                    do {
                        if (0 < swarm.getArmor(nextPassHit)) {
                            absorb += swarm.getArmor(nextPassHit);
                        }
                        if (0 < swarm.getInternal(nextPassHit)) {
                            absorb += swarm.getInternal(nextPassHit);
                        }
                        nextPassHit = swarm.getTransferLocation(nextPassHit);
                    } while ((damage > absorb)
                             && (nextPassHit.getLocation() >= 0));

                    // Damage the swarm.
                    int absorbedDamage = Math.min(damage, absorb);
                    Vector<Report> newReports = damageEntity(swarm, passHit,
                                                             absorbedDamage);
                    for (Report newReport : newReports) {
                        newReport.indent(2);
                    }
                    vDesc.addAll(newReports);

                    // Did some damage pass on?
                    if (damage > absorb) {
                        // Yup. Remove the absorbed damage.
                        damage -= absorb;
                        r = new Report(6080);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        r.addDesc(te);
                        vDesc.addElement(r);
                    } else {
                        // Nope. Return our description.
                        return vDesc;
                    }
                }

                // is this a mech/tank dumping ammo being hit in the rear torso?
                if (((te instanceof Mech) && hit.isRear() && bTorso)
                    || ((te instanceof Tank) && (hit.getLocation() == (te instanceof SuperHeavyTank ? SuperHeavyTank
                        .LOC_REAR
                                                                                                    : Tank.LOC_REAR))
                )) {
                    for (Mounted mAmmo : te.getAmmo()) {
                        if (mAmmo.isDumping() && !mAmmo.isDestroyed()
                            && !mAmmo.isHit()) {
                            // doh. explode it
                            vDesc.addAll(explodeEquipment(te,
                                                          mAmmo.getLocation(), mAmmo));
                            mAmmo.setHit(true);
                        }
                    }
                }
            }
            // is there armor in the location hit?
            if (!ammoExplosion && (te.getArmor(hit) > 0) && !damageIS) {
                int tmpDamageHold = -1;
                int origDamage = damage;

                if (isPlatoon) {
                    // infantry armour works differently
                    int armor = te.getArmor(hit);
                    int men = te.getInternal(hit);
                    tmpDamageHold = damage % 2;
                    damage /= 2;
                    if ((tmpDamageHold == 1) && (armor >= men)) {
                        // extra 1 point of damage to armor
                        tmpDamageHold = damage;
                        damage++;
                    } else {
                        // extra 0 or 1 point of damage to men
                        tmpDamageHold += damage;
                    }
                    // If the target has Ferro-Lamellor armor, we need to adjust
                    // damage. (4/5ths rounded down),
                    // Also check to eliminate crit chances for damage reduced
                    // to 0
                } else if (ferroLamellorArmor
                           && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                           && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                           && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor((((double) damage) * 4) / 5);
                    if (damage <= 0) {
                        isHeadHit = false;
                        crits = 0;
                    }
                    r = new Report(6073);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (ballisticArmor
                           && ((hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                               || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING)
                               || (hit.getGeneralDamageType() == HitData.DAMAGE_BALLISTIC) || (hit
                                                                                                       .getGeneralDamageType() == HitData.DAMAGE_MISSILE))) {
                    tmpDamageHold = damage;
                    damage = Math.max(1, damage / 2);
                    r = new Report(6088);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (impactArmor
                           && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)) {
                    tmpDamageHold = damage;
                    damage -= (int) Math.ceil((double) damage / 3);
                    damage = Math.max(1, damage);
                    r = new Report(6089);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor
                           && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)
                           && !isBattleArmor) { // BA reflec does not receive extra
                    // physical damage
                    tmpDamageHold = damage;
                    damage *= 2;
                    r = new Report(6066);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor && areaSatArty && !isBattleArmor) {
                    tmpDamageHold = damage; // BA reflec does not receive extra
                    // AE damage
                    damage *= 2;
                    r = new Report(6087);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reflectiveArmor
                           && (hit.getGeneralDamageType() == HitData.DAMAGE_ENERGY)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor(((double) damage) / 2);
                    if (tmpDamageHold == 1) {
                        damage = 1;
                    }
                    r = new Report(6067);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                } else if (reactiveArmor
                           && ((hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE)
                               || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE) ||
                               areaSatArty)) {
                    tmpDamageHold = damage;
                    damage = (int) Math.floor(((double) damage) / 2);
                    if (tmpDamageHold == 1) {
                        damage = 1;
                    }
                    r = new Report(6068);
                    r.subject = te_n;
                    r.indent(3);
                    r.add(damage);
                    vDesc.addElement(r);
                }

                // If we're using optional tank damage thresholds, setup our hit
                // effects now...
                if ((te instanceof Tank)
                        && game.getOptions()
                                .booleanOption("vehicles_threshold")
                        && !((te instanceof VTOL) || (te instanceof GunEmplacement))) {
                    int thresh = (int) Math.ceil((game.getOptions()
                            .booleanOption("vehicles_threshold_variable") ? te
                            .getArmor(hit) : te.getOArmor(hit))
                            / game.getOptions().intOption(
                                    "vehicles_threshold_divisor"));

                    // adjust for hardened armor
                    if (hardenedArmor
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                            && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                        thresh *= 2;
                    }

                    if ((damage > thresh) || (te.getArmor(hit) < damage)) {
                        hit.setEffect(((Tank) te).getPotCrit());
                        ((Tank) te).setOverThresh(true);
                        // TACs from the hit location table
                        crits = ((hit.getEffect() & HitData.EFFECT_CRITICAL)
                                == HitData.EFFECT_CRITICAL) ? 1 : 0;
                    } else {
                        ((Tank) te).setOverThresh(false);
                        crits = 0;
                    }
                }

                // if there's a mast mount in the rotor, it and all other
                // equipment
                // on it get destroyed
                if ((te instanceof VTOL)
                    && (hit.getLocation() == VTOL.LOC_ROTOR)
                    && te.hasWorkingMisc(MiscType.F_MAST_MOUNT, -1,
                                         VTOL.LOC_ROTOR)) {
                    r = new Report(6081);
                    r.subject = te_n;
                    r.indent(2);
                    vDesc.addElement(r);
                    for (Mounted mount : te.getMisc()) {
                        if (mount.getLocation() == VTOL.LOC_ROTOR) {
                            mount.setHit(true);
                        }
                    }
                }
                // Need to account for the possibility of hardened armor here
                int armorThreshold = te.getArmor(hit);
                if (hardenedArmor
                    && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                    && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                    && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                    armorThreshold *= 2;
                    armorThreshold -= (te.isHardenedArmorDamaged(hit)) ? 1 : 0;
                    vDesc.lastElement().newlines = 0;
                    r = new Report(6069);
                    r.subject = te_n;
                    r.indent(3);
                    int reportedDamage = damage / 2;
                    if ((damage % 2) > 0) {
                        r.add(String.valueOf(reportedDamage) + ".5");
                    } else {
                        r.add(reportedDamage);
                    }

                    vDesc.addElement(r);
                }
                if (armorThreshold >= damage) {

                    // armor absorbs all damage
                    // Hardened armor deals with damage in its own fashion...
                    if (hardenedArmor
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {
                        armorThreshold -= damage;
                        te.setHardenedArmorDamaged(hit,
                                                   (armorThreshold % 2) > 0);
                        te.setArmor(
                                (armorThreshold / 2) + (armorThreshold % 2),
                                hit);
                    } else {
                        te.setArmor(te.getArmor(hit) - damage, hit);
                    }

                    // set "armor damage" flag for HarJel II/III
                    // we only care about this if there is armor remaining,
                    // so don't worry about the case where damage exceeds
                    // armorThreshold
                    if ((te instanceof Mech) && (damage > 0)) {
                        ((Mech) te).setArmorDamagedThisTurn(hit.getLocation(), true);
                    }

                    // if the armor is hardened, any penetrating crits are
                    // rolled at -2
                    if (hardenedArmor) {
                        critBonus -= 2;
                    }

                    if (tmpDamageHold >= 0) {
                        te.damageThisPhase += tmpDamageHold;
                    } else {
                        te.damageThisPhase += damage;
                    }
                    damage = 0;
                    if (!te.isHardenedArmorDamaged(hit)) {
                        r = new Report(6085);
                    } else {
                        r = new Report(6086);
                    }

                    r.subject = te_n;
                    r.indent(3);
                    r.add(te.getArmor(hit));
                    vDesc.addElement(r);

                    // tele-missiles are destroyed if they lose all armor
                    if ((te instanceof TeleMissile)
                        && (te.getArmor(hit) == damage)) {
                        vDesc.addAll(destroyEntity(te, "damage", false));
                    }

                } else {
                    // damage goes on to internal
                    int absorbed = Math.max(te.getArmor(hit), 0);
                    if (hardenedArmor
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)
                        && (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {
                        absorbed = (absorbed * 2)
                                   - ((te.isHardenedArmorDamaged(hit)) ? 1 : 0);
                    }
                    if (reflectiveArmor
                        && (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)
                        && !isBattleArmor) {
                        absorbed = (int) Math.round(Math.ceil(absorbed / 2));
                        damage = tmpDamageHold;
                        tmpDamageHold = 0;
                    }
                    te.setArmor(IArmorState.ARMOR_DESTROYED, hit);
                    if (tmpDamageHold >= 0) {
                        te.damageThisPhase += 2 * absorbed;
                    } else {
                        te.damageThisPhase += absorbed;
                    }
                    damage -= absorbed;
                    r = new Report(6090);
                    r.subject = te_n;
                    r.indent(3);
                    vDesc.addElement(r);
                    if (te instanceof GunEmplacement) {
                        // gun emplacements have no internal,
                        // destroy the section
                        te.destroyLocation(hit.getLocation());
                        r = new Report(6115);
                        r.subject = te_n;
                        vDesc.addElement(r);

                        if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {
                            vDesc.addAll(destroyEntity(te, "damage", false));
                        }
                    }
                }

                // targets with BAR armor get crits, depending on damage and BAR
                // rating
                if (te.hasBARArmor(hit.getLocation())) {
                    if (origDamage > te.getBARRating(hit.getLocation())) {
                        if (te.hasArmoredChassis()) {
                            // crit roll with -1 mod
                            vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                                        hit.isRear(), -1 + critBonus, damage_orig));
                        } else {
                            vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                                        hit.isRear(), critBonus, damage_orig));
                        }
                    }
                }

                if ((tmpDamageHold > 0) && isPlatoon) {
                    damage = tmpDamageHold;
                }
            }

            // For optional tank damage thresholds, the overthresh flag won't
            // be set if IS is damaged, so set it here.
            if ((te instanceof Tank)
                    && ((te.getArmor(hit) < 1) || damageIS)
                    && game.getOptions().booleanOption("vehicles_threshold")
                    && !((te instanceof VTOL)
                            || (te instanceof GunEmplacement))) {
                ((Tank) te).setOverThresh(true);
            }

            // is there damage remaining?
            if (damage > 0) {

                // if this is an Aero then I need to apply internal damage
                // to the SI after halving it. Return from here to prevent
                // further processing
                if (te instanceof Aero) {
                    Aero a = (Aero) te;

                    // check for overpenetration
                    if (game.getOptions().booleanOption(
                            "stratops_over_penetrate")) {
                        int opRoll = Compute.d6(1);
                        if ((((te instanceof Jumpship) || (te instanceof SpaceStation))
                             && !(te instanceof Warship) && (opRoll > 3))
                            || ((te instanceof Dropship) && (opRoll > 4))
                            || ((te instanceof Warship)
                                && (a.get0SI() <= 30) && (opRoll > 5))) {
                            // over-penetration happened
                            r = new Report(9090);
                            r.subject = te_n;
                            r.newlines = 0;
                            vDesc.addElement(r);
                            int new_loc = a.getOppositeLocation(hit
                                                                        .getLocation());
                            damage = Math.min(damage, te.getArmor(new_loc));
                            // We don't want to deal negative damage
                            damage = Math.max(damage, 0);
                            r = new Report(6065);
                            r.subject = te_n;
                            r.indent(2);
                            r.newlines = 0;
                            r.addDesc(te);
                            r.add(damage);
                            r.add(te.getLocationAbbr(new_loc));
                            vDesc.addElement(r);
                            te.setArmor(te.getArmor(new_loc) - damage, new_loc);
                            if ((te instanceof Warship)
                                || (te instanceof Dropship)) {
                                damage = 2;
                            } else {
                                damage = 0;
                            }
                        }
                    }

                    // divide damage in half
                    // do not divide by half if it is an ammo exposion
                    if (!ammoExplosion && !nukeS2S
                        && !game.getOptions().booleanOption("aero_sanity")) {
                        damage /= 2;
                    }

                    // this should result in a crit
                    // but only if it really did damage after rounding down
                    if (damage > 0) {
                        critSI = true;
                    }

                    // Now apply damage to the structural integrity
                    a.setSI(a.getSI() - damage);
                    te.damageThisPhase += damage;
                    // send the report
                    r = new Report(1210);
                    r.subject = te_n;
                    r.newlines = 1;
                    if (!ammoExplosion) {
                        r.messageId = 9005;
                    } else {
                        r.messageId = 9006;
                    }
                    r.add(damage);
                    r.add(Math.max(a.getSI(), 0));
                    vDesc.addElement(r);
                    damage = 0;
                    // check to see if this would destroy the ASF
                    if (a.getSI() <= 0) {
                        vDesc.addAll(destroyEntity(te,
                                "Structural Integrity Collapse"));
                        a.setSI(0);
                        if (hit.getAttackerId() != Entity.NONE) {
                            creditKill(a, game.getEntity(hit.getAttackerId()));
                        }
                    }
                    checkAeroCrits(vDesc, a, hit, damage_orig, critThresh,
                                   critSI, ammoExplosion, nukeS2S);
                    return vDesc;
                }

                // Check for CASE II right away. if so reduce damage to 1
                // and let it hit the IS.
                // Also remove as much of the rear armor as allowed by the
                // damage. If arm/leg/head
                // Then they lose all their armor if its less then the
                // explosion damage.
                if (ammoExplosion && te.hasCASEII(hit.getLocation())) {
                    // 1 point of damage goes to IS
                    damage--;
                    // Remaining damage prevented by CASE II
                    r = new Report(6126);
                    r.subject = te_n;
                    r.add(damage);
                    r.indent(3);
                    vDesc.addElement(r);
                    int loc = hit.getLocation();
                    if ((te instanceof Mech)
                        && ((loc == Mech.LOC_HEAD)
                            || ((Mech) te).isArm(loc) || ((Mech) te)
                            .locationIsLeg(loc))) {
                        int half = (int) Math.ceil(((Mech) te).getOArmor(loc,
                                                                         false) / 2);
                        if (damage > half) {
                            damage = half;
                        }
                        if (damage >= te.getArmor(loc, false)) {
                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, false);
                        } else {
                            te.setArmor(te.getArmor(loc, false) - damage, loc,
                                        false);
                        }
                    } else {
                        if (damage >= te.getArmor(loc, true)) {
                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, true);
                        } else {
                            te.setArmor(te.getArmor(loc, true) - damage, loc,
                                        true);
                        }
                    }

                    if (te.getInternal(hit) > 0) {
                        // Mek takes 1 point of IS damage
                        damage = 1;
                    } else {
                        damage = 0;
                    }

                    te.damageThisPhase += damage;

                    int roll = Compute.d6(2);
                    r = new Report(6127);
                    r.subject = te.getId();
                    r.add(roll);
                    vDesc.add(r);
                    if (roll >= 8) {
                        hit.setEffect(HitData.EFFECT_NO_CRITICALS);
                    }
                }
                // check for tank CASE here: damage to rear armor, excess
                // dissipating, and a crew stunned crit
                if (ammoExplosion && (te instanceof Tank)
                    && te.locationHasCase(Tank.LOC_BODY)) {
                    te.damageThisPhase += damage;
                    r = new Report(6124);
                    r.subject = te_n;
                    r.indent(2);
                    r.add(damage);
                    vDesc.add(r);
                    if (damage > te
                            .getArmor(te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                                                                   : te instanceof LargeSupportTank ?
                                                                     LargeSupportTank.LOC_REAR
                                                                                                    : Tank.LOC_REAR)) {
                        te.setArmor(
                                IArmorState.ARMOR_DESTROYED,
                                te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                                                             : te instanceof LargeSupportTank ? LargeSupportTank
                                        .LOC_REAR
                                                                                              : Tank.LOC_REAR);
                        r = new Report(6090);
                    } else {
                        te.setArmor(
                                te.getArmor(te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                                                                         : te instanceof LargeSupportTank ?
                                                                           LargeSupportTank.LOC_REAR
                                                                                                          : Tank
                                                                                   .LOC_REAR)
                                - damage,
                                te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                                                             : te instanceof LargeSupportTank ? LargeSupportTank
                                        .LOC_REAR
                                                                                              : Tank.LOC_REAR);
                        r = new Report(6085);
                        r.add(te.getArmor(te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR
                                                                       : te instanceof LargeSupportTank ?
                                                                         LargeSupportTank.LOC_REAR
                                                                                                        : Tank
                                                                                 .LOC_REAR));
                    }
                    r.subject = te_n;
                    r.indent(3);
                    vDesc.add(r);
                    damage = 0;
                    int critIndex;
                    if (((Tank) te).isCommanderHit()
                        && ((Tank) te).isDriverHit()) {
                        critIndex = Tank.CRIT_CREW_KILLED;
                    } else {
                        critIndex = Tank.CRIT_CREW_STUNNED;
                    }
                    vDesc.addAll(applyCriticalHit(te, Entity.NONE,
                                                  new CriticalSlot(0, critIndex), true, 0, false));
                }

                // is there internal structure in the location hit?
                if (te.getInternal(hit) > 0) {

                    // Now we need to consider alternate structure types!
                    int tmpDamageHold = -1;
                    if ((te instanceof Mech)
                        && ((Mech) te).hasCompositeStructure()) {
                        tmpDamageHold = damage;
                        damage *= 2;
                        r = new Report(6091);
                        r.subject = te_n;
                        r.indent(3);
                        vDesc.add(r);
                    }
                    if ((te instanceof Mech)
                        && ((Mech) te).hasReinforcedStructure()) {
                        tmpDamageHold = damage;
                        damage /= 2;
                        damage += tmpDamageHold % 2;
                        r = new Report(6092);
                        r.subject = te_n;
                        r.indent(3);
                        vDesc.add(r);
                    }
                    if ((te.getInternal(hit) > damage) && (damage > 0)) {
                        // internal structure absorbs all damage
                        te.setInternal(te.getInternal(hit) - damage, hit);
                        // Triggers a critical hit on Vehicles and Mechs.
                        if (!isPlatoon && !isBattleArmor) {
                            crits++;
                        }
                        tookInternalDamage = true;
                        // Alternate structures don't affect our damage total
                        // for later PSR purposes, so use the previously stored
                        // value here as necessary.
                        te.damageThisPhase += (tmpDamageHold > -1) ?
                                tmpDamageHold : damage;
                        damage = 0;
                        r = new Report(6100);
                        r.subject = te_n;
                        r.indent(3);
                        // Infantry platoons have men not "Internals".
                        if (isPlatoon) {
                            r.messageId = 6095;
                        }
                        r.add(te.getInternal(hit));
                        vDesc.addElement(r);
                    } else if (damage > 0) {
                        // Triggers a critical hit on Vehicles and Mechs.
                        if (!isPlatoon && !isBattleArmor) {
                            crits++;
                        }
                        // damage transfers, maybe
                        int absorbed = Math.max(te.getInternal(hit), 0);

                        // Handle Protomech pilot damage
                        // due to location destruction
                        if (te instanceof Protomech) {
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit
                                    .getLocation()]
                                       - ((Protomech) te).getPilotDamageTaken(hit
                                                                                      .getLocation());
                            if (hits > 0) {
                                vDesc.addAll(damageCrew(te, hits));
                                ((Protomech) te).setPilotDamageTaken(hit
                                                                             .getLocation(),
                                                                     Protomech.POSSIBLE_PILOT_DAMAGE[hit
                                                                             .getLocation()]);
                            }
                        }

                        // Platoon, Trooper, or Section destroyed message
                        r = new Report(1210);
                        r.subject = te_n;
                        if (isPlatoon) {
                            // Infantry have only one section, and
                            // are therefore destroyed.
                            if (((Infantry) te).isSquad()) {
                                r.messageId = 6106; // Squad Killed
                            } else {
                                r.messageId = 6105; // Platoon Killed
                            }
                        } else if (isBattleArmor) {
                            r.messageId = 6110;
                        } else {
                            r.messageId = 6115;
                        }
                        r.indent(3);
                        vDesc.addElement(r);

                        // If a sidetorso got destroyed, and the
                        // corresponding arm is not yet destroyed, add
                        // it as a club to that hex (p.35 BMRr)
                        if ((te instanceof Mech)
                                && (((hit.getLocation() == Mech.LOC_RT)
                                        && (te.getInternal(Mech.LOC_RARM) > 0))
                                    || ((hit.getLocation() == Mech.LOC_LT)
                                        && (te.getInternal(Mech.LOC_LARM) > 0)))) {
                            int blownOffLocation;
                            if (hit.getLocation() == Mech.LOC_RT) {
                                blownOffLocation = Mech.LOC_RARM;
                            } else {
                                blownOffLocation = Mech.LOC_LARM;
                            }
                            te.destroyLocation(blownOffLocation, true);
                            r = new Report(6120);
                            r.subject = te_n;
                            r.add(te.getLocationName(blownOffLocation));
                            vDesc.addElement(r);
                            IHex h = game.getBoard().getHex(te.getPosition());
                            if (te instanceof BipedMech) {
                                if (!h.containsTerrain(Terrains.ARMS)) {
                                    h.addTerrain(Terrains.getTerrainFactory()
                                                         .createTerrain(Terrains.ARMS, 1));
                                } else {
                                    h.addTerrain(Terrains
                                                         .getTerrainFactory()
                                                         .createTerrain(
                                                                 Terrains.ARMS,
                                                                 h.terrainLevel(Terrains.ARMS) + 1));
                                }
                            } else if (!h.containsTerrain(Terrains.LEGS)) {
                                h.addTerrain(Terrains.getTerrainFactory()
                                                     .createTerrain(Terrains.LEGS, 1));
                            } else {
                                h.addTerrain(Terrains
                                                     .getTerrainFactory()
                                                     .createTerrain(
                                                             Terrains.LEGS,
                                                             h.terrainLevel(Terrains.LEGS) + 1));
                            }
                            sendChangedHex(te.getPosition());
                        }

                        // Troopers riding on a location
                        // all die when the location is destroyed.
                        if ((te instanceof Mech) || (te instanceof Tank)) {
                            Entity passenger = te.getExteriorUnitAt(
                                    hit.getLocation(), hit.isRear());
                            if ((null != passenger) && !passenger.isDoomed()) {
                                HitData passHit = passenger
                                        .getTrooperAtLocation(hit, te);
                                // ensures a kill
                                passHit.setEffect(HitData.EFFECT_CRITICAL);
                                if (passenger.getInternal(passHit) > 0) {
                                    vDesc.addAll(damageEntity(passenger,
                                                              passHit, damage));
                                }
                                passHit = new HitData(hit.getLocation(),
                                                      !hit.isRear());
                                passHit = passenger.getTrooperAtLocation(
                                        passHit, te);
                                // ensures a kill
                                passHit.setEffect(HitData.EFFECT_CRITICAL);
                                if (passenger.getInternal(passHit) > 0) {
                                    vDesc.addAll(damageEntity(passenger,
                                                              passHit, damage));
                                }
                            }
                        }

                        // BA inferno explosions
                        if (te instanceof BattleArmor) {
                            int infernos = 0;
                            for (Mounted m : te.getEquipment()) {
                                if (m.getType() instanceof AmmoType) {
                                    AmmoType at = (AmmoType) m.getType();
                                    if (((at.getAmmoType() == AmmoType.T_SRM) || (at
                                                                                          .getAmmoType() == AmmoType
                                                                                          .T_MML))
                                        && (at.getMunitionType() == AmmoType.M_INFERNO)) {
                                        infernos += at.getRackSize()
                                                    * m.getHittableShotsLeft();
                                    }
                                } else if (m.getType().hasFlag(
                                        MiscType.F_FIRE_RESISTANT)) {
                                    // immune to inferno explosion
                                    infernos = 0;
                                    break;
                                }
                            }
                            if (infernos > 0) {
                                int roll = Compute.d6(2);
                                r = new Report(6680);
                                r.add(roll);
                                vDesc.add(r);
                                if (roll >= 8) {
                                    Coords c = te.getPosition();
                                    if (c == null) {
                                        Entity transport = game.getEntity(te
                                                                                  .getTransportId());
                                        if (transport != null) {
                                            c = transport.getPosition();
                                        }
                                        vPhaseReport
                                                .addAll(deliverInfernoMissiles(
                                                        te, te, infernos));
                                    }
                                    if (c != null) {
                                        vPhaseReport
                                                .addAll(deliverInfernoMissiles(
                                                        te,
                                                        new HexTarget(
                                                                c,
                                                                game.getBoard(),
                                                                Targetable.TYPE_HEX_ARTILLERY),
                                                        infernos));
                                    }
                                }
                            }
                        }

                        // Mark off the internal structure here, but *don't*
                        // destroy the location just yet -- there are checks
                        // still to run!
                        te.setInternal(0, hit);
                        te.damageThisPhase += absorbed;
                        damage -= absorbed;

                        // Now we need to consider alternate structure types!
                        if (tmpDamageHold > 0) {
                            if (((Mech) te).hasCompositeStructure()) {
                                // If there's a remainder, we can actually
                                // ignore it.
                                damage /= 2;
                            } else if (((Mech) te).hasReinforcedStructure()) {
                                damage *= 2;
                                damage -= tmpDamageHold % 2;
                            }
                        }
                    }
                }
                if (te.getInternal(hit) <= 0) {
                    // internal structure is gone, what are the transfer
                    // potentials?
                    nextHit = te.getTransferLocation(hit);
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {
                        if (te instanceof Mech) {
                            // Start with the number of engine crits in this
                            // location, if any...
                            te.engineHitsThisPhase += te.getNumberOfCriticals(
                                    CriticalSlot.TYPE_SYSTEM,
                                    Mech.SYSTEM_ENGINE, hit.getLocation());
                            // ...then deduct the ones destroyed previously or
                            // critically
                            // hit this round already. That leaves the ones
                            // actually
                            // destroyed with the location.
                            te.engineHitsThisPhase -= te.getHitCriticals(
                                    CriticalSlot.TYPE_SYSTEM,
                                    Mech.SYSTEM_ENGINE, hit.getLocation());
                        }

                        boolean engineExploded = checkEngineExplosion(te,
                                                                      vDesc, te.engineHitsThisPhase);

                        if (!engineExploded) {
                            // Entity destroyed. Ammo explosions are
                            // neither survivable nor salvagable.
                            // Only ammo explosions in the CT are devastating.
                            vDesc.addAll(destroyEntity(
                                    te,
                                    "damage",
                                    !ammoExplosion,
                                    !((ammoExplosion || areaSatArty) && ((te instanceof Tank) || ((te instanceof
                                            Mech) && (hit
                                                              .getLocation() == Mech.LOC_CT))))));
                            // If the head is destroyed, kill the crew.

                            if ((te instanceof Mech)
                                && (hit.getLocation() == Mech.LOC_HEAD)
                                && !te.getCrew().isDead()
                                && !te.getCrew().isDoomed()
                                && game.getOptions()
                                       .booleanOption(
                                               "tacops_skin_of_the_teeth_ejection")) {
                                Mech mech = (Mech) te;
                                if (mech.isAutoEject()
                                    && (!game.getOptions().booleanOption(
                                        "conditional_ejection") || (game
                                                                            .getOptions().booleanOption(
                                                "conditional_ejection") && mech
                                                                            .isCondEjectHeadshot()))) {
                                    autoEject = true;
                                    vDesc.addAll(ejectEntity(te, true, true));
                                }
                            }

                            if ((te instanceof Mech)
                                && (hit.getLocation() == Mech.LOC_CT)
                                && !te.getCrew().isDead()
                                && !te.getCrew().isDoomed()) {
                                Mech mech = (Mech) te;
                                if (mech.isAutoEject()
                                    && game.getOptions().booleanOption(
                                        "conditional_ejection")
                                    && mech.isCondEjectCTDest()) {
                                    if (mech.getCrew().getHits() < 5) {
                                        Report.addNewline(vDesc);
                                        mech.setDoomed(false);
                                        // vDesc.addAll(damageCrew(te, 5 -
                                        // mech.getCrew().getHits()));
                                        mech.setDoomed(true);
                                    }
                                    autoEject = true;
                                    vDesc.addAll(ejectEntity(te, true));
                                }
                            }

                            if ((hit.getLocation() == Mech.LOC_HEAD)
                                || ((hit.getLocation() == Mech.LOC_CT) && ((ammoExplosion && !autoEject) ||
                                                                           areaSatArty))) {
                                te.getCrew().setDoomed(true);
                            }
                            if (game.getOptions().booleanOption(
                                    "auto_abandon_unit")) {
                                vDesc.addAll(abandonEntity(te));
                            }
                        }

                        // nowhere for further damage to go
                        damage = 0;
                    } else if (nextHit.getLocation() == Entity.LOC_NONE) {
                        // Rest of the damage is wasted.
                        damage = 0;
                    } else if (ammoExplosion
                               && te.locationHasCase(hit.getLocation())) {
                        // Remaining damage prevented by CASE
                        r = new Report(6125);
                        r.subject = te_n;
                        r.add(damage);
                        r.indent(3);
                        vDesc.addElement(r);

                        // The target takes no more damage from the explosion.
                        damage = 0;
                    } else if (damage > 0) {
                        // remaining damage transfers
                        r = new Report(6130);
                        r.subject = te_n;
                        r.indent(2);
                        r.add(damage);
                        r.add(te.getLocationAbbr(nextHit));
                        vDesc.addElement(r);

                        // If there are split weapons in this location, mark it
                        // as hit, even if it took no criticals.
                        for (Mounted m : te.getWeaponList()) {
                            if (m.isSplit()) {
                                if ((m.getLocation() == hit.getLocation())
                                    || (m.getLocation() == nextHit
                                        .getLocation())) {
                                    te.setWeaponHit(m);
                                }
                            }
                        }
                        // if this is damage from a nail/rivet gun, and we
                        // transfer
                        // to a location that has armor, and BAR >=5, no damage
                        if ((bFrag == DamageType.NAIL_RIVET)
                            && (te.getArmor(nextHit.getLocation()) > 0)
                            && (te.getBARRating(nextHit.getLocation()) >= 5)) {
                            damage = 0;
                            r = new Report(6065);
                            r.subject = te_n;
                            r.indent(2);
                            vDesc.add(r);
                        }
                    }
                }
            } else if (hit.getSpecCritMod() < 0) {
                // ok, we dealt damage but didn't go on to internal
                // we get a chance of a crit, using Armor Piercing.
                // but only if we don't have hardened or ferro-lamellor armor
                if (!hardenedArmor && !ferroLamellorArmor && !reactiveArmor) {
                    specCrits++;
                }
            }
            // check for breaching
            vDesc.addAll(breachCheck(te, hit.getLocation(), null, underWater));

            // resolve special results
            if ((hit.getEffect() & HitData.EFFECT_VEHICLE_MOVE_DAMAGED) == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {
                vDesc.addAll(vehicleMotiveDamage((Tank) te, hit.getMotiveMod()));
            }
            // roll all critical hits against this location
            // unless the section destroyed in a previous phase?
            // Cause a crit.
            if ((te.getInternal(hit) != IArmorState.ARMOR_DESTROYED)
                && ((hit.getEffect() & HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {
                for (int i = 0; i < crits; i++) {
                    vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                                hit.isRear(), hit.glancingMod() + critBonus,
                                                damage_orig));
                }
                crits = 0;

                for (int i = 0; i < specCrits; i++) {
                    // against BAR or reflective armor, we get a +2 mod
                    int critMod = te.hasBARArmor(hit.getLocation()) ? 2 : 0;
                    critMod += (reflectiveArmor && !isBattleArmor) ? 2 : 0; // BA
                    // against impact armor, we get a +1 mod
                    critMod += impactArmor ? 1 : 0;
                    // reflec
                    // has
                    // no
                    // crit
                    // penalty
                    if (!hardenedArmor) {
                        // non-hardened armor gets modifiers
                        // the -2 for hardened is handled in the critBonus
                        // variable
                        critMod += hit.getSpecCritMod();
                        critMod += hit.glancingMod();
                    }
                    vDesc.addAll(criticalEntity(te, hit.getLocation(),
                                                hit.isRear(), critMod + critBonus, damage_orig));
                }
                specCrits = 0;
            }

            // resolve Aero crits
            if (te instanceof Aero) {
                checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh,
                               critSI, ammoExplosion, nukeS2S);
            }

            if (isHeadHit
                && !te.getCrew().getOptions().booleanOption("dermal_armor")) {
                Report.addNewline(vDesc);
                vDesc.addAll(damageCrew(te, 1));
            }

            // If the location has run out of internal structure, finally
            // actually
            // destroy it here. *EXCEPTION:* Aero units have 0 internal
            // structure
            // in every location by default and are handled elsewhere, so they
            // get a bye.
            if (!(te instanceof Aero) && (te.getInternal(hit) <= 0)) {
                te.destroyLocation(hit.getLocation());

                // Check for possible engine destruction here
                if ((te instanceof Mech)
                    && ((hit.getLocation() == Mech.LOC_RT) || (hit
                                                                       .getLocation() == Mech.LOC_LT))) {

                    int numEngineHits = te.getEngineHits();
                    boolean engineExploded = checkEngineExplosion(te, vDesc,
                                                                  numEngineHits);

                    int hitsToDestroy = 3;
                    if ((te instanceof Mech)
                        && ((Mech) te).isSuperHeavy()
                        && (te.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                        hitsToDestroy = 2;
                    }

                    if (!engineExploded && (numEngineHits >= hitsToDestroy)) {
                        // third engine hit
                        vDesc.addAll(destroyEntity(te, "engine destruction"));
                        if (game.getOptions()
                                .booleanOption("auto_abandon_unit")) {
                            vDesc.addAll(abandonEntity(te));
                        }
                        te.setSelfDestructing(false);
                        te.setSelfDestructInitiated(false);
                    }
                }
            }

            // If damage remains, loop to next location; if not, be sure to stop
            // here because we may need to refer back to the last *damaged*
            // location again later. (This is safe because at damage <= 0 the
            // loop terminates anyway.)
            if (damage > 0) {
                hit = nextHit;
            }
            if (damageIS) {
                wasDamageIS = true;
                damageIS = false;
            }
        }
        // Mechs using EI implants take pilot damage each time a hit
        // inflicts IS damage
        if (tookInternalDamage
            && ((te instanceof Mech) || (te instanceof Protomech))
            && te.hasActiveEiCockpit()) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(5075);
            r.subject = te.getId();
            r.addDesc(te);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 7);
            r.indent(2);
            vDesc.add(r);
            if (roll < 7) {
                vDesc.addAll(damageCrew(te, 1));
            }
        }

        // if using VDNI (but not buffered), check for damage on an internal hit
        if (tookInternalDamage
            && te.getCrew().getOptions().booleanOption("vdni")
            && !te.getCrew().getOptions().booleanOption("bvdni")
            && !te.getCrew().getOptions().booleanOption("pain_shunt")) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(3580);
            r.subject = te.getId();
            r.addDesc(te);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 8);
            r.indent(2);
            vDesc.add(r);
            if (roll >= 8) {
                vDesc.addAll(damageCrew(te, 1));
            }
        }

        // TacOps p.78 Ammo booms can hurt other units in same and adjcent hexes
        // But, this does not apply to CASE'd units and it only applies if the
        // ammo explosion
        // destroyed the unit
        if (ammoExplosion
            && game.getOptions().booleanOption("tacops_ammunition")
            // For 'Mechs we care whether there was CASE specifically in the
            // location that went boom...
            && !(te.locationHasCase(hit.getLocation()) || te.hasCASEII(hit
                                                                               .getLocation()))
            // ...but vehicles and ASFs just have one CASE item for the
            // whole unit, so we need to look whether there's CASE anywhere
            // at all.
            && !(((te instanceof Tank) || (te instanceof Aero)) && te
                .hasCase()) && (te.isDestroyed() || te.isDoomed())
            && (damage_orig > 0) && ((damage_orig / 10) > 0)) {
            Report.addNewline(vDesc);
            r = new Report(5068, Report.PUBLIC);
            r.subject = te.getId();
            r.addDesc(te);
            r.indent(2);
            vDesc.add(r);
            Report.addNewline(vDesc);
            r = new Report(5400, Report.PUBLIC);
            r.subject = te.getId();
            r.indent(2);
            vDesc.add(r);
            int[] damages = {(int) Math.floor(damage_orig / 10),
                             (int) Math.floor(damage_orig / 20)};
            doExplosion(damages, false, te.getPosition(), true, vDesc, null, 5,
                        te.getId());
            Report.addNewline(vDesc);
            r = new Report(5410, Report.PUBLIC);
            r.subject = te.getId();
            r.indent(2);
            vDesc.add(r);
        }

        // This flag indicates the hit was directly to IS
        if (wasDamageIS) {
            Report.addNewline(vDesc);
        }
        return vDesc;
    }

    /**
     * Check to see if the entity's engine explodes. Rules for ICE explosions
     * are different to fusion engines.
     *
     * @param en    - the <code>Entity</code> in question. This value must not be
     *              <code>null</code>.
     * @param vDesc - the <code>Vector</code> that this function should add its
     *              <code>Report<code>s to.  It may be empty, but not
     *              <code>null</code>.
     * @param hits  - the number of criticals on the engine
     * @return <code>true</code> if the unit's engine exploded,
     * <code>false</code> if not.
     */
    private boolean checkEngineExplosion(Entity en, Vector<Report> vDesc,
                                         int hits) {
        if (!(en instanceof Mech) && !(en instanceof QuadMech)
            && !(en instanceof BipedMech) && !(en instanceof Aero)
            && !(en instanceof Tank)) {
            return false;
        }
        // If this method gets called for an entity that's already destroyed or
        // that
        // hasn't taken any actual engine hits this phase yet, do nothing.
        if (en.isDestroyed() || (en.engineHitsThisPhase <= 0)) {
            return false;
        }
        int explosionBTH = 10;
        int hitsPerRound = 4;
        Engine engine = null;

        if (en instanceof Mech) {
            engine = ((Mech) en).getEngine();
        } else if (en instanceof Tank) {
            explosionBTH = 12;
            hitsPerRound = 1;
            engine = ((Tank) en).getEngine();
        } else {
            engine = ((Aero) en).getEngine();
            explosionBTH = 12;
            hitsPerRound = 1;
        }

        // Non mechs and mechs that already rolled are safe
        if (en.rolledForEngineExplosion || !(en instanceof Mech)) {
            return false;
        }
        // ICE can always explode and roll every time hit
        if (engine.isFusion()
            && (!game.getOptions()
                     .booleanOption("tacops_engine_explosions") || (en.engineHitsThisPhase < hitsPerRound))) {
            return false;
        }
        if (!engine.isFusion()) {
            switch (hits) {
                case 0:
                    return false;
                case 1:
                    explosionBTH = 10;
                    break;
                case 2:
                    explosionBTH = 7;
                    break;
                case 3:
                default:
                    explosionBTH = 4;
                    break;
            }
        }
        int explosionRoll = Compute.d6(2);
        boolean didExplode = explosionRoll >= explosionBTH;

        Report r;
        r = new Report(6150);
        r.subject = en.getId();
        r.indent(2);
        r.addDesc(en);
        r.add(en.engineHitsThisPhase);
        vDesc.addElement(r);
        r = new Report(6155);
        r.subject = en.getId();
        r.indent(2);
        r.add(explosionBTH);
        r.add(explosionRoll);
        vDesc.addElement(r);

        if (!didExplode) {
            // whew!
            if (engine.isFusion()) {
                en.rolledForEngineExplosion = true;
            }
            // fusion engines only roll 1/phase but ICE roll every time damaged
            r = new Report(6160);
            r.subject = en.getId();
            r.indent(2);
            vDesc.addElement(r);
        } else {
            en.rolledForEngineExplosion = true;
            r = new Report(6165, Report.PUBLIC);
            r.subject = en.getId();
            r.indent(2);
            vDesc.addElement(r);
            vDesc.addAll(destroyEntity(en, "engine explosion", false, false));
            // kill the crew
            en.getCrew().setDoomed(true);

            // This is a hack so MM.NET marks the mech as not salvageable
            if (en instanceof Mech) {
                en.destroyLocation(Mech.LOC_CT);
            }

            // ICE explosions don't hurt anyone else, but fusion do
            if (engine.isFusion()) {
                int engineRating = en.getEngine().getRating();
                Report.addNewline(vDesc);
                r = new Report(5400, Report.PUBLIC);
                r.subject = en.getId();
                r.indent(2);
                vDesc.add(r);

                if (en instanceof Mech) {
                    Mech mech = (Mech) en;
                    if (mech.isAutoEject()
                        && (!game.getOptions().booleanOption(
                            "conditional_ejection") || (game
                                                                .getOptions().booleanOption(
                                    "conditional_ejection") && mech
                                                                .isCondEjectEngine()))) {
                        vDesc.addAll(ejectEntity(en, true));
                    }
                }

                doFusionEngineExplosion(engineRating, en.getPosition(), vDesc,
                                        null);
                Report.addNewline(vDesc);
                r = new Report(5410, Report.PUBLIC);
                r.subject = en.getId();
                r.indent(2);
                vDesc.add(r);

            }
        }

        return didExplode;
    }

    /**
     * Extract explosion functionality for generalized explosions in areas.
     */
    public void doFusionEngineExplosion(int engineRating, Coords position,
                                        Vector<Report> vDesc, Vector<Integer> vUnits) {
        int[] myDamages = {engineRating, (engineRating / 10),
                           (engineRating / 20), (engineRating / 40)};
        doExplosion(myDamages, true, position, false, vDesc, vUnits, 5, -1);
    }

    /**
     * General function to cause explosions in areas.
     */
    public void doExplosion(int damage, int degredation,
                            boolean autoDestroyInSameHex, Coords position,
                            boolean allowShelter, Vector<Report> vDesc, Vector<Integer> vUnits,
                            int excludedUnitId) {

        if (degredation < 1) {
            return;
        }

        int[] myDamages = new int[damage / degredation];

        if (myDamages.length < 1) {
            return;
        }

        myDamages[0] = damage;
        for (int x = 1; x < myDamages.length; x++) {
            myDamages[x] = myDamages[x - 1] - degredation;
        }
        doExplosion(myDamages, autoDestroyInSameHex, position, allowShelter,
                    vDesc, vUnits, 5, excludedUnitId);
    }

    /**
     * General function to cause explosions in areas.
     */
    public void doExplosion(int[] damages, boolean autoDestroyInSameHex,
                            Coords position, boolean allowShelter, Vector<Report> vDesc,
                            Vector<Integer> vUnits, int clusterAmt, int excludedUnitId) {
        if (vDesc == null) {
            vDesc = new Vector<Report>();
        }

        if (vUnits == null) {
            vUnits = new Vector<Integer>();
        }

        Report r;
        HashSet<Entity> entitiesHit = new HashSet<Entity>();

        // We need to damage buildings.
        Enumeration<Building> bldgs = game.getBoard().getBuildings();
        while (bldgs.hasMoreElements()) {
            final Building bldg = bldgs.nextElement();

            // Lets find the closest hex from the building.
            Enumeration<Coords> hexes = bldg.getCoords();

            while (hexes.hasMoreElements()) {
                final Coords coords = hexes.nextElement();
                int dist = position.distance(coords);
                if (dist < damages.length) {
                    Vector<Report> buildingReport = damageBuilding(bldg,
                                                                   damages[dist], coords);
                    for (Report report : buildingReport) {
                        report.type = Report.PUBLIC;
                    }
                    vDesc.addAll(buildingReport);
                }
            }
        }

        // Now we damage people near the explosion.
        ArrayList<Entity> loaded = new ArrayList<Entity>();
        for (Iterator<Entity> ents = game.getEntities(); ents.hasNext();) {
            Entity entity = ents.next();

            if (entitiesHit.contains(entity)) {
                continue;
            }

            if (entity.getId() == excludedUnitId) {
                continue;
            }

            if (entity.isDestroyed() || !entity.isDeployed()) {
                // FIXME
                // IS this the behavior we want?
                // This means, incidentally, that salvage is never affected by
                // explosions
                // as long as it was destroyed before the explosion.
                continue;
            }

            // We are going to assume that explosions are on the ground here so
            // flying entities should be
            // unaffected
            if (entity.isAirborne()) {
                continue;
            }

            if ((entity instanceof MechWarrior)
                && !((MechWarrior) entity).hasLanded()) {
                // MechWarrior is still up in the air ejecting hence safe
                // from this explosion.
                continue;
            }

            Coords entityPos = entity.getPosition();
            if (entityPos == null) {
                // maybe its loaded?
                Entity transport = game.getEntity(entity.getTransportId());
                if ((transport != null) && !transport.isAirborne()) {
                    loaded.add(entity);
                }
                continue;
            }
            int range = position.distance(entityPos);

            if (range >= damages.length) {
                // Yeah, this is fine. It's outside the blast radius.
                continue;
            }

            // We might need to nuke everyone in the explosion hex. If so...
            if ((range == 0) && autoDestroyInSameHex) {
                // Add the reports
                vDesc.addAll(destroyEntity(entity, "explosion proximity",
                                           false, false));

                // Add it to the "blasted units" list
                vUnits.add(entity.getId());

                // Kill the crew
                entity.getCrew().setDoomed(true);

                entitiesHit.add(entity);

                continue;
            }

            int damage = damages[range];

            if (allowShelter
                && canShelter(entityPos, position, entity.relHeight())) {
                if (isSheltered()) {
                    r = new Report(6545);
                    r.addDesc(entity);
                    r.subject = entity.getId();
                    vDesc.addElement(r);
                    continue;
                }
                // If shelter is allowed but didn't work, report that.
                r = new Report(6546);
                r.subject = entity.getId();
                r.addDesc(entity);
                vDesc.addElement(r);
            }

            // Since it's taking damage, add it to the list of units hit.
            vUnits.add(entity.getId());

            r = new Report(6175);
            r.subject = entity.getId();
            r.indent(2);
            r.addDesc(entity);
            r.add(damage);
            vDesc.addElement(r);

            while (damage > 0) {
                int cluster = Math.min(clusterAmt, damage);
                int table = ToHitData.HIT_NORMAL;
                if (entity instanceof Protomech) {
                    table = ToHitData.HIT_SPECIAL_PROTO;
                }
                HitData hit = entity.rollHitLocation(table,
                                                     Compute.targetSideTable(position, entity));
                vDesc.addAll(damageEntity(entity, hit, cluster, false,
                                          DamageType.IGNORE_PASSENGER, false, true));
                damage -= cluster;
            }
            Report.addNewline(vDesc);
        }

        // now deal with loaded units...
        for (Entity e : loaded) {
            // This can be null, if the transport died from damage
            final Entity transporter = game.getEntity(e.getTransportId());
            if ((transporter == null)
                || transporter.getExternalUnits().contains(e)) {
                // Its external or transport was destroyed - hit it.
                final Coords entityPos = (transporter == null ? e.getPosition()
                                                              : transporter.getPosition());
                final int range = position.distance(entityPos);

                if (range >= damages.length) {
                    // Yeah, this is fine. It's outside the blast radius.
                    continue;
                }

                int damage = damages[range];
                if (allowShelter) {
                    final int absHeight = (transporter == null ? e.relHeight()
                                                               : transporter.relHeight());
                    if ((entityPos != null)
                        && canShelter(entityPos, position, absHeight)) {
                        if (isSheltered()) {
                            r = new Report(6545);
                            r.addDesc(e);
                            r.subject = e.getId();
                            vDesc.addElement(r);
                            continue;
                        }
                        // If shelter is allowed but didn't work, report that.
                        r = new Report(6546);
                        r.subject = e.getId();
                        r.addDesc(e);
                        vDesc.addElement(r);
                    }
                }
                // No shelter
                // Since it's taking damage, add it to the list of units hit.
                vUnits.add(e.getId());

                r = new Report(6175);
                r.subject = e.getId();
                r.indent(2);
                r.addDesc(e);
                r.add(damage);
                vDesc.addElement(r);

                while (damage > 0) {
                    int cluster = Math.min(5, damage);
                    int table = ToHitData.HIT_NORMAL;
                    if (e instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    }
                    HitData hit = e
                            .rollHitLocation(table, ToHitData.SIDE_FRONT);
                    vDesc.addAll(damageEntity(e, hit, cluster, false,
                                              DamageType.IGNORE_PASSENGER, false, true));
                    damage -= cluster;
                }
                Report.addNewline(vDesc);
            }
        }
    }

    /**
     * Check if an Entity of the passed height can find shelter from a nukeblast
     *
     * @param entityPosition  the <code>Coords</code> the Entity is at
     * @param position        the <code>Coords</code> of the explosion
     * @param entityAbsHeight the <code>int</code> height of the entity
     * @return a <code>boolean</code> value indicating if the entity of the
     * given height can find shelter
     */
    public boolean canShelter(Coords entityPosition, Coords position,
                              int entityAbsHeight) {
        // What is the next hex in the direction of the blast?
        Coords shelteringCoords = Coords.nextHex(entityPosition, position);
        IHex shelteringHex = game.getBoard().getHex(shelteringCoords);

        // This is an error condition. It really shouldn't ever happen.
        if (shelteringHex == null) {
            return false;
        }

        // Now figure out the height to which that hex will provide shelter.
        // It's worth noting, this assumes that any building in the hex has
        // already survived the bomb blast. In the case where a building
        // won't survive the blast but hasn't actually taken the damage
        // yet, this will be wrong.
        int shelterLevel = shelteringHex.floor();
        if (shelteringHex.containsTerrain(Terrains.BUILDING)) {
            shelterLevel = shelteringHex.ceiling();
        }

        // Get the absolute height of the unit relative to level 0.
        entityAbsHeight += game.getBoard().getHex(entityPosition).surface();

        // Now find the height that needs to be sheltered, and compare.
        if (entityAbsHeight < shelterLevel) {
            return true;
        }

        // Well, if the above isn't true... Give up.
        return false;
    }

    /**
     * @return true if the unit succeeds a shelter roll
     */
    private boolean isSheltered() {
        if (Compute.d6(2) >= 9) {
            return true;
        }
        return false;
    }

    /**
     * add a nuke to be exploded in the next weapons attack phase
     *
     * @param nuke the nuke paramater either 3 or 6 ints 0 and 1 being X and Y
     *             when 3 ints: third is nuketype (from HS:3070) if 6 ints: third
     *             is damage fourth is degradation fifth is secondary radius
     *             sixth is crater depth
     */
    public void addScheduledNuke(int[] nuke) {
        scheduledNukes.add(nuke);
    }

    /**
     * explode any scheduled nukes
     */
    private void resolveScheduledNukes() {
        for (int[] nuke : scheduledNukes) {
            if (nuke.length == 3) {
                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1),
                                   nuke[2], vPhaseReport);
            }
            if (nuke.length == 6) {
                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1),
                                   nuke[2], nuke[3], nuke[4], nuke[5], vPhaseReport);
            }
        }
        scheduledNukes.clear();
    }

    /**
     * do a nuclear explosion
     *
     * @param position
     * @param nukeType
     * @param vDesc
     */
    public void doNuclearExplosion(Coords position, int nukeType,
                                   Vector<Report> vDesc) {
        // Throws a nuke for one of the pre-defined types.
        switch (nukeType) {
            case 0:
            case 1:
                doNuclearExplosion(position, 100, 5, 40, 0, vDesc);
                break;
            case 2:
                doNuclearExplosion(position, 1000, 23, 86, 1, vDesc);
                break;
            case 3:
                doNuclearExplosion(position, 10000, 109, 184, 3, vDesc);
                break;
            case 4:
                doNuclearExplosion(position, 100000, 505, 396, 5, vDesc);
                break;
            default:
                // This isn't a valid nuke type by HS:3070 rules.
                // And since that's our only current source...
                return;
        }
    }

    /**
     * explode a nuke
     *
     * @param position
     * @param baseDamage
     * @param degredation
     * @param secondaryRadius
     * @param craterDepth
     * @param vDesc
     */
    public void doNuclearExplosion(Coords position, int baseDamage,
                                   int degredation, int secondaryRadius, int craterDepth,
                                   Vector<Report> vDesc) {
        // Just in case.
        if (vDesc == null) {
            vDesc = new Vector<Report>();
        }

        // First, crater the terrain.
        // All terrain, units, buildings... EVERYTHING in here is just gone.
        // Gotta love nukes.
        Report r = new Report(1215, Report.PUBLIC);

        r.indent();
        r.add(position.getBoardNum(), true);
        vDesc.add(r);

        int curDepth = craterDepth;
        int range = 0;
        while (range < (2 * craterDepth)) {
            // Get the set of hexes at this range.
            Enumeration<Coords> hexSet = game.getBoard().getHexesAtDistance(
                    position, range);

            // Iterate through the hexes.
            while (hexSet.hasMoreElements()) {
                Coords myHexCoords = hexSet.nextElement();
                IHex myHex = game.getBoard().getHex(myHexCoords);
                // In each hex, first, sink the terrain if necessary.
                myHex.setLevel((myHex.getLevel() - curDepth));

                // Then, remove ANY terrains here.
                // I mean ALL of them; they're all just gone.
                // No ruins, no water, no rough, no nothing.
                if (myHex.containsTerrain(Terrains.WATER)) {
                    myHex.setLevel(myHex.floor());
                }
                myHex.removeAllTerrains();
                myHex.clearExits();

                sendChangedHex(myHexCoords);
            }

            // Lastly, if the next distance is a multiple of 2...
            // The crater depth goes down one.
            if ((range > 0) && ((range % 2) == 0)) {
                curDepth--;
            }

            // Now that the hexes are dealt with, increment the distance.
            range++;
        }

        // This is technically part of cratering, but...
        // Now we destroy all the units inside the cratering range.
        for (Entity entity : game.getEntitiesVector()) {
            // loaded units and off board units don't have a position,
            // so we don't count 'em here
            if ((entity.getTransportId() != Entity.NONE)
                || (entity.getPosition() == null)) {
                continue;
            }

            // If it's too far away for this...
            if (position.distance(entity.getPosition()) >= range) {
                continue;
            }

            // If it's already destroyed...
            if (entity.isDestroyed()) {
                continue;
            }

            vDesc.addAll(destroyEntity(entity, "nuclear explosion proximity",
                                       false, false));
            // Kill the crew
            entity.getCrew().setDoomed(true);
        }

        // Then, do actual blast damage.
        // Use the standard blast function for this.
        Vector<Report> tmpV = new Vector<Report>();
        Vector<Integer> blastedUnitsVec = new Vector<Integer>();
        doExplosion(baseDamage, degredation, true, position, true, tmpV,
                    blastedUnitsVec, -1);
        Report.indentAll(tmpV, 2);
        vDesc.addAll(tmpV);

        // Everything that was blasted by the explosion has to make a piloting
        // check at +6.
        for (int i : blastedUnitsVec) {
            Entity o = game.getEntity(i);
            if (o instanceof Mech) {
                Mech bm = (Mech) o;
                // Needs a piloting check at +6 to avoid falling over.
                // Obviously not if it's already prone, though.
                if (!bm.isProne()) {
                    game.addPSR(new PilotingRollData(bm.getId(), 6,
                                                     "hit by nuclear blast"));
                }
            } else if (o instanceof VTOL) {
                // Needs a piloting check at +6 to avoid crashing.
                // Wheeeeee!
                VTOL vt = (VTOL) o;

                // Check only applies if it's in the air.
                // FIXME: is this actually correct? What about
                // buildings/bridges?
                if (vt.getElevation() > 0) {
                    game.addPSR(new PilotingRollData(vt.getId(), 6,
                                                     "hit by nuclear blast"));
                }
            } else if (o instanceof Tank) {
                // As per official answer on the rules questions board...
                // Needs a piloting check at +6 to avoid a 1-level fall...
                // But ONLY if a hover-tank.
                // FIXME
            }
        }

        // Just get rid of it for the balance of the function...
        tmpV = null;

        // This ISN'T part of the blast, but if there's ANYTHING in the ground
        // zero hex, destroy it.
        Building tmpB = game.getBoard().getBuildingAt(position);
        if (tmpB != null) {
            r = new Report(2415);
            r.add(tmpB.getName());
            addReport(r);
            tmpB.setCurrentCF(0, position);
        }
        IHex gzHex = game.getBoard().getHex(position);
        if (gzHex.containsTerrain(Terrains.WATER)) {
            gzHex.setLevel(gzHex.floor());
        }
        gzHex.removeAllTerrains();

        // Next, for whatever's left, do terrain effects
        // such as clearing, roughing, and boiling off water.
        boolean damageFlag = true;
        int damageAtRange = baseDamage - (degredation * range);
        if (damageAtRange > 0) {
            for (int x = range; damageFlag; x++) {
                // Damage terrain as necessary.
                // Get all the hexes, and then iterate through them.
                Enumeration<Coords> hexSet = game.getBoard()
                                                 .getHexesAtDistance(position, x);

                // Iterate through the hexes.
                while (hexSet.hasMoreElements()) {
                    Coords myHexCoords = hexSet.nextElement();
                    IHex myHex = game.getBoard().getHex(myHexCoords);

                    // For each 3000 damage, water level is reduced by 1.
                    if ((damageAtRange >= 3000)
                        && (myHex.containsTerrain(Terrains.WATER))) {
                        int numCleared = damageAtRange / 3000;
                        int oldLevel = myHex.terrainLevel(Terrains.WATER);
                        myHex.removeTerrain(Terrains.WATER);
                        if (oldLevel > numCleared) {
                            myHex.setLevel(myHex.getLevel()
                                               - numCleared);
                            myHex.addTerrain(new Terrain(Terrains.WATER,
                                                         oldLevel - numCleared));
                        } else {
                            myHex.setLevel(myHex.getLevel() - oldLevel);
                        }
                    }

                    // ANY non-water hex that takes 200 becomes rough.
                    if ((damageAtRange >= 200)
                        && (!myHex.containsTerrain(Terrains.WATER))) {
                        myHex.removeAllTerrains();
                        myHex.clearExits();
                        myHex.addTerrain(new Terrain(Terrains.ROUGH, 1));
                    } else if ((damageAtRange >= 20)
                               && ((myHex.containsTerrain(Terrains.WOODS)) || (myHex
                            .containsTerrain(Terrains.JUNGLE)))) {
                        // Each 20 clears woods by 1 level.
                        int numCleared = damageAtRange / 20;
                        int terrainType = (myHex
                                                   .containsTerrain(Terrains.WOODS) ? Terrains.WOODS
                                                                                    : Terrains.JUNGLE);
                        int oldLevel = myHex.terrainLevel(terrainType);
                        myHex.removeTerrain(terrainType);
                        if (oldLevel > numCleared) {
                            myHex.addTerrain(new Terrain(terrainType, oldLevel
                                                                      - numCleared));
                        }
                    }

                    sendChangedHex(myHexCoords);
                }

                // Initialize for the next iteration.
                damageAtRange = baseDamage - ((degredation * x) + 1);

                // If the damage is less than 20, it has no terrain effect.
                if (damageAtRange < 20) {
                    damageFlag = false;
                }
            }
        }

        // Lastly, do secondary effects.
        for (Entity entity : game.getEntitiesVector()) {

            // loaded units and off board units don't have a position,
            // so we don't count 'em here
            if ((entity.getTransportId() != Entity.NONE)
                || (entity.getPosition() == null)) {
                continue;
            }

            // If it's already destroyed...
            if ((entity.isDoomed()) || (entity.isDestroyed())) {
                continue;
            }

            // If it's too far away for this...
            if (position.distance(entity.getPosition()) > secondaryRadius) {
                continue;
            }

            // Actually do secondary effects against it.
            // Since the effects are unit-dependant, we'll just define it in the
            // entity.
            applySecondaryNuclearEffects(entity, position, vDesc);
        }

        // All right. We're done.
        r = new Report(1216, Report.PUBLIC);
        r.indent();
        r.newlines = 2;
        vDesc.add(r);
    }

    /**
     * Handles secondary effects from nuclear blasts against all units in range.
     *
     * @param entity   The entity to affect.
     * @param position The coordinates of the nuclear blast, for to-hit directions.
     * @param vDesc    a description vector to use for reports.
     */
    public void applySecondaryNuclearEffects(Entity entity, Coords position,
                                             Vector<Report> vDesc) {
        // If it's already destroyed, give up. We really don't care.
        if (entity.isDestroyed()) {
            return;
        }

        // Check to see if the infantry is in a protective structure.
        boolean inHardenedBuilding = (Compute.isInBuilding(game, entity) && (game
                                                                                     .getBoard().getHex(entity.getPosition())
                                                                                     .terrainLevel(Terrains.BUILDING)
                                                                             == 4));

        // Roll 2d6.
        int roll = Compute.d6(2);

        Report r = new Report(6555);
        r.subject = entity.getId();
        r.add(entity.getDisplayName());
        r.add(roll);

        // If they are in protective structure, add 2 to the roll.
        if (inHardenedBuilding) {
            roll += 2;
            r.add(" + 2 (unit is in hardened building)");
        } else {
            r.add("");
        }

        // Also, if the entity is "hardened" against EMI, it gets a +2.
        // For these purposes, I'm going to hand this off to the Entity itself
        // to tell us.
        // Right now, it IS based purely on class, but I won't rule out the idea
        // of
        // "nuclear hardening" as equipment for a support vehicle, for example.
        if (entity.isNuclearHardened()) {
            roll += 2;
            r.add(" + 2 (unit is hardened against EMI)");
        } else {
            r.add("");
        }

        r.indent(2);
        vDesc.add(r);

        // Now, compare it to the table, and apply the effects.
        if (roll <= 4) {
            // The unit is destroyed.
            // Sucks, doesn't it?
            // This applies to all units.
            // Yup, just sucks.
            vDesc.addAll(destroyEntity(entity,
                                       "nuclear explosion secondary effects", false, false));
            // Kill the crew
            entity.getCrew().setDoomed(true);
        } else if (roll <= 6) {
            if (entity instanceof BattleArmor) {
                // It takes 50% casualties, rounded up.
                BattleArmor myBA = (BattleArmor) entity;
                int numDeaths = (int) (Math.ceil((myBA
                        .getNumberActiverTroopers())) / 2.0);
                for (int x = 0; x < numDeaths; x++) {
                    vDesc.addAll(applyCriticalHit(entity, 0, null, false, 0,
                                                  false));
                }
            } else if (entity instanceof Infantry) {
                // Standard infantry are auto-killed in this band, unless
                // they're in a building.
                if (game.getBoard().getHex(entity.getPosition())
                        .containsTerrain(Terrains.BUILDING)) {
                    // 50% casualties, rounded up.
                    int damage = (int) (Math.ceil((((Infantry) entity)
                            .getInternal(Infantry.LOC_INFANTRY)) / 2.0));
                    vDesc.addAll(damageEntity(entity, new HitData(
                            Infantry.LOC_INFANTRY), damage, true));
                } else {
                    vDesc.addAll(destroyEntity(entity,
                                               "nuclear explosion secondary effects", false, false));
                    entity.getCrew().setDoomed(true);
                }
            } else if (entity instanceof Tank) {
                // All vehicles suffer two critical hits...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                    entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));
                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                            entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));

                // ...and a Crew Killed hit.
                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,
                                                                          Tank.CRIT_CREW_KILLED), false, 0, false));
            } else if ((entity instanceof Mech)
                       || (entity instanceof Protomech)) {
                // 'Mechs suffer two critical hits...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                    entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));
                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                            entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));

                // and four pilot hits.
                vDesc.addAll(damageCrew(entity, 4));
            } else {
                // Buildings and gun emplacements and such are only affected by
                // the EMI.
                // No auto-crits or anything.
            }
        } else if (roll <= 10) {
            if (entity instanceof BattleArmor) {
                // It takes 25% casualties, rounded up.
                BattleArmor myBA = (BattleArmor) entity;
                int numDeaths = (int) (Math.ceil(((myBA
                        .getNumberActiverTroopers())) / 4.0));
                for (int x = 0; x < numDeaths; x++) {
                    vDesc.addAll(applyCriticalHit(entity, 0, null, false, 0,
                                                  false));
                }
            } else if (entity instanceof Infantry) {
                if (game.getBoard().getHex(entity.getPosition())
                        .containsTerrain(Terrains.BUILDING)) {
                    // 25% casualties, rounded up.
                    int damage = (int) (Math.ceil((((Infantry) entity)
                            .getInternal(Infantry.LOC_INFANTRY)) / 4.0));
                    vDesc.addAll(damageEntity(entity, new HitData(
                            Infantry.LOC_INFANTRY), damage, true));
                } else {
                    // 50% casualties, rounded up.
                    int damage = (int) (Math.ceil((((Infantry) entity)
                            .getInternal(Infantry.LOC_INFANTRY)) / 2.0));
                    vDesc.addAll(damageEntity(entity, new HitData(
                            Infantry.LOC_INFANTRY), damage, true));
                }
            } else if (entity instanceof Tank) {
                // It takes one crit...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                    entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));

                // Plus a Crew Stunned critical.
                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,
                                                                          Tank.CRIT_CREW_STUNNED), false, 0, false));
            } else if ((entity instanceof Mech)
                       || (entity instanceof Protomech)) {
                // 'Mechs suffer a critical hit...
                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                    entity.sideTable(position));
                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(),
                                               hd.isRear(), 0));

                // and two pilot hits.
                vDesc.addAll(damageCrew(entity, 2));
            } else {
                // Buildings and gun emplacements and such are only affected by
                // the EMI.
                // No auto-crits or anything.
            }
        }
        // If it's 11+, there are no secondary effects beyond EMI.
        // Lucky bastards.

        // And lastly, the unit is now affected by electromagnetic interference.
        entity.setEMI(true);
    }

    /**
     * Apply a single critical hit. The following private member of Server are
     * accessed from this function, preventing it from being factored out of the
     * Server class: destroyEntity() destroyLocation() checkEngineExplosion()
     * damageCrew() explodeEquipment() game
     *
     * @param en               the <code>Entity</code> that is being damaged. This value may
     *                         not be <code>null</code>.
     * @param loc              the <code>int</code> location of critical hit. This value may
     *                         be <code>Entity.NONE</code> for hits to <code>Tank</code>s and
     *                         for hits to a <code>Protomech</code> torso weapon.
     * @param cs               the <code>CriticalSlot</code> being damaged. This value may
     *                         not be <code>null</code>. For critical hits on a
     *                         <code>Tank</code>, the index of the slot should be the index
     *                         of the critical hit table.
     * @param secondaryEffects the <code>boolean</code> flag that indicates whether to allow
     *                         critical hits to cause secondary effects (such as triggering
     *                         an ammo explosion, sending hovercraft to watery graves, or
     *                         damaging Protomech torso weapons). This value is normally
     *                         <code>true</code>, but it will be <code>false</code> when the
     *                         hit is being applied from a saved game or scenario.
     * @param damageCaused     the amount of damage causing this critical.
     * @param isCapital        whether it was capital scale damage that caused critical
     */
    public Vector<Report> applyCriticalHit(Entity en, int loc, CriticalSlot cs,
                                           boolean secondaryEffects, int damageCaused, boolean isCapital) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // Handle hits on "critical slots" of tanks.
        if (en instanceof Tank) {
            Tank t = (Tank) en;
            HitData hit;
            switch (cs.getIndex()) {
                case Tank.CRIT_NONE:
                    // no effect
                    r = new Report(6005);
                    r.subject = t.getId();
                    vDesc.add(r);
                    break;
                case Tank.CRIT_AMMO:
                    // ammo explosion
                    r = new Report(6610);
                    r.subject = t.getId();
                    vDesc.add(r);
                    int damage = 0;
                    for (Mounted m : t.getAmmo()) {
                        // Don't include ammo of one-shot weapons.
                        if (m.getLocation() == Entity.LOC_NONE) {
                            continue;
                        }
                        m.setHit(true);
                        int tmp = m.getHittableShotsLeft()
                                  * ((AmmoType) m.getType()).getDamagePerShot()
                                  * ((AmmoType) m.getType()).getRackSize();
                        m.setShotsLeft(0);
                        // non-explosive ammo can't explode
                        if (!m.getType().isExplosive(m)) {
                            continue;
                        }
                        damage += tmp;
                        r = new Report(6390);
                        r.subject = t.getId();
                        r.add(m.getName());
                        r.add(tmp);
                        vDesc.add(r);
                    }
                    hit = new HitData(loc);
                    vDesc.addAll(damageEntity(t, hit, damage, true));
                    break;
                case Tank.CRIT_CARGO:
                    // Cargo/infantry damage
                    r = new Report(6615);
                    r.subject = t.getId();
                    vDesc.add(r);
                    List<Entity> passengers = t.getLoadedUnits();
                    if (passengers.size() > 0) {
                        Entity target = passengers.get(Compute.randomInt(passengers
                                                                                 .size()));
                        hit = target.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                        vDesc.addAll(damageEntity(target, hit, damageCaused));
                    }
                    break;
                case Tank.CRIT_COMMANDER:
                    if (en.getCrew().getOptions().booleanOption("vdni")
                        || en.getCrew().getOptions().booleanOption("bvdni")) {
                        r = new Report(6191);
                        r.subject = t.getId();
                        vDesc.add(r);
                        vDesc.addAll(damageCrew(en, 1));
                    } else {
                        if (en.getCrew().getOptions().booleanOption("pain_shunt")
                            && !t.isCommanderHitPS()) {
                            r = new Report(6606);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.setCommanderHitPS(true);
                        } else {
                            r = new Report(6605);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.setCommanderHit(true);
                        }
                    }
                    // fall through here, because effects of crew stunned also
                    // apply
                case Tank.CRIT_CREW_STUNNED:
                    if (en.getCrew().getOptions().booleanOption("vdni")
                        || en.getCrew().getOptions().booleanOption("bvdni")) {
                        r = new Report(6191);
                        r.subject = t.getId();
                        vDesc.add(r);
                        vDesc.addAll(damageCrew(en, 1));
                    } else {
                        if (en.getCrew().getOptions().booleanOption("pain_shunt")
                            || en.getCrew().getOptions()
                                 .booleanOption("dermal_armor")) {
                            r = new Report(6186);
                            r.subject = t.getId();
                            vDesc.add(r);
                        } else {
                            t.stunCrew();
                            r = new Report(6185);
                            r.add(t.getStunnedTurns() - 1);
                            r.subject = t.getId();
                            vDesc.add(r);
                        }
                    }
                    break;
                case Tank.CRIT_DRIVER:
                    if (en.getCrew().getOptions().booleanOption("vdni")
                        || en.getCrew().getOptions().booleanOption("bvdni")) {
                        r = new Report(6191);
                        r.subject = t.getId();
                        vDesc.add(r);
                        vDesc.addAll(damageCrew(en, 1));
                    } else {
                        if (en.getCrew().getOptions().booleanOption("pain_shunt")
                            && !t.isDriverHitPS()) {
                            r = new Report(6601);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.setDriverHitPS(true);
                        } else {
                            r = new Report(6600);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.setDriverHit(true);
                        }
                    }
                    break;
                case Tank.CRIT_CREW_KILLED:
                    if (en.getCrew().getOptions().booleanOption("vdni")
                        || en.getCrew().getOptions().booleanOption("bvdni")) {
                        r = new Report(6191);
                        r.subject = t.getId();
                        vDesc.add(r);
                        vDesc.addAll(damageCrew(en, 1));
                    } else {
                        if (en.getCrew().getOptions().booleanOption("pain_shunt")
                            && !t.isCrewHitPS()) {
                            r = new Report(6191);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.setCrewHitPS(true);
                        } else {
                            r = new Report(6190);
                            r.subject = t.getId();
                            vDesc.add(r);
                            t.getCrew().setDoomed(true);
                            if (en.isAirborneVTOLorWIGE()) {
                                vDesc.addAll(crashVTOLorWiGE((Tank)en));
                            }
                        }
                    }
                    break;
                case Tank.CRIT_ENGINE:
                    r = new Report(6210);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.engineHit();
                    t.engineHitsThisPhase++;
                    boolean engineExploded = checkEngineExplosion(t, vDesc, 1);
                    if (engineExploded) {
                        vDesc.addAll(destroyEntity(en, "engine destruction", true,
                                                   true));
                        t.setSelfDestructing(false);
                        t.setSelfDestructInitiated(false);
                    }
                    if (t.isAirborneVTOLorWIGE()
                        && !(t.isDestroyed() || t.isDoomed())) {
                        t.immobilize();
                        vDesc.addAll(forceLandVTOLorWiGE(t));
                    }
                    break;
                case Tank.CRIT_FUEL_TANK:
                    r = new Report(6215);
                    r.subject = t.getId();
                    vDesc.add(r);
                    vDesc.addAll(destroyEntity(t, "fuel explosion", false, false));
                    break;
                case Tank.CRIT_SENSOR:
                    r = new Report(6620);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.setSensorHits(t.getSensorHits() + 1);
                    break;
                case Tank.CRIT_STABILIZER:
                    r = new Report(6625);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.setStabiliserHit(loc);
                    break;
                case Tank.CRIT_TURRET_DESTROYED:
                    r = new Report(6630);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.destroyLocation(t.getLocTurret());
                    vDesc.addAll(destroyEntity(t, "turret blown off", true, true));
                    break;
                case Tank.CRIT_TURRET_JAM:
                    if (t.isTurretEverJammed(loc)) {
                        r = new Report(6640);
                        r.subject = t.getId();
                        vDesc.add(r);
                        t.lockTurret(loc);
                        break;
                    }
                    r = new Report(6635);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.jamTurret(loc);
                    break;
                case Tank.CRIT_TURRET_LOCK:
                    r = new Report(6640);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.lockTurret(loc);
                    break;
                case Tank.CRIT_WEAPON_DESTROYED: {
                    r = new Report(6305);
                    r.subject = t.getId();
                    ArrayList<Mounted> weapons = new ArrayList<Mounted>();
                    for (Mounted weap : t.getWeaponList()) {
                        if ((weap.getLocation() == loc) && !weap.isHit()
                            && !weap.isDestroyed()) {
                            weapons.add(weap);
                        }
                    }
                    // sort weapons by BV
                    Collections.sort(weapons, new WeaponComparatorBV());
                    int roll = Compute.d6();
                    Mounted weapon;
                    if (roll < 4) {
                        // defender should choose, we'll just use the lowest BV
                        // weapon
                        weapon = weapons.get(weapons.size() - 1);
                    } else {
                        // attacker chooses, we'll use the highest BV weapon
                        weapon = weapons.get(0);
                    }
                    r.add(weapon.getName());
                    vDesc.add(r);
                    // explosive weapons e.g. gauss now explode
                    if (weapon.getType().isExplosive(weapon) && !weapon.isHit()
                        && !weapon.isDestroyed()) {
                        vDesc.addAll(explodeEquipment(t, loc, weapon));
                    }
                    weapon.setHit(true);
                    //Taharqa: We should also damage the critical slot, or
                    //MM and MHQ won't remember that this weapon is damaged on the MUL
                    //file
                    for (int i = 0; i < t.getNumberOfCriticals(loc); i++) {
                        CriticalSlot slot1 = t.getCritical(loc, i);
                        if ((slot1 == null) ||
                                (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                            continue;
                        }
                        Mounted mounted = slot1.getMount();
                        if (mounted.equals(weapon)) {
                            t.hitAllCriticals(loc, i);
                            break;
                        }
                    }
                    break;
                }
                case Tank.CRIT_WEAPON_JAM: {
                    r = new Report(6645);
                    r.subject = t.getId();
                    ArrayList<Mounted> weapons = new ArrayList<Mounted>();
                    for (Mounted weap : t.getWeaponList()) {
                        if ((weap.getLocation() == loc) && !weap.isJammed()
                            && !weap.jammedThisPhase() && !weap.isHit()
                            && !weap.isDestroyed()) {
                            weapons.add(weap);
                        }
                    }
                    if (weapons.size() > 0) {
                        Mounted weapon = weapons.get(Compute.randomInt(weapons
                                                                               .size()));
                        weapon.setJammed(true);
                        t.addJammedWeapon(weapon);
                        r.add(weapon.getName());
                        vDesc.add(r);
                    }
                    break;
                }
                case VTOL.CRIT_PILOT:
                    r = new Report(6650);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.setDriverHit(true);
                    PilotingRollData psr = t.getBasePilotingRoll();
                    psr.addModifier(0, "pilot injury");
                    if (!doSkillCheckInPlace(t, psr)) {
                        r = new Report(6675);
                        r.subject = t.getId();
                        r.addDesc(t);
                        vDesc.add(r);
                        boolean crash = true;
                        if (t.canGoDown()) {
                            t.setElevation(t.getElevation() - 1);
                            crash = !t.canGoDown();
                        }
                        if (crash) {
                            vDesc.addAll(crashVTOLorWiGE(t));
                        }
                    }
                    break;
                case VTOL.CRIT_COPILOT:
                    r = new Report(6655);
                    r.subject = t.getId();
                    vDesc.add(r);
                    t.setCommanderHit(true);
                    break;
                case VTOL.CRIT_ROTOR_DAMAGE: {
                    // Only resolve rotor crits if the rotor was actually still
                    // there.
                    if (!(t.isLocationBad(VTOL.LOC_ROTOR) || t
                            .isLocationDoomed(VTOL.LOC_ROTOR))) {
                        r = new Report(6660);
                        r.subject = t.getId();
                        vDesc.add(r);
                        t.setMotiveDamage(t.getMotiveDamage() + 1);
                        if (t.getMotiveDamage() >= t.getOriginalWalkMP()) {
                            t.immobilize();
                            if (t.isAirborneVTOLorWIGE()
                                // Don't bother with forcing a landing if
                                // we're already otherwise destroyed.
                                && !(t.isDestroyed() || t.isDoomed())) {
                                vDesc.addAll(forceLandVTOLorWiGE(t));
                            }
                        }
                    }
                    break;
                }
                case VTOL.CRIT_ROTOR_DESTROYED:
                    // Only resolve rotor crits if the rotor was actually still
                    // there. Note that despite the name this critical hit does
                    // not in itself physically destroy the rotor *location*
                    // (which would simply kill the VTOL).
                    if (!(t.isLocationBad(VTOL.LOC_ROTOR) || t
                            .isLocationDoomed(VTOL.LOC_ROTOR))) {
                        r = new Report(6670);
                        r.subject = t.getId();
                        vDesc.add(r);
                        t.immobilize();
                        vDesc.addAll(crashVTOLorWiGE(t, true));
                    }
                    break;
                case VTOL.CRIT_FLIGHT_STABILIZER:
                    // Only resolve rotor crits if the rotor was actually still
                    // there.
                    if (!(t.isLocationBad(VTOL.LOC_ROTOR) || t
                            .isLocationDoomed(VTOL.LOC_ROTOR))) {
                        r = new Report(6665);
                        r.subject = t.getId();
                        vDesc.add(r);
                        t.setStabiliserHit(VTOL.LOC_ROTOR);
                    }
                    break;
            }
        } else if (en instanceof Aero) {
            Aero a = (Aero) en;

            Jumpship js = new Jumpship();
            if (en instanceof Jumpship) {
                js = (Jumpship) en;
            } else {
                js = null;
            }

            switch (cs.getIndex()) {
                case Aero.CRIT_NONE:
                    // no effect
                    r = new Report(6005);
                    r.subject = a.getId();
                    vDesc.add(r);
                    break;
                case Aero.CRIT_FCS:
                    // Fire control system
                    r = new Report(9105);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setFCSHits(a.getFCSHits() + 1);
                    break;
                case Aero.CRIT_SENSOR:
                    // sensors
                    r = new Report(6620);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setSensorHits(a.getSensorHits() + 1);
                    break;
                case Aero.CRIT_AVIONICS:
                    // avionics
                    r = new Report(9110);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setAvionicsHits(a.getAvionicsHits() + 1);
                    if (a.isPartOfFighterSquadron()) {
                        game.addControlRoll(new PilotingRollData(
                                a.getTransportId(), 1, "avionics hit"));
                    } else if (a.isCapitalFighter()) {
                        game.addControlRoll(new PilotingRollData(a.getId(), 1,
                                                                 "avionics hit"));
                    } else {
                        game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                                 "avionics hit"));
                    }
                    break;
                case Aero.CRIT_CONTROL:
                    // force control roll
                    r = new Report(9115);
                    r.subject = a.getId();
                    vDesc.add(r);
                    if (a.isPartOfFighterSquadron()) {
                        game.addControlRoll(new PilotingRollData(
                                a.getTransportId(), 1, "critical hit"));
                    } else if (a.isCapitalFighter()) {
                        game.addControlRoll(new PilotingRollData(a.getId(), 1,
                                                                 "critical hit"));
                    } else {
                        game.addControlRoll(new PilotingRollData(a.getId(), 0,
                                                                 "critical hit"));
                    }
                    break;
                case Aero.CRIT_FUEL_TANK:
                    // fuel tank
                    r = new Report(9120);
                    r.subject = a.getId();
                    int boomTarget = 9;
                    if (a.hasQuirk("fragile_fuel")) {
                        boomTarget = 7;
                    }
                    if (a.isLargeCraft() && a.isClan()
                        && game.getOptions().booleanOption("stratops_harjel")) {
                        boomTarget = 11;
                    }
                    // check for possible explosion
                    int fuelroll = Compute.d6(2);
                    if (fuelroll > boomTarget) {
                        r.choose(true);
                        vDesc.add(r);
                        vDesc.addAll(destroyEntity(a, "fuel explosion", false,
                                                   false));
                    } else {
                        r.choose(false);
                        vDesc.add(r);
                    }
                    break;
                case Aero.CRIT_CREW:
                    // pilot hit
                    r = new Report(6650);
                    if (en.getCrew().getOptions().booleanOption("dermal_armor")) {
                        r = new Report(6651);
                        r.subject = a.getId();
                        vDesc.add(r);
                        break;
                    } else if (en.getCrew().getOptions()
                                 .booleanOption("tsm_implant")) {
                        r = new Report(6652);
                        r.subject = a.getId();
                        vDesc.add(r);
                        break;
                    }
                    if ((a instanceof SmallCraft) || (a instanceof Jumpship)) {
                        r = new Report(9197);
                    }
                    if (a.isLargeCraft() && a.isClan()
                        && game.getOptions().booleanOption("stratops_harjel")
                        && (a.getIgnoredCrewHits() < 2)) {
                        a.setIgnoredCrewHits(a.getIgnoredCrewHits() + 1);
                        r = new Report(9198);
                        r.subject = a.getId();
                        vDesc.add(r);
                        break;
                    }
                    r.subject = a.getId();
                    vDesc.add(r);
                    vDesc.addAll(damageCrew(a, 1));
                    // The pilot may have just expired.
                    if ((a.getCrew().isDead() || a.getCrew().isDoomed())
                        && !a.getCrew().isEjected()) {
                        vDesc.addAll(destroyEntity(a, "pilot death", true, true));
                    }
                    break;
                case Aero.CRIT_GEAR:
                    // landing gear
                    r = new Report(9125);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setGearHit(true);
                    break;
                case Aero.CRIT_BOMB:
                    // bomb destroyed
                    // go through bomb list and choose one
                    ArrayList<Mounted> bombs = new ArrayList<Mounted>();
                    for (Mounted bomb : a.getBombs()) {
                        if (bomb.getType().isHittable()
                            && (bomb.getHittableShotsLeft() > 0)) {
                            bombs.add(bomb);
                        }
                    }
                    if (bombs.size() > 0) {
                        Mounted hitbomb = bombs
                                .get(Compute.randomInt(bombs.size()));
                        hitbomb.setShotsLeft(0);
                        hitbomb.setDestroyed(true);
                        r = new Report(9130);
                        r.subject = a.getId();
                        r.add(hitbomb.getDesc());
                        vDesc.add(r);
                        // If we are part of a squadron, we should recalculate
                        // the bomb salvo for the squadron
                        if (a.getTransportId() != Entity.NONE) {
                            Entity e = game.getEntity(a.getTransportId());
                            if (e instanceof FighterSquadron) {
                                ((FighterSquadron) e).computeSquadronBombLoadout();
                            }
                        }
                    } else {
                        r = new Report(9131);
                        r.subject = a.getId();
                        vDesc.add(r);
                    }
                    break;
                case Aero.CRIT_HEATSINK:
                    // heat sink hit
                    int sinksLost = 1;
                    if (isCapital) {
                        sinksLost = 10;
                    }
                    r = new Report(9135);
                    r.subject = a.getId();
                    r.add(sinksLost);
                    vDesc.add(r);
                    a.setHeatSinks(Math.max(0, a.getHeatSinks() - sinksLost));
                    break;
                case Aero.CRIT_WEAPON_BROAD:
                    if (a instanceof Warship) {
                        if ((loc == Jumpship.LOC_ALS) || (loc == Jumpship.LOC_FLS)) {
                            loc = Warship.LOC_LBS;
                        } else if ((loc == Jumpship.LOC_ARS)
                                   || (loc == Jumpship.LOC_FRS)) {
                            loc = Warship.LOC_RBS;
                        }
                    }
                case Aero.CRIT_WEAPON:
                    if (a.isCapitalFighter()) {
                        boolean destroyAll = false;
                        if ((loc == Aero.LOC_NOSE) || (loc == Aero.LOC_AFT)) {
                            destroyAll = true;
                        }
                        if (loc == Aero.LOC_WINGS) {
                            if (a.areWingsHit()) {
                                destroyAll = true;
                            } else {
                                a.setWingsHit(true);
                            }
                        }
                        for (Mounted weap : a.getWeaponList()) {
                            if (weap.getLocation() == loc) {
                                if (destroyAll) {
                                    weap.setHit(true);
                                } else {
                                    weap.setNWeapons(weap.getNWeapons() / 2);
                                }
                            }
                        }
                        // also destroy any ECM or BAP in this location
                        for (Mounted misc : a.getMisc()) {
                            if (misc.getType().hasFlag(MiscType.F_ECM)
                                || misc.getType().hasFlag(MiscType.F_ANGEL_ECM)
                                || misc.getType().hasFlag(MiscType.F_BAP)) {
                                misc.setHit(true);
                            }
                        }
                        r = new Report(9152);
                        r.subject = a.getId();
                        r.add(a.getLocationName(loc));
                        vDesc.add(r);
                        break;
                    }
                    r = new Report(9150);
                    r.subject = a.getId();
                    ArrayList<Mounted> weapons = new ArrayList<Mounted>();
                    for (Mounted weap : a.getWeaponList()) {
                        if ((weap.getLocation() == loc) && !weap.isDestroyed()
                            && weap.getType().isHittable()) {
                            weapons.add(weap);
                        }
                    }
                    // add in in hittable misc equipment
                    for (Mounted misc : a.getMisc()) {
                        if (misc.getType().isHittable()
                            && (misc.getLocation() == loc)
                            && !misc.isDestroyed()) {
                            weapons.add(misc);
                        }
                    }
                    if (weapons.size() > 0) {
                        Mounted weapon = weapons.get(Compute.randomInt(weapons
                                                                               .size()));
                        // possibly check for an ammo explosion
                        // don't allow ammo explosions on fighter squadrons
                        if (game.getOptions().booleanOption("ammo_explosions")
                            && !(a instanceof FighterSquadron)
                            && (weapon.getType() instanceof WeaponType)) {
                            // does it use Ammo?
                            WeaponType wtype = (WeaponType) weapon.getType();
                            if (wtype.getAmmoType() != AmmoType.T_NA) {
                                Mounted m = weapon.getLinked();
                                int ammoroll = Compute.d6(2);
                                if (ammoroll >= 10) {
                                    r = new Report(9151);
                                    r.subject = a.getId();
                                    r.add(m.getName());
                                    r.newlines = 0;
                                    vDesc.add(r);
                                    vDesc.addAll(explodeEquipment(a, loc, m));
                                    break;
                                }
                            }
                        }
                        r.add(weapon.getName());
                        vDesc.add(r);
                        // explosive weapons e.g. gauss now explode
                        if (weapon.getType().isExplosive(weapon) && !weapon.isHit()
                            && !weapon.isDestroyed()) {
                            vDesc.addAll(explodeEquipment(a, loc, weapon));
                        }
                        weapon.setHit(true);
                        //Taharqa: We should also damage the critical slot, or
                        //MM and MHQ won't remember that this weapon is damaged on the MUL
                        //file
                        for (int i = 0; i < a.getNumberOfCriticals(loc); i++) {
                            CriticalSlot slot1 = a.getCritical(loc, i);
                            if ((slot1 == null) ||
                                    (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                                continue;
                            }
                            Mounted mounted = slot1.getMount();
                            if (mounted.equals(weapon)) {
                                a.hitAllCriticals(loc, i);
                                break;
                            }
                        }
                        //if this is a weapons bay then also hit all the other weapons
                        for(int wId : weapon.getBayWeapons()) {
                            Mounted bayWeap = a.getEquipment(wId);
                            if(null != bayWeap) {
                                bayWeap.setHit(true);
                                //Taharqa: We should also damage the critical slot, or
                                //MM and MHQ won't remember that this weapon is damaged on the MUL
                                //file
                                for (int i = 0; i < a.getNumberOfCriticals(loc); i++) {
                                    CriticalSlot slot1 = a.getCritical(loc, i);
                                    if ((slot1 == null) ||
                                            (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {
                                        continue;
                                    }
                                    Mounted mounted = slot1.getMount();
                                    if (mounted.equals(bayWeap)) {
                                        a.hitAllCriticals(loc, i);
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        r = new Report(9155);
                        r.subject = a.getId();
                        vDesc.add(r);
                    }
                    break;
                case Aero.CRIT_ENGINE:
                    // engine hit
                    r = new Report(9140);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.engineHitsThisPhase++;
                    boolean engineExploded = checkEngineExplosion(a, vDesc, 1);
                    a.setEngineHits(a.getEngineHits() + 1);
                    if ((a.getEngineHits() >= a.getMaxEngineHits())
                        || engineExploded) {
                        // this engine hit puts the ASF out of commission
                        vDesc.addAll(destroyEntity(a, "engine destruction", true,
                                                   true));
                        a.setSelfDestructing(false);
                        a.setSelfDestructInitiated(false);
                    }
                    break;
                case Aero.CRIT_LEFT_THRUSTER:
                    // thruster hit
                    r = new Report(9160);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setLeftThrustHits(a.getLeftThrustHits() + 1);
                    break;
                case Aero.CRIT_RIGHT_THRUSTER:
                    // thruster hit
                    r = new Report(9160);
                    r.subject = a.getId();
                    vDesc.add(r);
                    a.setRightThrustHits(a.getRightThrustHits() + 1);
                    break;
                case Aero.CRIT_CARGO:
                    // cargo hit
                    // First what percentage of the cargo did the hit destroy?
                    double percentDestroyed = 0.0;
                    double mult = 2.0;
                    if (a.isLargeCraft() && a.isClan()
                        && game.getOptions().booleanOption("stratops_harjel")) {
                        mult = 4.0;
                    }
                    if (damageCaused > 0) {
                        percentDestroyed = Math.min(
                                damageCaused / (mult * a.getSI()), 1.0);
                    }
                    // did it hit cargo or units
                    int roll = Compute.d6(1);
                    if (roll < 4) {
                        // cargo was hit
                        // just report; no game effect
                        r = new Report(9165);
                        r.subject = a.getId();
                        r.add((int) (percentDestroyed * 100));
                        vDesc.add(r);
                    } else {
                        // units were hit
                        // get a list of units
                        Vector<Entity> passengers = en.getBayLoadedUnits();
                        int unitsDestroyed = (int) Math.ceil(percentDestroyed
                                                             * passengers.size());
                        r = new Report(9166);
                        r.subject = a.getId();
                        r.add(unitsDestroyed);
                        vDesc.add(r);
                        while (unitsDestroyed > 0) {
                            // redraw loaded units to make sure I don't get ones
                            // already destroyed
                            List<Entity> units = en.getLoadedUnits();
                            if (units.size() > 0) {
                                Entity target = units.get(Compute.randomInt(units
                                                                                    .size()));
                                vDesc.addAll(destroyEntity(target, "cargo damage",
                                                           false, false));
                            }
                            unitsDestroyed--;
                        }
                    }
                    break;
                case Aero.CRIT_DOOR:
                    // door hit
                    // choose a random bay
                    String bayType = en.damageBayDoor();
                    if (!bayType.equals("none")) {
                        r = new Report(9170);
                        r.subject = a.getId();
                        r.add(bayType);
                        vDesc.add(r);
                    } else {
                        r = new Report(9171);
                        r.subject = a.getId();
                        vDesc.add(r);
                    }
                    break;
                case Aero.CRIT_DOCK_COLLAR:
                    // docking collar hit
                    // different effect for dropships and jumpships
                    if (en instanceof Dropship) {
                        Dropship ds = (Dropship) en;
                        ds.setDamageDockCollar(true);
                        r = new Report(9175);
                        r.subject = a.getId();
                        vDesc.add(r);
                    }
                    if (en instanceof Jumpship) {
                        // damage the docking collar
                        if (en.damageDockCollar()) {
                            r = new Report(9176);
                            r.subject = a.getId();
                            vDesc.add(r);
                        } else {
                            r = new Report(9177);
                            r.subject = a.getId();
                            vDesc.add(r);
                        }
                    }
                    break;
                case Aero.CRIT_KF_BOOM:
                    // KF boom hit
                    // no real effect yet
                    r = new Report(9180);
                    r.subject = a.getId();
                    vDesc.add(r);
                    break;
                case Aero.CRIT_CIC:
                    if (js == null) {
                        break;
                    }
                    // CIC hit
                    r = new Report(9185);
                    r.subject = a.getId();
                    vDesc.add(r);
                    js.setCICHits(js.getCICHits() + 1);
                    break;
                case Aero.CRIT_KF_DRIVE:
                    if (js == null) {
                        break;
                    }
                    // KF Drive hit
                    r = new Report(9190);
                    r.subject = a.getId();
                    vDesc.add(r);
                    js.setKFIntegrity(js.getKFIntegrity() - 1);
                    break;
                case Aero.CRIT_GRAV_DECK:
                    if (js == null) {
                        break;
                    }
                    // Grave Deck hit
                    r = new Report(9195);
                    r.subject = a.getId();
                    vDesc.add(r);
                    break;
                case Aero.CRIT_LIFE_SUPPORT:
                    // Life Support hit
                    a.setLifeSupport(false);
                    r = new Report(9196);
                    r.subject = a.getId();
                    vDesc.add(r);
                    break;
            }
        } else if (en instanceof BattleArmor) {
            // We might as well handle this here.
            // However, we're considering a crit against BA as a "crew kill".
            BattleArmor ba = (BattleArmor) en;
            r = new Report(6111);
            int randomTrooper = ba.getRandomTrooper();
            ba.destroyLocation(randomTrooper);
            r.add(randomTrooper);
            r.newlines = 1;
            vDesc.add(r);
        } else if (CriticalSlot.TYPE_SYSTEM == cs.getType()) {
            // Handle critical hits on system slots.
            cs.setHit(true);
            if (en instanceof Protomech) {
                int numHit = ((Protomech) en).getCritsHit(loc);
                if ((cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_A)
                    && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_B)
                    && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_C)
                    && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_D)
                    && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_E)
                    && (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_F)) {
                    r = new Report(6225);
                    r.subject = en.getId();
                    r.indent(3);
                    r.add(Protomech.systemNames[cs.getIndex()]);
                    vDesc.addElement(r);
                }
                switch (cs.getIndex()) {
                    case Protomech.SYSTEM_HEADCRIT:
                        if (2 == numHit) {
                            r = new Report(6230);
                            r.subject = en.getId();
                            vDesc.addElement(r);
                            en.destroyLocation(loc);
                        }
                        break;
                    case Protomech.SYSTEM_ARMCRIT:
                        if (2 == numHit) {
                            r = new Report(6235);
                            r.subject = en.getId();
                            vDesc.addElement(r);
                            en.destroyLocation(loc);
                        }
                        break;
                    case Protomech.SYSTEM_LEGCRIT:
                        if (3 == numHit) {
                            r = new Report(6240);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                            en.destroyLocation(loc);
                        }
                        break;
                    case Protomech.SYSTEM_TORSOCRIT:
                        if (3 == numHit) {
                            vDesc.addAll(destroyEntity(en, "torso destruction"));
                        }
                        // Torso weapon hits are secondary effects and
                        // do not occur when loading from a scenario.
                        else if (secondaryEffects) {
                            int tweapRoll = Compute.d6(1);
                            CriticalSlot newSlot = null;

                            switch (tweapRoll) {
                                case 1:
                                    if (((Protomech) en).isQuad()) {
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_A);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                                case 2:
                                    if (((Protomech) en).isQuad()) {
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_B);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                                    newSlot = new CriticalSlot(
                                            CriticalSlot.TYPE_SYSTEM,
                                            Protomech.SYSTEM_TORSO_WEAPON_A);
                                    vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                  newSlot, secondaryEffects, damageCaused,
                                                                  isCapital));
                                    break;
                                case 3:
                                    if (((Protomech) en).isQuad()) {
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_C);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                                case 4:
                                    if (((Protomech) en).isQuad()) {
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_D);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                                    newSlot = new CriticalSlot(
                                            CriticalSlot.TYPE_SYSTEM,
                                            Protomech.SYSTEM_TORSO_WEAPON_B);
                                    vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                  newSlot, secondaryEffects, damageCaused,
                                                                  isCapital));
                                    break;
                                case 5:
                                    if (en.getWeight() > 9) {
                                        if (((Protomech) en).isQuad()) {
                                            newSlot = new CriticalSlot(
                                                    CriticalSlot.TYPE_SYSTEM,
                                                    Protomech.SYSTEM_TORSO_WEAPON_E);
                                            vDesc.addAll(applyCriticalHit(en,
                                                                          Entity.NONE, newSlot,
                                                                          secondaryEffects, damageCaused,
                                                                          isCapital));
                                            break;
                                        }
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_C);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                                case 6:
                                    if (en.getWeight() > 9) {
                                        if (((Protomech) en).isQuad()) {
                                            newSlot = new CriticalSlot(
                                                    CriticalSlot.TYPE_SYSTEM,
                                                    Protomech.SYSTEM_TORSO_WEAPON_F);
                                            vDesc.addAll(applyCriticalHit(en,
                                                                          Entity.NONE, newSlot,
                                                                          secondaryEffects, damageCaused,
                                                                          isCapital));
                                            break;
                                        }
                                        newSlot = new CriticalSlot(
                                                CriticalSlot.TYPE_SYSTEM,
                                                Protomech.SYSTEM_TORSO_WEAPON_C);
                                        vDesc.addAll(applyCriticalHit(en, Entity.NONE,
                                                                      newSlot, secondaryEffects,
                                                                      damageCaused, isCapital));
                                        break;
                                    }
                            }
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_A:
                        Mounted weaponA = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponA) {
                            weaponA.setHit(true);
                            r = new Report(6245);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_B:
                        Mounted weaponB = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponB) {
                            weaponB.setHit(true);
                            r = new Report(6250);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_C:
                        Mounted weaponC = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponC) {
                            weaponC.setHit(true);
                            r = new Report(6245);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_D:
                        Mounted weaponD = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponD) {
                            weaponD.setHit(true);
                            r = new Report(6250);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_E:
                        Mounted weaponE = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponE) {
                            weaponE.setHit(true);
                            r = new Report(6245);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                    case Protomech.SYSTEM_TORSO_WEAPON_F:
                        Mounted weaponF = ((Protomech) en).getTorsoWeapon(cs
                                                                                  .getIndex());
                        if (null != weaponF) {
                            weaponF.setHit(true);
                            r = new Report(6250);
                            r.subject = en.getId();
                            r.newlines = 0;
                            vDesc.addElement(r);
                        }
                        break;
                } // End switch( cs.getType() )

                // Shaded hits cause pilot damage.
                if (((Protomech) en).shaded(loc, numHit)) {
                    // Destroyed Protomech sections have
                    // already damaged the pilot.
                    int pHits = Protomech.POSSIBLE_PILOT_DAMAGE[loc]
                                - ((Protomech) en).getPilotDamageTaken(loc);
                    if (Math.min(1, pHits) > 0) {
                        Report.addNewline(vDesc);
                        vDesc.addAll(damageCrew(en, 1));
                        pHits = 1 + ((Protomech) en).getPilotDamageTaken(loc);
                        ((Protomech) en).setPilotDamageTaken(loc, pHits);
                    }
                } // End have-shaded-hit

            } // End entity-is-protomech
            else {
                r = new Report(6225);
                r.subject = en.getId();
                r.indent(3);
                r.add(((Mech) en).getSystemName(cs.getIndex()));
                vDesc.addElement(r);
                switch (cs.getIndex()) {
                    case Mech.SYSTEM_COCKPIT:
                        // Lets auto-eject if we can!
                        if (en instanceof Mech) {
                            Mech mech = (Mech) en;
                            if (game.getOptions().booleanOption(
                                    "tacops_skin_of_the_teeth_ejection")) {
                                if (mech.isAutoEject()
                                    && (!game.getOptions().booleanOption(
                                        "conditional_ejection") || (game
                                                                            .getOptions().booleanOption(
                                                "conditional_ejection") && mech
                                                                            .isCondEjectHeadshot()))) {
                                    vDesc.addAll(ejectEntity(en, true, true));
                                }
                            }
                        }

                        // Don't kill a pilot multiple times.
                        if (Crew.DEATH > en.getCrew().getHits()) {
                            // boink!
                            en.getCrew().setDoomed(true);
                            Report.addNewline(vDesc);
                            vDesc.addAll(destroyEntity(en, "pilot death", true));
                        }
                        break;
                    case Mech.SYSTEM_ENGINE:
                        // if the slot is missing, the location was previously
                        // destroyedd and the enginehit was then counted already
                        if (!cs.isMissing()) {
                            en.engineHitsThisPhase++;
                        }
                        int numEngineHits = en.getEngineHits();
                        boolean engineExploded = checkEngineExplosion(en, vDesc,
                                                                      numEngineHits);
                        int hitsToDestroy = 3;
                        if ((en instanceof Mech)
                            && ((Mech) en).isSuperHeavy()
                            && (en.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                            hitsToDestroy = 2;
                        }

                        if (!engineExploded && (numEngineHits >= hitsToDestroy)) {
                            // third engine hit
                            vDesc.addAll(destroyEntity(en, "engine destruction"));
                            if (game.getOptions()
                                    .booleanOption("auto_abandon_unit")) {
                                vDesc.addAll(abandonEntity(en));
                            }
                            en.setSelfDestructing(false);
                            en.setSelfDestructInitiated(false);
                        }
                        break;
                    case Mech.SYSTEM_GYRO:
                        int gyroHits = en.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                                                          Mech.SYSTEM_GYRO, loc);
                        if (en.getGyroType() != Mech.GYRO_HEAVY_DUTY) {
                            gyroHits++;
                        }
                        switch (gyroHits) {
                            case 3:
                                // HD 3 hits, standard 2 hits
                                game.addPSR(new PilotingRollData(en.getId(),
                                                                 TargetRoll.AUTOMATIC_FAIL, 1, "gyro destroyed"));
                                // Gyro destroyed entities may not be hull down
                                en.setHullDown(false);
                                break;
                            case 2:
                                // HD 2 hits, standard 1 hit
                                game.addPSR(new PilotingRollData(en.getId(), 3,
                                                                 "gyro hit"));
                                break;
                            case 1:
                                // HD 1 hit
                                game.addPSR(new PilotingRollData(en.getId(), 2,
                                                                 "gyro hit"));
                                break;
                            default:
                                // ignore if >4 hits (don't over do it, the auto
                                // fail
                                // already happened.)
                        }
                        break;
                    case Mech.ACTUATOR_UPPER_LEG:
                    case Mech.ACTUATOR_LOWER_LEG:
                    case Mech.ACTUATOR_FOOT:
                        // leg/foot actuator piloting roll
                        game.addPSR(new PilotingRollData(en.getId(), 1,
                                                         "leg/foot actuator hit"));
                        break;
                    case Mech.ACTUATOR_HIP:
                        // hip piloting roll
                        game.addPSR(new PilotingRollData(en.getId(), 2,
                                                         "hip actuator hit"));
                        break;
                }

            } // End entity-is-mek

        } // End crit-on-system-slot

        // Handle critical hits on equipment slots.
        else if (CriticalSlot.TYPE_EQUIPMENT == cs.getType()) {
            cs.setHit(true);
            Mounted mounted = cs.getMount();
            EquipmentType eqType = mounted.getType();
            boolean hitBefore = mounted.isHit();

            r = new Report(6225);
            r.subject = en.getId();
            r.indent(3);
            r.add(mounted.getDesc());
            vDesc.addElement(r);

            // Shield objects are not useless when they take one crit.
            // Shields can be critted and still be usable.
            if ((eqType instanceof MiscType) && ((MiscType) eqType).isShield()) {
                mounted.setHit(false);
            } else {
                mounted.setHit(true);
            }

            if ((eqType instanceof MiscType)
                    && eqType.hasFlag(MiscType.F_EMERGENCY_COOLANT_SYSTEM)) {
                ((Mech)en).setHasDamagedCoolantSystem(true);
            }

            if ((eqType instanceof MiscType)
                && eqType.hasFlag(MiscType.F_HARJEL)) {
                vDesc.addAll(breachLocation(en, loc, null, true));
            }

            // HarJel II/III hits trigger another possible critical hit on
            // the same location
            // it's like an ammunition explosion---a secondary effect
            if (secondaryEffects && (eqType instanceof MiscType)
                && (eqType.hasFlag(MiscType.F_HARJEL_II)
                || eqType.hasFlag(MiscType.F_HARJEL_III))
                && !hitBefore) {
                r = new Report(9852);
                r.subject = en.getId();
                r.indent(2);
                vDesc.addElement(r);
                vDesc.addAll(criticalEntity(en, loc, false, 0, 0));
            }

            // If the item is the ECM suite of a Mek Stealth system
            // then it's destruction turns off the stealth.
            if (!hitBefore && (eqType instanceof MiscType)
                && eqType.hasFlag(MiscType.F_ECM)
                && (mounted.getLinkedBy() != null)) {
                Mounted stealth = mounted.getLinkedBy();
                r = new Report(6255);
                r.subject = en.getId();
                r.indent(2);
                r.add(stealth.getType().getName());
                vDesc.addElement(r);
                stealth.setMode("Off");
            }

            // Handle equipment explosions.
            // Equipment explosions are secondary effects and
            // do not occur when loading from a scenario.
            if (((secondaryEffects && eqType.isExplosive(mounted))
                 || mounted.isHotLoaded() || (mounted.hasChargedCapacitor() != 0))
                && !hitBefore) {
                vDesc.addAll(explodeEquipment(en, loc, mounted));
            }

            // Make sure that ammo in this slot is exhaused.
            if (mounted.getBaseShotsLeft() > 0) {
                mounted.setShotsLeft(0);
            }

        } // End crit-on-equipment-slot
        // mechs with TSM hit by anti-tsm missiles this round get another
        // crit
        if ((en instanceof Mech) && en.hitThisRoundByAntiTSM) {
            Mech mech = (Mech) en;
            if (mech.hasTSM()) {
                r = new Report(6430);
                r.subject = en.getId();
                r.indent(2);
                r.addDesc(en);
                r.newlines = 0;
                vDesc.addElement(r);
                vDesc.addAll(oneCriticalEntity(en, Compute.d6(2), false,
                                               damageCaused));
            }
            en.hitThisRoundByAntiTSM = false;
        }

        // if using buffered VDNI then a possible pilot hit
        if (en.getCrew().getOptions().booleanOption("bvdni")
            && !en.getCrew().getOptions().booleanOption("pain_shunt")) {
            Report.addNewline(vDesc);
            int roll = Compute.d6(2);
            r = new Report(3580);
            r.subject = en.getId();
            r.addDesc(en);
            r.add(7);
            r.add(roll);
            r.choose(roll >= 8);
            r.indent(2);
            vDesc.add(r);
            if (roll >= 8) {
                vDesc.addAll(damageCrew(en, 1));
            }
        }

        // Return the results of the damage.
        return vDesc;
    }

    /**
     * Rolls and resolves critical hits with a die roll modifier.
     */

    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
                                         int critMod, int damage) {
        return criticalEntity(en, loc, isRear, critMod, true, false, damage);
    }

    /**
     * Rolls and resolves critical hits with a die roll modifier.
     */

    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
                                         int critMod, int damage, boolean damagedByFire) {
        return criticalEntity(en, loc, isRear, critMod, true, false, damage, damagedByFire);
    }

    /**
     * Rolls one critical hit
     */
    public Vector<Report> oneCriticalEntity(Entity en, int loc,
                                             boolean isRear, int damage) {
        return criticalEntity(en, loc, isRear, 0, false, false, damage);
    }

    /**
     * Rolls one critical hit
     */
    public Vector<Report> oneCriticalEntity(Entity en, int loc,
                                             boolean isRear, int damage, boolean damagedByFire) {
        return criticalEntity(en, loc, isRear, 0, false, false, damage, damagedByFire);
    }

    /**
     * Resolves the forced landing of one airborne {@code VTOL} or {@code WiGE}
     * in its current hex. As this method is only for internal use and not part
     * of the exported public API, it simply relies on its client code to only
     * ever hand it a valid airborne vehicle and does not run any further checks
     * of its own.
     *
     * @param en The {@code VTOL} or {@WiGE} in question.
     * @return The resulting {@code Vector} of {@code Report}s.
     */
    private Vector<Report> forceLandVTOLorWiGE(Tank en) {
        Vector<Report> vDesc = new Vector<Report>();
        PilotingRollData psr = en.getBasePilotingRoll();
        IHex hex = game.getBoard().getHex(en.getPosition());
        if (en instanceof VTOL) {
            psr.addModifier(4, "VTOL making forced landing");
        } else {
            psr.addModifier(0, "WiGE making forced landing");
        }
        int elevation = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),
                                 hex.terrainLevel(Terrains.BRIDGE_ELEV));
        elevation = Math.max(elevation, 0);
        elevation = Math.min(elevation, en.getElevation());
        if (en.getElevation() > elevation) {
            if (!hex.containsTerrain(Terrains.FUEL_TANK)
                && !hex.containsTerrain(Terrains.JUNGLE)
                && !hex.containsTerrain(Terrains.MAGMA)
                && !hex.containsTerrain(Terrains.MUD)
                && !hex.containsTerrain(Terrains.RUBBLE)
                && !hex.containsTerrain(Terrains.WATER)
                && !hex.containsTerrain(Terrains.WOODS)) {
                Report r = new Report(2180);
                r.subject = en.getId();
                r.addDesc(en);
                r.add(psr.getLastPlainDesc(), true);
                vDesc.add(r);

                // roll
                final int diceRoll = Compute.d6(2);
                r = new Report(2185);
                r.subject = en.getId();
                r.add(psr.getValueAsString());
                r.add(psr.getDesc());
                r.add(diceRoll);
                if (diceRoll < psr.getValue()) {
                    r.choose(false);
                    vDesc.add(r);
                    vDesc.addAll(crashVTOLorWiGE(en, true));
                } else {
                    r.choose(true);
                    vDesc.add(r);
                    en.setElevation(elevation);
                }
            } else {
                vDesc.addAll(crashVTOLorWiGE(en, true));
            }
        }
        return vDesc;
    }

    /**
     * Crash a VTOL
     *
     * @param en the <code>VTOL</code> to be crashed
     * @return the <code>Vector<Report></code> containg phasereports
     */
    private Vector<Report> crashVTOLorWiGE(Tank en) {
        return crashVTOLorWiGE(en, false, false, 0, en.getPosition(),
                               en.getElevation(), 0);
    }

    /**
     * Crash a VTOL or WiGE.
     *
     * @param en              The {@code VTOL} or {@code WiGE} to crash.
     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
     *                        typically after a "rotor destroyed" critical hit.
     * @return The {@code Vector<Report>} of resulting reports.
     */
    private Vector<Report> crashVTOLorWiGE(Tank en, boolean rerollRotorHits) {
        return crashVTOLorWiGE(en, rerollRotorHits, false, 0, en.getPosition(),
                               en.getElevation(), 0);
    }

    /**
     * Crash a VTOL or WiGE.
     *
     * @param en              The {@code VTOL} or {@code WiGE} to crash.
     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
     *                        typically after a "rotor destroyed" critical hit.
     * @param sideSlipCrash   A <code>boolean</code> value indicating wether this is a
     *                        sideslip crash or not.
     * @param hexesMoved      The <code>int</code> number of hexes moved.
     * @param crashPos        The <code>Coords</code> of the crash
     * @param crashElevation  The <code>int</code> elevation of the VTOL
     * @param impactSide      The <code>int</code> describing the side on which the VTOL
     *                        falls
     * @return a <code>Vector<Report></code> of Reports.
     */

    private Vector<Report> crashVTOLorWiGE(Tank en, boolean rerollRotorHits,
                                           boolean sideSlipCrash, int hexesMoved, Coords crashPos,
                                           int crashElevation, int impactSide) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // we might be off the board after a DFA, so return then
        if (!game.getBoard().contains(crashPos)) {
            return vDesc;
        }

        if (!sideSlipCrash) {
            // report lost movement and crashing
            if (en.getCrew().isDoomed()) {
                r = new Report(6260);
            } else {
                r = new Report(6260);
            }
            r.subject = en.getId();
            r.newlines = 0;
            r.addDesc(en);
            vDesc.addElement(r);
            int newElevation = 0;
            IHex fallHex = game.getBoard().getHex(crashPos);

            // May land on roof of building or bridge
            if (fallHex.containsTerrain(Terrains.BLDG_ELEV)) {
                newElevation = fallHex.terrainLevel(Terrains.BLDG_ELEV);
            } else if (fallHex.containsTerrain(Terrains.BRIDGE_ELEV)) {
                newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
                if (newElevation > crashElevation) {
                    newElevation = 0; // vtol was under bridge already
                }
            }

            int fall = crashElevation - newElevation;
            if (fall == 0) {
                // already on ground, no harm done
                r = new Report(6265);
                r.subject = en.getId();
                vDesc.addElement(r);
                return vDesc;
            }
            // set elevation 1st to avoid multiple crashes
            en.setElevation(newElevation);

            // plummets to ground
            r = new Report(6270);
            r.subject = en.getId();
            r.add(fall);
            vDesc.addElement(r);

            // facing after fall
            String side;
            int table;
            int facing = Compute.d6() - 1;
            switch (facing) {
                case 1:
                case 2:
                    side = "right side";
                    table = ToHitData.SIDE_RIGHT;
                    break;
                case 3:
                    side = "rear";
                    table = ToHitData.SIDE_REAR;
                    break;
                case 4:
                case 5:
                    side = "left side";
                    table = ToHitData.SIDE_LEFT;
                    break;
                case 0:
                default:
                    side = "front";
                    table = ToHitData.SIDE_FRONT;
            }

            if (newElevation <= 0) {
                boolean waterFall = fallHex.containsTerrain(Terrains.WATER);
                if (waterFall && fallHex.containsTerrain(Terrains.ICE)) {
                    int roll = Compute.d6(1);
                    r = new Report(2119);
                    r.subject = en.getId();
                    r.addDesc(en);
                    r.add(roll);
                    r.subject = en.getId();
                    vDesc.add(r);
                    if (roll > 3) {
                        vDesc.addAll(resolveIceBroken(crashPos));
                    } else {
                        waterFall = false; // saved by ice
                    }
                }
                if (waterFall) {
                    // falls into water and is destroyed
                    r = new Report(6275);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                    vDesc.addAll(destroyEntity(en, "Fell into water", false,
                                               false));
                    // not sure, is this salvagable?
                }
            }

            // calculate damage for hitting the surface
            int damage = (int) Math.round(en.getWeight() / 10.0) * (fall + 1);

            // adjust damage for gravity
            damage = Math.round(damage
                                * game.getPlanetaryConditions().getGravity());
            // report falling
            r = new Report(6280);
            r.subject = en.getId();
            r.indent();
            r.addDesc(en);
            r.add(side);
            r.add(damage);
            //r.newlines = 0;
            vDesc.addElement(r);

            en.setFacing((en.getFacing() + (facing)) % 6);

            boolean exploded = false;

            // standard damage loop
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, table);
                if ((en instanceof VTOL)
                    && (hit.getLocation() == VTOL.LOC_ROTOR)
                    && rerollRotorHits) {
                    continue;
                }
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                int isBefore[] = {en.getInternal(Tank.LOC_FRONT),
                                  en.getInternal(Tank.LOC_RIGHT),
                                  en.getInternal(Tank.LOC_LEFT),
                                  en.getInternal(Tank.LOC_REAR)};// hack?
                vDesc.addAll(damageEntity(en, hit, cluster));
                int ISAfter[] = {en.getInternal(Tank.LOC_FRONT),
                                 en.getInternal(Tank.LOC_RIGHT),
                                 en.getInternal(Tank.LOC_LEFT),
                                 en.getInternal(Tank.LOC_REAR)};
                for (int x = 0; x <= 3; x++) {
                    if (isBefore[x] != ISAfter[x]) {
                        exploded = true;
                    }
                }
                damage -= cluster;
            }
            if (exploded) {
                r = new Report(6285);
                r.subject = en.getId();
                r.addDesc(en);
                vDesc.addElement(r);
                vDesc.addAll(explodeVTOLorWiGE(en));
            }

            // check for location exposure
            vDesc.addAll(doSetLocationsExposure(en, fallHex, false,
                                                newElevation));

        } else {
            en.setElevation(0);// considered landed in the hex.
            // crashes into ground thanks to sideslip
            r = new Report(6290);
            r.subject = en.getId();
            r.addDesc(en);
            vDesc.addElement(r);
            int damage = (int) Math.round(en.getWeight() / 10.0)
                         * (hexesMoved + 1);
            boolean exploded = false;

            // standard damage loop
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL,
                                                 impactSide);
                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                int ISBefore[] = {en.getInternal(Tank.LOC_FRONT),
                                  en.getInternal(Tank.LOC_RIGHT),
                                  en.getInternal(Tank.LOC_LEFT),
                                  en.getInternal(Tank.LOC_REAR)};// hack?
                vDesc.addAll(damageEntity(en, hit, cluster));
                int ISAfter[] = {en.getInternal(Tank.LOC_FRONT),
                                 en.getInternal(Tank.LOC_RIGHT),
                                 en.getInternal(Tank.LOC_LEFT),
                                 en.getInternal(Tank.LOC_REAR)};
                for (int x = 0; x <= 3; x++) {
                    if (ISBefore[x] != ISAfter[x]) {
                        exploded = true;
                    }
                }
                damage -= cluster;
            }
            if (exploded) {
                r = new Report(6295);
                r.subject = en.getId();
                r.addDesc(en);
                vDesc.addElement(r);
                vDesc.addAll(explodeVTOLorWiGE(en));
            }

        }

        if (game.containsMinefield(crashPos)) {
            // may set off any minefields in the hex
            enterMinefield(en, crashPos, 0, true, vDesc, 7);
            // it may also clear any minefields that it detonated
            clearDetonatedMines(crashPos, 5);
            resetMines();
        }

        return vDesc;

    }

    /**
     * Explode a VTOL
     *
     * @param en The <code>VTOL</code> to explode.
     * @return a <code>Vector</code> of reports
     */
    private Vector<Report> explodeVTOLorWiGE(Tank en) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        if (en.getEngine().isFusion()) {
            // fusion engine, no effect
            r = new Report(6300);
            r.subject = en.getId();
            vDesc.addElement(r);
        } else {
            Coords pos = en.getPosition();
            IHex hex = game.getBoard().getHex(pos);
            if (hex.containsTerrain(Terrains.WOODS)
                || hex.containsTerrain(Terrains.JUNGLE)) {
                ignite(pos, Terrains.FIRE_LVL_NORMAL, vDesc);
            } else {
                ignite(pos, Terrains.FIRE_LVL_INFERNO, vDesc);
            }
            vDesc.addAll(destroyEntity(en, "crashed and burned", false, false));
        }

        return vDesc;
    }

    /**
     * rolls and resolves one tank critical hit
     *
     * @param t       the <code>Tank</code> to be critted
     * @param loc     the <code>int</code> location of the Tank to be critted
     * @param critMod the <code>int</code> modifier to the critroll
     * @return a <code>Vector<Report></code> containing the phasereports
     */
    private Vector<Report> criticalTank(Tank t, int loc, int critMod, int damage, boolean damagedByFire) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // roll the critical
        r = new Report(6305);
        r.subject = t.getId();
        r.indent(3);
        r.add(t.getLocationAbbr(loc));
        r.newlines = 0;
        vDesc.add(r);
        int roll = Compute.d6(2);
        r = new Report(6310);
        r.subject = t.getId();
        String rollString = "";
        if (critMod != 0) {
            rollString = "(" + roll;
            if (critMod > 0) {
                rollString += "+";
            }
            rollString += critMod + ") = ";
            roll += critMod;
        }
        rollString += roll;
        r.add(rollString);
        r.newlines = 0;
        vDesc.add(r);

        // now look up on vehicle crits table
        int critType = t.getCriticalEffect(roll, loc, damagedByFire);
        if ((critType == Tank.CRIT_NONE)
                && game.getOptions().booleanOption("vehicles_threshold")
                && !t.getOverThresh()) {
            r = new Report(6006);
            r.subject = t.getId();
            r.newlines = 0;
            vDesc.add(r);
        }
        vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0, critType),
                                      true, damage, false));
        if ((critType != Tank.CRIT_NONE) && !t.getEngine().isFusion()
            && t.hasQuirk("fragile_fuel") && (Compute.d6(2) > 9)) {
            // BOOM!!
            vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0,
                    Tank.CRIT_FUEL_TANK), true, damage, false));
        }
        return vDesc;
    }

    /**
     * Checks for aero criticals
     *
     * @param a             - the entity being critted
     * @param hit           - the hitdata for the attack
     * @param damage_orig   - the original damage of the attack
     * @param critThresh    - did the attack go over the damage threshold
     * @param critSI        - did the attack damage SI
     * @param ammoExplosion - was the damage from an ammo explosion
     * @param nukeS2S       - was this a ship 2 ship nuke attack
     * @return
     */
    private void checkAeroCrits(Vector<Report> vDesc, Aero a, HitData hit,
                                int damage_orig, boolean critThresh, boolean critSI,
                                boolean ammoExplosion, boolean nukeS2S) {

        Report r;

        boolean isCapital = hit.isCapital();
        // get any capital missile critical mods
        int capitalMissile = hit.getCapMisCritMod();

        // check for nuclear critical
        if (nukeS2S) {
            // add a control roll
            PilotingRollData nukePSR = new PilotingRollData(a.getId(), 4,
                                                            "Nuclear attack", false);
            game.addControlRoll(nukePSR);

            Report.addNewline(vDesc);
            // need some kind of report
            int nukeroll = Compute.d6(2);
            r = new Report(9145);
            r.subject = a.getId();
            r.indent(3);
            r.add(capitalMissile);
            r.add(nukeroll);
            vDesc.add(r);
            if (nukeroll >= capitalMissile) {
                int nukeDamage = damage_orig;
                a.setSI(a.getSI() - nukeDamage);
                a.damageThisPhase += nukeDamage;
                r = new Report(9146);
                r.subject = a.getId();
                r.add(nukeDamage);
                r.indent(4);
                r.add(Math.max(a.getSI(), 0));
                vDesc.addElement(r);
                if (a.getSI() <= 0) {
                    vDesc.addAll(destroyEntity(a,
                            "Structural Integrity Collapse"));
                    a.setSI(0);
                    if (hit.getAttackerId() != Entity.NONE) {
                        creditKill(a, game.getEntity(hit.getAttackerId()));
                    }
                } else if (!critSI) {
                    critSI = true;
                }
            } else {
                r = new Report(9147);
                r.subject = a.getId();
                r.indent(4);
                vDesc.addElement(r);
            }
        }

        // apply crits
        if (hit.rolledBoxCars()) {
            if (hit.isFirstHit()) {
                vDesc.addAll(criticalAero(a, hit.getLocation(),
                        hit.glancingMod(), "12 to hit", 8, damage_orig,
                        isCapital));
            } else { // Let the user know why the lucky crit doesn't apply
                r = new Report(9102);
                r.subject = a.getId();
                r.indent(3);
                vDesc.addElement(r);
            }
        }
        // ammo explosions shouldn't affect threshold because they
        // go right to SI
        if (critThresh && !ammoExplosion) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "Damage threshold exceeded", 8, damage_orig, isCapital));
        }
        if (critSI && !ammoExplosion) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "SI damaged", 8, damage_orig, isCapital));
        }
        if ((capitalMissile > 0) && !nukeS2S) {
            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),
                    "Capital Missile", capitalMissile, damage_orig, isCapital));
        }
    }

    private Vector<Report> criticalAero(Aero a, int loc, int critMod,
            String reason, int target, int damage, boolean isCapital) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // roll the critical
        r = new Report(9100);
        r.subject = a.getId();
        r.add(reason);
        r.indent(3);
        r.newlines = 0;
        vDesc.add(r);
        int roll = Compute.d6(2);
        r = new Report(9101);
        r.subject = a.getId();
        r.add(target);
        String rollString = "";
        if (critMod != 0) {
            rollString = "(" + roll;
            if (critMod > 0) {
                rollString += "+";
            }
            rollString += critMod + ") = ";
            roll += critMod;
        }
        rollString += roll;
        r.add(rollString);
        r.newlines = 0;
        vDesc.add(r);

        // now look up on vehicle crits table
        int critType = a.getCriticalEffect(roll, target);
        vDesc.addAll(applyCriticalHit(a, loc, new CriticalSlot(0, critType),
                true, damage, isCapital));
        return vDesc;
    }

    /**
     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
     */
    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
            int critMod, boolean rollNumber, boolean isCapital, int damage) {
        return criticalEntity(en, loc, isRear, critMod, rollNumber, isCapital,
                damage, false);
    }

    /**
     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
     */
    public Vector<Report> criticalEntity(Entity en, int loc, boolean isRear,
            int critMod, boolean rollNumber, boolean isCapital, int damage,
            boolean damagedByFire) {

        if (en.hasQuirk("poor_work")) {
            critMod += 1;
        }
        if (en.hasQuirk(OptionsConstants.QUIRK_NEG_PROTOTYPE)) {
            critMod += 2;
        }

        // Apply modifiers for Anti-penetrative ablation armor
        if ((en.getArmor(loc, isRear) > 0)
                && (en.getArmorType(loc) == EquipmentType.T_ARMOR_ANTI_PENETRATIVE_ABLATION)) {
            critMod -= 2;
        }

        if (en instanceof Tank) {
            return criticalTank((Tank) en, loc, critMod, damage, damagedByFire);
        }
        if (en instanceof Aero) {
            return criticalAero((Aero) en, loc, critMod, "unknown", 8, damage,
                    isCapital);
        }
        CriticalSlot slot = null;
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        Coords coords = en.getPosition();
        IHex hex = null;
        int hits;
        if (rollNumber) {
            if (null != coords) {
                hex = game.getBoard().getHex(coords);
            }
            r = new Report(6305);
            r.subject = en.getId();
            r.indent(3);
            r.add(en.getLocationAbbr(loc));
            r.newlines = 0;
            vDesc.addElement(r);
            hits = 0;
            int roll = Compute.d6(2);
            r = new Report(6310);
            r.subject = en.getId();
            String rollString = "";
            // industrials get a +2 bonus on the roll
            if ((en instanceof Mech) && ((Mech) en).isIndustrial()) {
                critMod += 2;
            }
            // reinforced structure gets a -1 mod
            if ((en instanceof Mech) && ((Mech) en).hasReinforcedStructure()) {
                critMod -= 1;
            }
            if (critMod != 0) {
                rollString = "(" + roll;
                if (critMod > 0) {
                    rollString += "+";
                }
                rollString += critMod + ") = ";
                roll += critMod;
            }
            rollString += roll;
            r.add(rollString);
            r.newlines = 0;
            vDesc.addElement(r);
            boolean advancedCrit = game.getOptions().booleanOption(
                    "tacops_crit_roll");
            if ((!advancedCrit && (roll <= 7)) || (advancedCrit && (roll <= 8))) {
                // no effect
                r = new Report(6005);
                r.subject = en.getId();
                vDesc.addElement(r);
                return vDesc;
            } else if ((!advancedCrit && (roll >= 8) && (roll <= 9))
                    || (advancedCrit && (roll >= 9) && (roll <= 10))) {
                hits = 1;
                r = new Report(6315);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if ((!advancedCrit && (roll >= 10) && (roll <= 11))
                    || (advancedCrit && (roll >= 11) && (roll <= 12))) {
                hits = 2;
                r = new Report(6320);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if (advancedCrit && (roll >= 13) && (roll <= 14)) {
                hits = 3;
                r = new Report(6325);
                r.subject = en.getId();
                vDesc.addElement(r);
            } else if ((!advancedCrit && (roll >= 12))
                    || (advancedCrit && (roll >= 15))) {
                if (en instanceof Protomech) {
                    hits = 3;
                    r = new Report(6325);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                } else if (en.locationIsLeg(loc)) {

                    CriticalSlot cs = en.getCritical(loc, 0);
                    if ((cs != null) && cs.isArmored()) {
                        r = new Report(6700);
                        r.subject = en.getId();
                        r.add(en.getLocationName(loc));
                        r.newlines = 0;
                        vDesc.addElement(r);
                        cs.setArmored(false);
                        return vDesc;
                    }
                    // limb blown off
                    r = new Report(6120);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    if (en.getInternal(loc) > 0) {
                        en.destroyLocation(loc, true);
                    }
                    if (null != hex) {
                        if (!hex.containsTerrain(Terrains.LEGS)) {
                            hex.addTerrain(Terrains.getTerrainFactory()
                                    .createTerrain(Terrains.LEGS, 1));
                        } else {
                            hex.addTerrain(Terrains
                                    .getTerrainFactory()
                                    .createTerrain(Terrains.LEGS,
                                            hex.terrainLevel(Terrains.LEGS) + 1));
                        }
                    }
                    sendChangedHex(en.getPosition());
                    return vDesc;
                } else if ((loc == Mech.LOC_RARM) || (loc == Mech.LOC_LARM)) {
                    CriticalSlot cs = en.getCritical(loc, 0);
                    if ((cs != null) && cs.isArmored()) {
                        r = new Report(6700);
                        r.subject = en.getId();
                        r.add(en.getLocationName(loc));
                        r.newlines = 0;
                        vDesc.addElement(r);
                        cs.setArmored(false);
                        return vDesc;
                    }

                    // limb blown off
                    r = new Report(6120);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    en.destroyLocation(loc, true);
                    if (null != hex) {
                        if (!hex.containsTerrain(Terrains.ARMS)) {
                            hex.addTerrain(Terrains.getTerrainFactory()
                                    .createTerrain(Terrains.ARMS, 1));
                        } else {
                            hex.addTerrain(Terrains
                                    .getTerrainFactory()
                                    .createTerrain(Terrains.ARMS,
                                            hex.terrainLevel(Terrains.ARMS) + 1));
                        }
                    }
                    sendChangedHex(en.getPosition());
                    return vDesc;
                } else if (loc == Mech.LOC_HEAD) {
                    // head blown off
                    r = new Report(6330);
                    r.subject = en.getId();
                    r.add(en.getLocationName(loc));
                    vDesc.addElement(r);
                    en.destroyLocation(loc, true);
                    if (((Mech) en).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED) {
                        // Don't kill a pilot multiple times.
                        if (Crew.DEATH > en.getCrew().getHits()) {
                            en.getCrew().setDoomed(true);
                            Report.addNewline(vDesc);
                            vDesc.addAll(destroyEntity(en, "pilot death", true));
                        }
                    }
                    return vDesc;
                } else {
                    // torso hit
                    hits = 3;
                    // industrials get 4 crits on a modified result of 14
                    if ((roll >= 14) && (en instanceof Mech)
                            && ((Mech) en).isIndustrial()) {
                        hits = 4;
                    }
                    r = new Report(6325);
                    r.subject = en.getId();
                    vDesc.addElement(r);
                }
            }
        } else {
            hits = 1;
        }

        // Check if there is the potential for a reactive armor crit
        // Because reactive armor isn't hittable, the transfer check doesn't
        // consider it
        boolean possibleReactiveCrit = (en.getArmor(loc) > 0)
                && (en.getArmorType(loc) == EquipmentType.T_ARMOR_REACTIVE);
        boolean locContainsReactiveArmor = false;
        for (int i = 0; (i < en.getNumberOfCriticals(loc))
                && possibleReactiveCrit; i++) {
            CriticalSlot crit = en.getCritical(loc, i);
            if ((crit != null)
                    && (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)
                    && (crit.getMount() != null)
                    && crit.getMount().getType().hasFlag(MiscType.F_REACTIVE)) {
                locContainsReactiveArmor = true;
                break;
            }
        }
        possibleReactiveCrit &= locContainsReactiveArmor;

        // transfer criticals, if needed
        while ((hits > 0) && (en.canTransferCriticals(loc) && !possibleReactiveCrit)
                && (en.getTransferLocation(loc) != Entity.LOC_DESTROYED)
                && (en.getTransferLocation(loc) != Entity.LOC_NONE)) {
            loc = en.getTransferLocation(loc);
            r = new Report(6335);
            r.subject = en.getId();
            r.indent(3);
            r.add(en.getLocationAbbr(loc));
            vDesc.addElement(r);
        }

        // Roll critical hits in this location.
        while (hits > 0) {

            // Have we hit all available slots in this location?
            if (en.getHittableCriticals(loc) <= 0) {
                r = new Report(6340);
                r.subject = en.getId();
                r.indent(3);
                vDesc.addElement(r);
                break;
            }

            // Randomly pick a slot to be hit.
            int slotIndex = Compute.randomInt(en.getNumberOfCriticals(loc));
            slot = en.getCritical(loc, slotIndex);

            // There are certain special cases, like reactive armor
            // some crits aren't normally hittable, except in certain cases
            boolean reactiveArmorCrit = false;
            if ((slot != null)
                    && (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                    && (slot.getMount() != null)) {
                Mounted eq = slot.getMount();
                if (eq.getType().hasFlag(MiscType.F_REACTIVE)
                        && (en.getArmor(loc) > 0)) {
                    reactiveArmorCrit = true;
                }
            }

            // Ignore empty or unhitable slots (this
            // includes all previously hit slots).
            if ((slot != null) && (slot.isHittable() || reactiveArmorCrit)) {

                if (slot.isArmored()) {
                    r = new Report(6710);
                    r.subject = en.getId();
                    if (slot.getType() == CriticalSlot.TYPE_SYSTEM) {
                        // Pretty sure that only 'mechs have system crits,
                        // but just in case....
                        if (en instanceof Mech) {
                            r.add(((Mech) en).getSystemName(slot.getIndex()));
                        }
                    } else {
                        // Shouldn't be null, but we'll be careful...
                        if (slot.getMount() != null) {
                            r.add(slot.getMount().getName());
                        }
                    }
                    vDesc.addElement(r);
                    slot.setArmored(false);
                    hits--;
                    continue;
                }
                // if explosive use edge
                if ((en instanceof Mech)
                        && (en.getCrew().hasEdgeRemaining() && en.getCrew()
                                .getOptions()
                                .booleanOption("edge_when_explosion"))
                        && (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)
                        && slot.getMount().getType()
                                .isExplosive(slot.getMount())) {
                    en.getCrew().decreaseEdge();
                    r = new Report(6530);
                    r.subject = en.getId();
                    r.indent(3);
                    r.add(en.getCrew().getOptions().intOption("edge"));
                    vDesc.addElement(r);
                    continue;
                }

                // check for reactive armor exploding
                if (reactiveArmorCrit) {
                    Mounted mount = slot.getMount();
                    if ((mount != null)
                            && mount.getType().hasFlag(MiscType.F_REACTIVE)) {
                        int roll = Compute.d6(2);
                        r = new Report(6082);
                        r.subject = en.getId();
                        r.indent(3);
                        r.add(roll);
                        vDesc.addElement(r);
                        // big budda boom
                        if (roll == 2) {
                            r = new Report(6083);
                            r.subject = en.getId();
                            r.indent(4);
                            vDesc.addElement(r);
                            Vector<Report> newReports = new Vector<>();
                            newReports.addAll(damageEntity(en,
                                    new HitData(loc), en.getArmor(loc)));
                            if (en.hasRearArmor(loc)) {
                                newReports.addAll(damageEntity(en, new HitData(
                                        loc, true), en.getArmor(loc, true)));
                            }
                            newReports.addAll(damageEntity(en,
                                    new HitData(loc), 1));
                            for (Report rep : newReports) {
                                rep.indent(4);
                            }
                            vDesc.addAll(newReports);
                        } else {
                            // If only hittable crits are reactive,
                            // this crit is absorbed
                            boolean allHittableCritsReactive = true;
                            for (int i = 0; i < en.getNumberOfCriticals(loc); i++) {
                                CriticalSlot crit = en.getCritical(loc, i);
                                if (crit.isHittable()) {
                                    allHittableCritsReactive = false;
                                    break;
                                }
                                // We must have reactive crits to get to this
                                // point, so if nothing else is hittable, we
                                // must only have reactive crits
                            }
                            if (allHittableCritsReactive) {
                                hits--;
                            }
                            continue;
                        }
                    }
                }
                vDesc.addAll(applyCriticalHit(en, loc, slot, true, damage,
                        isCapital));
                hits--;
            }

        } // Hit another slot in this location.

        return vDesc;
    }

    /**
     * Checks for location breach and returns phase logging.
     * <p/>
     *
     * @param entity the <code>Entity</code> that needs to be checked.
     * @param loc    the <code>int</code> location on the entity that needs to be
     *               checked for a breach.
     * @param hex    the <code>IHex</code> the enitity occupies when checking This
     *               value will be <code>null</code> if the check is the result of
     *               an attack, and non-null if it occurs during movement.
     */
    private Vector<Report> breachCheck(Entity entity, int loc, IHex hex) {
        return breachCheck(entity, loc, hex, false);
    }

    /**
     * Checks for location breach and returns phase logging.
     * <p/>
     *
     * @param entity     the <code>Entity</code> that needs to be checked.
     * @param loc        the <code>int</code> location on the entity that needs to be
     *                   checked for a breach.
     * @param hex        the <code>IHex</code> the enitity occupies when checking This
     *                   value will be <code>null</code> if the check is the result of
     *                   an attack, and non-null if it occurs during movement.
     * @param underWater Is the breach check a result of an underwater attack?
     */
    private Vector<Report> breachCheck(Entity entity, int loc, IHex hex,
                                       boolean underWater) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // BattleArmor does not breach
        if (entity instanceof Infantry) {
            return vDesc;
        }

        if (entity instanceof VTOL) {
            return vDesc;
        }

        boolean dumping = false;
        for (Mounted m : entity.getAmmo()) {
            if (m.isDumping()) {
                // dumping ammo underwater is very stupid thing to do
                dumping = true;
                break;
            }
        }
        // This handles both water and vacuum breaches.
        // Also need to account for hull breaches on surface naval vessels which
        // are technically not "wet"
        if ((entity.getLocationStatus(loc) > ILocationExposureStatus.NORMAL)
            || (entity.isSurfaceNaval() && (loc != ((Tank) entity)
                .getLocTurret()))) {
            // Does the location have armor (check rear armor on Mek)
            // and is the check due to damage?
            int breachroll = 0;
            // set the target roll for the breach
            int target = 10;
            // if this is a vacuum check and we are in trace atmosphere then
            // adjust target
            if ((entity.getLocationStatus(loc) == ILocationExposureStatus.VACUUM)
                && (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE)) {
                target = 12;
            }
            // if this is a surface naval vessel and the attack is not from
            // underwater
            // then the breach should only occur on a roll of 12
            if (entity.isSurfaceNaval() && !underWater) {
                target = 12;
            }
            if ((entity.getArmor(loc) > 0)
                && (entity instanceof Mech ? entity.getArmor(loc, true) > 0
                                           : true) && (null == hex)) {
                // functional HarJel prevents breach
                if (entity.hasHarJelIn(loc)) {
                    r = new Report(6342);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    return vDesc;
                }
                if ((entity instanceof Mech)
                    && (((Mech) entity).hasHarJelIIIn(loc)
                        || ((Mech) entity).hasHarJelIIIIn(loc))) {
                    r = new Report(6343);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    target -= 2;
                }
                // Impact-resistant armor easier to breach
                if ((entity.getArmorType(loc) == EquipmentType.T_ARMOR_IMPACT_RESISTANT)) {
                    r = new Report(6344);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    target += 1;
                }
                breachroll = Compute.d6(2);
                r = new Report(6345);
                r.subject = entity.getId();
                r.indent(3);
                r.add(entity.getLocationAbbr(loc));
                r.add(breachroll);
                r.newlines = 0;
                if (breachroll >= target) {
                    r.choose(false);
                } else {
                    r.choose(true);
                }
                vDesc.addElement(r);
            }
            // Breach by damage or lack of armor.
            if ((breachroll >= target)
                || !(entity.getArmor(loc) > 0)
                || (dumping && (!(entity instanceof Mech)
                                || (loc == Mech.LOC_CT) || (loc == Mech.LOC_RT) || (loc == Mech.LOC_LT)))
                || !(entity instanceof Mech ? entity.getArmor(loc, true) > 0
                                            : true)) {
                // Functional HarJel prevents breach as long as armor remains
                // (and, presumably, as long as you don't open your chassis on
                // purpose, say to dump ammo...).
                if ((entity.hasHarJelIn(loc))
                    && (entity.getArmor(loc) > 0)
                    && (entity instanceof Mech ? entity.getArmor(loc, true) > 0
                                               : true) && !dumping) {
                    r = new Report(6342);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    return vDesc;
                }
                vDesc.addAll(breachLocation(entity, loc, hex, false));
            }
        }
        return vDesc;
    }

    /**
     * Marks all equipment in a location on an entity as useless.
     *
     * @param entity the <code>Entity</code> that needs to be checked.
     * @param loc    the <code>int</code> location on the entity that needs to be
     *               checked for a breach.
     * @param hex    the <code>IHex</code> the enitity occupies when checking This
     *               value will be <code>null</code> if the check is the result of
     *               an attack, and non-null if it occurs during movement.
     * @param harJel a <code>boolean</code> value indicating if the uselessness is
     *               the cause of a critically hit HarJel system
     */
    private Vector<Report> breachLocation(Entity entity, int loc, IHex hex,
                                          boolean harJel) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        if ((entity.getInternal(loc) < 0)
            || (entity.getLocationStatus(loc) < ILocationExposureStatus.NORMAL)) {
            // already destroyed or breached? don't bother
            return vDesc;
        }

        r = new Report(6350);
        if (harJel) {
            r.messageId = 6351;
        }
        r.subject = entity.getId();
        r.add(entity.getShortName());
        r.add(entity.getLocationAbbr(loc));
        vDesc.addElement(r);

        if (entity instanceof Tank) {
            vDesc.addAll(destroyEntity(entity, "hull breach", true, true));
            return vDesc;
        }
        if (entity instanceof Mech) {
            Mech mech = (Mech) entity;
            // equipment and crits will be marked in applyDamage?

            // equipment marked missing
            for (Mounted mounted : entity.getEquipment()) {
                if (mounted.getLocation() == loc) {
                    mounted.setBreached(true);
                }
            }
            // all critical slots set as useless
            for (int i = 0; i < entity.getNumberOfCriticals(loc); i++) {
                final CriticalSlot cs = entity.getCritical(loc, i);
                if (cs != null) {
                    // for every undamaged actuator destroyed by breaching,
                    // we make a PSR (see bug 1040858)
                    if (entity.locationIsLeg(loc)) {
                        if (cs.isHittable()) {
                            switch (cs.getIndex()) {
                                case Mech.ACTUATOR_UPPER_LEG:
                                case Mech.ACTUATOR_LOWER_LEG:
                                case Mech.ACTUATOR_FOOT:
                                    // leg/foot actuator piloting roll
                                    game.addPSR(new PilotingRollData(
                                            entity.getId(), 1,
                                            "leg/foot actuator hit"));
                                    break;
                                case Mech.ACTUATOR_HIP:
                                    // hip piloting roll (at +0, because we get
                                    // the
                                    // +2
                                    // anyway because the location is breached
                                    // phase report will look a bit weird, but
                                    // the
                                    // roll
                                    // is correct
                                    game.addPSR(new PilotingRollData(
                                            entity.getId(), 0, "hip actuator hit"));
                                    break;
                            }
                        }
                    }
                    cs.setBreached(true);
                }
            }

            // Check location for engine/cockpit breach and report accordingly
            if (loc == Mech.LOC_CT) {
                vDesc.addAll(destroyEntity(entity, "hull breach"));
                if (game.getOptions().booleanOption("auto_abandon_unit")) {
                    vDesc.addAll(abandonEntity(entity));
                }
            }
            if (loc == Mech.LOC_HEAD) {
                entity.getCrew().setDoomed(true);
                vDesc.addAll(destroyEntity(entity, "hull breach"));
                if (entity.getLocationStatus(loc) == ILocationExposureStatus.WET) {
                    r = new Report(6355);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    vDesc.addElement(r);
                } else {
                    r = new Report(6360);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    vDesc.addElement(r);
                }
            }

            // Set the status of the location.
            // N.B. if we set the status before rolling water PSRs, we get a
            // "LEG DESTROYED" modifier; setting the status after gives a hip
            // actuator modifier.
            entity.setLocationStatus(loc, ILocationExposureStatus.BREACHED);

            // Did the hull breach destroy the engine?
            int hitsToDestroy = 3;
            if (mech.isSuperHeavy()
                && (mech.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {
                hitsToDestroy = 2;
            }
            if ((entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                                        Mech.SYSTEM_ENGINE, Mech.LOC_LT)
                 + entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                                          Mech.SYSTEM_ENGINE, Mech.LOC_CT) + entity
                         .getHitCriticals(CriticalSlot.TYPE_SYSTEM,
                                          Mech.SYSTEM_ENGINE, Mech.LOC_RT)) >= hitsToDestroy) {
                vDesc.addAll(destroyEntity(entity, "engine destruction"));
                if (game.getOptions().booleanOption("auto_abandon_unit")) {
                    vDesc.addAll(abandonEntity(entity));
                }
            }

            if (loc == Mech.LOC_LT) {
                vDesc.addAll(breachLocation(entity, Mech.LOC_LARM, hex, false));
            }
            if (loc == Mech.LOC_RT) {
                vDesc.addAll(breachLocation(entity, Mech.LOC_RARM, hex, false));
            }

        }

        return vDesc;
    }

    /**
     * Mark the unit as destroyed! Units transported in the destroyed unit will
     * get a chance to escape.
     *
     * @param entity - the <code>Entity</code> that has been destroyed.
     * @param reason - a <code>String</code> detailing why the entity was
     *               destroyed.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    private Vector<Report> destroyEntity(Entity entity, String reason) {
        return destroyEntity(entity, reason, true);
    }

    /**
     * Marks a unit as destroyed! Units transported inside the destroyed unit
     * will get a chance to escape unless the destruction was not survivable.
     *
     * @param entity     - the <code>Entity</code> that has been destroyed.
     * @param reason     - a <code>String</code> detailing why the entity was
     *                   destroyed.
     * @param survivable - a <code>boolean</code> that identifies the desctruction as
     *                   unsurvivable for transported units.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    public Vector<Report> destroyEntity(Entity entity, String reason,
                                        boolean survivable) {
        // Generally, the entity can still be salvaged.
        return destroyEntity(entity, reason, survivable, true);
    }

    /**
     * Marks a unit as destroyed! Units transported inside the destroyed unit
     * will get a chance to escape unless the destruction was not survivable.
     *
     * @param entity     - the <code>Entity</code> that has been destroyed.
     * @param reason     - a <code>String</code> detailing why the entity was
     *                   destroyed.
     * @param survivable - a <code>boolean</code> that identifies the desctruction as
     *                   unsurvivable for transported units.
     * @param canSalvage - a <code>boolean</code> that indicates if the unit can be
     *                   salvaged (or cannibalized for spare parts). If
     *                   <code>true</code>, salvage operations are possible, if
     *                   <code>false</code>, the unit is too badly damaged.
     * @return a <code>Vector</code> of <code>Report</code> objects that can be
     * sent to the output log.
     */
    private Vector<Report> destroyEntity(Entity entity, String reason,
                                         boolean survivable, boolean canSalvage) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // regardless of what was passed in, units loaded onto aeros not on the
        // ground are destroyed
        if (entity.isAirborne()) {
            survivable = false;
        } else if (entity instanceof Aero) {
            survivable = true;
        }

        // The unit can suffer an ammo explosion after it has been destroyed.
        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;
        if (!canSalvage) {
            entity.setSalvage(canSalvage);
            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;
        }

        // Destroy the entity, unless it's already destroyed.
        if (!entity.isDoomed() && !entity.isDestroyed()) {
            r = new Report(6365);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(reason);
            vDesc.addElement(r);

            entity.setDoomed(true);

            // Kill any picked up MechWarriors
            Enumeration<Integer> iter = entity.getPickedUpMechWarriors()
                                              .elements();
            while (iter.hasMoreElements()) {
                int mechWarriorId = iter.nextElement();
                Entity mw = game.getEntity(mechWarriorId);
                mw.setDestroyed(true);
                // We can safely remove these, as they can't be targeted
                game.removeEntity(mw.getId(), condition);
                entityUpdate(mw.getId());
                send(createRemoveEntityPacket(mw.getId(), condition));
                r = new Report(6370);
                r.subject = mw.getId();
                r.addDesc(mw);
                vDesc.addElement(r);
            }

            // make any remaining tele-missiles operated by this entity
            // out of contact
            for (int missileId : entity.getTMTracker().getMissiles()) {
                Entity tm = game.getEntity(missileId);
                if ((null != tm) && !tm.isDestroyed()
                    && (tm instanceof TeleMissile)) {
                    ((TeleMissile) tm).setOutContact(true);
                    entityUpdate(tm.getId());
                }
            }

            // Mechanized BA that could die on a 3+
            ArrayList<Entity> externalUnits = entity.getExternalUnits();

            // Handle escape of transported units.
            if (entity.getLoadedUnits().size() > 0) {
                Coords curPos = entity.getPosition();
                int curFacing = entity.getFacing();
                for (Entity other : entity.getLoadedUnits()) {
                    // Can the other unit survive?
                    boolean survived = false;
                    if (entity instanceof Tank) {
                        if ((entity.getMovementMode() == EntityMovementMode.NAVAL)
                            || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)) {
                            if (other.getMovementMode() == EntityMovementMode.INF_UMU) {
                                survived = Compute.d6() <= 3;
                            } else if (other.getMovementMode() == EntityMovementMode.INF_JUMP) {
                                survived = Compute.d6() == 1;
                            } else if (other.getMovementMode() == EntityMovementMode.VTOL) {
                                survived = Compute.d6() <= 2;
                            }
                        } else if (entity.getMovementMode() == EntityMovementMode.SUBMARINE) {
                            if (other.getMovementMode() == EntityMovementMode.INF_UMU) {
                                survived = Compute.d6() == 1;
                            }
                        } else {
                            survived = Compute.d6() <= 4;
                        }
                    } else if (entity instanceof Mech) {
                        // mechanized BA can escape on a roll of 1 or 2
                        if (externalUnits.contains(other)) {
                            survived = Compute.d6() < 3;
                        }
                    }
                    if (!survivable
                        || (externalUnits.contains(other) && !survived)) {
                        // Nope.
                        other.setDestroyed(true);
                        // We need to unload the unit, since it's ID goes away
                        entity.unload(other);
                        // Safe to remove, as they aren't targeted
                        game.moveToGraveyard(other.getId());
                        send(createRemoveEntityPacket(other.getId(), condition));
                        r = new Report(6370);
                        r.subject = other.getId();
                        r.addDesc(other);
                        vDesc.addElement(r);
                    }
                    // Can we unload the unit to the current hex?
                    // TODO : unloading into stacking violation is not
                    // explicitly prohibited in the BMRr.
                    else if ((null != Compute.stackingViolation(game,
                                                                other.getId(), curPos))
                             || other.isLocationProhibited(curPos)) {
                        // Nope.
                        other.setDestroyed(true);
                        // We need to unload the unit, since it's ID goes away
                        entity.unload(other);
                        // Safe to remove, as they aren't targeted
                        game.moveToGraveyard(other.getId());
                        send(createRemoveEntityPacket(other.getId(), condition));
                        r = new Report(6375);
                        r.subject = other.getId();
                        r.addDesc(other);
                        vDesc.addElement(r);
                    } // End can-not-unload
                    else {
                        // The other unit survives.
                        unloadUnit(entity, other, curPos, curFacing,
                                   entity.getElevation(), true, false);
                    }

                } // Handle the next transported unit.

            } // End has-transported-unit

            // Handle transporting unit.
            if (Entity.NONE != entity.getTransportId()) {
                final Entity transport = game
                        .getEntity(entity.getTransportId());
                Coords curPos = transport.getPosition();
                int curFacing = transport.getFacing();
                unloadUnit(transport, entity, curPos, curFacing,
                           transport.getElevation());
                entityUpdate(transport.getId());

                // if this is the last fighter in a fighter squadron then remove
                // the squadron
                if ((transport instanceof FighterSquadron)
                    && (((FighterSquadron) transport).getFighters().size() < 1)) {
                    transport.setDestroyed(true);
                    // Can't remove this here, otherwise later attacks will fail
                    //game.moveToGraveyard(transport.getId());
                    //entityUpdate(transport.getId());
                    //send(createRemoveEntityPacket(transport.getId(), condition));
                    r = new Report(6365);
                    r.subject = transport.getId();
                    r.addDesc(transport);
                    r.add("fighter destruction");
                    vDesc.addElement(r);
                }

            } // End unit-is-transported

            // Is this unit being swarmed?
            final int swarmerId = entity.getSwarmAttackerId();
            if (Entity.NONE != swarmerId) {
                final Entity swarmer = game.getEntity(swarmerId);

                swarmer.setSwarmTargetId(Entity.NONE);
                // a unit that stopped swarming due to the swarmed unit dieing
                // should be able to move: setSwarmTargetId to Entity.None
                // changes done to true and unloaded to true, need to undo this
                swarmer.setUnloaded(false);
                swarmer.setDone(false);
                entity.setSwarmAttackerId(Entity.NONE);
                Report.addNewline(vDesc);
                r = new Report(6380);
                r.subject = swarmerId;
                r.addDesc(swarmer);
                vDesc.addElement(r);
                // Swarming infantry shouldn't take damage when their target dies
                // http://bg.battletech.com/forums/total-warfare/swarming-question
                entityUpdate(swarmerId);
            }

            // Is this unit swarming somebody?
            final int swarmedId = entity.getSwarmTargetId();
            if (Entity.NONE != swarmedId) {
                final Entity swarmed = game.getEntity(swarmedId);
                swarmed.setSwarmAttackerId(Entity.NONE);
                entity.setSwarmTargetId(Entity.NONE);
                r = new Report(6385);
                r.subject = swarmed.getId();
                r.addDesc(swarmed);
                vDesc.addElement(r);
                entityUpdate(swarmedId);
            }

            // If in a grapple, release both mechs
            if (entity.getGrappled() != Entity.NONE) {
                int grappler = entity.getGrappled();
                entity.setGrappled(Entity.NONE, false);
                Entity e = game.getEntity(grappler);
                if (e != null) {
                    e.setGrappled(Entity.NONE, false);
                }
                entityUpdate(grappler);
            }

        } // End entity-not-already-destroyed.

        // if using battlefield wreckage rules, then the destruction of this
        // unit
        // might convert the hex to rough
        Coords curPos = entity.getPosition();
        IHex entityHex = game.getBoard().getHex(curPos);
        if (game.getOptions().booleanOption("tacops_battle_wreck")
            && (entityHex != null)
            && game.getBoard().onGround()
            && !((entity instanceof Infantry) || (entity instanceof Protomech))) {
            // large support vees will create ultra rough, otherwise rough
            if (entity instanceof LargeSupportTank) {
                if (entityHex.terrainLevel(Terrains.ROUGH) < 2) {
                    entityHex.addTerrain(Terrains.getTerrainFactory()
                                                 .createTerrain(Terrains.ROUGH, 2));
                    sendChangedHex(curPos);
                }
            } else if ((entity.getWeight() >= 40)
                       && !entityHex.containsTerrain(Terrains.ROUGH)) {
                entityHex.addTerrain(Terrains.getTerrainFactory()
                                             .createTerrain(Terrains.ROUGH, 1));
                sendChangedHex(curPos);
            }

        }

        // update our entity, so clients have correct data
        // needed for MekWars stuff
        entityUpdate(entity.getId());

        return vDesc;
    }

    /**
     * Makes a piece of equipment on a mech explode! POW! This expects either
     * ammo, or an explosive weapon. Returns a vector of Report objects.
     */
    private Vector<Report> explodeEquipment(Entity en, int loc, int slot) {
        CriticalSlot critSlot = en.getCritical(loc, slot);
        Vector<Report> reports = explodeEquipment(en, loc, critSlot.getMount());
        if (critSlot.getMount2() != null) {
            reports.addAll(explodeEquipment(en, loc, critSlot.getMount2()));
        }
        return reports;
    }

    /**
     * Makes a piece of equipment on a mech explode! POW! This expects either
     * ammo, or an explosive weapon. Returns a vector of Report objects.
     */
    public Vector<Report> explodeEquipment(Entity en, int loc, Mounted mounted) {
        Vector<Report> vDesc = new Vector<Report>();
        // is this already destroyed?
        if (mounted.isDestroyed()) {
            System.err.println("server: explodeEquipment called on destroyed"
                               + " equipment (" + mounted.getName() + ')');
            return vDesc;
        }

        // Special case: discharged M- and B-pods shouldn't explode.
        if (((mounted.getType() instanceof MPodWeapon) || (mounted.getType() instanceof BPodWeapon))
            && (mounted.getLinked().getHittableShotsLeft() == 0)) {
            return vDesc;
        }

        // special-case. RACs only explode when jammed
        if ((mounted.getType() instanceof WeaponType)
            && (((WeaponType) mounted.getType()).getAmmoType() == AmmoType.T_AC_ROTARY)) {
            if (!mounted.isJammed()) {
                return vDesc;
            }
        }

        // special case. ACs only explode if firing incendiary ammo or rapid
        // firing
        if ((mounted.getType() instanceof WeaponType)
            && !mounted.curMode().equals("Rapid")
            && ((((WeaponType) mounted.getType()).getAmmoType() == AmmoType.T_AC) || (((WeaponType) mounted
                .getType()).getAmmoType() == AmmoType.T_LAC))) {
            if (!mounted.isUsedThisRound()) {
                return vDesc;
            }
            Mounted ammo = mounted.getLinked();
            if ((ammo == null)
                || !(ammo.getType() instanceof AmmoType)
                || (((AmmoType) ammo.getType()).getMunitionType() != AmmoType.M_INCENDIARY_AC)) {
                return vDesc;
            }

            WeaponType wtype = (WeaponType) mounted.getType();
            if ((wtype.getAmmoType() == AmmoType.T_LRM)
                || (wtype.getAmmoType() == AmmoType.T_LRM_STREAK)
                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)
                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO_COMBO)) {
                return vDesc;
            }
        }

        // special case. HVACs only explode if there's ammo left or rapid firing
        if ((mounted.getType() instanceof HVACWeapon)
            && !mounted.curMode().equals("Rapid")) {
            if (mounted.getEntity().getTotalAmmoOfType(
                    mounted.getLinked().getType()) == 0) {
                return vDesc;
            }
        }

        // special case. Blue Shield Particle Field Damper only explodes when
        // switched on
        if ((mounted.getType() instanceof MiscType)
            && (mounted.getType().hasFlag(MiscType.F_BLUE_SHIELD) && mounted
                .curMode().equals("Off"))) {
            return vDesc;
        }

        // special case. PPC with Capacitor only explodes when charged
        if ((mounted.getType() instanceof MiscType)
            && mounted.getType().hasFlag(MiscType.F_PPC_CAPACITOR)
            && !mounted.curMode().equals("Charge")) {
            return vDesc;
        }
        if ((mounted.getType() instanceof PPCWeapon)
            && (mounted.hasChargedCapacitor() == 0)) {
            return vDesc;
        }

        // Inferno ammo causes heat buildup as well as the damage
        if ((mounted.getType() instanceof AmmoType)
            && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM)
                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_IATM) || (((AmmoType) mounted
                .getType()).getAmmoType() == AmmoType.T_MML))
            && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_INFERNO)
            && (mounted.getHittableShotsLeft() > 0)) {
            en.heatBuildup += Math.min(mounted.getExplosionDamage(), 30);
        }

        // determine and deal damage
        int damage = mounted.getExplosionDamage();

        // Smoke ammo halves damage
        if ((mounted.getType() instanceof AmmoType)
            && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM) || (((AmmoType) mounted
                .getType()).getAmmoType() == AmmoType.T_LRM))
            && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_SMOKE_WARHEAD)
            && (mounted.getHittableShotsLeft() > 0)) {
            damage = ((mounted.getExplosionDamage()) / 2);
        }
        // coolant explodes for 2 damage and reduces heat by 3
        if ((mounted.getType() instanceof AmmoType)
            && ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_VEHICLE_FLAMER) || (((AmmoType) mounted
                .getType()).getAmmoType() == AmmoType.T_HEAVY_FLAMER))
            && (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_COOLANT)
            && (mounted.getHittableShotsLeft() > 0)) {
            damage = 2;
            en.coolFromExternal += 3;
        }

        // divide damage by 10 for aeros, per TW rules on pg. 161
        if (en instanceof Aero) {
            int newdamage = (int) Math.floor(damage / 10.0);
            if ((newdamage == 0) && (damage > 0)) {
                damage = 1;
            } else {
                damage = newdamage;
            }
        }

        if (damage <= 0) {
            return vDesc;
        }

        Report r = new Report(6390);
        r.subject = en.getId();
        r.add(mounted.getName());
        r.add(damage);
        r.indent(3);
        vDesc.addElement(r);
        // Mounted is a weapon and has Hot-Loaded ammo in it and it exploded now
        // we need to roll for chain reaction
        if ((mounted.getType() instanceof WeaponType) && mounted.isHotLoaded()) {
            int roll = Compute.d6(2);
            int ammoExploded = 0;
            r = new Report(6077);
            r.subject = en.getId();
            r.add(roll);
            r.indent(2);
            vDesc.addElement(r);

            // roll of 2-5 means a chain reaction happened
            if (roll < 6) {
                for (Mounted ammo : en.getAmmo()) {
                    if ((ammo.getLocation() == loc)
                        && (ammo.getExplosionDamage() > 0)
                        // Dead-Fire ammo bins are designed not to explode
                        // from the chain reaction
                        // Of Critted Launchers with DFM or HotLoaded ammo.
                        && (((AmmoType) ammo.getType()).getMunitionType() != AmmoType.M_DEAD_FIRE)) {
                        ammoExploded++;
                        vDesc.addAll(this.explodeEquipment(en, loc, ammo));
                        break;
                    }
                }
                if (ammoExploded == 0) {
                    r = new Report(6078);
                    r.subject = en.getId();
                    r.indent(2);
                    vDesc.addElement(r);
                }
            } else {
                r = new Report(6079);
                r.subject = en.getId();
                r.indent(2);
                vDesc.addElement(r);
            }
        }

        HitData hit = new HitData(loc);
        // check to determine whether this is capital scale if we have a capital
        // scale entity
        if (mounted.getType() instanceof AmmoType) {
            if (((AmmoType) mounted.getType()).isCapital()) {
                hit.setCapital(true);
            }
        }

        // exploding RISC laser pulse module should cause no normal crits, just
        // automatically crit the first uncritted crit of the laser it's
        // attached to
        if ((mounted.getType() instanceof MiscType)  && mounted.getType().hasFlag(MiscType.F_RISC_LASER_PULSE_MODULE)) {
            hit.setEffect(HitData.EFFECT_NO_CRITICALS);
            Mounted laser = mounted.getLinkedBy();
            if (en instanceof Mech) {
                for (int slot = 0; slot < en.getNumberOfCriticals(laser.getLocation()); slot++) {
                    CriticalSlot cs = en.getCritical(laser.getLocation(), slot);
                    if ((cs.getType() == CriticalSlot.TYPE_EQUIPMENT) && cs.getMount().equals(laser) && cs.isHittable()) {
                        cs.setHit(true);
                        cs.setRepairable(true);
                        break;
                    }
                }
            }
            laser.setHit(true);
        }

        mounted.setShotsLeft(0);
        Vector<Report> newReports = damageEntity(en, hit, damage, true);
        for (Report rep : newReports) {
            rep.indent(2);
        }
        vDesc.addAll(newReports);
        Report.addNewline(vDesc);

        int pilotDamage = 2;
        if (en instanceof Aero) {
            pilotDamage = 1;
        }
        if (game.getOptions().booleanOption("case_pilot_damage")
            && (en.locationHasCase(hit.getLocation()) || en.hasCASEII(hit
                                                                              .getLocation()))) {
            pilotDamage = 1;
        }
        if (en.getCrew().getOptions().booleanOption("pain_resistance")
            || en.getCrew().getOptions().booleanOption("iron_man")) {
            pilotDamage -= 1;
        }
        // tanks only take pilot damage when using BVDNI or VDNI
        if ((en instanceof Tank)
            && !(en.getCrew().getOptions().booleanOption("vdni") || en
                .getCrew().getOptions().booleanOption("bvdni"))) {
            pilotDamage = 0;
        }
        if (!en.getCrew().getOptions().booleanOption("pain_shunt")) {
            vDesc.addAll(damageCrew(en, pilotDamage));
        }
        if (en.getCrew().isDoomed() || en.getCrew().isDead()) {
            vDesc.addAll(destroyEntity(en, "crew death", true));
        } else {
            Report.addNewline(vDesc);
        }

        return vDesc;
    }

    /**
     * Makes one slot of ammo, determined by certain rules, explode on a mech.
     */
    private Vector<Report> explodeAmmoFromHeat(Entity entity) {
        int damage = 0;
        int rack = 0;
        int boomloc = -1;
        int boomslot = -1;
        Vector<Report> vDesc = new Vector<Report>();

        for (int j = 0; j < entity.locations(); j++) {
            for (int k = 0; k < entity.getNumberOfCriticals(j); k++) {
                CriticalSlot cs = entity.getCritical(j, k);
                if ((cs == null) || cs.isDestroyed() || cs.isHit()
                    || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {
                    continue;
                }
                Mounted mounted = cs.getMount();
                if ((mounted == null)
                    || (!(mounted.getType() instanceof AmmoType))) {
                    continue;
                }
                AmmoType atype = (AmmoType) mounted.getType();
                if (!atype.isExplosive(mounted)) {
                    continue;
                }
                // coolant pods and flamer coolant ammo don't explode from heat
                if ((atype.getAmmoType() == AmmoType.T_COOLANT_POD)
                        || (((atype.getAmmoType() == AmmoType.T_VEHICLE_FLAMER)
                                || (atype.getAmmoType() == AmmoType.T_HEAVY_FLAMER))
                                && (atype.getMunitionType() == AmmoType.M_COOLANT))) {
                    continue;
                }
                // ignore empty, destroyed, or missing bins
                if (mounted.getHittableShotsLeft() == 0) {
                    continue;
                }
                // TW page 160, compare one rack's
                // damage. Ties go to most rounds.
                int newRack = atype.getDamagePerShot() * atype.getRackSize();
                int newDamage = mounted.getExplosionDamage();
                Mounted mount2 = cs.getMount2();
                if ((mount2 != null) && (mount2.getType() instanceof AmmoType)
                    && (mount2.getHittableShotsLeft() > 0)) {
                    // must be for same weapontype, so racksize stays
                    atype = (AmmoType) mount2.getType();
                    newRack += atype.getDamagePerShot() * atype.getRackSize();
                    newDamage += mount2.getExplosionDamage();
                }
                if (!mounted.isHit()
                    && ((rack < newRack) || ((rack == newRack) && (damage < newDamage)))) {
                    rack = newRack;
                    damage = newDamage;
                    boomloc = j;
                    boomslot = k;
                }
            }
        }
        if ((boomloc != -1) && (boomslot != -1)) {
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);
            slot.setHit(true);
            slot.getMount().setHit(true);
            if (slot.getMount2() != null) {
                slot.getMount2().setHit(true);
            }
            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));
        } else {
            // Luckily, there is no ammo to explode.
            Report r = new Report(5105);
            r.subject = entity.getId();
            r.indent();
            vDesc.addElement(r);
        }
        return vDesc;
    }

    /**
     * Makes a mech fall.
     *
     * @param entity
     *            The Entity that is falling. It is expected that the Entity's
     *            position and elevation reflect the state prior to the fall
     * @param fallPos
     *            The location that the Entity is falling into.
     * @param fallHeight
     *            The height that Entity is falling.
     * @param facing
     *            The facing of the fall. Used to determine the the hit location
     *            and also determines facing after the fall (used as an offset
     *            of the Entity's current facing).
     * @param roll
     *            The PSR required to avoid damage to the pilot/crew.
     * @param intoBasement
     *            Flag that determines whether this is a fall into a basement or
     *            not.
     */
    private Vector<Report> doEntityFall(Entity entity, Coords fallPos,
            int fallHeight, int facing, PilotingRollData roll,
            boolean intoBasement) {
        entity.setFallen(true);

        Vector<Report> vPhaseReport = new Vector<Report>();
        Report r;

        IHex fallHex = game.getBoard().getHex(fallPos);

        boolean handlingBasement = false;
        int damageTable = ToHitData.HIT_NORMAL;

        // we don't need to deal damage yet, if the entity is doing DFA
        if (entity.isMakingDfa()) {
            r = new Report(2305);
            r.subject = entity.getId();
            vPhaseReport.add(r);
            entity.setProne(true);
            return vPhaseReport;
        }

        // facing after fall
        String side;
        int table;
        switch (facing) {
            case 1:
            case 2:
                side = "right side";
                table = ToHitData.SIDE_RIGHT;
                break;
            case 3:
                side = "rear";
                table = ToHitData.SIDE_REAR;
                break;
            case 4:
            case 5:
                side = "left side";
                table = ToHitData.SIDE_LEFT;
                break;
            case 0:
            default:
                side = "front";
                table = ToHitData.SIDE_FRONT;
        }

        int waterDepth = 0;
        if (fallHex.containsTerrain(Terrains.WATER)) {
            // *Only* use this if there actually is water in the hex, otherwise
            // we get ITerrain.LEVEL_NONE, i.e. Integer.minValue...
            waterDepth = fallHex.terrainLevel(Terrains.WATER);
        }
        boolean fallOntoBridge = false;
        // only fall onto the bridge if we were in the hex and on it,
        // or we fell from a hex that the bridge exits to
        if ((entity.climbMode() && (entity.getPosition() != fallPos)
             && fallHex.containsTerrain(Terrains.BRIDGE) && fallHex
                .containsTerrainExit(Terrains.BRIDGE,
                                     fallPos.direction(entity.getPosition())))
            || (entity.getElevation() == fallHex
                .terrainLevel(Terrains.BRIDGE_ELEV))) {
            fallOntoBridge = true;
        }
        int bridgeElev = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
        int buildingElev = fallHex.terrainLevel(Terrains.BLDG_ELEV);
        int damageHeight = fallHeight;
        int newElevation = 0;

        // we might have to check if the building/bridge we are falling onto
        // collapses
        boolean checkCollapse = false;

        if ((entity.relHeight() >= buildingElev)
            && (buildingElev >= 0)) {
            // fallHeight should already reflect this
            newElevation = buildingElev;
            checkCollapse = true;
        } else if (fallOntoBridge && (entity.relHeight() >= bridgeElev)
                && (bridgeElev >= 0)) {
            // fallHeight should already reflect this
            waterDepth = 0;
            newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);
            checkCollapse = true;
        } else if (fallHex.containsTerrain(Terrains.ICE)
                   && (entity.getElevation() == 0)) {
            waterDepth = 0;
            newElevation = 0;
            // If we are in a basement, we are at a negative elevation, and so
            // setting newElevation = 0 will cause us to "fall up"
        } else if ((entity.getMovementMode() != EntityMovementMode.VTOL)
                   && (game.getBoard().getBuildingAt(fallPos) != null)) {
            newElevation = entity.getElevation();
        }
        // HACK: if the dest hex is water, assume that the fall height given is
        // to the floor of the hex, and modify it so that it's to the surface
        else if (waterDepth > 0) {
            damageHeight = fallHeight - waterDepth;
            newElevation = -waterDepth;
        }
        // only do these basement checks if we didn't fall onto the building
        // from above
        if (intoBasement) {
            Building bldg = game.getBoard().getBuildingAt(fallPos);
            BasementType bsmnt = bldg.getBasement(fallPos);
            if ((bsmnt != BasementType.NONE)
                && (bsmnt != BasementType.ONE_DEEP_NORMALINFONLY)
                && (entity.getElevation() == 0)
                && (bldg.getBasementCollapsed(fallPos) == true)) {

                if (fallHex.depth(true) == 0) {
                    System.err.println(" Entity " + entity.getDisplayName()
                            + " is falling into a depth " + fallHex.depth(true)
                            + " basement -- not allowed!!");
                    return vPhaseReport;
                }
                damageHeight = bsmnt.getDepth();

                newElevation = newElevation - damageHeight;

                handlingBasement = true;
                // May have to adjust hit table for 'mechs
                if (entity instanceof Mech) {
                    if ((bsmnt == BasementType.TWO_DEEP_FEET)
                            || (bsmnt == BasementType.ONE_DEEP_FEET)) {
                        damageTable = ToHitData.HIT_KICK;
                    } else if ((bsmnt == BasementType.TWO_DEEP_HEAD)
                            || (bsmnt == BasementType.ONE_DEEP_HEAD)) {
                        damageTable = ToHitData.HIT_PUNCH;
                    } else {
                        damageTable = ToHitData.HIT_NORMAL;
                    }
                }
            }
        }
        if (entity instanceof Protomech) {
            damageTable = ToHitData.HIT_SPECIAL_PROTO;
        }
        // Falling into water instantly destroys most non-mechs
        if ((waterDepth > 0)
            && !(entity instanceof Mech)
            && !(entity instanceof Protomech)
            && !((entity.getRunMP() > 0) && (entity.getMovementMode() == EntityMovementMode.HOVER))
            && (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)
            && (entity.getMovementMode() != EntityMovementMode.NAVAL)
            && (entity.getMovementMode() != EntityMovementMode.SUBMARINE)
            && (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {
            vPhaseReport.addAll(destroyEntity(entity, "a watery grave", false));
            return vPhaseReport;
        }

        // set how deep the mech has fallen
        if (entity instanceof Mech) {
            Mech mech = (Mech) entity;
            mech.setLevelsFallen(damageHeight + waterDepth + 1);
            // an industrial mech now needs to check for a crit at the end of
            // the turn
            if (mech.isIndustrial()) {
                mech.setCheckForCrit(true);
            }
        }

        // calculate damage for hitting the surface
        int damage = (int) Math.round(entity.getWeight() / 10.0)
                     * (damageHeight + 1);
        // different rules (pg. 151 of TW) for battle armor and infantry
        if (entity instanceof Infantry) {
            damage = (int) Math.ceil(damageHeight / 2.0);
            // no damage for fall from less than 2 levels
            if (damageHeight < 2) {
                damage = 0;
            }
            if (!(entity instanceof BattleArmor)) {
                int dice = 3;
                if (entity.getMovementMode() == EntityMovementMode.INF_MOTORIZED) {
                    dice = 2;
                } else if ((entity.getMovementMode() == EntityMovementMode.INF_JUMP)
                           || ((Infantry) entity).isMechanized()) {
                    dice = 1;
                }
                damage = damage * Compute.d6(dice);
            }
        }
        // Different rules (pg 151 of TW) for Tanks
        if (entity instanceof Tank) {
            // Falls from less than 1 elevation don't damage combat vehicles
            if (damageHeight < 2) {
                damage = 0;
            } else { // Falls from >= 2 elevations damage like crashing VTOLs
                // Ends up being the regular damage: weight / 10 * (height + 1)
                // And this was already computed
            }
        }
        // calculate damage for hitting the ground, but only if we actually fell
        // into water
        // if we fell onto the water surface, that damage is halved.
        int waterDamage = 0;
        if (waterDepth > 0) {
            damage /= 2;
            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (waterDepth + 1)) / 2;
        }

        // If the waterDepth is larger than the fall height,
        // we fell underwater
        if ((waterDepth >= fallHeight) && ((waterDepth != 0) || (fallHeight != 0))) {
            damage = 0;
            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (fallHeight + 1)) / 2;
        }
        // adjust damage for gravity
        damage = Math
                .round(damage * game.getPlanetaryConditions().getGravity());
        waterDamage = Math.round(waterDamage
                                 * game.getPlanetaryConditions().getGravity());

        // report falling
        if (waterDamage == 0) {
            r = new Report(2310);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side); // international issue
            r.add(damage);
        } else if (damage > 0) {
            r = new Report(2315);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side); // international issue
            r.add(damage);
            r.add(waterDamage);
        } else {
            r = new Report(2310);
            r.subject = entity.getId();
            r.indent();
            r.addDesc(entity);
            r.add(side); // international issue
            r.add(waterDamage);
        }
        vPhaseReport.add(r);

        // Any swarming infantry will be dislodged, but we don't want to
        // interrupt the fall's report. We have to get the ID now because
        // the fall may kill the entity which will reset the attacker ID.
        final int swarmerId = entity.getSwarmAttackerId();

        // Positioning must be prior to damage for proper handling of breaches
        // Only Mechs can fall prone.
        if (entity instanceof Mech) {
            entity.setProne(true);
        }
        entity.setPosition(fallPos);
        entity.setElevation(newElevation);
        // Only 'mechs change facing when they fall
        if (entity instanceof Mech) {
            entity.setFacing((entity.getFacing() + (facing)) % 6);
            entity.setSecondaryFacing(entity.getFacing());
        }

        // if falling into a bog-down hex, the entity automatically gets stuck
        if (fallHex.getBogDownModifier(entity.getMovementMode(),
                entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
            entity.setStuck(true);
            r = new Report(2081);
            r.subject = entity.getId();
            r.add(entity.getDisplayName(), true);
            vPhaseReport.add(r);
            // check for quicksand
            vPhaseReport.addAll(checkQuickSand(fallPos));
        }

        // standard damage loop
        if ((entity instanceof Infantry) && (damage > 0)) {
            if (entity instanceof BattleArmor) {
                for (int i = 1; i < entity.locations(); i++) {
                    HitData h = new HitData(i);
                    vPhaseReport.addAll(damageEntity(entity, h, damage));
                    addNewLines();
                }
            } else {
                HitData h = new HitData(Infantry.LOC_INFANTRY);
                vPhaseReport.addAll(damageEntity(entity, h, damage));
            }
        } else {
            while (damage > 0) {
                int cluster = Math.min(5, damage);
                HitData hit = entity.rollHitLocation(damageTable, table);
                hit.makeFallDamage(true);
                vPhaseReport.addAll(damageEntity(entity, hit, cluster));
                damage -= cluster;
            }
        }

        if (waterDepth > 0) {
            for (int loop = 0; loop < entity.locations(); loop++) {
                entity.setLocationStatus(loop, ILocationExposureStatus.WET);
            }
        }
        // Water damage
        while (waterDamage > 0) {
            int cluster = Math.min(5, waterDamage);
            HitData hit = entity.rollHitLocation(damageTable, table);
            hit.makeFallDamage(true);
            vPhaseReport.addAll(damageEntity(entity, hit, cluster));
            waterDamage -= cluster;
        }

        // check for location exposure
        vPhaseReport.addAll(doSetLocationsExposure(entity, fallHex, false,
                                                   -waterDepth));

        // only mechs should roll to avoid pilot damage
        // vehicles may fall due to sideslips
        if ((entity instanceof Mech)
            && !entity.getCrew().getOptions().booleanOption("dermal_armor")
            && !entity.getCrew().getOptions().booleanOption("tsm_implant")) {
            // we want to be able to avoid pilot damage even when it was
            // an automatic fall, only unconsciousness should cause auto-damage
            roll.removeAutos();

            if (fallHeight > 1) {
                roll.addModifier(fallHeight - newElevation - 1, "height of fall");
            }

            if (roll.getValue() == TargetRoll.IMPOSSIBLE) {
                r = new Report(2320);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(entity.getCrew().getName());
                r.indent();
                vPhaseReport.add(r);
                vPhaseReport.addAll(damageCrew(entity, 1));
                Report.addNewline(vPhaseReport);
            } else {
                int diceRoll = entity.getCrew().rollPilotingSkill();
                r = new Report(2325);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.add(entity.getCrew().getName());
                r.add(roll.getValueAsString());
                r.add(diceRoll);
                if (diceRoll >= roll.getValue()) {
                    r.choose(true);
                    vPhaseReport.add(r);
                } else {
                    r.choose(false);
                    vPhaseReport.add(r);
                    vPhaseReport.addAll(damageCrew(entity, 1));
                    Report.addNewline(vPhaseReport);
                }
            }
        }

        // Now dislodge any swarming infantry.
        if (Entity.NONE != swarmerId) {
            final Entity swarmer = game.getEntity(swarmerId);
            entity.setSwarmAttackerId(Entity.NONE);
            swarmer.setSwarmTargetId(Entity.NONE);
            // Did the infantry fall into water?
            if ((waterDepth > 0)
                && (swarmer.getMovementMode() != EntityMovementMode.INF_UMU)) {
                // Swarming infantry die.
                swarmer.setPosition(fallPos);
                r = new Report(2330);
                r.newlines = 0;
                r.subject = swarmer.getId();
                r.addDesc(swarmer);
                vPhaseReport.add(r);
                vPhaseReport.addAll(destroyEntity(swarmer, "a watery grave",
                                                  false));
            } else {
                // Swarming infantry take a 2d6 point hit.
                // ASSUMPTION : damage should not be doubled.
                r = new Report(2335);
                r.newlines = 0;
                r.subject = swarmer.getId();
                r.addDesc(swarmer);
                vPhaseReport.add(r);
                vPhaseReport.addAll(damageEntity(swarmer, swarmer
                        .rollHitLocation(ToHitData.HIT_NORMAL,
                                         ToHitData.SIDE_FRONT), Compute.d6(2)));
                Report.addNewline(vPhaseReport);
            }
            swarmer.setPosition(fallPos);
            entityUpdate(swarmerId);
            if (!swarmer.isDone()) {
                game.removeTurnFor(swarmer);
                swarmer.setDone(true);
                send(createTurnVectorPacket());
            }
        } // End dislodge-infantry

        // clear all PSRs after a fall -- the Mek has already failed ONE and
        // fallen, it'd be cruel to make it fail some more!
        game.resetPSRs(entity);

        // if there is a minefield in this hex, then the mech may set it off
        if (game.containsMinefield(fallPos)
            && enterMinefield(entity, fallPos, newElevation, true,
                              vPhaseReport, 12)) {
            resetMines();
        }
        // if we have to, check if the building/bridge we fell on collapses -
        // unless it's a fall into a basement,
        // then we're already gonna check that in building collapse, where we
        // came from
        if (checkCollapse && !handlingBasement) {

            checkForCollapse(game.getBoard().getBuildingAt(fallPos),
                             game.getPositionMap(), fallPos, false, vPhaseReport);
        }

        return vPhaseReport;
    }

    /**
     * The mech falls into an unoccupied hex from the given height above
     */
    private Vector<Report> doEntityFall(Entity entity, Coords fallPos,
                                        int height, PilotingRollData roll) {
        return doEntityFall(entity, fallPos, height, Compute.d6(1) - 1, roll,
                            false);
    }

    /**
     * The mech falls down in place
     */
    private Vector<Report> doEntityFall(Entity entity, PilotingRollData roll) {
        boolean fallToSurface = false;
        // on ice
        int toSubtract = 0;
        IHex currHex = game.getBoard().getHex(entity.getPosition());
        if (currHex.containsTerrain(Terrains.ICE)
            && (entity.getElevation() != -currHex.depth())) {
            fallToSurface = true;
            toSubtract = 0;
        }
        // on a bridge
        if (currHex.containsTerrain(Terrains.BRIDGE_ELEV)
            && (entity.getElevation() >= currHex
                .terrainLevel(Terrains.BRIDGE_ELEV))) {
            fallToSurface = true;
            toSubtract = currHex.terrainLevel(Terrains.BRIDGE_ELEV);
        }
        // on a building
        if (currHex.containsTerrain(Terrains.BLDG_ELEV)
            && (entity.getElevation() >= currHex
                .terrainLevel(Terrains.BLDG_ELEV))) {
            fallToSurface = true;
            toSubtract = currHex.terrainLevel(Terrains.BLDG_ELEV);
        }
        return doEntityFall(entity, entity.getPosition(), entity.getElevation()
                + (!fallToSurface ? currHex.depth(true) : -toSubtract), roll);
    }

    /**
     * Report: - Any ammo dumps beginning the following round. - Any ammo dumps
     * that have ended with the end of this round.
     */
    private void resolveAmmoDumps() {
        Report r;
        for (Entity entity : game.getEntitiesVector()) {
            for (Mounted m : entity.getAmmo()) {
                if (m.isPendingDump()) {
                    // report dumping next round
                    r = new Report(5110);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                    // update status
                    m.setPendingDump(false);
                    m.setDumping(true);
                } else if (m.isDumping()) {
                    // report finished dumping
                    r = new Report(5115);
                    r.subject = entity.getId();
                    r.addDesc(entity);
                    r.add(m.getName());
                    addReport(r);
                    // update status
                    m.setDumping(false);
                    m.setShotsLeft(0);
                }
            }
            // also do DWP dumping
            if (entity instanceof BattleArmor) {
                for (Mounted m : entity.getWeaponList()) {
                    if (m.isDWPMounted() && m.isPendingDump()) {
                        m.setMissing(true);
                        r = new Report(5116);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(m.getName());
                        addReport(r);
                        m.setPendingDump(false);
                        // Also dump all of the ammo in the DWP
                        for (Mounted ammo : entity.getAmmo()) {
                            if (m.equals(ammo.getLinkedBy())) {
                                ammo.setMissing(true);
                            }
                        }
                    // Check for jettisoning missiles
                    } else if (m.isBodyMounted() && m.isPendingDump()
                            && m.getType().hasFlag(WeaponType.F_MISSILE)
                            && (m.getLinked() != null)
                            && (m.getLinked().getUsableShotsLeft() > 0)) {
                        m.setMissing(true);
                        r = new Report(5116);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(m.getName());
                        addReport(r);
                        m.setPendingDump(false);
                        // Dump all ammo related to this launcher
                        // BA burdened is based on whether the launcher has
                        // ammo left
                        while ((m.getLinked() != null)
                                && (m.getLinked().getUsableShotsLeft() > 0)) {
                            m.getLinked().setMissing(true);
                            entity.loadWeapon(m);
                        }
                    }
                }
            }
            entity.reloadEmptyWeapons();
        }
    }

    /**
     * Checks for fire ignition based on a given target roll. If successful,
     * lights a fire also checks to see that fire is possible in the specified
     * hex.
     *
     * @param c        - the <code>Coords</code> to be lit.
     * @param roll     - the <code>TargetRoll</code> for the ignition roll
     * @param bInferno - <code>true</code> if the fire is an inferno fire. If this
     *                 value is <code>false</code> the hex will be lit only if it
     *                 contains Woods,jungle or a Building.
     * @param entityId - the entityId responsible for the ignite attempt. If the
     *                 value is Entity.NONE, then the roll attempt will not be
     *                 included in the report.
     */
    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno,
                                 int entityId, Vector<Report> vPhaseReport) {

        IHex hex = game.getBoard().getHex(c);

        // The hex might be null due to spreadFire translation
        // goes outside of the board limit.
        if (null == hex) {
            return false;
        }

        // The hex may already be on fire.
        if (hex.containsTerrain(Terrains.FIRE)) {
            return false;
        }

        if (!bInferno && !hex.isIgnitable()) {
            return false;
        }

        int fireRoll = Compute.d6(2);
        Report r = null;
        if (entityId != Entity.NONE) {
            r = new Report(3430);
            r.indent(2);
            r.subject = entityId;
            r.add(roll.getValueAsString());
            r.add(roll.getDesc());
            r.add(fireRoll);
            vPhaseReport.add(r);
        }
        if (fireRoll >= roll.getValue()) {
            ignite(c, Terrains.FIRE_LVL_NORMAL, vPhaseReport);
            return true;
        }
        return false;
    }

    /**
     * Returns true if the hex is set on fire with the specified roll. Of
     * course, also checks to see that fire is possible in the specified hex.
     * This version of the method will not report the attempt roll.
     *
     * @param c        - the <code>Coords</code> to be lit.
     * @param roll     - the <code>int</code> target number for the ignition roll
     * @param bInferno - <code>true</code> if the fire can be lit in any terrain. If
     *                 this value is <code>false</code> the hex will be lit only if
     *                 it contains Woods, jungle or a Building.
     */
    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno) {
        return checkIgnition(c, roll, bInferno, Entity.NONE, null);
    }

    /**
     * Returns true if the hex is set on fire with the specified roll. Of
     * course, also checks to see that fire is possible in the specified hex.
     * This version of the method will not report the attempt roll.
     *
     * @param c    - the <code>Coords</code> to be lit.
     * @param roll - the <code>int</code> target number for the ignition roll
     */
    public boolean checkIgnition(Coords c, TargetRoll roll) {
        // default signature, assuming only woods can burn
        return checkIgnition(c, roll, false, Entity.NONE, null);
    }

    /**
     * add fire to a hex
     *
     * @param c         - the <code>Coords</code> of the hex to be set on fire
     * @param fireLevel - The level of fire, see Terrains
     */
    public void ignite(Coords c, int fireLevel, Vector<Report> vReport) {
        // you can't start fires in some planetary conditions!
        if (null != game.getPlanetaryConditions().cannotStartFire()) {
            if (null != vReport) {
                Report r = new Report(3007);
                r.indent(2);
                r.add(game.getPlanetaryConditions().cannotStartFire());
                r.type = Report.PUBLIC;
                vReport.add(r);
            }
            return;
        }

        if (!game.getOptions().booleanOption("tacops_start_fire")) {
            if (null != vReport) {
                Report r = new Report(3008);
                r.indent(2);
                r.type = Report.PUBLIC;
                vReport.add(r);
            }
            return;
        }

        IHex hex = game.getBoard().getHex(c);
        if (null == hex) {
            return;
        }

        Report r = new Report(3005);
        r.indent(2);
        r.add(c.getBoardNum());
        r.type = Report.PUBLIC;

        // Adjust report message for inferno types
        switch (fireLevel) {
            case Terrains.FIRE_LVL_INFERNO:
                r.messageId = 3006;
                break;
            case Terrains.FIRE_LVL_INFERNO_BOMB:
                r.messageId = 3003;
                break;
            case Terrains.FIRE_LVL_INFERNO_IV:
                r.messageId = 3004;
                break;
        }

        // report it
        if (null != vReport) {
            vReport.add(r);
        }
        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                Terrains.FIRE, fireLevel));
        sendChangedHex(c);
    }

    /**
     * remove fire from a hex
     *
     * @param fireCoords
     * @param reason
     */
    public void removeFire(Coords fireCoords, String reason) {
        IHex hex = game.getBoard().getHex(fireCoords);
        if (null == hex) {
            return;
        }
        hex.removeTerrain(Terrains.FIRE);
        hex.resetFireTurn();
        sendChangedHex(fireCoords);
        // fire goes out
        Report r = new Report(5170, Report.PUBLIC);
        r.add(fireCoords.getBoardNum());
        r.add(reason);
        addReport(r);
    }

    /**
     * Called when a fire is burning. Called 3 times per fire hex.
     *
     * @param coords The <code>Coords</code> x-coordinate of the hex
     */
    public void addSmoke(ArrayList<Coords> coords, int windDir, boolean bInferno) {

        // if a tornado, then no smoke!
        if (game.getPlanetaryConditions().getWindStrength() > PlanetaryConditions.WI_STORM) {
            return;
        }

        int smokeLevel = 0;
        for (Coords smokeCoords : coords) {
            IHex smokeHex = game.getBoard().getHex(smokeCoords);
            Report r;
            if (smokeHex == null) {
                continue;
            }
            // Have to check if it's inferno smoke or from a heavy/hardened
            // building
            // - heavy smoke from those
            if (bInferno
                || (Building.MEDIUM < smokeHex
                    .terrainLevel(Terrains.FUEL_TANK))
                || (Building.MEDIUM < smokeHex
                    .terrainLevel(Terrains.BUILDING))) {
                if (smokeHex.terrainLevel(Terrains.SMOKE)
                    == SmokeCloud.SMOKE_HEAVY) {
                    // heavy smoke fills hex
                    r = new Report(5180, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                    smokeLevel = SmokeCloud.SMOKE_HEAVY;
                } else {
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_HEAVY);
                    r = new Report(5185, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                    smokeLevel = SmokeCloud.SMOKE_HEAVY;
                }
            } else {
                if (smokeHex.terrainLevel(Terrains.SMOKE)
                    == SmokeCloud.SMOKE_HEAVY) {
                    // heavy smoke overpowers light
                    r = new Report(5190, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                    addReport(r);
                } else if (smokeHex.terrainLevel(Terrains.SMOKE)
                           == SmokeCloud.SMOKE_LIGHT) {
                    // light smoke continue to fill hex
                    r = new Report(5195, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                } else {
                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);
                    // light smoke fills hex
                    r = new Report(5200, Report.PUBLIC);
                    r.add(smokeCoords.getBoardNum());
                    addReport(r);
                }
            }
        }
        createSmoke(coords, smokeLevel, 0);
    }

    /**
     * Scans the boards directory for map boards of the appropriate size and
     * returns them.
     *
     * @return A list of relative paths to the board files, without the '.board'
     * extension.
     */
    private ArrayList<String> scanForBoardsInDir(final File boardDir,
            final String basePath, final BoardDimensions dimensions,
            ArrayList<String> boards) {
        if (boardDir == null) {
            throw new IllegalArgumentException("must provide searchDir");
        }

        if (basePath == null) {
            throw new IllegalArgumentException("must provide basePath");
        }

        if (dimensions == null) {
            throw new IllegalArgumentException("must provide dimensions");
        }

        if (boards == null) {
            throw new IllegalArgumentException("must provide boards");
        }

        String fileList[] = boardDir.list();
        for (String filename : fileList) {
            File filepath = new File(boardDir, filename);
            if (filepath.isDirectory()) {
                scanForBoardsInDir(new File(boardDir, filename), basePath
                        .concat(File.separator).concat(filename), dimensions,
                        boards);
            } else {
                if (filename.endsWith(".board")) { //$NON-NLS-1$
                    if (Board.boardIsSize(filepath, dimensions)) {
                        boards.add(basePath.concat(File.separator)
                                .concat(filename.substring(0,
                                        filename.lastIndexOf("."))));
                    }
                }
            }
        }
        return boards;
    }

    /**
     * Recursively scan the specified path to determine the board sizes
     * available.
     *
     * @param searchDir The directory to search below this path (may be null for all
     *                  in base path).
     * @return
     */
    private void getBoardSizesInDir(final File searchDir,
                                    TreeSet<BoardDimensions> sizes) {
        if (searchDir == null) {
            throw new IllegalArgumentException("must provide searchDir");
        }

        if (sizes == null) {
            throw new IllegalArgumentException("must provide sizes");
        }

        String file_list[] = searchDir.list();

        for (String filename : file_list) {
            File query_file = new File(searchDir, filename);

            if (query_file.isDirectory()) {
                getBoardSizesInDir(query_file, sizes);
            } else {
                try {
                    if (filename.endsWith(".board")) { //$NON-NLS-1$
                        BoardDimensions size = Board.getSize(query_file);
                        if (size == null) {
                            throw new Exception();
                        }
                        sizes.add(Board.getSize(query_file));
                    }
                } catch (Exception e) {
                    System.out.println("Error parsing board: "
                                       + query_file.getAbsolutePath());
                }
            }
        }
    }

    /**
     * Get a list of the available board sizes from the boards data directory.
     *
     * @return A Set containing all the available board sizes.
     */
    private Set<BoardDimensions> getBoardSizes() {
        TreeSet<BoardDimensions> board_sizes = new TreeSet<BoardDimensions>();

        File boards_dir = Configuration.boardsDir();
        // Slightly overkill sanity check...
        if (boards_dir.isDirectory()) {
            getBoardSizesInDir(boards_dir, board_sizes);
        }

        return board_sizes;
    }

    /**
     * Scan for map boards with the specified dimensions.
     *
     * @param dimensions The desired board dimensions.
     * @return A list of path names, minus the '.board' extension, relative to
     * the boards data directory.
     */
    private ArrayList<String> scanForBoards(final BoardDimensions dimensions) {
        ArrayList<String> boards = new ArrayList<String>();

        File boardDir = Configuration.boardsDir();
        boards.add(MapSettings.BOARD_GENERATED);
        // just a check...
        if (!boardDir.isDirectory()) {
            return boards;
        }

        // scan files
        ArrayList<String> tempList = new ArrayList<String>();
        Comparator<String> sortComp = StringUtil.stringComparator();
        scanForBoardsInDir(boardDir, "", dimensions, tempList);
        // if there are any boards, add these:
        if (tempList.size() > 0) {
            boards.add(MapSettings.BOARD_RANDOM);
            boards.add(MapSettings.BOARD_SURPRISE);
            Collections.sort(tempList, sortComp);
            for (int loop = 0; loop < tempList.size(); loop++) {
                boards.add(tempList.get(loop));
            }
        }

        return boards;
    }

    /**
     * @return wether this game is double blind or not and we should be blind in
     * the current phase
     */
    private boolean doBlind() {
        return game.getOptions().booleanOption("double_blind")
               && game.getPhase()
                      .isDuringOrAfter(IGame.Phase.PHASE_DEPLOYMENT);
    }

    private boolean suppressBlindBV() {
        return game.getOptions().booleanOption("suppress_double_blind_bv");
    }

    /**
     * In a double-blind game, update only visible entities. Otherwise, update
     * everyone
     */
    public void entityUpdate(int nEntityID) {
        entityUpdate(nEntityID, new Vector<UnitLocation>(), true, null);
    }

    /**
     * In a double-blind game, update only visible entities. Otherwise, update
     * everyone
     *
     * @param updateVisibility Flag that determines if whoCanSee needs to be
     *                         called to update who can see the entity for
     *                         double-blind games.
     */
    public void entityUpdate(int nEntityID, Vector<UnitLocation> movePath,
            boolean updateVisibility,
            Map<EntityTargetPair, LosEffects> losCache) {
        Entity eTarget = game.getEntity(nEntityID);
        if (eTarget == null) {
            if (game.getOutOfGameEntity(nEntityID) != null) {
                System.err
                        .print("S: attempted to send entity update for out of game entity, id was ");
                System.err.println(nEntityID);
            } else {
                System.err
                        .print("S: attempted to send entity update for null entity, id was ");
                System.err.println(nEntityID);
            }

            return; // do not send the update it will crash the client
        }

        // If we're doing double blind, be careful who can see it...
        if (doBlind()) {
            Vector<IPlayer> playersVector = game.getPlayersVector();
            Vector<IPlayer> vCanSee;
            if (updateVisibility) {
                vCanSee = whoCanSee(eTarget, true, losCache);
            } else {
                vCanSee = eTarget.getWhoCanSee();
            }

            // If this unit has ECM, players with units affected by the ECM will
            //  need to know about this entity, even if they can't see it.
            //  Otherwise, the client can't properly report things like to-hits.
            if ((eTarget.getECMRange() > 0) && (eTarget.getPosition() != null)) {
                int ecmRange = eTarget.getECMRange();
                Coords pos = eTarget.getPosition();
                for (Entity ent : game.getEntitiesVector()) {
                    if ((ent.getPosition() != null)
                        && (pos.distance(ent.getPosition()) <= ecmRange)) {
                        if (!vCanSee.contains(ent.getOwner())) {
                            vCanSee.add(ent.getOwner());
                        }
                    }
                }
            }

            // send an entity update to everyone who can see
            Packet pack = createEntityPacket(nEntityID, movePath);
            for (int x = 0; x < vCanSee.size(); x++) {
                IPlayer p = vCanSee.elementAt(x);
                send(p.getId(), pack);
            }
            // send an entity delete to everyone else
            pack = createRemoveEntityPacket(nEntityID,
                                            eTarget.getRemovalCondition());
            for (int x = 0; x < playersVector.size(); x++) {
                if (!vCanSee.contains(playersVector.elementAt(x))) {
                    IPlayer p = playersVector.elementAt(x);
                    send(p.getId(), pack);
                }
            }

            entityUpdateLoadedUnits(eTarget, vCanSee, playersVector);
        } else {
            // But if we're not, then everyone can see.
            send(createEntityPacket(nEntityID, movePath));
        }
    }

    /**
     * Whenever updating an Entity, we also need to update all of its loaded
     * Entity's, otherwise it could cause issues with Clients.
     *
     * @param loader        An Entity being updated that is transporting units that should
     *                      also send an update
     * @param vCanSee       The list of Players who can see the loader.
     * @param playersVector The list of all Players
     */
    private void entityUpdateLoadedUnits(Entity loader,
                                         Vector<IPlayer> vCanSee, Vector<IPlayer> playersVector) {
        Packet pack;

        // In double-blind, the client may not know about the loaded units,
        // so we need to send them.
        for (Entity eLoaded : loader.getLoadedUnits()) {
            // send an entity update to everyone who can see
            pack = createEntityPacket(eLoaded.getId(), null);
            for (int x = 0; x < vCanSee.size(); x++) {
                IPlayer p = vCanSee.elementAt(x);
                send(p.getId(), pack);
            }
            // send an entity delete to everyone else
            pack = createRemoveEntityPacket(eLoaded.getId(),
                                            eLoaded.getRemovalCondition());
            for (int x = 0; x < playersVector.size(); x++) {
                if (!vCanSee.contains(playersVector.elementAt(x))) {
                    IPlayer p = playersVector.elementAt(x);
                    send(p.getId(), pack);
                }
            }
            entityUpdateLoadedUnits(eLoaded, vCanSee, playersVector);
        }
    }

    /**
     * Returns a vector of which players can see this entity, always allowing
     * for sensor detections.
     */
    private Vector<IPlayer> whoCanSee(Entity entity) {
        return whoCanSee(entity, true, null);
    }

    /**
     * Returns a vector of which players can see the given entity, optionally
     * allowing for sensors to count.
     *
     * @param entity     The entity to check visiblity for
     * @param useSensors A flag that determines whether sensors are allowed
     * @return A vector of the players who can see the entity
     */
    private Vector<IPlayer> whoCanSee(Entity entity, boolean useSensors,
            Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        // Some times Null entities are sent to this
        if (entity == null) {
            return new Vector<IPlayer>();
        }

        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption("tacops_sensors") && useSensors) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }

        boolean bTeamVision = game.getOptions().booleanOption("team_vision");
        List<Entity> vEntities = game.getEntitiesVector();

        Vector<IPlayer> vCanSee = new Vector<IPlayer>();
        vCanSee.addElement(entity.getOwner());
        if (bTeamVision) {
            addTeammates(vCanSee, entity.getOwner());
        }

        // Deal with players who can see all.
        for (Enumeration<IPlayer> p = game.getPlayers(); p.hasMoreElements();) {
            IPlayer player = p.nextElement();

            if (player.canSeeAll() && !vCanSee.contains(p)) {
                vCanSee.addElement(player);
            }
        }

        // If the entity is hidden, skip; noone else will be able to see it.
        if (entity.isHidden()) {
            return vCanSee;
        }
        for (Entity spotter : vEntities) {
            // Certain conditions make the spotter ineligible
            if (!spotter.isActive() || spotter.isOffBoard()
                    || vCanSee.contains(spotter.getOwner())) {
                continue;
            }
            // See if the LosEffects is cached, and if not cache it
            EntityTargetPair etp = new EntityTargetPair(spotter, entity);
            LosEffects los = losCache.get(etp);
            if (los == null) {
                los = LosEffects.calculateLos(game, spotter.getId(), entity);
                losCache.put(etp, los);
            }
            if (Compute.canSee(game, spotter, entity, useSensors, los,
                    allECMInfo)) {
                if (!vCanSee.contains(spotter.getOwner())) {
                    vCanSee.addElement(spotter.getOwner());
                }
                if (bTeamVision) {
                    addTeammates(vCanSee, spotter.getOwner());
                }
                addObservers(vCanSee);
            }
        }
        return vCanSee;
    }

    /**
     * Determine which players can detect the given entity with sensors.
     * Because recomputing ECM and LosEffects frequently can get expensive, this
     * data can be cached and passed in.
     *
     * @param entity        The Entity being detected.
     * @param allECMInfo    Cached ECMInfo for all Entities in the game.
     * @param losCache      Cached LosEffects for particular Entity/Targetable
     *                      pairs.  Can be passed in null.
     * @return
     */
    private Vector<IPlayer> whoCanDetect(Entity entity,
            List<ECMInfo> allECMInfo,
            Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }

        boolean bTeamVision = game.getOptions().booleanOption("team_vision");
        List<Entity> vEntities = game.getEntitiesVector();

        Vector<IPlayer> vCanDetect = new Vector<IPlayer>();

        // If the entity is hidden, skip; noone else will be able to detect it
        if (entity.isHidden() || entity.isOffBoard()) {
            return vCanDetect;
        }

        for (Entity spotter : vEntities) {
            if (!spotter.isActive() || spotter.isOffBoard()
                    || vCanDetect.contains(spotter.getOwner())) {
                continue;
            }
            // See if the LosEffects is cached, and if not cache it
            EntityTargetPair etp = new EntityTargetPair(spotter, entity);
            LosEffects los = losCache.get(etp);
            if (los == null) {
                los = LosEffects.calculateLos(game, spotter.getId(), entity);
                losCache.put(etp, los);
            }
            if (Compute.inSensorRange(game, los, spotter, entity, allECMInfo)) {
                if (!vCanDetect.contains(spotter.getOwner())) {
                    vCanDetect.addElement(spotter.getOwner());
                }
                if (bTeamVision) {
                    addTeammates(vCanDetect, spotter.getOwner());
                }
                addObservers(vCanDetect);
            }
            }

        return vCanDetect;
    }

    /**
     * Adds teammates of a player to the Vector. Utility function for whoCanSee.
     */
    private void addTeammates(Vector<IPlayer> vector, IPlayer player) {
        Vector<IPlayer> playersVector = game.getPlayersVector();
        for (int j = 0; j < playersVector.size(); j++) {
            IPlayer p = playersVector.elementAt(j);
            if (!player.isEnemyOf(p) && !vector.contains(p)) {
                vector.addElement(p);
            }
        }
    }

    /**
     * Adds observers to the Vector. Utility function for whoCanSee.
     */
    private void addObservers(Vector<IPlayer> vector) {
        Vector<IPlayer> playersVector = game.getPlayersVector();
        for (int j = 0; j < playersVector.size(); j++) {
            IPlayer p = playersVector.elementAt(j);
            if (p.isObserver() && !vector.contains(p)) {
                vector.addElement(p);
            }
        }
    }

    /**
     * Send the complete list of entities to the players. If double_blind is in
     * effect, enforce it by filtering the entities
     */
    private void entityAllUpdate() {
        // If double-blind is in effect, filter each players' list individually,
        // and then quit out...
        if (doBlind()) {
            Vector<IPlayer> playersVector = game.getPlayersVector();
            for (int x = 0; x < playersVector.size(); x++) {
                IPlayer p = playersVector.elementAt(x);
                send(p.getId(), createFilteredEntitiesPacket(p, null));
            }
            return;
        }

        // Otherwise, send the full list.
        send(createEntitiesPacket());
    }

    /**
     * Filters an entity vector according to LOS
     */
    private List<Entity> filterEntities(IPlayer pViewer,
            List<Entity> vEntities,
            Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        Vector<Entity> vCanSee = new Vector<Entity>();
        Vector<Entity> vMyEntities = new Vector<Entity>();
        boolean bTeamVision = game.getOptions().booleanOption("team_vision");

        // If they can see all, return the input list
        if (pViewer.canSeeAll()) {
            return vEntities;
        }

        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption("tacops_sensors")) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }

        // If they're an observer, they can see anything seen by any enemy.
        if (pViewer.isObserver()) {
            vMyEntities.addAll(vEntities);
            for (Entity a : vMyEntities) {
                for (Entity b : vMyEntities) {
                    if (a.isEnemyOf(b)
                        && Compute.canSee(game, b, a, true, null, allECMInfo)) {
                        addVisibleEntity(vCanSee, a);
                        break;
                    }
                }
            }
            return vCanSee;
        }

        // If they aren't an observer and can't see all, create the list of
        // "friendly" units.
        for (Entity e : vEntities) {
            if ((e.getOwner() == pViewer)
                || (bTeamVision && !e.getOwner().isEnemyOf(pViewer))) {
                vMyEntities.addElement(e);
            }
        }

        // Then, break down the list by whether they're friendly,
        // or whether or not any friendly unit can see them.
        for (Entity e : vEntities) {
            // If it's their own unit, obviously, they can see it.
            if (vMyEntities.contains(e)) {
                addVisibleEntity(vCanSee, e);
                continue;
            } else if (e.isHidden()) {
                // If it's NOT friendly and is hidden, they can't see it,
                // period.
                // LOS doesn't matter.
                continue;
            }
            for (Entity spotter : vMyEntities) {

                // If they're off-board, skip it; they can't see anything.
                if (spotter.isOffBoard()) {
                    continue;
                }

                // See if the LosEffects is cached, and if not cache it
                EntityTargetPair etp = new EntityTargetPair(spotter, e);
                LosEffects los = losCache.get(etp);
                if (los == null) {
                    los = LosEffects.calculateLos(game, spotter.getId(), e);
                    losCache.put(etp, los);
                }
                // Otherwise, if they can see the entity in question
                if (Compute.canSee(game, spotter, e, true, los, allECMInfo)) {
                    addVisibleEntity(vCanSee, e);
                    break;
                }

                // If this unit has ECM, players with units affected by the ECM
                //  will need to know about this entity, even if they can't see
                //  it.  Otherwise, the client can't properly report things
                //  like to-hits.
                if ((e.getECMRange() > 0) && (e.getPosition() != null) &&
                    (spotter.getPosition() != null)) {
                    int ecmRange = e.getECMRange();
                    Coords pos = e.getPosition();
                    if (pos.distance(spotter.getPosition()) <= ecmRange) {
                        addVisibleEntity(vCanSee, e);
                    }
                }
            }
        }

        return vCanSee;
    }

    /**
     * Recursive method to add an <code>Entity</code> and all of its transported
     * units to the list of units visible to a particular player. It is
     * important to ensure that if a unit is in the list of visible units then
     * all of its transported units (and their transported units, and so on) are
     * also considered visible, otherwise it can lead to issues. This method
     * also ensures that no duplicate Entities are added.
     *
     * @param vCanSee A collection of units that can be see
     * @param e       An Entity that is seen and needs to be added to the collection
     *                of seen entities. All of
     */
    private void addVisibleEntity(Vector<Entity> vCanSee, Entity e) {
        if (!vCanSee.contains(e)) {
            vCanSee.add(e);
        }
        for (Entity transported : e.getLoadedUnits()) {
            addVisibleEntity(vCanSee, transported);
        }
    }

    /**
     * Filter a report vector for double blind.
     *
     * @param originalReportVector the original <code>Vector<Report></code>
     * @param p                    the <code>Player</code> who should see stuff only visible to
     *                             him
     * @return the <code>Vector<Report></code> with stuff only Player p can see
     */
    private Vector<Report> filterReportVector(
            Vector<Report> originalReportVector, IPlayer p) {
        // If no double blind, no filtering to do
        if (!doBlind()) {
            return new Vector<Report>(originalReportVector);
        }
        // But if it is, then filter everything properly.
        Vector<Report> filteredReportVector = new Vector<Report>();
        for (Report r : originalReportVector) {
            Report filteredReport = filterReport(r, p, false);
            if (filteredReport != null) {
                filteredReportVector.addElement(filteredReport);
            }
        }
        return filteredReportVector;
    }

    /**
     * Filter a single report so that the correct double-blind obscuration takes
     * place. To mark a message as "this should be visible to anyone seeing this
     * entity" set r.subject to the entity id to mark a message as "only visble
     * to the player" set r.player to that player's id and set r.type to
     * Report.PLAYER to mark a message as visible to all, set r.type to
     * Report.PUBLIC
     *
     * @param r         the Report to filter
     * @param p         the Player that we are going to send the filtered report to
     * @param omitCheck boolean indicating that this report hapened in the past, so we
     *                  no longer have access to the Player
     * @return a new Report, which has possibly been obscured
     */
    private Report filterReport(Report r, IPlayer p, boolean omitCheck) {

        if ((r.subject == Entity.NONE) && (r.type != Report.PLAYER)
            && (r.type != Report.PUBLIC)) {
            // Reports that don't have a subject should be public.
            System.err.println("Error: Attempting to filter a Report object "
                               + "that is not public yet has no subject.\n\t\tmessageId: "
                               + r.messageId);
            return r;
        }
        if ((r.type == Report.PUBLIC) || ((p == null) && !omitCheck)) {
            return r;
        }
        Entity entity = game.getEntity(r.subject);
        if (entity == null) {
            entity = game.getOutOfGameEntity(r.subject);
        }
        IPlayer owner = null;
        if (entity != null) {
            owner = entity.getOwner();
            // off board (Artillery) units get treated as public messages
            if (entity.isOffBoard()) {
                return r;
            }
        }

        if ((r.type != Report.PLAYER) && !omitCheck
            && ((entity == null) || (owner == null))) {
            System.err.println("Error: Attempting to filter a Report object "
                               + "that is not public but has a subject (" + entity
                               + ") with owner (" + owner + ").\n\tmessageId: "
                               + r.messageId);
            return r;
        }

        boolean shouldObscure = omitCheck
                                || ((entity != null) && !entity.hasSeenEntity(p))
                                || ((r.type == Report.PLAYER) && (p.getId() != r.player));
        // If supressing double blind messages, don't send this report at all.
        if (game.getOptions()
                .booleanOption("supress_all_double_blind_messages")
            && shouldObscure) {
            // Mark the original report to indicate it was filtered
            if (p != null) {
                r.addObscuredRecipient(p.getName());
            }
            return null;
        }
        Report copy = new Report(r);
        // Otherwise, obscure data in the report
        for (int j = 0; j < copy.dataCount(); j++) {
            if (shouldObscure) {
                // This report should be obscured
                if (r.isValueObscured(j)) {
                    copy.hideData(j);
                    // Mark the original report to indicate which players
                    // received an obscured version of it.
                    if (p != null) {
                        r.addObscuredRecipient(p.getName());
                    }
                }
            }
        }
        return copy;
    }

    /**
     * Returns a vector which has as it's keys the round number and as it's
     * elements vectors that contain all the reports for the specified player
     * that round. The reports returned this way are properly filtered for
     * double blind.
     *
     * @param pastReports
     * @param p
     * @return
     */
    private Vector<Vector<Report>> filterPastReports(
            Vector<Vector<Report>> pastReports, IPlayer p) {
        // Only actually bother with the filtering if double-blind is in effect.
        if (!doBlind()) {
            return pastReports;
        }
        // Perform filtering
        Vector<Vector<Report>> filteredReports = new Vector<Vector<Report>>();
        for (Vector<Report> roundReports : pastReports) {
            Vector<Report> filteredRoundReports = new Vector<Report>();
            for (Report r : roundReports) {
                if (r.isObscuredRecipient(p.getName())) {
                    r = filterReport(r, null, true);
                }
                if (r != null) {
                    filteredRoundReports.addElement(r);
                }
            }
            filteredReports.addElement(filteredRoundReports);
        }
        return filteredReports;
    }

    /**
     * Updates entities graphical "visibility indications" which are used in
     * double-blind games.
     *
     * @param losCache  It can be expensive to have to recompute LoSEffects
     *                  again and again, so in some cases where this may happen,
     *                  the LosEffects are cached.   This can safely be null.
     */
    private void updateVisibilityIndicator(
            Map<EntityTargetPair, LosEffects> losCache) {
        if (losCache == null) {
            losCache = new HashMap<>();
        }
        List<ECMInfo> allECMInfo = null;
        if (game.getOptions().booleanOption("tacops_sensors")) {
            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game
                    .getEntitiesVector());
        }

        List<Entity> vAllEntities = game.getEntitiesVector();
        for (int x = 0; x < vAllEntities.size(); x++) {
            Entity e = vAllEntities.get(x);
            Vector<IPlayer> whoCouldSee = new Vector<>(e.getWhoCanSee());
            Vector<IPlayer> whoCouldDetect =  new Vector<>(e.getWhoCanDetect());
            e.setVisibleToEnemy(false);
            e.setDetectedByEnemy(false);
            e.clearSeenBy();
            e.clearDetectedBy();
            Vector<IPlayer> vCanSee = whoCanSee(e, false, losCache);
            // Who can See this unit?
            for (IPlayer p : vCanSee) {
                if (e.getOwner().isEnemyOf(p) && !p.isObserver()) {
                    e.setVisibleToEnemy(true);
                    e.setEverSeenByEnemy(true);
                    // If we can see it, it's detected
                    e.setDetectedByEnemy(true);
                }
                e.addBeenSeenBy(p);
            }
            // Who can Detect this unit?
            Vector<IPlayer> vCanDetect = whoCanDetect(e, allECMInfo, losCache);
            for (IPlayer p : vCanDetect) {
                if (e.getOwner().isEnemyOf(p) && !p.isObserver()) {
                    e.setDetectedByEnemy(true);
                }
                e.addBeenDetectedBy(p);
            }

            // If a client can now see/detect this entity, but couldn't before,
            // then the client needs to be updated with the Entity
            boolean hasClientWithoutEntity = false;
            for (IPlayer p : vCanSee) {
                if (!whoCouldSee.contains(p) && !whoCouldDetect.contains(p)) {
                    hasClientWithoutEntity = true;
                    break;
                }
            }
            if (!hasClientWithoutEntity) {
                for (IPlayer p : vCanDetect) {
                    if (!whoCouldSee.contains(p)
                            && !whoCouldDetect.contains(p)) {
                        hasClientWithoutEntity = true;
                        break;
                    }
                }
            }
            if (hasClientWithoutEntity) {
                entityUpdate(e.getId(), new Vector<UnitLocation>(), false,
                        losCache);
            } else {
                sendVisibilityIndicator(e);
            }
        }
    }

    /**
     * Checks if an entity added by the client is valid and if so, adds it to
     * the list
     */
    private void receiveEntityAdd(Packet c, int connIndex) {
        @SuppressWarnings("unchecked")
        final List<Entity> entities = (List<Entity>) c.getObject(0);
        ArrayList<Integer> entityIds = new ArrayList<Integer>(entities.size());

        for (final Entity entity : entities) {

            // Verify the entity's design
            if (Server.entityVerifier == null) {
                Server.entityVerifier = EntityVerifier.getInstance(new File(
                        Configuration.unitsDir(),
                        EntityVerifier.CONFIG_FILENAME));
            }

            // Create a TestEntity instance for supported unit types
            TestEntity testEntity = null;
            entity.restore();
            if (entity instanceof Mech) {
                testEntity = new TestMech((Mech) entity,
                        entityVerifier.mechOption, null);
            } else if ((entity.getEntityType() == Entity.ETYPE_TANK)
                       && (entity.getEntityType() != Entity.ETYPE_GUN_EMPLACEMENT)) {
                if (entity.isSupportVehicle()) {
                    testEntity = new TestSupportVehicle((Tank) entity,
                            entityVerifier.tankOption, null);
                } else {
                    testEntity = new TestTank((Tank) entity,
                            entityVerifier.tankOption, null);
                }
            } else if ((entity.getEntityType() == Entity.ETYPE_AERO)
                       && (entity.getEntityType() != Entity.ETYPE_DROPSHIP)
                       && (entity.getEntityType() != Entity.ETYPE_SMALL_CRAFT)
                       && (entity.getEntityType() != Entity.ETYPE_FIGHTER_SQUADRON)
                       && (entity.getEntityType() != Entity.ETYPE_JUMPSHIP)
                       && (entity.getEntityType() != Entity.ETYPE_SPACE_STATION)) {
                testEntity = new TestAero((Aero) entity,
                        entityVerifier.aeroOption, null);
            } else if (entity instanceof BattleArmor) {
                testEntity = new TestBattleArmor((BattleArmor) entity,
                        entityVerifier.baOption, null);
            }

            if (testEntity != null) {
                StringBuffer sb = new StringBuffer();
                if (testEntity.correctEntity(sb,
                        TechConstants.getGameTechLevel(game, entity.isClan()))) {
                    entity.setDesignValid(true);
                } else {
                    System.err.println(sb);
                    if (game.getOptions().booleanOption("allow_illegal_units")) {
                        entity.setDesignValid(false);
                    } else {
                        IPlayer cheater = game.getPlayer(connIndex);
                        sendServerChat("Player " + cheater.getName()
                                       + " attempted to add an illegal unit design ("
                                       + entity.getShortNameRaw()
                                       + "), the unit was rejected.");
                        return;
                    }
                }
            }

            // If we're adding a Protomech, calculate it's unit number.
            if (entity instanceof Protomech) {

                // How many Protomechs does the player already have?
                int numPlayerProtos = game
                        .getSelectedEntityCount(new EntitySelector() {
                            private final int ownerId = entity.getOwnerId();

                            public boolean accept(Entity entity) {
                                if ((entity instanceof Protomech)
                                    && (ownerId == entity.getOwnerId())) {
                                    return true;
                                }
                                return false;
                            }
                        });

                // According to page 54 of the BMRr, Protomechs must be
                // deployed in full Points of five, unless circumstances have
                // reduced the number to less that that.
                entity.setUnitNumber((char) (numPlayerProtos / 5));

            } // End added-Protomech

            // Only assign an entity ID when the client hasn't.
            if (Entity.NONE == entity.getId()) {
                entity.setId(getFreeEntityId());
            }

            game.addEntity(entity);

            // Now we relink C3/C3i to our guys! Yes, this is hackish... but, we
            // do
            // what we must.
            // Its just too bad we have to loop over the entire entities array..
            if (entity.hasC3() || entity.hasC3i()) {
                boolean C3iSet = false;

                for (Entity e : game.getEntitiesVector()) {

                    // C3 Checks
                    if (entity.hasC3()) {
                        if ((entity.getC3MasterIsUUIDAsString() != null)
                            && entity.getC3MasterIsUUIDAsString().equals(
                                e.getC3UUIDAsString())) {
                            entity.setC3Master(e, false);
                            entity.setC3MasterIsUUIDAsString(null);
                        } else if ((e.getC3MasterIsUUIDAsString() != null)
                                   && e.getC3MasterIsUUIDAsString().equals(
                                entity.getC3UUIDAsString())) {
                            e.setC3Master(entity, false);
                            e.setC3MasterIsUUIDAsString(null);
                            // Taharqa: we need to update the other entity for
                            // the
                            // client
                            // or it won't show up right. I am not sure if I
                            // like
                            // the idea of updating other entities in this
                            // method,
                            // but it
                            // will work for now.
                            if (!entities.contains(e)) {
                                entityUpdate(e.getId());
                            }
                        }
                    }

                    // C3i Checks// C3i Checks
                    if (entity.hasC3i() && (C3iSet == false)) {
                        entity.setC3NetIdSelf();
                        int pos = 0;
                        while (pos < Entity.MAX_C3i_NODES) {
                            // We've found a network, join it.
                            if ((entity.getC3iNextUUIDAsString(pos) != null)
                                && (e.getC3UUIDAsString() != null)
                                && entity.getC3iNextUUIDAsString(pos)
                                         .equals(e.getC3UUIDAsString())) {
                                entity.setC3NetId(e);
                                C3iSet = true;
                                break;
                            }

                            pos++;
                        }
                    }
                }
            }
            // Give the unit a spotlight, if it has the spotlight quirk
            entity.setExternalSpotlight(entity.hasExternaSpotlight()
                                        || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));
            entityIds.add(entity.getId());
        }

        send(createAddEntityPacket(entityIds));
    }

    /**
     * adds a squadron to the game
     */
    @SuppressWarnings("unchecked")
    private void receiveSquadronAdd(Packet c, int connIndex) {

        final FighterSquadron fs = (FighterSquadron) c.getObject(0);
        final Vector<Integer> fighters = (Vector<Integer>) c.getObject(1);
        if (fighters.size() < 1) {
            return;
        }
        // fs.setOwner(fighters.firstElement().getOwner());
        // Only assign an entity ID when the client hasn't.
        if (Entity.NONE == fs.getId()) {
            fs.setId(getFreeEntityId());
        }
        game.addEntity(fs);
        for (int id : fighters) {
            Aero fighter = (Aero) game.getEntity(id);
            if (null != fighter) {
                fs.load(fighter, false);
                fs.autoSetMaxBombPoints();
                fighter.setTransportId(fs.getId());
                // If this is the lounge, we want to configure bombs
                if (game.getPhase() == Phase.PHASE_LOUNGE) {
                    fighter.setBombChoices(fs.getBombChoices());
                }
                entityUpdate(fighter.getId());
            }
        }
        send(createAddEntityPacket(fs.getId()));

    }

    /**
     * Updates an entity with the info from the client. Only valid to do this
     * during the lounge phase, except for heat sink changing.
     */
    private void receiveEntityUpdate(Packet c, int connIndex) {
        Entity entity = (Entity) c.getObject(0);
        Entity oldEntity = game.getEntity(entity.getId());
        if ((oldEntity != null)
                && ((oldEntity.getOwner() == getPlayer(connIndex)) || (oldEntity
                        .getOwner().getTeam() == getPlayer(connIndex).getTeam()))) {
            game.setEntity(entity.getId(), entity);
            entityUpdate(entity.getId());
            // In the chat lounge, notify players of customizing of unit
            if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {
                StringBuffer message = new StringBuffer();
                message.append("Unit ");
                if (game.getOptions().booleanOption("blind_drop")
                    || game.getOptions().booleanOption("real_blind_drop")) {
                    if (!entity.getExternalIdAsString().equals("-1")) {
                        message.append('[')
                               .append(entity.getExternalIdAsString())
                               .append("] ");
                    }
                    message.append(entity.getId()).append('(')
                           .append(entity.getOwner().getName()).append(')');
                } else {
                    message.append(entity.getDisplayName());
                }
                message.append(" has been customized.");
                sendServerChat(message.toString());
            }
        } else {
            // hey!
        }
    }

    /**
     * loads an entity into another one. Meant to be called from the chat lounge
     */
    private void receiveEntityLoad(Packet c, int connIndex) {
        int loadeeId = (Integer) c.getObject(0);
        int loaderId = (Integer) c.getObject(1);
        int bayNumber = (Integer) c.getObject(2);
        Entity loadee = game.getEntity(loadeeId);
        Entity loader = game.getEntity(loaderId);

        if ((loadee != null) && (loader != null)) {
            loadUnit(loader, loadee, bayNumber);
            // In the chat lounge, notify players of customizing of unit
            if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {
                /*
                 * StringBuffer message = new StringBuffer();
                 * message.append("Unit "); if
                 * (game.getOptions().booleanOption("blind_drop") ||
                 * game.getOptions().booleanOption("real_blind_drop")) { if
                 * (!entity.getExternalIdAsString().equals("-1")) {
                 * message.append('[') .append(entity.getExternalIdAsString())
                 * .append("] "); } message.append(entity.getId()).append('(')
                 * .append(entity.getOwner().getName()).append(')'); } else {
                 * message.append(entity.getDisplayName()); }
                 * message.append(" has been customized.");
                 * sendServerChat(message.toString());
                 */
                // Set this so units can be unloaded in the first movement phase
                loadee.setLoadedThisTurn(false);
            }
        } else {
            // hey!
        }
    }

    private void receiveCustomInit(Packet c, int connIndex) {
        // In the chat lounge, notify players of customizing of unit
        if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {
            IPlayer p = (IPlayer) c.getObject(0);
            sendServerChat("" + p.getName() + " has customized initiative.");
        }
    }

    /**
     * receive and process an entity mode change packet
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntityModeChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int mode = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }

        try {
            // Check for BA dumping body mounted missile launchers
            if ((e instanceof BattleArmor) && (!m.isMissing())
                    && m.isBodyMounted()
                    && m.getType().hasFlag(WeaponType.F_MISSILE)
                    && (m.getLinked() != null)
                    && (m.getLinked().getUsableShotsLeft() > 0)
                    && (mode <= 0)) {
                m.setPendingDump(mode == -1);
            // a mode change for ammo means dumping or hotloading
            } else if ((m.getType() instanceof AmmoType)
                && !m.getType().hasInstantModeSwitch() && (mode <= 0)) {
                m.setPendingDump(mode == -1);
            } else if ((m.getType() instanceof WeaponType) && m.isDWPMounted()
                       && (mode <= 0)) {
                m.setPendingDump(mode == -1);
            } else {
                if (!m.setMode(mode)) {
                    System.err.println(e.getShortName() + ": " + m.getName()
                                       + ": " + e.getLocationName(m.getLocation())
                                       + " trying to compensate");
                    sendServerChat(e.getShortName() + ": " + m.getName() + ": "
                                   + e.getLocationName(m.getLocation())
                                   + " trying to compensate");
                    e.setGameOptions();

                    if (!m.setMode(mode)) {
                        System.err.println(e.getShortName() + ": "
                                           + m.getName() + ": "
                                           + e.getLocationName(m.getLocation())
                                           + " unable to compensate");
                        sendServerChat(e.getShortName() + ": " + m.getName()
                                       + ": " + e.getLocationName(m.getLocation())
                                       + " unable to compensate");
                    }

                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    /**
     * Receive and process an Entity Sensor Change Packet
     * @param c
     * @param connIndex
     */
    private void receiveEntitySensorChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int sensorId = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        e.setNextSensor(e.getSensors().elementAt(sensorId));
    }

    /**
     * Receive and process an Entity Heat Sinks Change Packet
     * @param c
     * @param connIndex
     */
    private void receiveEntitySinksChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int numSinks = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        if (e instanceof Mech) {
            ((Mech)e).setActiveSinksNextRound(numSinks);
        }
    }


    /**
     * receive and process an entity nova network mode change packet
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntityNovaNetworkModeChange(Packet c, int connIndex) {

        try {
            int entityId = c.getIntValue(0);
            String networkID = c.getObject(1).toString();
            Entity e = game.getEntity(entityId);
            if (e.getOwner() != getPlayer(connIndex)) {
                return;
            }
            // FIXME: Greg: This can result in setting the network to link to
            // hostile units.
            // However, it should be catched by both the ismemberofnetwork test
            // from the c3 module as well as
            // by the clients possible input.
            e.setNewRoundNovaNetworkString(networkID);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    /**
     * receive and process an entity mounted facing change packet
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntityMountedFacingChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int facing = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }
        m.setFacing(facing);
    }

    /**
     * receive and process an entity mode change packet
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntityCalledShotChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != getPlayer(connIndex)) {
            return;
        }
        Mounted m = e.getEquipment(equipId);

        if (m == null) {
            return;
        }
        m.getCalledShot().switchCalledShot();
    }

    /**
     * receive and process an entity sytem mode change packet
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntitySystemModeChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int equipId = c.getIntValue(1);
        int mode = c.getIntValue(2);
        Entity e = game.getEntity(entityId);
        if (e.getOwner() != getPlayer(connIndex)) {
            return;
        }
        if ((e instanceof Mech) && (equipId == Mech.SYSTEM_COCKPIT)) {
            ((Mech) e).setCockpitStatus(mode);
        }
    }

    /**
     * Receive a packet that contains an Entity ammo change
     *
     * @param c
     * @param connIndex
     */
    private void receiveEntityAmmoChange(Packet c, int connIndex) {
        int entityId = c.getIntValue(0);
        int weaponId = c.getIntValue(1);
        int ammoId = c.getIntValue(2);
        Entity e = game.getEntity(entityId);

        // Did we receive a request for a valid Entity?
        if (null == e) {
            System.err
                    .print("Server.receiveEntityAmmoChange: could not find entity #");
            System.err.println(entityId);
            return;
        }
        IPlayer player = getPlayer(connIndex);
        if ((null != player) && (e.getOwner() != player)) {
            System.err.print("Server.receiveEntityAmmoChange: player ");
            System.err.print(player.getName());
            System.err.print(" does not own the entity ");
            System.err.println(e.getDisplayName());
            return;
        }

        // Make sure that the entity has the given equipment.
        Mounted mWeap = e.getEquipment(weaponId);
        Mounted mAmmo = e.getEquipment(ammoId);
        if (null == mAmmo) {
            System.err.print("Server.receiveEntityAmmoChange: entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" does not have ammo #");
            System.err.println(ammoId);
            return;
        }
        if (!(mAmmo.getType() instanceof AmmoType)) {
            System.err.print("Server.receiveEntityAmmoChange: item # ");
            System.err.print(ammoId);
            System.err.print(" of entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" is a ");
            System.err.print(mAmmo.getName());
            System.err.println(" and not ammo.");
            return;
        }
        if (null == mWeap) {
            System.err.print("Server.receiveEntityAmmoChange: entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" does not have weapon #");
            System.err.println(weaponId);
            return;
        }
        if (!(mWeap.getType() instanceof WeaponType)) {
            System.err.print("Server.receiveEntityAmmoChange: item # ");
            System.err.print(weaponId);
            System.err.print(" of entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" is a ");
            System.err.print(mWeap.getName());
            System.err.println(" and not a weapon.");
            return;
        }
        if (((WeaponType) mWeap.getType()).getAmmoType() == AmmoType.T_NA) {
            System.err.print("Server.receiveEntityAmmoChange: item # ");
            System.err.print(weaponId);
            System.err.print(" of entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" is a ");
            System.err.print(mWeap.getName());
            System.err.println(" and does not use ammo.");
            return;
        }
        if (((WeaponType) mWeap.getType()).hasFlag(WeaponType.F_ONESHOT)) {
            System.err.print("Server.receiveEntityAmmoChange: item # ");
            System.err.print(weaponId);
            System.err.print(" of entity ");
            System.err.print(e.getDisplayName());
            System.err.print(" is a ");
            System.err.print(mWeap.getName());
            System.err.println(" and cannot use external ammo.");
            return;
        }

        // Load the weapon.
        e.loadWeapon(mWeap, mAmmo);
    }

    /**
     * Deletes an entity owned by a certain player from the list
     */
    private void receiveEntityDelete(Packet c, int connIndex) {
        @SuppressWarnings("unchecked")
        List<Integer> ids = (List<Integer>) c.getObject(0);
        for (Integer entityId : ids) {
            final Entity entity = game.getEntity(entityId);

            // Only allow players to delete their *own* entities.
            if ((entity != null) && (entity.getOwner() == getPlayer(connIndex))) {

                // If we're deleting a Protomech, recalculate unit numbers.
                if (entity instanceof Protomech) {

                    // How many Protomechs does the player have (include this
                    // one)?
                    int numPlayerProtos = game
                            .getSelectedEntityCount(new EntitySelector() {
                                private final int ownerId = entity.getOwnerId();

                                public boolean accept(Entity entity) {
                                    if ((entity instanceof Protomech)
                                        && (ownerId == entity.getOwnerId())) {
                                        return true;
                                    }
                                    return false;
                                }
                            });

                    // According to page 54 of the BMRr, Protomechs must be
                    // deployed in full Points of five, unless "losses" have
                    // reduced the number to less that that.
                    final char oldMax = (char) (Math
                                                        .ceil(numPlayerProtos / 5.0) - 1);
                    char newMax = (char) (Math
                                                  .ceil((numPlayerProtos - 1) / 5.0) - 1);
                    char deletedUnitNum = entity.getUnitNumber();

                    // Do we have to update a Protomech from the last unit?
                    if ((oldMax != deletedUnitNum) && (oldMax != newMax)) {

                        // Yup. Find a Protomech from the last unit, and
                        // set it's unit number to the deleted entity.
                        Iterator<Entity> lastUnit = game
                                .getSelectedEntities(new EntitySelector() {
                                    private final int ownerId = entity
                                            .getOwnerId();

                                    private final char lastUnitNum = oldMax;

                                    public boolean accept(Entity entity) {
                                        if ((entity instanceof Protomech)
                                            && (ownerId == entity
                                                .getOwnerId())
                                            && (lastUnitNum == entity
                                                .getUnitNumber())) {
                                            return true;
                                        }
                                        return false;
                                    }
                                });
                        Entity lastUnitMember = lastUnit.next();
                        lastUnitMember.setUnitNumber(deletedUnitNum);
                        entityUpdate(lastUnitMember.getId());

                    } // End update-unit-numbetr

                } // End added-Protomech

                if (game.getPhase() != IGame.Phase.PHASE_DEPLOYMENT) {
                    // if a unit is removed during deployment just keep going
                    // without adjusting the turn vector.
                    game.removeTurnFor(entity);
                }
                game.removeEntity(entityId,
                        IEntityRemovalConditions.REMOVE_NEVER_JOINED);

            }
        }
        send(createRemoveEntityPacket(ids,
                IEntityRemovalConditions.REMOVE_NEVER_JOINED));

        // Prevents deployment hanging. Only do this during deployment.
        if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {
            for (Integer entityId : ids) {
                final Entity entity = game.getEntity(entityId);
                endCurrentTurn(entity);
            }
        }
    }

    /**
     * Sets a player's ready status
     */
    private void receivePlayerDone(Packet pkt, int connIndex) {
        boolean ready = pkt.getBooleanValue(0);
        IPlayer player = getPlayer(connIndex);
        if (null != player) {
            player.setDone(ready);
        }
    }

    private void receiveInitiativeRerollRequest(Packet pkt, int connIndex) {
        IPlayer player = getPlayer(connIndex);
        if (IGame.Phase.PHASE_INITIATIVE_REPORT != game.getPhase()) {
            StringBuffer message = new StringBuffer();
            if (null == player) {
                message.append("Player #").append(connIndex);
            } else {
                message.append(player.getName());
            }
            message.append(" is not allowed to ask for a reroll at this time.");
            System.err.println(message.toString());
            sendServerChat(message.toString());
            return;
        }
        if (game.hasTacticalGenius(player)) {
            game.addInitiativeRerollRequest(game.getTeamForPlayer(player));
        }
        if (null != player) {
            player.setDone(true);
        }
        checkReady();
    }

    /**
     * Sets game options, providing that the player has specified the password
     * correctly.
     *
     * @return true if any options have been successfully changed.
     */
    private boolean receiveGameOptions(Packet packet, int connId) {
        IPlayer player = game.getPlayer(connId);
        // Check player
        if (null == player) {
            System.err.print("Server does not recognize player at connection ");
            System.err.println(connId);
            return false;
        }

        // check password
        if ((password != null) && (password.length() > 0)
            && !password.equals(packet.getObject(0))) {
            sendServerChat(connId,
                           "The password you specified to change game options is incorrect.");
            return false;
        }

        if (game.getPhase().isDuringOrAfter(Phase.PHASE_DEPLOYMENT)) {
            return false;
        }

        int changed = 0;

        for (Enumeration<?> i = ((Vector<?>) packet.getObject(1)).elements(); i
                .hasMoreElements(); ) {
            IBasicOption option = (IBasicOption) i.nextElement();
            IOption originalOption = game.getOptions().getOption(
                    option.getName());

            if (originalOption == null) {
                continue;
            }

            StringBuffer message = new StringBuffer();
            message.append("Player ").append(player.getName())
                   .append(" changed option \"")
                   .append(originalOption.getDisplayableName())
                   .append("\" to ").append(option.getValue().toString())
                   .append('.');
            sendServerChat(message.toString());
            originalOption.setValue(option.getValue());
            changed++;
        }

        // Set proper RNG
        Compute.setRNG(game.getOptions().intOption("rng_type"));

        if (changed > 0) {
            for (Entity en : game.getEntitiesVector()) {
                en.setGameOptions();
            }
            entityAllUpdate();
            return true;
        }
        return false;
    }

    /**
     * Performs the additional processing of the received options after the the
     * <code>receiveGameOptions<code> done its job; should be called after
     * <code>receiveGameOptions<code> only if the <code>receiveGameOptions<code>
     * returned <code>true</code>
     *
     * @param packet
     * @param connId
     */
    private void receiveGameOptionsAux(Packet packet, int connId) {

        for (Enumeration<?> i = ((Vector<?>) packet.getObject(1)).elements(); i
                .hasMoreElements(); ) {
            IBasicOption option = (IBasicOption) i.nextElement();
            IOption originalOption = game.getOptions().getOption(
                    option.getName());
            if (originalOption != null) {
                if ("maps_include_subdir".equals(originalOption.getName())) {
                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(
                            mapSettings.getBoardWidth(),
                            mapSettings.getBoardHeight())));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    send(createMapSettingsPacket());
                }
            }
        }

    }

    /**
     * Sends out the game victory event to all connections
     */
    private void transmitGameVictoryEventToAll() {
        for (IConnection conn : connections) {
            send(conn.getId(), new Packet(Packet.COMMAND_GAME_VICTORY_EVENT));
        }
    }

    /**
     * Sends out all player info to the specified connection
     */
    private void transmitAllPlayerConnects(int connId) {
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();

            send(connId, createPlayerConnectPacket(player.getId()));
        }
    }

    /**
     * Creates a packet informing that the player has connected
     */
    private Packet createPlayerConnectPacket(int playerId) {
        final Object[] data = new Object[2];
        data[0] = new Integer(playerId);
        data[1] = getPlayer(playerId);
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);
    }

    /**
     * Creates a packet containing the player info, for update
     */
    private Packet createPlayerUpdatePacket(int playerId) {
        final Object[] data = new Object[2];
        data[0] = new Integer(playerId);
        data[1] = getPlayer(playerId);
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);
    }

    /**
     * Sends out the player info updates for all players to all connections
     */
    private void transmitAllPlayerUpdates() {
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();
            if (null != player) {
                send(createPlayerUpdatePacket(player.getId()));
            }
        }
    }

    /**
     * Sends out the player ready stats for all players to all connections
     */
    private void transmitAllPlayerDones() {
        for (Enumeration<IPlayer> i = game.getPlayers(); i.hasMoreElements(); ) {
            final IPlayer player = i.nextElement();

            send(createPlayerDonePacket(player.getId()));
        }
    }

    /**
     * Creates a packet containing the player ready status
     */
    private Packet createPlayerDonePacket(int playerId) {
        Object[] data = new Object[2];
        data[0] = new Integer(playerId);
        data[1] = Boolean.valueOf(getPlayer(playerId).isDone());
        return new Packet(Packet.COMMAND_PLAYER_READY, data);
    }

    /**
     * Creates a packet containing the current turn vector
     */
    private Packet createTurnVectorPacket() {
        return new Packet(Packet.COMMAND_SENDING_TURNS, game.getTurnVector());
    }

    /**
     * Creates a packet containing the current turn index
     */
    private Packet createTurnIndexPacket() {
        return new Packet(Packet.COMMAND_TURN, new Integer(game.getTurnIndex()));
    }

    /**
     * Creates a packet containing the map settings
     */
    private Packet createMapSettingsPacket() {
        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);
    }

    private Packet createMapSizesPacket() {
        Set<BoardDimensions> sizes = getBoardSizes();
        return new Packet(Packet.COMMAND_SENDING_AVAILABLE_MAP_SIZES, sizes);
    }

    /**
     * Creates a packet containing the planetary conditions
     */
    private Packet createPlanetaryConditionsPacket() {
        return new Packet(Packet.COMMAND_SENDING_PLANETARY_CONDITIONS,
                          game.getPlanetaryConditions());
    }

    /**
     * Creates a packet containing the game settingss
     */
    private Packet createGameSettingsPacket() {
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS,
                          game.getOptions());
    }

    /**
     * Creates a packet containing the game board
     */
    private Packet createBoardPacket() {
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.getBoard());
    }

    /**
     * Creates a packet containing a single entity, for update
     */
    private Packet createEntityPacket(int entityId,
                                      Vector<UnitLocation> movePath) {
        final Entity entity = game.getEntity(entityId);
        final Object[] data = new Object[3];
        data[0] = new Integer(entityId);
        data[1] = entity;
        data[2] = movePath;
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);
    }

    /**
     * Creates a packet containing a Vector of Reports
     */
    private Packet createReportPacket(IPlayer p) {
        // When the final report is created, MM sends a null player to create
        // the
        // report. This will handle that issue.
        if ((p == null) || !doBlind()) {
            return new Packet(Packet.COMMAND_SENDING_REPORTS, vPhaseReport);
        }
        return new Packet(Packet.COMMAND_SENDING_REPORTS, filterReportVector(
                vPhaseReport, p));
    }

    /**
     * Creates a packet containing a Vector of special Reports which needs to be
     * sent during a phase that is not a report phase.
     */
    private Packet createSpecialReportPacket() {
        return new Packet(Packet.COMMAND_SENDING_REPORTS_SPECIAL,
                          vPhaseReport.clone());
    }

    /**
     * Creates a packet containing a Vector of Reports that represent a Tactical
     * Genius re-roll request which needs to update a current phase's report.
     */
    private Packet createTacticalGeniusReportPacket() {
        return new Packet(Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS,
                          vPhaseReport.clone());
    }

    /**
     * Creates a packet containing all the round reports
     */
    private Packet createAllReportsPacket(IPlayer p) {
        return new Packet(Packet.COMMAND_SENDING_REPORTS_ALL,
                          filterPastReports(game.getAllReports(), p));
    }

    /**
     * Creates a packet containing all current entities
     */
    private Packet createEntitiesPacket() {
        return new Packet(Packet.COMMAND_SENDING_ENTITIES,
                          game.getEntitiesVector());
    }

    /**
     * Creates a packet containing all current and out-of-game entities
     */
    private Packet createFullEntitiesPacket() {
        final Object[] data = new Object[2];
        data[0] = game.getEntitiesVector();
        data[1] = game.getOutOfGameEntitiesVector();
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);
    }

    /**
     * Creates a packet containing all entities visible to the player in a blind
     * game
     */
    private Packet createFilteredEntitiesPacket(IPlayer p,
            Map<EntityTargetPair, LosEffects> losCache) {
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, filterEntities(p,
                game.getEntitiesVector(), losCache));
    }

    /**
     * Creates a packet containing all entities, including wrecks, visible to
     * the player in a blind game
     */
    private Packet createFilteredFullEntitiesPacket(IPlayer p) {
        final Object[] data = new Object[2];
        data[0] = filterEntities(p, game.getEntitiesVector(), null);
        data[1] = game.getOutOfGameEntitiesVector();
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);
    }

    private Packet createAddEntityPacket(int entityId) {
        ArrayList<Integer> entityIds = new ArrayList<Integer>(1);
        entityIds.add(entityId);
        return createAddEntityPacket(entityIds);
    }

    /**
     * Creates a packet detailing the addition of an entity
     */
    private Packet createAddEntityPacket(List<Integer> entityIds) {
        ArrayList<Entity> entities = new ArrayList<Entity>(entityIds.size());
        for (Integer id : entityIds) {
            entities.add(game.getEntity(id));
        }
        final Object[] data = new Object[2];
        data[0] = entityIds;
        data[1] = entities;
        return new Packet(Packet.COMMAND_ENTITY_ADD, data);
    }

    /**
     * Creates a packet detailing the removal of an entity. Maintained for
     * backwards compatability.
     *
     * @param entityId - the <code>int</code> ID of the entity being removed.
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(int entityId) {
        return createRemoveEntityPacket(entityId,
                                        IEntityRemovalConditions.REMOVE_SALVAGEABLE);
    }

    /**
     * Creates a packet detailing the removal of an entity.
     *
     * @param entityId  - the <code>int</code> ID of the entity being removed.
     * @param condition - the <code>int</code> condition the unit was in. This value
     *                  must be one of constants in
     *                  <code>IEntityRemovalConditions</code>, or an
     *                  <code>IllegalArgumentException</code> will be thrown.
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(int entityId, int condition) {
        ArrayList<Integer> ids = new ArrayList<Integer>(1);
        ids.add(entityId);
        return createRemoveEntityPacket(ids, condition);
    }

    /**
     * Creates a packet detailing the removal of a list of entities.
     *
     * @param entityIds - the <code>int</code> ID of each entity being removed.
     * @param condition - the <code>int</code> condition the units were in. This value
     *                  must be one of constants in
     *                  <code>IEntityRemovalConditions</code>, or an
     *                  <code>IllegalArgumentException</code> will be thrown.
     * @return A <code>Packet</code> to be sent to clients.
     */
    private Packet createRemoveEntityPacket(List<Integer> entityIds,
                                            int condition) {
        if ((condition != IEntityRemovalConditions.REMOVE_UNKNOWN)
            && (condition != IEntityRemovalConditions.REMOVE_IN_RETREAT)
            && (condition != IEntityRemovalConditions.REMOVE_PUSHED)
            && (condition != IEntityRemovalConditions.REMOVE_SALVAGEABLE)
            && (condition != IEntityRemovalConditions.REMOVE_EJECTED)
            && (condition != IEntityRemovalConditions.REMOVE_CAPTURED)
            && (condition != IEntityRemovalConditions.REMOVE_DEVASTATED)
            && (condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED)) {
            throw new IllegalArgumentException("Unknown unit condition: "
                                               + condition);
        }
        Object[] array = new Object[2];
        array[0] = entityIds;
        array[1] = new Integer(condition);
        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);
    }

    /**
     * Creates a packet indicating end of game, including detailed unit status
     */
    private Packet createEndOfGamePacket() {
        Object[] array = new Object[3];
        array[0] = getDetailedVictoryReport();
        array[1] = new Integer(game.getVictoryPlayerId());
        array[2] = new Integer(game.getVictoryTeam());
        return new Packet(Packet.COMMAND_END_OF_GAME, array);
    }

    public static String ORIGIN = "***Server";

    public static String formatChatMessage(String origin, String message) {
        return origin + ": " + message;
    }

    /**
     * Transmits a chat message to all players
     */
    public void sendChat(int connId, String origin, String message) {
        send(connId,
             new Packet(Packet.COMMAND_CHAT, formatChatMessage(origin,
                                                               message)));
    }

    /**
     * Transmits a chat message to all players
     */
    private void sendChat(String origin, String message) {
        String chat = formatChatMessage(origin, message);
        send(new Packet(Packet.COMMAND_CHAT, chat));
    }

    public void sendServerChat(int connId, String message) {
        sendChat(connId, ORIGIN, message);
    }

    public void sendServerChat(String message) {
        sendChat(ORIGIN, message);
    }

    /**
     * Creates a packet containing a hex, and the coordinates it goes at.
     */
    private Packet createHexChangePacket(Coords coords, IHex hex) {
        final Object[] data = new Object[2];
        data[0] = coords;
        data[1] = hex;
        return new Packet(Packet.COMMAND_CHANGE_HEX, data);
    }

    public void sendSmokeCloudAdded(SmokeCloud cloud) {
        final Object[] data = new Object[1];
        data[0] = cloud;
        send(new Packet(Packet.COMMAND_ADD_SMOKE_CLOUD, data));
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedHex(Coords coords) {
        send(createHexChangePacket(coords, game.getBoard().getHex(coords)));
    }

    /**
     * Creates a packet containing a hex, and the coordinates it goes at.
     */
    private Packet createHexesChangePacket(Set<Coords> coords, Set<IHex> hex) {
        final Object[] data = new Object[2];
        data[0] = coords;
        data[1] = hex;
        return new Packet(Packet.COMMAND_CHANGE_HEXES, data);
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedHexes(Set<Coords> coords) {
        Set<IHex> hexes = new LinkedHashSet<IHex>();
        for (Coords coord : coords) {
            hexes.add(game.getBoard().getHex(coord));
        }
        send(createHexesChangePacket(coords, hexes));
    }

    /**
     * Creates a packet containing a vector of mines.
     */
    private Packet createMineChangePacket(Coords coords) {
        return new Packet(Packet.COMMAND_UPDATE_MINEFIELDS,
                          game.getMinefields(coords));
    }

    /**
     * Sends notification to clients that the specified hex has changed.
     */
    public void sendChangedMines(Coords coords) {
        send(createMineChangePacket(coords));
    }

    public void sendVisibilityIndicator(Entity e) {
        final Object[] data = new Object[6];
        data[0] = new Integer(e.getId());
        data[1] = Boolean.valueOf(e.isEverSeenByEnemy());
        data[2] = Boolean.valueOf(e.isVisibleToEnemy());
        data[3] = Boolean.valueOf(e.isDetectedByEnemy());
        data[4] = e.getWhoCanSee();
        data[5] = e.getWhoCanDetect();
        send(new Packet(Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR, data));
    }

    /**
     * Creates a packet for an attack
     */
    private Packet createAttackPacket(List<?> vector, int charges) {
        final Object[] data = new Object[2];
        data[0] = vector;
        data[1] = new Integer(charges);
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);
    }

    /**
     * Creates a packet for an attack
     */
    private Packet createAttackPacket(EntityAction ea, int charge) {
        Vector<EntityAction> vector = new Vector<EntityAction>(1);
        vector.addElement(ea);
        Object[] data = new Object[2];
        data[0] = vector;
        data[1] = new Integer(charge);
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);
    }

    /**
     *
     */
    private Packet createSpecialHexDisplayPacket(int toPlayer) {
        Hashtable<Coords, Collection<SpecialHexDisplay>> shdTable = game
                .getBoard().getSpecialHexDisplayTable();
        Hashtable<Coords, Collection<SpecialHexDisplay>> shdTable2 = new Hashtable<Coords,
                Collection<SpecialHexDisplay>>();
        LinkedList<SpecialHexDisplay> tempList = null;
        IPlayer player = getPlayer(toPlayer);
        if (player != null) {
            for (Coords coord : shdTable.keySet()) {
                tempList = new LinkedList<SpecialHexDisplay>();
                for (SpecialHexDisplay shd : shdTable.get(coord)) {
                    if (!shd.isObscured(player)) {
                        tempList.add(0, shd);
                    }
                }
                if (!tempList.isEmpty()) {
                    shdTable2.put(coord, tempList);
                }
            }
        }
        return new Packet(Packet.COMMAND_SENDING_SPECIAL_HEX_DISPLAY, shdTable2);
    }

    private Packet createTagInfoUpdatesPacket() {
        return new Packet(Packet.COMMAND_SENDING_TAGINFO, game.getTagInfo());
    }

    /**
     * Creates a packet containing offboard artillery attacks
     */
    private Packet createArtilleryPacket(IPlayer p) {
        Vector<ArtilleryAttackAction> v = new Vector<ArtilleryAttackAction>();
        int team = p.getTeam();
        for (Enumeration<AttackHandler> i = game.getAttacks(); i
                .hasMoreElements(); ) {
            WeaponHandler wh = (WeaponHandler) i.nextElement();
            if (wh.waa instanceof ArtilleryAttackAction) {
                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;
                if ((aaa.getPlayerId() == p.getId())
                    || ((team != IPlayer.TEAM_NONE) && (team == game
                        .getPlayer(aaa.getPlayerId()).getTeam()))
                    || p.getSeeAll()) {
                    v.addElement(aaa);
                }
            }
        }
        return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, v);
    }

    private Packet createIlluminatedHexesPacket() {
        HashSet<Coords> illumHexes = game.getIlluminatedPositions();
        return new Packet(Packet.COMMAND_SENDING_ILLUM_HEXES, illumHexes);
    }

    /**
     * Creates a packet containing flares
     */
    private Packet createFlarePacket() {

        return new Packet(Packet.COMMAND_SENDING_FLARES, game.getFlares());
    }

    /**
     * Send a packet to all connected clients.
     */
    private void send(Packet packet) {
        if (connections == null) {
            return;
        }
        for (Enumeration<IConnection> connEnum = connections.elements(); connEnum
                .hasMoreElements(); ) {
            IConnection conn = connEnum.nextElement();
            conn.send(packet);
        }
    }

    // WOR
    public void send_Nova_Change(int ID, String net) {
        Object[] data = {new Integer(ID), new String(net)};
        Packet packet = new Packet(Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE,
                                   data);
        send(packet);
    }

    private void sendReport() {
        sendReport(false);
    }

    /**
     * Send the round report to all connected clients.
     */
    private void sendReport(boolean tacticalGeniusReport) {
        if (connections == null) {
            return;
        }

        for (Enumeration<IConnection> connEnum = connections.elements(); connEnum
                .hasMoreElements(); ) {
            IConnection conn = connEnum.nextElement();
            IPlayer p = game.getPlayer(conn.getId());
            Packet packet;
            if (tacticalGeniusReport) {
                packet = createTacticalGeniusReportPacket();
            } else {
                packet = createReportPacket(p);
            }
            conn.send(packet);
        }
    }

    /**
     * Send a packet to a specific connection.
     */
    public void send(int connId, Packet packet) {
        if (getClient(connId) != null) {
            getClient(connId).send(packet);
        } else {
            // What should we do if we've lost this client?
            // For now, nothing.
        }
    }

    /**
     * Send a packet to a pending connection
     */
    private void sendToPending(int connId, Packet packet) {
        IConnection pendingConn = getPendingConnection(connId);
        if (pendingConn != null) {
            pendingConn.send(packet);
        } else {
            // What should we do if we've lost this client?
            // For now, nothing.
        }
    }

    /**
     * Process an in-game command
     */
    private void processCommand(int connId, String commandString) {
        String[] args;
        String commandName;
        // all tokens are read as strings; if they're numbers, string-ize 'em.
        // replaced the tokenizer with the split function.
        args = commandString.split("\\s+");

        // figure out which command this is
        commandName = args[0].substring(1);

        // process it
        ServerCommand command = getCommand(commandName);
        if (command != null) {
            command.run(connId, args);
        } else {
            sendServerChat(connId,
                           "Command not recognized.  Type /help for a list of commands.");
        }
    }

    // Easter eggs. Happy April Fool's Day!!
    private static final String DUNE_CALL = "They tried and failed?";

    private static final String DUNE_RESPONSE = "They tried and died!";

    private static final String STAR_WARS_CALL = "I'd just as soon kiss a Wookiee.";

    private static final String STAR_WARS_RESPONSE = "I can arrange that!";

    private static final String INVADER_ZIM_CALL = "What does the G stand for?";

    private static final String INVADER_ZIM_RESPONSE = "I dont know.";

    /**
     * Process a packet from a connection.
     *
     * @param connId - the <code>int</code> ID the connection that received the
     *               packet.
     * @param packet - the <code>Packet</code> to be processed.
     */
    protected void handle(int connId, Packet packet) {
        IPlayer player = game.getPlayer(connId);
        // Check player. Please note, the connection may be pending.
        if ((null == player) && (null == getPendingConnection(connId))) {
            System.err.print("Server does not recognize player at connection ");
            System.err.println(connId);
            return;
        }

        // System.out.println("s(" + cn + "): received command");
        if (packet == null) {
            System.out.println("server.connection.handle: got null packet");
            return;
        }
        // act on it
        switch (packet.getCommand()) {
            case Packet.COMMAND_CLIENT_VERSIONS:
                receivePlayerVersion(packet, connId);
                break;
            case Packet.COMMAND_CLOSE_CONNECTION:
                // We have a client going down!
                IConnection c = getConnection(connId);
                if (c != null) {
                    c.close();
                }
                break;
            case Packet.COMMAND_CLIENT_NAME:
                receivePlayerName(packet, connId);
                break;
            case Packet.COMMAND_PLAYER_UPDATE:
                receivePlayerInfo(packet, connId);
                validatePlayerInfo(connId);
                send(createPlayerUpdatePacket(connId));
                break;
            case Packet.COMMAND_PLAYER_READY:
                receivePlayerDone(packet, connId);
                send(createPlayerDonePacket(connId));
                checkReady();
                break;
            case Packet.COMMAND_REROLL_INITIATIVE:
                receiveInitiativeRerollRequest(packet, connId);
                // send(createPlayerDonePacket(connId));
                break;
            case Packet.COMMAND_FORWARD_INITIATIVE:
                receiveForwardIni(packet, connId);
                break;
            case Packet.COMMAND_CHAT:
                String chat = (String) packet.getObject(0);
                if (chat.startsWith("/")) {
                    processCommand(connId, chat);
                } else if (packet.getData().length > 1) {
                    connId = (int) packet.getObject(1);
                    if (connId == IPlayer.PLAYER_NONE) {
                        sendServerChat(chat);
                    } else {
                        sendServerChat(connId, chat);
                    }
                } else {
                    sendChat(player.getName(), chat);
                }
                // Easter eggs. Happy April Fool's Day!!
                if (DUNE_CALL.equalsIgnoreCase(chat)) {
                    sendServerChat(DUNE_RESPONSE);
                } else if (STAR_WARS_CALL.equalsIgnoreCase(chat)) {
                    sendServerChat(STAR_WARS_RESPONSE);
                } else if (INVADER_ZIM_CALL.equalsIgnoreCase(chat)) {
                    sendServerChat(INVADER_ZIM_RESPONSE);
                }
                break;
            case Packet.COMMAND_ENTITY_MOVE:
                receiveMovement(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_DEPLOY:
                receiveDeployment(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_DEPLOY_UNLOAD:
                receiveDeploymentUnload(packet, connId);
                break;
            case Packet.COMMAND_DEPLOY_MINEFIELDS:
                receiveDeployMinefields(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_ATTACK:
                receiveAttack(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_GTA_HEX_SELECT:
                receiveGroundToAirHexSelectPacket(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_ADD:
                receiveEntityAdd(packet, connId);
                resetPlayersDone();
                break;
            case Packet.COMMAND_ENTITY_UPDATE:
                receiveEntityUpdate(packet, connId);
                resetPlayersDone();
                break;
            case Packet.COMMAND_ENTITY_LOAD:
                receiveEntityLoad(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case Packet.COMMAND_ENTITY_MODECHANGE:
                receiveEntityModeChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_SENSORCHANGE:
                receiveEntitySensorChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_SINKSCHANGE:
                receiveEntitySinksChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE:
                receiveEntityNovaNetworkModeChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_MOUNTED_FACINGCHANGE:
                receiveEntityMountedFacingChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_CALLEDSHOTCHANGE:
                receiveEntityCalledShotChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_SYSTEMMODECHANGE:
                receiveEntitySystemModeChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_AMMOCHANGE:
                receiveEntityAmmoChange(packet, connId);
                break;
            case Packet.COMMAND_ENTITY_REMOVE:
                receiveEntityDelete(packet, connId);
                resetPlayersDone();
                break;
            case Packet.COMMAND_ENTITY_WORDER_UPDATE:
                Object data[] = packet.getData();
                Entity ent = game.getEntity((Integer)data[0]);
                if (ent != null) {
                    Entity.WeaponSortOrder order =
                        (Entity.WeaponSortOrder)data[1];
                    ent.setWeaponSortOrder(order);
                    // Used by the client but is set in setWeaponSortOrder
                    ent.setWeapOrderChanged(false);
                    if (order == Entity.WeaponSortOrder.CUSTOM) {
                        @SuppressWarnings("unchecked") // Unchecked cause of limitations in Java when casting to a collection
                        Map<Integer, Integer> customWeapOrder = (Map<Integer, Integer>)data[2];
                        ent.setCustomWeaponOrder(customWeapOrder);
                    }
                }
                break;
            case Packet.COMMAND_SENDING_GAME_SETTINGS:
                if (receiveGameOptions(packet, connId)) {
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createGameSettingsPacket());
                    receiveGameOptionsAux(packet, connId);
                }
                break;
            case Packet.COMMAND_SENDING_MAP_SETTINGS:
                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {
                    MapSettings newSettings = (MapSettings) packet.getObject(0);
                    if (!mapSettings.equalMapGenParameters(newSettings)) {
                        sendServerChat("Player " + player.getName()
                                       + " changed map settings");
                    }
                    mapSettings = newSettings;
                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(
                            mapSettings.getBoardWidth(),
                            mapSettings.getBoardHeight())));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);
                    mapSettings.removeUnavailable();
                    // if still only nulls left, use BOARD_GENERATED
                    if (mapSettings.getBoardsSelected().next() == null) {
                        mapSettings.setNullBoards((MapSettings.BOARD_GENERATED));
                    }
                    newSettings = null;
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createMapSettingsPacket());
                }
                break;
            case Packet.COMMAND_SENDING_MAP_DIMENSIONS:
                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {
                    MapSettings newSettings = (MapSettings) packet.getObject(0);
                    if (!mapSettings.equalMapGenParameters(newSettings)) {
                        sendServerChat("Player " + player.getName()
                                       + " changed map dimensions");
                    }
                    mapSettings = newSettings;
                    newSettings = null;
                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(
                            mapSettings.getBoardWidth(),
                            mapSettings.getBoardHeight())));
                    mapSettings.removeUnavailable();
                    mapSettings.setNullBoards(DEFAULT_BOARD);
                    mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);
                    mapSettings.removeUnavailable();
                    // if still only nulls left, use BOARD_GENERATED
                    if (mapSettings.getBoardsSelected().next() == null) {
                        mapSettings.setNullBoards((MapSettings.BOARD_GENERATED));
                    }
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createMapSettingsPacket());
                }
                break;
            case Packet.COMMAND_SENDING_PLANETARY_CONDITIONS:
                // MapSettings newSettings = (MapSettings) packet.getObject(0);
                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {
                    PlanetaryConditions conditions = (PlanetaryConditions) packet
                            .getObject(0);
                    sendServerChat("Player " + player.getName()
                                   + " changed planetary conditions");
                    game.setPlanetaryConditions(conditions);
                    resetPlayersDone();
                    transmitAllPlayerDones();
                    send(createPlanetaryConditionsPacket());
                }
                break;
            case Packet.COMMAND_UNLOAD_STRANDED:
                receiveUnloadStranded(packet, connId);
                break;
            case Packet.COMMAND_SET_ARTYAUTOHITHEXES:
                receiveArtyAutoHitHexes(packet, connId);
                break;
            case Packet.COMMAND_CUSTOM_INITIATIVE:
                receiveCustomInit(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case Packet.COMMAND_LOAD_GAME:
                try {
                    sendServerChat(getPlayer(connId).getName()
                                   + " loaded a new game.");
                    setGame((IGame) packet.getObject(0));
                    for (IConnection conn : connections) {
                        sendCurrentInfo(conn.getId());
                    }
                } catch (Exception e) {
                    System.out.println("Error loading savegame sent from client");
                }
                break;
            case Packet.COMMAND_SQUADRON_ADD:
                receiveSquadronAdd(packet, connId);
                resetPlayersDone();
                transmitAllPlayerDones();
                break;
            case Packet.COMMAND_RESET_ROUND_DEPLOYMENT:
                game.setupRoundDeployment();
                break;
            case Packet.COMMAND_SPECIAL_HEX_DISPLAY_DELETE:
                game.getBoard().removeSpecialHexDisplay(
                        (Coords) packet.getObject(0),
                        (SpecialHexDisplay) packet.getObject(1));
                sendSpecialHexDisplayPackets();
                break;
            case Packet.COMMAND_SPECIAL_HEX_DISPLAY_APPEND:
                game.getBoard().addSpecialHexDisplay((Coords) packet.getObject(0),
                                                     (SpecialHexDisplay) packet.getObject(1));
                sendSpecialHexDisplayPackets();
                break;
        }
    }

    /**
     * Listen for incoming clients.
     */
    public void run() {
        Thread currentThread = Thread.currentThread();
        System.out.println("s: listening for clients...");
        // HashSet<IConnection> toUpdate = new HashSet<IConnection>();
        while (connector == currentThread) {
            try {
                Socket s = serverSocket.accept();
                synchronized (serverLock) {
                    int id = getFreeConnectionId();
                    System.out.println("s: accepting player connection #" + id
                            + " ...");

                    IConnection c = ConnectionFactory.getInstance()
                            .createServerConnection(s, id);
                    c.addConnectionListener(connectionListener);
                    c.open();
                    connectionsPending.addElement(c);
                    ConnectionHandler ch = new ConnectionHandler(c);
                    Thread newConnThread = new Thread(ch, "Connection " + id);
                    newConnThread.start();
                    connectionHandlers.put(id, ch);

                    greeting(id);
                    ConnectionWatchdog w = new ConnectionWatchdog(this, id);
                    watchdogTimer.schedule(w, 1000, 500);
                }
            } catch (InterruptedIOException iioe) {
                // ignore , just SOTimeout blowing..
            } catch (IOException ex) {

            }
            /* update all connections */
            // Changed method to using clones of the connections &
            // connectionsPending in order to avoid
            // ConcurrentModificationExceptions.
            /*
             * toUpdate.clear(); Vector<IConnection> clone =
             * (Vector<IConnection>) connections .clone(); Vector<IConnection>
             * connectionsClone = clone; toUpdate.addAll(connectionsClone);
             * connectionsClone = (Vector<IConnection>)
             * connectionsPending.clone(); toUpdate.addAll(connectionsClone); //
             * process stuff Iterator<IConnection> it = toUpdate.iterator();
             * while (it.hasNext()) { it.next().update(); } // then make sure
             * stuff is sent away it = toUpdate.iterator(); while (it.hasNext())
             * { it.next().flush(); }
             */
        }
    }

    /**
     * Makes one slot of inferno ammo, determined by certain rules, explode on a
     * mech.
     *
     * @param entity The <code>Entity</code> that should suffer an inferno ammo
     *               explosion.
     */
    private Vector<Report> explodeInfernoAmmoFromHeat(Entity entity) {
        int damage = 0;
        int rack = 0;
        int boomloc = -1;
        int boomslot = -1;
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // Find the most destructive Inferno ammo.
        for (int j = 0; j < entity.locations(); j++) {
            for (int k = 0; k < entity.getNumberOfCriticals(j); k++) {
                CriticalSlot cs = entity.getCritical(j, k);
                // Ignore empty, destroyed, hit, and structure slots.
                if ((cs == null) || cs.isDestroyed() || cs.isHit()
                    || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {
                    continue;
                }
                // Ignore everything but weapons slots.
                Mounted mounted = cs.getMount();
                if (!(mounted.getType() instanceof AmmoType)) {
                    continue;
                }
                // Ignore everything but Inferno ammo.
                AmmoType atype = (AmmoType) mounted.getType();
                if (!atype.isExplosive(mounted)
                    || ((atype.getMunitionType() != AmmoType.M_INFERNO) && (atype
                                                                                    .getMunitionType() != AmmoType
                                                                                    .M_IATM_IIW))) {
                    continue;
                }

                // ignore empty, destroyed, or missing bins
                if (mounted.getHittableShotsLeft() == 0) {
                    continue;
                }

                // Find the most destructive undamaged ammo.
                // TW page 160, compare one rack's
                // damage. Ties go to most rounds.
                int newRack = atype.getDamagePerShot() * atype.getRackSize();
                int newDamage = mounted.getExplosionDamage();
                Mounted mount2 = cs.getMount2();
                if ((mount2 != null) && (mount2.getType() instanceof AmmoType)
                    && (mount2.getHittableShotsLeft() > 0)) {
                    // must be for same weapontype, so racksize stays
                    atype = (AmmoType) mount2.getType();
                    newRack += atype.getDamagePerShot() * atype.getRackSize();
                    newDamage += mount2.getExplosionDamage();
                }
                if (!mounted.isHit()
                    && ((rack < newRack) || ((rack == newRack) && (damage < newDamage)))) {
                    rack = newRack;
                    damage = newDamage;
                    boomloc = j;
                    boomslot = k;
                }
            }
        }
        // Did we find anything to explode?
        if ((boomloc != -1) && (boomslot != -1)) {
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);
            slot.setHit(true);
            Mounted equip = slot.getMount();
            equip.setHit(true);
            // We've allocated heatBuildup to heat in resolveHeat(),
            // so need to add to the entity's heat instead.
            entity.heat += Math.min(equip.getExplosionDamage(), 30);
            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));
            r = new Report(5155);
            r.indent();
            r.subject = entity.getId();
            r.add(entity.heat);
            vDesc.addElement(r);
            entity.heatBuildup = 0;
        } else { // no ammo to explode
            r = new Report(5160);
            r.indent();
            r.subject = entity.getId();
            vDesc.addElement(r);
        }
        return vDesc;
    }

    /**
     * checks for unintended exposion of heavy industrial zone hex and applies
     * damage to entities occupying the hex
     */
    public void checkExplodeIndustrialZone(Coords c, Vector<Report> vDesc) {
        Report r;
        IHex hex = game.getBoard().getHex(c);
        if (null == hex) {
            return;
        }

        if (!hex.containsTerrain(Terrains.INDUSTRIAL)) {
            return;
        }

        r = new Report(3590, Report.PUBLIC);
        r.add(c.getBoardNum());
        r.indent(2);
        int effect = Compute.d6(2);
        r.add(8);
        r.add(effect);
        if (effect > 7) {
            r.choose(true);
            r.newlines = 0;
            vDesc.add(r);
            boolean onFire = false;
            boolean powerLine = false;
            boolean minorExp = false;
            boolean elecExp = false;
            boolean majorExp = false;
            if (effect == 8) {
                onFire = true;
                r = new Report(3600, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 9) {
                powerLine = true;
                r = new Report(3605, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 10) {
                minorExp = true;
                onFire = true;
                r = new Report(3610, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else if (effect == 11) {
                elecExp = true;
                r = new Report(3615, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            } else {
                onFire = true;
                majorExp = true;
                r = new Report(3620, Report.PUBLIC);
                r.newlines = 0;
                vDesc.add(r);
            }
            // apply damage here
            if (powerLine || minorExp || elecExp || majorExp) {
                // cycle through the entities in the hex and apply damage
                for (Entity en : game.getEntitiesVector(c)) {
                    int damage = 3;
                    if (minorExp) {
                        damage = 5;
                    }
                    if (elecExp) {
                        damage = Compute.d6(1) + 3;
                    }
                    if (majorExp) {
                        damage = Compute.d6(2);
                    }
                    HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL,
                                                     ToHitData.SIDE_FRONT);
                    if (en instanceof BattleArmor) {
                        // ugly - I have to apply damage to each trooper
                        // separately
                        for (int loc = 0; loc < en.locations(); loc++) {
                            if ((IArmorState.ARMOR_NA != en.getInternal(loc))
                                && (IArmorState.ARMOR_DESTROYED != en
                                    .getInternal(loc))
                                && (IArmorState.ARMOR_DOOMED != en
                                    .getInternal(loc))) {
                                vDesc.addAll(damageEntity(en, new HitData(loc),
                                                          damage));
                            }
                        }
                    } else {
                        vDesc.addAll(damageEntity(en, hit, damage));
                    }
                    if (majorExp) {
                        // lets pretend that the infernos came from the entity
                        // itself (should give us side_front)
                        vDesc.addAll(deliverInfernoMissiles(en, en,
                                                            Compute.d6(2)));
                    }
                }
            }
            Report.addNewline(vDesc);
            if (onFire && !hex.containsTerrain(Terrains.FIRE)) {
                ignite(c, Terrains.FIRE_LVL_NORMAL, vDesc);
            }
        } else {
            // report no explosion
            r.choose(false);
            vDesc.add(r);
        }
    }

    /**
     * Determine the results of an entity moving through a wall of a building
     * after having moved a certain distance. This gets called when a Mech or a
     * Tank enters a building, leaves a building, or travels from one hex to
     * another inside a multi-hex building.
     *
     * @param entity    - the <code>Entity</code> that passed through a wall. Don't
     *                  pass <code>Infantry</code> units to this method.
     * @param bldg      - the <code>Building</code> the entity is passing through.
     * @param lastPos   - the <code>Coords</code> of the hex the entity is exiting.
     * @param curPos    - the <code>Coords</code> of the hex the entity is entering
     * @param distance  - the <code>int</code> number of hexes the entity has moved
     *                  already this phase.
     * @param why       - the <code>String</code> explanation for this action.
     * @param backwards - the <code>boolean</code> indicating if the entity is
     *                  entering the hex backwards
     * @param entering  - a <code>boolean</code> if the entity is entering or exiting
     *                  a building
     */
    private void passBuildingWall(Entity entity, Building bldg, Coords lastPos,
                                  Coords curPos, int distance, String why, boolean backwards,
                                  EntityMovementType overallMoveType, boolean entering) {

        Report r;

        if (entity instanceof Protomech) {
            Vector<Report> vBuildingReport = damageBuilding(bldg, 1, curPos);
            for (Report report : vBuildingReport) {
                report.subject = entity.getId();
            }
            addReport(vBuildingReport);
        } else {
            // Need to roll based on building type.
            PilotingRollData psr = entity.rollMovementInBuilding(bldg,
                                                                 distance, why, overallMoveType);

            // Did the entity make the roll?
            if (0 < doSkillCheckWhileMoving(entity, entity.getElevation(),
                                            lastPos, curPos, psr, false)) {

                // Divide the building's current CF by 10, round up.
                int damage = (int) Math.floor(bldg.getDamageFromScale()
                                              * Math.ceil(bldg.getCurrentCF(entering ? curPos
                                                                                     : lastPos) / 10.0));

                // Infantry and Battle armor take different amounts of damage
                // then Meks and vehicles.
                if (entity instanceof Infantry) {
                    damage = bldg.getType() + 1;
                }
                // It is possible that the unit takes no damage.
                if (damage == 0) {
                    r = new Report(6440);
                    r.add(entity.getDisplayName());
                    r.subject = entity.getId();
                    r.indent(2);
                    addReport(r);
                } else {
                    // TW, pg. 268: if unit moves forward, damage from front,
                    // if backwards, damage from rear.
                    int side = ToHitData.SIDE_FRONT;
                    if (backwards) {
                        side = ToHitData.SIDE_REAR;
                    }
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         side);
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    addReport(damageEntity(entity, hit, damage));
                }
            }

            // Infantry and BA are damaged by buildings but do not damage them
            if (entity instanceof Infantry) {
                return;
            }
            // Damage the building. The CF can never drop below 0.
            int toBldg = (int) Math.floor(bldg.getDamageToScale()
                                          * Math.ceil(entity.getWeight() / 10.0));
            int curCF = bldg.getCurrentCF(entering ? curPos : lastPos);
            curCF -= Math.min(curCF, toBldg);
            bldg.setCurrentCF(curCF, entering ? curPos : lastPos);

            // Apply the correct amount of damage to infantry in the building.
            // ASSUMPTION: We inflict toBldg damage to infantry and
            // not the amount to bring building to 0 CF.
            addReport(damageInfantryIn(bldg, toBldg, entering ? curPos
                                                              : lastPos));
        }
    }

    /**
     * check if a building collapes because of a moving entity
     *
     * @param bldg   the <code>Building</code>
     * @param entity the <code>Entity</code>
     * @param curPos the <coode>Coords</code> of the position of the entity
     * @return a <code>boolean</code> value indicating if the building collapses
     */
    private boolean checkBuildingCollapseWhileMoving(Building bldg,
                                                     Entity entity, Coords curPos) {
        Coords oldPos = entity.getPosition();
        // Count the moving entity in its current position, not
        // its pre-move postition. Be sure to handle nulls.
        entity.setPosition(curPos);

        // Get the position map of all entities in the game.
        Hashtable<Coords, Vector<Entity>> positionMap = game.getPositionMap();

        // Check for collapse of this building due to overloading, and return.
        boolean rv = checkForCollapse(bldg, positionMap, curPos, true,
                                      vPhaseReport);

        // If the entity was not displaced and didnt fall, move it back where it
        // was
        if (curPos.equals(entity.getPosition()) && !entity.isProne()) {
            entity.setPosition(oldPos);
        }
        return rv;
    }

    public Vector<Report> damageInfantryIn(Building bldg, int damage,
                                           Coords hexCoords) {
        return damageInfantryIn(bldg, damage, hexCoords, WeaponType.WEAPON_NA);
    }

    /**
     * Apply the correct amount of damage that passes on to any infantry unit in
     * the given building, based upon the amount of damage the building just
     * sustained. This amount is a percentage dictated by pg. 52 of BMRr.
     *
     * @param bldg   - the <code>Building</code> that sustained the damage.
     * @param damage - the <code>int</code> amount of damage.
     */
    public Vector<Report> damageInfantryIn(Building bldg, int damage,
                                           Coords hexCoords, int infDamageClass) {

        Vector<Report> vDesc = new Vector<Report>();

        if (bldg == null) {
            return vDesc;
        }
        // Calculate the amount of damage the infantry will sustain.
        float percent = 0.0f;
        Report r;
        switch (bldg.getType()) {
            case Building.LIGHT:
                percent = 0.75f;
                break;
            case Building.MEDIUM:
                percent = 0.5f;
                break;
            case Building.HEAVY:
                percent = 0.25f;
                break;
        }

        // Round up at .5 points of damage.
        int toInf = Math.round(damage * percent);

        // some buildings scale remaining damage
        // TODO: this isn't quite right for castles brian
        damage = (int) Math.floor(bldg.getDamageToScale() * toInf);

        // Record if we find any infantry.
        boolean foundInfantry = false;

        // Walk through the entities in the game.
        for (Entity entity : game.getEntitiesVector()) {
            final Coords coords = entity.getPosition();

            // If the entity is infantry in the affected hex?
            if ((entity instanceof Infantry) && bldg.isIn(coords)
                && coords.equals(hexCoords)) {

                // Is the entity is inside of the building
                // (instead of just on top of it)?
                if (Compute.isInBuilding(game, entity, coords)) {

                    // Report if the infantry receive no points of damage.
                    if (toInf == 0) {
                        r = new Report(6445);
                        r.subject = entity.getId();
                        vDesc.addElement(r);
                    } else {
                        // Yup. Damage the entity.
                        r = new Report(6450);
                        r.indent(2);
                        r.subject = entity.getId();
                        r.add(toInf);
                        r.add(entity.getDisplayName());
                        vDesc.addElement(r);
                        // need to adjust damage to conventional infantry
                        // TW page 217 says left over damage gets treated as
                        // direct
                        // fire ballistic damage
                        if (!(entity instanceof BattleArmor)) {
                            toInf = Compute.directBlowInfantryDamage(toInf, 0,
                                                                     WeaponType.WEAPON_DIRECT_FIRE, false);
                        }
                        int remaining = toInf;
                        int cluster = toInf;
                        // Battle Armor units use 5 point clusters.
                        if (entity instanceof BattleArmor) {
                            cluster = 5;
                        }
                        while (remaining > 0) {
                            int next = Math.min(cluster, remaining);
                            HitData hit = entity.rollHitLocation(
                                    ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
                            vDesc.addAll((damageEntity(entity, hit, next)));
                            remaining -= next;
                        }
                        Report.addNewline(vDesc);
                    }

                } // End infantry-inside-building

            } // End entity-is-infantry-in-building-hex

        } // Handle the next entity

        // If we found any infantry, add a line to the phase report.
        if (foundInfantry) {
            Report.addNewline(vDesc);
        }

        return vDesc;

    } // End private void damageInfantryIn( Building, int )

    /**
     * Determine if the given building should collapse. If so, inflict the
     * appropriate amount of damage on each entity in the building and update
     * the clients. If the building does not collapse, determine if any entities
     * crash through its floor into its basement. Again, apply appropriate
     * damage.
     *
     * @param bldg        - the <code>Building</code> being checked. This value should
     *                    not be <code>null</code>.
     * @param positionMap - a <code>Hashtable</code> that maps the <code>Coords</code>
     *                    positions or each unit in the game to a <code>Vector</code> of
     *                    <code>Entity</code>s at that position. This value should not
     *                    be <code>null</code>.
     * @param coords      - the <code>Coords</code> of the building hex to be checked
     * @return <code>true</code> if the building collapsed.
     */
    public boolean checkForCollapse(Building bldg,
                                    Hashtable<Coords, Vector<Entity>> positionMap, Coords coords,
                                    boolean checkBecauseOfDamage, Vector<Report> vPhaseReport) {

        // If the input is meaningless, do nothing and throw no exception.
        if ((bldg == null) || (positionMap == null) || positionMap.isEmpty()
            || (coords == null) || !bldg.isIn(coords)
            || !bldg.hasCFIn(coords)) {
            return false;
        }

        // Get the building's current CF.
        int currentCF = bldg.getCurrentCF(coords);

        // Track all units that fall into the building's basement by Coords.
        Hashtable<Coords, Vector<Entity>> basementMap = new Hashtable<Coords, Vector<Entity>>();

        // look for a collapse.
        boolean collapse = false;

        boolean basementCollapse = false;

        if (checkBecauseOfDamage && (currentCF <= 0)) {
            collapse = true;
        }

        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> vector = positionMap.get(coords);

        // Are there any Entities at these coords?
        if (vector != null) {

            // How many levels does this building have in this hex?
            final IHex curHex = game.getBoard().getHex(coords);
            final int numFloors = Math.max(0,
                                           curHex.terrainLevel(Terrains.BLDG_ELEV));
            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);
            int numLoads = numFloors;
            if (bridgeEl != ITerrain.LEVEL_NONE) {
                numLoads++;
            }
            if (numLoads < 1) {
                System.err.println("Check for collapse: hex "
                                   + coords.toString() + " has no bridge or building");
                return false;
            }

            // Track the load of each floor (and of the roof) separately.
            // Track all units that fall into the basement in this hex.
            // track all floors, ground at index 0, the first floor is at
            // index 1, the second is at index 1, etc., and the roof is
            // at index (numFloors).
            // if bridge is present, bridge will be numFloors+1
            float[] loads = new float[numLoads + 1];
            // track all units that might fall into the basement
            Vector<Entity> basement = new Vector<Entity>();

            boolean recheckLoop = true;
            for (int i = 0; (i < 2) && recheckLoop; i++) {

                recheckLoop = false;
                for (int loop = 0; loop < numLoads; loop++) {
                    loads[loop] = 0;
                }

                // Walk through the entities in this position.
                Enumeration<Entity> entities = vector.elements();
                while (!collapse && entities.hasMoreElements()) {
                    final Entity entity = entities.nextElement();
                    final int entityElev = entity.getElevation();

                    if (entityElev != bridgeEl) {
                        // Ignore entities not *inside* the building
                        if (entityElev > numFloors) {
                            continue;
                        }
                    }

                    if ((entity.getMovementMode() == EntityMovementMode.HYDROFOIL)
                        || (entity.getMovementMode() == EntityMovementMode.NAVAL)
                        || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)
                        || (entity.getMovementMode() == EntityMovementMode.INF_UMU)) {
                        continue; // under the bridge even at same level
                    }

                    if (entityElev == 0) {
                        basement.add(entity);
                    }

                    // units already in the basement
                    if (entityElev < 0) {
                        continue;
                    }

                    // Add the weight to the
                    // correct floor.

                    float load = entity.getWeight();
                    int floor = entityElev;
                    if (floor == bridgeEl) {
                        floor = numLoads;
                    }

                    loads[floor] += load;
                    if (loads[floor] > currentCF) {
                        // If the load on any floor but the ground floor
                        // exceeds the building's current CF it collapses.
                        if (floor != 0) {
                            collapse = true;
                        } else if (!bldg.getBasementCollapsed(coords)) {
                            basementCollapse = true;
                        }
                    }
                    // End increase-load

                } // Handle the next entity.

                // Track all entities that fell into the basement.
                if (basementCollapse) {
                    basementMap.put(coords, basement);
                }

            } // End have-entities-here

            // did anyone fall into the basement?
            if (!basementMap.isEmpty()
                && (bldg.getBasement(coords) != BasementType.NONE)
                && !collapse) {

                collapseBasement(bldg, basementMap, coords, vPhaseReport);
                if (currentCF == 0) {
                    collapse = true;
                    recheckLoop = false;
                } else {
                    recheckLoop = true; // basement collapse might cause a
                    // further collapse
                }
            } else {
                recheckLoop = false; // don't check again, we didn't change the
                // CF
            }
            if (collapse == true) {
                recheckLoop = false;
                // recheck if the basement collapsed since the basement falls
                // might trigger a greater collapse.
            }
        }
        // Collapse the building if the flag is set.
        if (collapse) {
            Report r = new Report(2375, Report.PUBLIC);
            r.add(bldg.getName());
            vPhaseReport.add(r);

            collapseBuilding(bldg, positionMap, coords, vPhaseReport);
        }

        // Return true if the building collapsed.
        return collapse;

    } // End private boolean checkForCollapse( Building, Hashtable )

    public void collapseBuilding(Building bldg,
                                 Hashtable<Coords, Vector<Entity>> positionMap, Coords coords,
                                 Vector<Report> vPhaseReport) {
        collapseBuilding(bldg, positionMap, coords, true, vPhaseReport);
    }

    /**
     * Collapse a building basement. Inflict the appropriate amount of damage on
     * all entities that fell to the basement. Update all clients.
     *
     * @param bldg        - the <code>Building</code> that has collapsed.
     * @param positionMap - a <code>Hashtable</code> that maps the <code>Coords</code>
     *                    positions or each unit in the game to a <code>Vector</code> of
     *                    <code>Entity</code>s at that position. This value should not
     *                    be <code>null</code>.
     * @param coords      - The <code>Coords></code> of the building basement hex that
     *                    has collapsed
     */
    public void collapseBasement(Building bldg,
                                 Hashtable<Coords, Vector<Entity>> positionMap, Coords coords,
                                 Vector<Report> vPhaseReport) {
        if (!bldg.hasCFIn(coords)) {
            return;
        }
        int runningCFTotal;
        runningCFTotal = bldg.getCurrentCF(coords);

        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> entities = positionMap.get(coords);

        if (bldg.getBasement(coords) == BasementType.NONE) {
            return;
        } else {
            bldg.collapseBasement(coords, game.getBoard(), vPhaseReport);
        }

        // Are there any Entities at these coords?
        if (entities != null) {

            // Sort in elevation order
            Collections.sort(entities, new Comparator<Entity>() {
                public int compare(Entity a, Entity b) {
                    if (a.getElevation() > b.getElevation()) {
                        return -1;
                    } else if (a.getElevation() > b.getElevation()) {
                        return 1;
                    }
                    return 0;
                }
            });
            // Walk through the entities in this position.
            for (Entity entity : entities) {

                // int floor = entity.getElevation();

                int cfDamage = (int) Math
                        .ceil(Math.round(entity.getWeight() / 10.0));

                // all entities should fall
                // ASSUMPTION: PSR to avoid pilot damage
                PilotingRollData psr = entity.getBasePilotingRoll();
                entity.addPilotingModifierForTerrain(psr, coords);

                // fall into basement
                if ((bldg.getBasement(coords) == BasementType.TWO_DEEP_HEAD)
                    || (bldg.getBasement(coords) == BasementType.TWO_DEEP_FEET)) {
                    System.err.println(entity.getDisplayName()
                                       + " is falling 2 floors into " + coords.toString());
                    // Damage is determined by the depth of the basement, so a
                    //  fall of 0 elevation is correct in this case
                    vPhaseReport.addAll(doEntityFall(entity, coords, 0,
                                                     Compute.d6(), psr, true));
                    runningCFTotal -= cfDamage * 2;
                } else if ((bldg.getBasement(coords) != BasementType.NONE)
                           && (bldg.getBasement(coords) != BasementType.ONE_DEEP_NORMALINFONLY)) {
                    System.err.println(entity.getDisplayName()
                                       + " is falling 1 floor into " + coords.toString());
                    // Damage is determined by the depth of the basement, so a
                    //  fall of 0 elevation is correct in this case
                    vPhaseReport.addAll(doEntityFall(entity, coords, 0,
                                                     Compute.d6(), psr, true));
                    runningCFTotal -= cfDamage;
                } else {
                    System.err.println(entity.getDisplayName()
                                       + " is not falling into " + coords.toString());
                }

                // Update this entity.
                // ASSUMPTION: this is the correct thing to do.
                entityUpdate(entity.getId());

            } // Handle the next entity.

        } // End have-entities-here.

        // Update the building
        if (runningCFTotal < 0) {
            bldg.setCurrentCF(0, coords);
            bldg.setPhaseCF(0, coords);
        } else {
            bldg.setCurrentCF(runningCFTotal, coords);
            bldg.setPhaseCF(runningCFTotal, coords);
        }
        sendChangedHex(coords);
        Vector<Building> buildings = new Vector<Building>();
        buildings.add(bldg);
        sendChangedBuildings(buildings);
    }

    /**
     * Collapse a building hex. Inflict the appropriate amount of damage on all
     * entities in the building. Update all clients.
     *
     * @param bldg        - the <code>Building</code> that has collapsed.
     * @param positionMap - a <code>Hashtable</code> that maps the <code>Coords</code>
     *                    positions or each unit in the game to a <code>Vector</code> of
     *                    <code>Entity</code>s at that position. This value should not
     *                    be <code>null</code>.
     * @param coords      - The <code>Coords></code> of the building hex that has
     *                    collapsed
     * @param collapseAll - A <code>boolean</code> indicating wether or not this
     *                    collapse of a hex should be able to collapse the whole
     *                    building
     */
    public void collapseBuilding(Building bldg,
                                 Hashtable<Coords, Vector<Entity>> positionMap, Coords coords,
                                 boolean collapseAll, Vector<Report> vPhaseReport) {
        if (!bldg.hasCFIn(coords)) {
            return;
        }
        // Loop through the hexes in the building, and apply
        // damage to all entities inside or on top of the building.
        Report r;
        final int phaseCF = bldg.getPhaseCF(coords);
        // Get the Vector of Entities at these coordinates.
        final Vector<Entity> vector = positionMap.get(coords);

        // Are there any Entities at these coords?
        if (vector != null) {

            // How many levels does this building have in this hex?
            final IHex curHex = game.getBoard().getHex(coords);
            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);
            final int numFloors = Math.max(bridgeEl,
                                           curHex.terrainLevel(Terrains.BLDG_ELEV));

            // Now collapse the building in this hex, so entities fall to
            // the ground
            bldg.setCurrentCF(0, coords);
            bldg.setPhaseCF(0, coords);
            send(createCollapseBuildingPacket(coords));
            game.getBoard().collapseBuilding(coords);

            // Sort in elevation order
            Collections.sort(vector, new Comparator<Entity>() {
                public int compare(Entity a, Entity b) {
                    if (a.getElevation() > b.getElevation()) {
                        return -1;
                    } else if (a.getElevation() > b.getElevation()) {
                        return 1;
                    }
                    return 0;
                }
            });
            // Walk through the entities in this position.
            Enumeration<Entity> entities = vector.elements();
            while (entities.hasMoreElements()) {
                final Entity entity = entities.nextElement();
                // all gun emplacements are simply destroyed
                if (entity instanceof GunEmplacement) {
                    vPhaseReport.addAll(destroyEntity(entity,
                                                      "building collapse"));
                    addNewLines();
                    continue;
                }

                int floor = entity.getElevation();
                // units trapped in a basement under a collapsing building are
                // destroyed
                if (floor < 0) {
                    vPhaseReport.addAll(destroyEntity(entity,
                                                      "Crushed under building rubble", false, false));
                }

                // Ignore units above the building / bridge.
                if (floor > numFloors) {
                    continue;
                }

                // Treat units on the roof like
                // they were in the top floor.
                if (floor == numFloors) {
                    floor--;
                }

                // Calculate collapse damage for this entity.
                int damage = (int) Math.floor(bldg.getDamageFromScale()
                                              * Math.ceil((phaseCF * (numFloors - floor)) / 10.0));

                // Infantry suffer more damage.
                if (entity instanceof Infantry) {
                    if ((entity instanceof BattleArmor)
                        || ((Infantry) entity).isMechanized()) {
                        damage *= 2;
                    } else {
                        damage *= 3;
                    }
                }

                // Apply collapse damage the entity.
                r = new Report(6455);
                r.indent();
                r.subject = entity.getId();
                r.add(entity.getDisplayName());
                r.add(damage);
                vPhaseReport.add(r);
                int remaining = damage;
                int cluster = damage;
                if ((entity instanceof BattleArmor) || (entity instanceof Mech)
                    || (entity instanceof Tank)) {
                    cluster = 5;
                }
                while (remaining > 0) {
                    int next = Math.min(cluster, remaining);
                    int table;
                    if (entity instanceof Protomech) {
                        table = ToHitData.HIT_SPECIAL_PROTO;
                    } else if (entity.getElevation() == numFloors) {
                        table = ToHitData.HIT_NORMAL;
                    } else {
                        table = ToHitData.HIT_PUNCH;
                    }
                    HitData hit = entity.rollHitLocation(table,
                                                         ToHitData.SIDE_FRONT);
                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);
                    vPhaseReport.addAll(damageEntity(entity, hit, next));
                    remaining -= next;
                }
                vPhaseReport.add(new Report(1210, Report.PUBLIC));

                // all entities should fall
                floor = entity.getElevation();
                if ((floor > 0) || (floor == bridgeEl)) {
                    // ASSUMPTION: PSR to avoid pilot damage
                    // should use mods for entity damage and
                    // 20+ points of collapse damage (if any).
                    PilotingRollData psr = entity.getBasePilotingRoll();
                    entity.addPilotingModifierForTerrain(psr, coords);
                    if (damage >= 20) {
                        psr.addModifier(1, "20+ damage");
                    }
                    vPhaseReport.addAll(doEntityFallsInto(entity, coords, psr,
                                                          true));
                }
                // Update this entity.
                // ASSUMPTION: this is the correct thing to do.
                entityUpdate(entity.getId());

            } // Handle the next entity.

        } // End have-entities-here.

        else {
            // Update the building.
            bldg.setCurrentCF(0, coords);
            bldg.setPhaseCF(0, coords);
            send(createCollapseBuildingPacket(coords));
            game.getBoard().collapseBuilding(coords);
        }
        // if more than half of the hexes are gone, collapse all
        if (bldg.getCollapsedHexCount() > (bldg.getOriginalHexCount() / 2)) {
            for (Enumeration<Coords> coordsEnum = bldg.getCoords(); coordsEnum
                    .hasMoreElements(); ) {
                coords = coordsEnum.nextElement();
                collapseBuilding(bldg, game.getPositionMap(), coords, false,
                                 vPhaseReport);
            }
        }

    } // End private void collapseBuilding( Building )

    /**
     * Tell the clients to replace the given building with rubble hexes.
     *
     * @param coords - the <code>Coords</code> that has collapsed.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createCollapseBuildingPacket(Coords coords) {
        Vector<Coords> coordsV = new Vector<Coords>();
        coordsV.addElement(coords);
        return createCollapseBuildingPacket(coordsV);
    }

    /**
     * Tell the clients to replace the given building hexes with rubble hexes.
     *
     * @param coords - a <code>Vector</code> of <code>Coords</code>s that has
     *               collapsed.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createCollapseBuildingPacket(Vector<Coords> coords) {
        return new Packet(Packet.COMMAND_BLDG_COLLAPSE, coords);
    }

    /**
     * Tell the clients to update the CFs of the given buildings.
     *
     * @param buildings - a <code>Vector</code> of <code>Building</code>s that need to
     *                  be updated.
     * @return a <code>Packet</code> for the command.
     */
    private Packet createUpdateBuildingPacket(Vector<Building> buildings) {
        return new Packet(Packet.COMMAND_BLDG_UPDATE, buildings);
    }

    /**
     * Apply this phase's damage to all buildings. Buildings may collapse due to
     * damage.
     */
    private void applyBuildingDamage() {

        // Walk through the buildings in the game.
        // Build the collapse and update vectors as you go.
        // N.B. never, NEVER, collapse buildings while you are walking through
        // the Enumeration from megamek.common.Board#getBuildings.
        Map<Building, Vector<Coords>> collapse = new HashMap<Building, Vector<Coords>>();
        Map<Building, Vector<Coords>> update = new HashMap<Building, Vector<Coords>>();
        Enumeration<Building> buildings = game.getBoard().getBuildings();
        while (buildings.hasMoreElements()) {
            Building bldg = buildings.nextElement();
            Vector<Coords> collapseCoords = new Vector<Coords>();
            Vector<Coords> updateCoords = new Vector<Coords>();
            Enumeration<Coords> buildingCoords = bldg.getCoords();
            while (buildingCoords.hasMoreElements()) {
                Coords coords = buildingCoords.nextElement();
                // If the CF is zero, the building should fall.
                if (bldg.getCurrentCF(coords) == 0) {
                    collapseCoords.addElement(coords);
                }
                // If the building took damage this round, update it.
                else if (bldg.getPhaseCF(coords) != bldg.getCurrentCF(coords)) {
                    bldg.setPhaseCF(bldg.getCurrentCF(coords), coords);
                    updateCoords.addElement(coords);
                }
            }
            collapse.put(bldg, collapseCoords);
            update.put(bldg, updateCoords);
        } // Handle the next building

        // If we have any buildings to collapse, collapse them now.
        if (!collapse.isEmpty()) {

            // Get the position map of all entities in the game.
            Hashtable<Coords, Vector<Entity>> positionMap = game
                    .getPositionMap();

            // Walk through the hexes that have collapsed.
            for (Building bldg : collapse.keySet()) {
                Vector<Coords> coordsVector = collapse.get(bldg);
                for (Coords coords : coordsVector) {
                    Report r = new Report(6460, Report.PUBLIC);
                    r.add(bldg.getName());
                    addReport(r);
                    collapseBuilding(bldg, positionMap, coords, vPhaseReport);
                }
            }
        }

        // check for buildings which should collapse due to being overloaded now
        // CF is reduced
        if (!update.isEmpty()) {
            Hashtable<Coords, Vector<Entity>> positionMap = game
                    .getPositionMap();
            for (Building bldg : update.keySet()) {
                Vector<Coords> updateCoords = update.get(bldg);
                Vector<Coords> coordsToRemove = new Vector<Coords>();
                for (Coords coords : updateCoords) {
                    if (checkForCollapse(bldg, positionMap, coords, false,
                                         vPhaseReport)) {
                        coordsToRemove.add(coords);
                    }
                }
                updateCoords.removeAll(coordsToRemove);
                update.put(bldg, updateCoords);
            }
        }

        // If we have any buildings to update, send the message.
        if (!update.isEmpty()) {
            sendChangedBuildings(new Vector<Building>(update.keySet()));
        }
    }

    /**
     * Apply the given amount of damage to the building. Please note, this
     * method does <b>not</b> apply any damage to units inside the building,
     * update the clients, or check for the building's collapse.
     * <p/>
     * A default message will be used to describe why the building took the
     * damage.
     *
     * @param bldg   - the <code>Building</code> that has been damaged. This value
     *               should not be <code>null</code>, but no exception will occur.
     * @param damage - the <code>int</code> amount of damage.
     * @param coords - the <code>Coords</code> of the building hex to be damaged
     * @return a <code>Report</code> to be shown to the players.
     */
    public Vector<Report> damageBuilding(Building bldg, int damage,
                                         Coords coords) {
        final String defaultWhy = " absorbs ";
        return damageBuilding(bldg, damage, defaultWhy, coords);
    }

    /**
     * Apply the given amount of damage to the building. Please note, this
     * method does <b>not</b> apply any damage to units inside the building,
     * update the clients, or check for the building's collapse.
     *
     * @param bldg   - the <code>Building</code> that has been damaged. This value
     *               should not be <code>null</code>, but no exception will occur.
     * @param damage - the <code>int</code> amount of damage.
     * @param why    - the <code>String</code> message that describes why the
     *               building took the damage.
     * @param coords - the <code>Coords</code> of the building hex to be damaged
     * @return a <code>Report</code> to be shown to the players.
     */
    public Vector<Report> damageBuilding(Building bldg, int damage, String why,
                                         Coords coords) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        Report r = new Report(1210, Report.PUBLIC);

        // Do nothing if no building or no damage was passed.
        if ((bldg != null) && (damage > 0)) {
            r.messageId = 3435;
            r.add(bldg.getName());
            r.add(why);
            r.add(damage);
            vPhaseReport.add(r);
            int curArmor = bldg.getArmor(coords);
            if (curArmor >= damage) {
                curArmor -= Math.min(curArmor, damage);
                bldg.setArmor(curArmor, coords);
                r = new Report(3436, Report.PUBLIC);
                r.indent(0);
                r.add(damage);
                r.add(curArmor);
                vPhaseReport.add(r);
            } else {
                r.add(damage);
                if (curArmor > 0) {
                    bldg.setArmor(0, coords);
                    damage = damage - curArmor;
                    r = new Report(3436, Report.PUBLIC);
                    r.indent(0);
                    r.add(curArmor);
                    r.add(0);
                    vPhaseReport.add(r);
                }
                damage = (int) Math.floor(bldg.getDamageToScale() * damage);
                if (bldg.getDamageToScale() < 1.0) {
                    r = new Report(3437, Report.PUBLIC);
                    r.indent(0);
                    r.add(damage);
                    vPhaseReport.add(r);
                }
                if (bldg.getDamageToScale() > 1.0) {
                    r = new Report(3438, Report.PUBLIC);
                    r.indent(0);
                    r.add(damage);
                    vPhaseReport.add(r);
                }
                int curCF = bldg.getCurrentCF(coords);
                final int startingCF = curCF;
                curCF -= Math.min(curCF, damage);
                bldg.setCurrentCF(curCF, coords);
                final int damageThresh = (int) Math.ceil(bldg
                                                                 .getPhaseCF(coords) / 10.0);

                // If the CF is zero, the building should fall.
                if ((curCF == 0) && (startingCF != 0)) {
                    if (bldg instanceof FuelTank) {
                        // If this is a fuel tank, we'll give it its own
                        // message.
                        r = new Report(3441);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                        // ...But we ALSO need to blow up everything nearby.
                        // Bwahahahahaha...
                        r = new Report(3560);
                        r.type = Report.PUBLIC;
                        r.newlines = 1;
                        vPhaseReport.add(r);
                        Vector<Report> vRep = new Vector<Report>();
                        doExplosion(((FuelTank) bldg).getMagnitude(), 10,
                                    false, bldg.getCoords().nextElement(), true,
                                    vRep, null, -1);
                        Report.indentAll(vRep, 2);
                        vPhaseReport.addAll(vRep);
                        return vPhaseReport;
                    }
                    if (bldg.getType() == Building.WALL) {
                        r = new Report(3442);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                    } else {
                        r = new Report(3440);
                        r.type = Report.PUBLIC;
                        r.indent(0);
                        vPhaseReport.add(r);
                    }
                } else if ((curCF < startingCF) && (damage > damageThresh)) {
                    // need to check for crits
                    // don't bother unless we have some gun emplacements
                    Vector<GunEmplacement> guns = game
                            .getGunEmplacements(coords);
                    if (guns.size() > 0) {
                        vPhaseReport.addAll(criticalGunEmplacement(guns, bldg,
                                                                   coords));
                    }
                }
            }
        }
        Report.indentAll(vPhaseReport, 2);
        return vPhaseReport;
    }

    private Vector<Report> criticalGunEmplacement(Vector<GunEmplacement> guns,
                                                  Building bldg, Coords coords) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        r = new Report(3800);
        r.type = Report.PUBLIC;
        r.indent(0);
        vDesc.add(r);

        int critroll = Compute.d6(2);
        if (critroll < 6) {
            r = new Report(3805);
            r.type = Report.PUBLIC;
            r.indent(1);
            vDesc.add(r);
        } else if (critroll == 6) {
            // weapon malfunction
            // lets just randomly determine which weapon gets hit
            Vector<Mounted> wpns = new Vector<Mounted>();
            for (GunEmplacement gun : guns) {
                for (Mounted wpn : gun.getWeaponList()) {
                    if (!wpn.isHit() && !wpn.isJammed()
                        && !wpn.jammedThisPhase()) {
                        wpns.add(wpn);
                    }
                }
            }
            if (wpns.size() > 0) {
                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));
                weapon.setJammed(true);
                ((GunEmplacement) weapon.getEntity()).addJammedWeapon(weapon);
                r = new Report(3845);
                r.type = Report.PUBLIC;
                r.indent(1);
                r.add(weapon.getDesc());
                vDesc.add(r);
            } else {
                r = new Report(3846);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
            }
        } else if (critroll == 7) {
            // gunners stunned
            for (GunEmplacement gun : guns) {
                gun.stunCrew();
                r = new Report(3810);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
            }
        } else if (critroll == 8) {
            // weapon destroyed
            // lets just randomly determine which weapon gets hit
            Vector<Mounted> wpns = new Vector<Mounted>();
            for (GunEmplacement gun : guns) {
                for (Mounted wpn : gun.getWeaponList()) {
                    if (!wpn.isHit()) {
                        wpns.add(wpn);
                    }
                }
            }
            if (wpns.size() > 0) {
                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));
                weapon.setHit(true);
                r = new Report(3840);
                r.type = Report.PUBLIC;
                r.indent(1);
                r.add(weapon.getDesc());
                vDesc.add(r);
            } else {
                r = new Report(3841);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
            }
        } else if (critroll == 9) {
            // gunners killed
            r = new Report(3815);
            r.type = Report.PUBLIC;
            r.indent(1);
            vDesc.add(r);
            for (GunEmplacement gun : guns) {
                gun.getCrew().setDoomed(true);
            }
        } else if (critroll == 10) {
            if (Compute.d6() > 3) {
                // turret lock
                r = new Report(3820);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
                for (GunEmplacement gun : guns) {
                    gun.lockTurret(gun.getLocTurret());
                }
            } else {
                // turret jam
                r = new Report(3825);
                r.type = Report.PUBLIC;
                r.indent(1);
                vDesc.add(r);
                for (GunEmplacement gun : guns) {
                    if (gun.isTurretEverJammed(gun.getLocTurret())) {
                        gun.lockTurret(gun.getLocTurret());
                    } else {
                        gun.jamTurret(gun.getLocTurret());
                    }
                }
            }
        } else if (critroll == 11) {
            r = new Report(3830);
            r.type = Report.PUBLIC;
            r.indent(1);
            r.add(bldg.getName());
            int boom = 0;
            for (GunEmplacement gun : guns) {
                for (Mounted ammo : gun.getAmmo()) {
                    ammo.setHit(true);
                    if (ammo.getType().isExplosive(ammo)) {
                        boom += ammo.getHittableShotsLeft()
                                * ((AmmoType) ammo.getType())
                                .getDamagePerShot()
                                * ((AmmoType) ammo.getType()).getRackSize();
                    }
                }
            }
            boom = (int) Math.floor(bldg.getDamageToScale() * boom);
            r.add(boom);
            int curCF = bldg.getCurrentCF(coords);
            curCF -= Math.min(curCF, boom);
            bldg.setCurrentCF(curCF, coords);
            r.add(bldg.getCurrentCF(coords));
            vDesc.add(r);
            // If the CF is zero, the building should fall.
            if ((curCF == 0) && (bldg.getPhaseCF(coords) != 0)) {
                if (bldg instanceof FuelTank) {
                    // If this is a fuel tank, we'll give it its own
                    // message.
                    r = new Report(3441);
                    r.type = Report.PUBLIC;
                    r.indent(0);
                    vDesc.add(r);
                    // ...But we ALSO need to blow up everything nearby.
                    // Bwahahahahaha...
                    r = new Report(3560);
                    r.type = Report.PUBLIC;
                    r.newlines = 1;
                    vDesc.add(r);
                    Vector<Report> vRep = new Vector<Report>();
                    doExplosion(((FuelTank) bldg).getMagnitude(), 10, false,
                                bldg.getCoords().nextElement(), true, vRep, null,
                                -1);
                    Report.indentAll(vRep, 2);
                    vDesc.addAll(vRep);
                    return vPhaseReport;
                }
                if (bldg.getType() == Building.WALL) {
                    r = new Report(3442);
                    r.type = Report.PUBLIC;
                    r.indent(0);
                    vDesc.add(r);
                } else {
                    r = new Report(3440);
                    r.type = Report.PUBLIC;
                    r.indent(0);
                    vDesc.add(r);
                }
            }
        } else if (critroll == 12) {
            // other
            r = new Report(3835);
            r.type = Report.PUBLIC;
            r.indent(1);
            vDesc.add(r);
        }

        return vDesc;

    }

    public void sendChangedBuildings(Vector<Building> buildings) {
        send(createUpdateBuildingPacket(buildings));
    }

    /**
     * Receives an packet to unload entityis stranded on immobile transports,
     * and queue all valid requests for execution. If all players that have
     * stranded entities have answered, executes the pending requests and end
     * the current turn.
     */
    private void receiveUnloadStranded(Packet packet, int connId) {
        GameTurn.UnloadStrandedTurn turn = null;
        final IPlayer player = game.getPlayer(connId);
        int[] entityIds = (int[]) packet.getObject(0);
        Vector<IPlayer> declared = null;
        IPlayer other = null;
        Enumeration<EntityAction> pending = null;
        UnloadStrandedAction action = null;
        Entity entity = null;

        // Is this the right phase?
        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {
            System.err
                    .println("error: server got unload stranded packet in wrong phase");
            return;
        }

        // Are we in an "unload stranded entities" turn?
        if (game.getTurn() instanceof GameTurn.UnloadStrandedTurn) {
            turn = (GameTurn.UnloadStrandedTurn) game.getTurn();
        } else {
            System.err
                    .println("error: server got unload stranded packet out of sequence");
            StringBuffer message = new StringBuffer();
            message.append(player.getName())
                   .append(" should not be sending 'unload stranded entity' packets at this time.");
            sendServerChat(message.toString());
            return;
        }

        // Can this player act right now?
        if (!turn.isValid(connId, game)) {
            System.err
                    .println("error: server got unload stranded packet from invalid player");
            StringBuffer message = new StringBuffer();
            message.append(player.getName()).append(
                    " should not be sending 'unload stranded entity' packets.");
            sendServerChat(message.toString());
            return;
        }

        // Did the player already send an 'unload' request?
        // N.B. we're also building the list of players who
        // have declared their "unload stranded" actions.
        declared = new Vector<IPlayer>();
        pending = game.getActions();
        while (pending.hasMoreElements()) {
            action = (UnloadStrandedAction) pending.nextElement();
            if (action.getPlayerId() == connId) {
                System.err
                        .println("error: server got multiple unload stranded packets from player");
                StringBuffer message = new StringBuffer();
                message.append(player.getName())
                       .append(" should not send multiple 'unload stranded entity' packets.");
                sendServerChat(message.toString());
                return;
            }
            // This player is not from the current connection.
            // Record this player to determine if this turn is done.
            other = game.getPlayer(action.getPlayerId());
            if (!declared.contains(other)) {
                declared.addElement(other);
            }
        } // Handle the next "unload stranded" action.

        // Make sure the player selected at least *one* valid entity ID.
        boolean foundValid = false;
        for (int index = 0; (null != entityIds) && (index < entityIds.length); index++) {
            entity = game.getEntity(entityIds[index]);
            if (!game.getTurn().isValid(connId, entity, game)) {
                System.err
                        .println("error: server got unload stranded packet for invalid entity");
                StringBuffer message = new StringBuffer();
                message.append(player.getName()).append(
                        " can not unload stranded entity ");
                if (null == entity) {
                    message.append('#').append(entityIds[index]);
                } else {
                    message.append(entity.getDisplayName());
                }
                message.append(" at this time.");
                sendServerChat(message.toString());
            } else {
                foundValid = true;
                game.addAction(new UnloadStrandedAction(connId,
                                                        entityIds[index]));
            }
        }

        // Did the player choose not to unload any valid stranded entity?
        if (!foundValid) {
            game.addAction(new UnloadStrandedAction(connId, Entity.NONE));
        }

        // Either way, the connection's player has now declared.
        declared.addElement(player);

        // Are all players who are unloading entities done? Walk
        // through the turn's stranded entities, and look to see
        // if their player has finished their turn.
        entityIds = turn.getEntityIds();
        for (int entityId : entityIds) {
            entity = game.getEntity(entityId);
            other = entity.getOwner();
            if (!declared.contains(other)) {
                // At least one player still needs to declare.
                return;
            }
        }

        // All players have declared whether they're unloading stranded units.
        // Walk the list of pending actions and unload the entities.
        pending = game.getActions();
        while (pending.hasMoreElements()) {
            action = (UnloadStrandedAction) pending.nextElement();

            // Some players don't want to unload any stranded units.
            if (Entity.NONE != action.getEntityId()) {
                entity = game.getEntity(action.getEntityId());
                if (null == entity) {
                    // After all this, we couldn't find the entity!!!
                    System.err
                            .print("error: server could not find stranded entity #");
                    System.err.print(action.getEntityId());
                    System.err.println(" to unload!!!");
                } else {
                    // Unload the entity. Get the unit's transporter.
                    Entity transporter = game
                            .getEntity(entity.getTransportId());
                    unloadUnit(transporter, entity, transporter.getPosition(),
                               transporter.getFacing(), transporter.getElevation());
                }
            }

        } // Handle the next pending unload action

        // Clear the list of pending units and move to the next turn.
        game.resetActions();
        changeToNextTurn();
    }

    /**
     * For all current artillery attacks in the air from this entity with this
     * weapon, clear the list of spotters. Needed because firing another round
     * before first lands voids spotting.
     *
     * @param entityID the <code>int</code> id of the entity
     * @param weaponID the <code>int</code> id of the weapon
     */
    private void clearArtillerySpotters(int entityID, int weaponID) {
        for (Enumeration<AttackHandler> i = game.getAttacks(); i
                .hasMoreElements(); ) {
            WeaponHandler wh = (WeaponHandler) i.nextElement();
            if ((wh.waa instanceof ArtilleryAttackAction)
                && (wh.waa.getEntityId() == entityID)
                && (wh.waa.getWeaponId() == weaponID)) {
                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;
                aaa.setSpotterIds(null);
            }
        }
    }

    /**
     * Credits a Kill for an entity, if the target got killed.
     *
     * @param target   The <code>Entity</code> that got killed.
     * @param attacker The <code>Entity</code> that did the killing.
     */
    public void creditKill(Entity target, Entity attacker) {
        // Kills should be credited for each individual fighter, instead of the
        // squadron
        if (target instanceof FighterSquadron) {
            return;
        }
        if ((target.isDoomed() || target.getCrew().isDoomed())
            && !target.getGaveKillCredit() && (attacker != null)) {
            attacker.addKill(target);
        }
    }

    /**
     * pre-treats a physical attack
     *
     * @param aaa The <code>AbstractAttackAction</code> of the physical attack
     *            to pre-treat
     * @return The <code>PhysicalResult</code> of that action, including
     * possible damage.
     */
    private PhysicalResult preTreatPhysicalAttack(AbstractAttackAction aaa) {
        final Entity ae = game.getEntity(aaa.getEntityId());
        int damage = 0;
        PhysicalResult pr = new PhysicalResult();
        ToHitData toHit = new ToHitData();
        pr.roll = Compute.d6(2);
        pr.aaa = aaa;
        if (aaa instanceof BrushOffAttackAction) {
            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;
            int arm = baa.getArm();
            baa.setArm(BrushOffAttackAction.LEFT);
            toHit = BrushOffAttackAction.toHit(game, aaa.getEntityId(),
                                               aaa.getTarget(game), BrushOffAttackAction.LEFT);
            baa.setArm(BrushOffAttackAction.RIGHT);
            pr.toHitRight = BrushOffAttackAction.toHit(game, aaa.getEntityId(),
                                                       aaa.getTarget(game), BrushOffAttackAction.RIGHT);
            damage = BrushOffAttackAction.getDamageFor(ae,
                                                       BrushOffAttackAction.LEFT);
            pr.damageRight = BrushOffAttackAction.getDamageFor(ae,
                                                               BrushOffAttackAction.RIGHT);
            baa.setArm(arm);
            pr.rollRight = Compute.d6(2);
        } else if (aaa instanceof ChargeAttackAction) {
            ChargeAttackAction caa = (ChargeAttackAction) aaa;
            toHit = caa.toHit(game);
            if (caa.getTarget(game) instanceof Entity) {
                Entity target = (Entity) caa.getTarget(game);
                damage = ChargeAttackAction.getDamageFor(ae, target, game
                                                                 .getOptions().booleanOption("tacops_charge_damage"),
                                                         toHit.getMoS());
            } else {
                damage = ChargeAttackAction.getDamageFor(ae);
            }
        } else if (aaa instanceof ClubAttackAction) {
            ClubAttackAction caa = (ClubAttackAction) aaa;
            toHit = caa.toHit(game);
            damage = ClubAttackAction.getDamageFor(
                    ae,
                    caa.getClub(),
                    (caa.getTarget(game) instanceof Infantry)
                    && !(caa.getTarget(game) instanceof BattleArmor));
            if (caa.getTargetType() == Targetable.TYPE_BUILDING) {
                EquipmentType clubType = caa.getClub().getType();
                if (clubType.hasSubType(MiscType.S_BACKHOE)
                        || clubType.hasSubType(MiscType.S_CHAINSAW)
                        || clubType.hasSubType(MiscType.S_MINING_DRILL)
                        || clubType.hasSubType(MiscType.S_PILE_DRIVER)) {
                    damage += Compute.d6(1);
                } else if (clubType.hasSubType(MiscType.S_DUAL_SAW)) {
                    damage += Compute.d6(2);
                } else if (clubType.hasSubType(MiscType.S_ROCK_CUTTER)) {
                    damage += Compute.d6(3);
                }
                else if (clubType.hasSubType(MiscType.S_WRECKING_BALL)) {
                    damage += Compute.d6(4);
                }
            }
        } else if (aaa instanceof DfaAttackAction) {
            DfaAttackAction daa = (DfaAttackAction) aaa;
            toHit = daa.toHit(game);
            damage = DfaAttackAction.getDamageFor(
                    ae,
                    (daa.getTarget(game) instanceof Infantry)
                    && !(daa.getTarget(game) instanceof BattleArmor));
        } else if (aaa instanceof KickAttackAction) {
            KickAttackAction kaa = (KickAttackAction) aaa;
            toHit = kaa.toHit(game);
            damage = KickAttackAction.getDamageFor(
                    ae,
                    kaa.getLeg(),
                    (kaa.getTarget(game) instanceof Infantry)
                    && !(kaa.getTarget(game) instanceof BattleArmor));
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {
            ProtomechPhysicalAttackAction paa = (ProtomechPhysicalAttackAction) aaa;
            toHit = paa.toHit(game);
            damage = ProtomechPhysicalAttackAction.getDamageFor(ae,
                                                                paa.getTarget(game));
        } else if (aaa instanceof PunchAttackAction) {
            PunchAttackAction paa = (PunchAttackAction) aaa;
            int arm = paa.getArm();
            int damageRight = 0;
            paa.setArm(PunchAttackAction.LEFT);
            toHit = paa.toHit(game);
            paa.setArm(PunchAttackAction.RIGHT);
            ToHitData toHitRight = paa.toHit(game);
            damage = PunchAttackAction.getDamageFor(
                    ae,
                    PunchAttackAction.LEFT,
                    (paa.getTarget(game) instanceof Infantry)
                    && !(paa.getTarget(game) instanceof BattleArmor));
            damageRight = PunchAttackAction.getDamageFor(
                    ae,
                    PunchAttackAction.RIGHT,
                    (paa.getTarget(game) instanceof Infantry)
                    && !(paa.getTarget(game) instanceof BattleArmor));
            paa.setArm(arm);
            // If we're punching while prone (at a Tank,
            // duh), then we can only use one arm.
            if (ae.isProne()) {
                double oddsLeft = Compute.oddsAbove(toHit.getValue(),
                                                    ae.getCrew().getOptions().booleanOption(OptionsConstants
                                                                                                    .PILOT_APTITUDE_PILOTING));
                double oddsRight = Compute.oddsAbove(toHitRight.getValue(),
                                                     ae.getCrew().getOptions().booleanOption(OptionsConstants
                                                                                                     .PILOT_APTITUDE_PILOTING));
                // Use the best attack.
                if ((oddsLeft * damage) > (oddsRight * damageRight)) {
                    paa.setArm(PunchAttackAction.LEFT);
                } else {
                    paa.setArm(PunchAttackAction.RIGHT);
                }
            }
            pr.damageRight = damageRight;
            pr.toHitRight = toHitRight;
            pr.rollRight = Compute.d6(2);
        } else if (aaa instanceof PushAttackAction) {
            PushAttackAction paa = (PushAttackAction) aaa;
            toHit = paa.toHit(game);
        } else if (aaa instanceof TripAttackAction) {
            TripAttackAction paa = (TripAttackAction) aaa;
            toHit = paa.toHit(game);
        } else if (aaa instanceof LayExplosivesAttackAction) {
            LayExplosivesAttackAction leaa = (LayExplosivesAttackAction) aaa;
            toHit = leaa.toHit(game);
            damage = LayExplosivesAttackAction.getDamageFor(ae);
        } else if (aaa instanceof ThrashAttackAction) {
            ThrashAttackAction taa = (ThrashAttackAction) aaa;
            toHit = taa.toHit(game);
            damage = ThrashAttackAction.getDamageFor(ae);
        } else if (aaa instanceof JumpJetAttackAction) {
            JumpJetAttackAction jaa = (JumpJetAttackAction) aaa;
            toHit = jaa.toHit(game);
            if (jaa.getLeg() == JumpJetAttackAction.BOTH) {
                damage = JumpJetAttackAction.getDamageFor(ae,
                                                          JumpJetAttackAction.LEFT);
                pr.damageRight = JumpJetAttackAction.getDamageFor(ae,
                                                                  JumpJetAttackAction.LEFT);
            } else {
                damage = JumpJetAttackAction.getDamageFor(ae, jaa.getLeg());
                pr.damageRight = 0;
            }
            ae.heatBuildup += (damage + pr.damageRight) / 3;
        } else if (aaa instanceof GrappleAttackAction) {
            GrappleAttackAction taa = (GrappleAttackAction) aaa;
            toHit = taa.toHit(game);
        } else if (aaa instanceof BreakGrappleAttackAction) {
            BreakGrappleAttackAction taa = (BreakGrappleAttackAction) aaa;
            toHit = taa.toHit(game);
        } else if (aaa instanceof RamAttackAction) {
            RamAttackAction raa = (RamAttackAction) aaa;
            toHit = raa.toHit(game);
            damage = RamAttackAction.getDamageFor((Aero) ae,
                                                  (Aero) aaa.getTarget(game));
        } else if (aaa instanceof TeleMissileAttackAction) {
            TeleMissileAttackAction taa = (TeleMissileAttackAction) aaa;
            toHit = taa.toHit(game);
            damage = TeleMissileAttackAction.getDamageFor(ae);
        } else if (aaa instanceof BAVibroClawAttackAction) {
            BAVibroClawAttackAction bvca = (BAVibroClawAttackAction) aaa;
            toHit = bvca.toHit(game);
            damage = BAVibroClawAttackAction.getDamageFor(ae);
        }
        pr.toHit = toHit;
        pr.damage = damage;
        return pr;
    }

    /**
     * Resolve a Physical Attack
     *
     * @param pr  The <code>PhysicalResult</code> of the physical attack
     * @param cen The <code>int</code> Entity Id of the entit's whose physical
     *            attack was last resolved
     */
    private void resolvePhysicalAttack(PhysicalResult pr, int cen) {
        AbstractAttackAction aaa = pr.aaa;
        if (aaa instanceof PunchAttackAction) {
            PunchAttackAction paa = (PunchAttackAction) aaa;
            if (paa.getArm() == PunchAttackAction.BOTH) {
                paa.setArm(PunchAttackAction.LEFT);
                pr.aaa = paa;
                resolvePunchAttack(pr, cen);
                cen = paa.getEntityId();
                paa.setArm(PunchAttackAction.RIGHT);
                pr.aaa = paa;
                resolvePunchAttack(pr, cen);
            } else {
                resolvePunchAttack(pr, cen);
                cen = paa.getEntityId();
            }
        } else if (aaa instanceof KickAttackAction) {
            resolveKickAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BrushOffAttackAction) {
            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;
            if (baa.getArm() == BrushOffAttackAction.BOTH) {
                baa.setArm(BrushOffAttackAction.LEFT);
                pr.aaa = baa;
                resolveBrushOffAttack(pr, cen);
                cen = baa.getEntityId();
                baa.setArm(BrushOffAttackAction.RIGHT);
                pr.aaa = baa;
                resolveBrushOffAttack(pr, cen);
            } else {
                resolveBrushOffAttack(pr, cen);
                cen = baa.getEntityId();
            }
        } else if (aaa instanceof ThrashAttackAction) {
            resolveThrashAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {
            resolveProtoAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ClubAttackAction) {
            resolveClubAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof PushAttackAction) {
            resolvePushAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof ChargeAttackAction) {
            resolveChargeAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof DfaAttackAction) {
            resolveDfaAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof LayExplosivesAttackAction) {
            resolveLayExplosivesAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof TripAttackAction) {
            resolveTripAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof JumpJetAttackAction) {
            resolveJumpJetAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof GrappleAttackAction) {
            resolveGrappleAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BreakGrappleAttackAction) {
            resolveBreakGrappleAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof RamAttackAction) {
            resolveRamAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof TeleMissileAttackAction) {
            resolveTeleMissileAttack(pr, cen);
            cen = aaa.getEntityId();
        } else if (aaa instanceof BAVibroClawAttackAction) {
            resolveBAVibroClawAttack(pr, cen);
            cen = aaa.getEntityId();
        } else {
            // hmm, error.
        }
        // Not all targets are Entities.
        Targetable target = game.getTarget(aaa.getTargetType(),
                                           aaa.getTargetId());
        if (target instanceof Entity) {
            Entity targetEntity = (Entity) target;
            targetEntity.setStruck(true);
            targetEntity.addAttackedByThisTurn(target.getTargetId());
            creditKill(targetEntity, game.getEntity(cen));
        }
    }

    /**
     * Add any extreme gravity PSRs the entity gets due to its movement
     *
     * @param entity
     *            The <code>Entity</code> to check.
     * @param step
     *            The last <code>MoveStep</code> of this entity
     * @param moveType
     *            The movement type for the MovePath the supplied MoveStep comes
     *            from. This generally comes from the last step in the move
     *            path.
     * @param curPos
     *            The current <code>Coords</code> of this entity
     * @param cachedMaxMPExpenditure
     *            Server checks run/jump MP at start of move, as appropriate,
     *            caches to avoid mid-move change in MP causing erroneous grav
     *            check
     */
    private void checkExtremeGravityMovement(Entity entity, MoveStep step,
            EntityMovementType moveType, Coords curPos,
            int cachedMaxMPExpenditure) {
        PilotingRollData rollTarget;
        if (game.getPlanetaryConditions().getGravity() != 1) {
            if (entity instanceof Mech) {
                if ((moveType == EntityMovementType.MOVE_WALK)
                    || (moveType == EntityMovementType.MOVE_VTOL_WALK)
                    || (moveType == EntityMovementType.MOVE_RUN)
                    || (moveType == EntityMovementType.MOVE_SPRINT)
                    || (moveType == EntityMovementType.MOVE_VTOL_RUN)) {
                    if (step.getMpUsed() > cachedMaxMPExpenditure) {
                        // We moved too fast, let's make PSR to see if we get
                        // damage
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    }
                } else if (moveType == EntityMovementType.MOVE_JUMP) {
                    System.err.println("gravity move check jump: "
                                       + step.getMpUsed() + "/" + cachedMaxMPExpenditure);
                    System.err.flush();
                    if (step.getMpUsed() > cachedMaxMPExpenditure) {
                        // We jumped too far, let's make PSR to see if we get
                        // damage
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    } else if (game.getPlanetaryConditions().getGravity() > 1) {
                        // jumping in high g is bad for your legs
                        rollTarget = entity.getBasePilotingRoll(moveType);
                        entity.addPilotingModifierForTerrain(rollTarget, step);
                        rollTarget.append(new PilotingRollData(entity.getId(),
                                                               0, "jumped in high gravity"));
                        game.addExtremeGravityPSR(rollTarget);
                    }
                }
            } else if (entity instanceof Tank) {
                if ((moveType == EntityMovementType.MOVE_WALK)
                    || (moveType == EntityMovementType.MOVE_VTOL_WALK)
                    || (moveType == EntityMovementType.MOVE_RUN)
                    || (moveType == EntityMovementType.MOVE_VTOL_RUN)) {
                    // For Tanks, we need to check if the tank had
                    // more MPs because it was moving along a road.
                    if ((step.getMpUsed() > cachedMaxMPExpenditure)
                        && !step.isOnlyPavement()) {
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    } else if (step.getMpUsed() > (cachedMaxMPExpenditure + 1)) {
                        // If the tank was moving on a road, he got a +1 bonus.
                        // N.B. The Ask Precentor Martial forum said that a 4/6
                        // tank on a road can move 5/7, **not** 5/8.
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(
                                step, moveType));
                    } // End tank-has-road-bonus
                }
            }
        }
    }

    /**
     * Damage the inner structure of a mech's leg / a tank's front. This only
     * happens when the Entity fails an extreme Gravity PSR.
     *
     * @param entity The <code>Entity</code> to damage.
     * @param damage The <code>int</code> amount of damage.
     */
    private Vector<Report> doExtremeGravityDamage(Entity entity, int damage) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        HitData hit;
        if (entity instanceof BipedMech) {
            for (int i = 6; i <= 7; i++) {
                hit = new HitData(i);
                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                                                 DamageType.NONE, true));
            }
        }
        if (entity instanceof QuadMech) {
            for (int i = 4; i <= 7; i++) {
                hit = new HitData(i);
                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                                                 DamageType.NONE, true));
            }
        } else if (entity instanceof Tank) {
            hit = new HitData(Tank.LOC_FRONT);
            vPhaseReport.addAll(damageEntity(entity, hit, damage, false,
                                             DamageType.NONE, true));
            vPhaseReport.addAll(vehicleMotiveDamage((Tank) entity, 0));
        }
        return vPhaseReport;
    }

    /**
     * Eject an Entity.
     *
     * @param entity    The <code>Entity</code> to eject.
     * @param autoEject The <code>boolean</code> state of the entity's auto- ejection
     *                  system
     * @return a <code>Vector</code> of report objects for the gamelog.
     */
    public Vector<Report> ejectEntity(Entity entity, boolean autoEject) {
        return ejectEntity(entity, autoEject, false);
    }

    /**
     * Eject an Entity.
     *
     * @param entity            The <code>Entity</code> to eject.
     * @param autoEject         The <code>boolean</code> state of the entity's auto- ejection
     *                          system
     * @param skin_of_the_teeth Perform a skin of the teeth ejection
     * @return a <code>Vector</code> of report objects for the gamelog.
     */
    public Vector<Report> ejectEntity(Entity entity, boolean autoEject,
                                      boolean skin_of_the_teeth) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // An entity can only eject it's crew once.
        if (entity.getCrew().isEjected()) {
            return vDesc;
        }

        // If the crew are already dead, don't bother
        if (entity.isCarcass()) {
            return vDesc;
        }

        // Mek pilots may get hurt during ejection,
        // and run around the board afterwards.
        if (entity instanceof Mech) {
            PilotingRollData rollTarget = getEjectModifiers(game, entity,
                    autoEject);
            int facing = entity.getFacing();
            Coords targetCoords = entity.getPosition().translated(
                    (facing + 3) % 6);

            if (autoEject) {
                r = new Report(6395);
                r.subject = entity.getId();
                r.addDesc(entity);
                r.indent(2);
                vDesc.addElement(r);
            }
            // okay, print the info
            r = new Report(2180);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(rollTarget.getLastPlainDesc(), true);
            r.indent();
            vDesc.addElement(r);
            // roll
            final int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            r.indent();
            // create the MechWarrior in any case, for campaign tracking
            MechWarrior pilot = new MechWarrior(entity);
            pilot.setDeployed(true);
            pilot.setId(getFreeEntityId());
            pilot.setLanded(false);
            game.addEntity(pilot);
            send(createAddEntityPacket(pilot.getId()));
            // make him not get a move this turn
            pilot.setDone(true);
            if (diceRoll < rollTarget.getValue()) {
                r.choose(false);
                vDesc.addElement(r);
                Report.addNewline(vDesc);
                if ((rollTarget.getValue() - diceRoll) > 1) {
                    int damage = (rollTarget.getValue() - diceRoll) / 2;
                    if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_DIFFICULT_EJECT)) {
                        damage++;
                    }
                    vDesc.addAll(damageCrew(pilot, damage));
                }

                // If this is a skin of the teeth ejection...
                if (skin_of_the_teeth && (pilot.getCrew().getHits() < 6)) {
                    Report.addNewline(vDesc);
                    pilot.setDoomed(true); // Set them to doomed so they die
                    // later by 'deadly ejection'
                    vDesc.addAll(damageCrew(pilot, 6 - pilot.getCrew()
                                                            .getHits()));
                }
            } else {
                r.choose(true);
                vDesc.addElement(r);
            }
            if (entity.getCrew().isDoomed()) {
                vDesc.addAll(destroyEntity(pilot, "deadly ejection", false,
                                           false));
            } else {
                // Add the pilot as an infantry unit on the battlefield.
                if (game.getBoard().contains(targetCoords)) {
                    pilot.setPosition(targetCoords);
                    /*
                     * Can pilots eject into water??? ASSUMPTION : They can
                     * (because they get a -1 mod to the PSR. // Did the pilot
                     * land in water? if ( game.getBoard().getHex(
                     * targetCoords).levelOf ( Terrain.WATER ) > 0 ) { //report
                     * missing desc.append("and the pilot ejects, but lands in
                     * water!!!\n"); //report missing desc.append(destroyEntity(
                     * pilot, "a watery grave", false )); } else { //report
                     * missing desc.append("and the pilot ejects safely!\n"); }
                     */
                    // report safe ejection
                    r = new Report(6400);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    // infantry have auto XTC gear so do pilots
                    /*
                     * if (game.getPlanetaryConditions().isVacuum()) { // ended
                     * up in a vacuum r = new Report(6405); r.subject =
                     * entity.getId(); r.indent(3); vDesc.addElement(r);
                     * vDesc.addAll(destroyEntity(pilot,
                     * "explosive decompression", false, false)); }
                     */
                    // Update the entity
                    entityUpdate(pilot.getId());
                    // check if the pilot lands in a minefield
                    vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot,
                            entity.getPosition(), targetCoords,
                            entity.getElevation()));
                } else {
                    // ejects safely
                    r = new Report(6410);
                    r.subject = entity.getId();
                    r.indent(3);
                    vDesc.addElement(r);
                    /*
                     * if (game.getPlanetaryConditions().isVacuum()) { // landed
                     * in vacuum r = new Report(6405); r.subject =
                     * entity.getId(); r.indent(3); vDesc.addElement(r);
                     * vDesc.addAll(destroyEntity(pilot,
                     * "explosive decompression", false, false)); } else {
                     */
                    game.removeEntity(pilot.getId(),
                                      IEntityRemovalConditions.REMOVE_IN_RETREAT);
                    send(createRemoveEntityPacket(pilot.getId(),
                                                  IEntityRemovalConditions.REMOVE_IN_RETREAT));
                    // }
                }
                if (game.getOptions().booleanOption("ejected_pilots_flee")) {
                    game.removeEntity(pilot.getId(),
                                      IEntityRemovalConditions.REMOVE_IN_RETREAT);
                    send(createRemoveEntityPacket(pilot.getId(),
                                                  IEntityRemovalConditions.REMOVE_IN_RETREAT));
                }

                // If this is a skin of the teeth ejection...
                if (skin_of_the_teeth && (pilot.getCrew().getHits() < 5)) {
                    Report.addNewline(vDesc);
                    vDesc.addAll(damageCrew(pilot, 5 - pilot.getCrew()
                                                            .getHits()));
                }
            } // Crew safely ejects.

        } // End entity-is-Mek
        else if (game.getBoard().contains(entity.getPosition())
                 && !game.getOptions().booleanOption("ejected_pilots_flee")
                 && (entity instanceof Tank)) {
            EjectedCrew crew = new EjectedCrew(entity);
            // Need to set game manually; since game.addEntity not called yet
            // Don't want to do this yet, as Entity may not be added
            crew.setGame(game);
            crew.setDeployed(true);
            crew.setId(getFreeEntityId());
            // Make them not get a move this turn
            crew.setDone(true);
            // Place on board
            // Vehicles don't have ejection systems, so crew must abandon into
            // a legal hex
            Coords legalPosition = null;
            if (!crew.isLocationProhibited(entity.getPosition())) {
                legalPosition = entity.getPosition();
            } else {
                for (int dir = 0; (dir < 6) && (legalPosition == null); dir++) {
                    Coords adjCoords = entity.getPosition().translated(dir);
                    if (!crew.isLocationProhibited(adjCoords)) {
                        legalPosition = adjCoords;
                    }
                }
            }
            // Cannot abandon if there is no legal hex.  This shoudln't have
            // been allowed
            if (legalPosition == null) {
                System.err.println("Error in Server.ejectEntity: vehicle " +
                        "crews cannot abandon if there is no legal hex!");
                return vDesc;
            }
            crew.setPosition(legalPosition);
            // Add Entity to game
            game.addEntity(crew);
            // Tell clients about new entity
            send(createAddEntityPacket(crew.getId()));
            // Sent entity info to clients
            entityUpdate(crew.getId());
            // Check if the crew lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew,
                    entity.getPosition(), entity.getPosition(),
                    entity.getElevation()));
        }

        // Mark the entity's crew as "ejected".
        entity.getCrew().setEjected(true);
        if (entity instanceof VTOL) {
            vDesc.addAll(crashVTOLorWiGE((VTOL) entity));
        }
        vDesc.addAll(destroyEntity(entity, "ejection", true, true));

        // only remove the unit that ejected manually
        if (!autoEject) {
            game.removeEntity(entity.getId(),
                    IEntityRemovalConditions.REMOVE_EJECTED);
            send(createRemoveEntityPacket(entity.getId(),
                    IEntityRemovalConditions.REMOVE_EJECTED));
        }
        return vDesc;
    }

    public static PilotingRollData getEjectModifiers(IGame game,
            Entity entity, boolean autoEject) {
        int facing = entity.getFacing();
        Coords targetCoords = entity.getPosition().translated((facing + 3) % 6);
        return getEjectModifiers(game, entity, autoEject, targetCoords,
                "ejecting");
    }

    public static PilotingRollData getEjectModifiers(IGame game, Entity entity,
            boolean autoEject, Coords targetCoords, String desc) {
        PilotingRollData rollTarget = new PilotingRollData(entity.getId(),
                entity.getCrew().getPiloting(), desc);
        if (entity.isProne()) {
            rollTarget.addModifier(5, "Mech is prone");
        }
        if (entity.getCrew().isUnconscious()) {
            rollTarget.addModifier(3, "pilot unconscious");
        }
        if (autoEject) {
            rollTarget.addModifier(1, "automatic ejection");
        }
        if ((entity instanceof Mech)
                && (entity.getInternal(Mech.LOC_HEAD) < entity
                        .getOInternal(Mech.LOC_HEAD))) {
            rollTarget.addModifier(
                    entity.getOInternal(Mech.LOC_HEAD)
                            - entity.getInternal(Mech.LOC_HEAD),
                    "Head Internal Structure Damage");
        }
        IHex targetHex = game.getBoard().getHex(targetCoords);
        if (targetHex != null) {
            if ((targetHex.terrainLevel(Terrains.WATER) > 0)
                    && !targetHex.containsTerrain(Terrains.ICE)) {
                rollTarget.addModifier(-1, "landing in water");
            } else if (targetHex.containsTerrain(Terrains.ROUGH)) {
                rollTarget.addModifier(0, "landing in rough");
            } else if (targetHex.containsTerrain(Terrains.RUBBLE)) {
                rollTarget.addModifier(0, "landing in rubble");
            } else if (targetHex.terrainLevel(Terrains.WOODS) == 1) {
                rollTarget.addModifier(2, "landing in light woods");
            } else if (targetHex.terrainLevel(Terrains.WOODS) == 2) {
                rollTarget.addModifier(3, "landing in heavy woods");
            } else if (targetHex.terrainLevel(Terrains.WOODS) == 3) {
                rollTarget.addModifier(4, "landing in ultra heavy woods");
            } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 1) {
                rollTarget.addModifier(3, "landing in light jungle");
            } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 2) {
                rollTarget.addModifier(5, "landing in heavy jungle");
            } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 3) {
                rollTarget.addModifier(7, "landing in ultra heavy jungle");
            } else if (targetHex.terrainLevel(Terrains.BLDG_ELEV) > 0) {
                rollTarget.addModifier(
                        targetHex.terrainLevel(Terrains.BLDG_ELEV),
                        "landing in a building");
            } else {
                rollTarget.addModifier(-2, "landing in clear terrain");
            }
        } else {
            rollTarget.addModifier(-2, "landing off the board");
        }

        if (game.getPlanetaryConditions().getGravity() == 0) {
            rollTarget.addModifier(3, "Zero-G");
        } else if (game.getPlanetaryConditions().getGravity() < .8) {
            rollTarget.addModifier(2, "Low-G");
        } else if (game.getPlanetaryConditions().getGravity() > 1.2) {
            rollTarget.addModifier(2, "High-G");
        }

        if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VACUUM) {
            rollTarget.addModifier(3, "Vacuum");
        } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VHIGH) {
            rollTarget.addModifier(2, "Very High Atmosphere Pressure");
        } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE) {
            rollTarget.addModifier(2, "Trace atmosphere");
        }

        if ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW)
                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_ICE_STORM)
                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_DOWNPOUR)
                || (game.getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE)) {
            rollTarget.addModifier(2, "Bad Weather");
        }

        if ((game.getPlanetaryConditions().getWindStrength() >= PlanetaryConditions.WI_STORM)
                || ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW) && (game
                        .getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE))) {
            rollTarget.addModifier(3, "Really Bad Weather");
        }
        return rollTarget;
    }

    /**
     * Abandon an Entity.
     *
     * @param entity The <code>Entity</code> to abandon.
     * @return a <code>Vector</code> of report objects for the gamelog.
     */
    public Vector<Report> abandonEntity(Entity entity) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;

        // An entity can only eject it's crew once.
        if (entity.getCrew().isEjected()) {
            return vDesc;
        }

        if (entity.getCrew().isDoomed() || entity.getCrew().isDead()) {
            return vDesc;
        }

        // Don't make them abandon into vacuum
        if (game.getPlanetaryConditions().isVacuum()) {
            return vDesc;
        }

        Coords targetCoords = entity.getPosition();

        if (entity instanceof Mech) {
            // okay, print the info
            r = new Report(2027);
            r.subject = entity.getId();
            r.add(entity.getCrew().getName());
            r.addDesc(entity);
            r.indent(3);
            vDesc.addElement(r);

            // create the MechWarrior in any case, for campaign tracking
            MechWarrior pilot = new MechWarrior(entity);
            pilot.getCrew().setUnconscious(entity.getCrew().isUnconscious());
            pilot.setDeployed(true);
            pilot.setId(getFreeEntityId());
            game.addEntity(pilot);
            send(createAddEntityPacket(pilot.getId()));
            // make him not get a move this turn
            pilot.setDone(true);
            // Add the pilot as an infantry unit on the battlefield.
            if (game.getBoard().contains(targetCoords)) {
                pilot.setPosition(targetCoords);
            }
            pilot.setCommander(entity.isCommander());
            // Update the entity
            entityUpdate(pilot.getId());
            // check if the pilot lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot,
                                                            entity.getPosition(), targetCoords, entity.getElevation()));
            if (game.getOptions().booleanOption("ejected_pilots_flee")) {
                game.removeEntity(pilot.getId(),
                                  IEntityRemovalConditions.REMOVE_IN_RETREAT);
                send(createRemoveEntityPacket(pilot.getId(),
                                              IEntityRemovalConditions.REMOVE_IN_RETREAT));
            }
        } // End entity-is-Mek
        else if (game.getBoard().contains(entity.getPosition())
                 && !game.getOptions().booleanOption("ejected_pilots_flee")
                 && game.getOptions().booleanOption("vehicles_can_eject")
                 && (entity instanceof Tank)) {
            EjectedCrew crew = new EjectedCrew(entity);
            crew.setDeployed(true);
            crew.setId(getFreeEntityId());
            game.addEntity(crew);
            send(createAddEntityPacket(crew.getId()));
            // Make them not get a move this turn
            crew.setDone(true);
            // Place on board

            crew.setPosition(entity.getPosition());
            // Update the entity
            entityUpdate(crew.getId());
            // Check if the crew lands in a minefield
            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew,
                                                            entity.getPosition(), entity.getPosition(),
                                                            entity.getElevation()));
        }

        // Mark the entity's crew as "ejected".
        entity.getCrew().setEjected(true);

        return vDesc;
    }

    /**
     * Checks if ejected Mechwarriors are eligible to be picked up, and if so,
     * captures them or picks them up
     */
    private void resolveMechWarriorPickUp() {
        Report r;

        // fetch all mechWarriors that are not picked up
        Iterator<Entity> mechWarriors = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if (entity instanceof MechWarrior) {
                            MechWarrior mw = (MechWarrior) entity;
                            if ((mw.getPickedUpById() == Entity.NONE)
                                && !mw.isDoomed()
                                && (mw.getTransportId() == Entity.NONE)) {
                                return true;
                            }
                        }
                        return false;
                    }
                });
        // loop through them, check if they are in a hex occupied by another
        // unit
        while (mechWarriors.hasNext()) {
            boolean pickedUp = false;
            MechWarrior e = (MechWarrior) mechWarriors.next();
            // Check for owner entities first...
            for (Entity pe : game.getEntitiesVector(e.getPosition())) {
                if (pe.isDoomed() || pe.isShutDown()
                    || pe.getCrew().isUnconscious() || pe.isAirborne()
                    || (pe.getElevation() != e.getElevation())
                    || (pe.getOwnerId() != e.getOwnerId())
                    || (pe.getId() == e.getId())) {
                    continue;
                }
                if (!pickedUp) {
                    if (pe instanceof MechWarrior) {
                        // MWs have a beer together
                        r = new Report(6415, Report.PUBLIC);
                        r.add(pe.getDisplayName());
                        addReport(r);
                        continue;
                    }
                    // Pick up the unit.
                    pe.pickUp(e);
                    // The picked unit is being carried by the loader.
                    e.setPickedUpById(pe.getId());
                    e.setPickedUpByExternalId(pe.getExternalIdAsString());
                    pickedUp = true;
                    r = new Report(6420, Report.PUBLIC);
                    r.add(e.getDisplayName());
                    r.addDesc(pe);
                    addReport(r);
                    break;
                }
            }
            // Check for allied entities next...
            if (!pickedUp) {
                for (Entity pe : game.getEntitiesVector(e.getPosition())) {
                    if (pe.isDoomed()
                        || pe.isShutDown()
                        || pe.getCrew().isUnconscious()
                        || pe.isAirborne()
                        || (pe.getElevation() != e.getElevation())
                        || (pe.getOwnerId() == e.getOwnerId())
                        || (pe.getId() == e.getId())
                        || (pe.getOwner().getTeam() == IPlayer.TEAM_NONE)
                        || (pe.getOwner().getTeam() != e.getOwner()
                                                        .getTeam())) {
                        continue;
                    }
                    if (!pickedUp) {
                        if (pe instanceof MechWarrior) {
                            // MWs have a beer together
                            r = new Report(6415, Report.PUBLIC);
                            r.add(pe.getDisplayName());
                            addReport(r);
                            continue;
                        }
                        // Pick up the unit.
                        pe.pickUp(e);
                        // The picked unit is being carried by the loader.
                        e.setPickedUpById(pe.getId());
                        e.setPickedUpByExternalId(pe.getExternalIdAsString());
                        pickedUp = true;
                        r = new Report(6420, Report.PUBLIC);
                        r.add(e.getDisplayName());
                        r.addDesc(pe);
                        addReport(r);
                        break;
                    }
                }
            }
            // Now check for anyone else...
            if (!pickedUp) {
                Iterator<Entity> pickupEnemyEntities = game
                        .getEnemyEntities(e.getPosition(), e);
                while (pickupEnemyEntities.hasNext()) {
                    Entity pe = pickupEnemyEntities.next();
                    if (pe.isDoomed() || pe.isShutDown()
                        || pe.getCrew().isUnconscious() || pe.isAirborne()
                        || (pe.getElevation() != e.getElevation())) {
                        continue;
                    }
                    if (pe instanceof MechWarrior) {
                        // MWs have a beer together
                        r = new Report(6415, Report.PUBLIC);
                        r.add(pe.getDisplayName());
                        addReport(r);
                        continue;
                    }
                    // Capture the unit.
                    pe.pickUp(e);
                    // The captured unit is being carried by the loader.
                    e.setCaptured(true);
                    e.setPickedUpById(pe.getId());
                    e.setPickedUpByExternalId(pe.getExternalIdAsString());
                    pickedUp = true;
                    r = new Report(6420, Report.PUBLIC);
                    r.add(e.getDisplayName());
                    r.addDesc(pe);
                    addReport(r);
                    break;
                }
            }
            if (pickedUp) {
                // Remove the picked-up unit from the screen.
                e.setPosition(null);
                // Update the loaded unit.
                entityUpdate(e.getId());
            }
        }
    }

    /**
     * destroy all wheeled and tracked Tanks that got displaced into water
     */
    private void resolveSinkVees() {
        Iterator<Entity> sinkableTanks = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if (entity.isOffBoard()
                                || (entity.getPosition() == null)
                                || !(entity instanceof Tank)) {
                            return false;
                        }
                        final IHex hex = game.getBoard().getHex(
                                entity.getPosition());
                        final boolean onBridge = (hex
                                .terrainLevel(Terrains.BRIDGE) > 0)
                                && (entity.getElevation() == hex
                                        .terrainLevel(Terrains.BRIDGE_ELEV));
                        if (((entity.getMovementMode()
                                    == EntityMovementMode.TRACKED)
                                || (entity.getMovementMode()
                                        == EntityMovementMode.WHEELED)
                                || ((entity.getMovementMode()
                                        == EntityMovementMode.HOVER)))
                                    && entity.isImmobile()
                                    && (hex.terrainLevel(Terrains.WATER) > 0)
                                    && !onBridge
                                    && !(entity.hasWorkingMisc(
                                            MiscType.F_FULLY_AMPHIBIOUS))
                                    && !(entity.hasWorkingMisc(
                                            MiscType.F_FLOTATION_HULL))) {
                            return true;
                        }
                        return false;
                    }
                });
        while (sinkableTanks.hasNext()) {
            Entity e = sinkableTanks.next();
            addReport(destroyEntity(e, "a watery grave", false));
        }
    }

    /**
     * let all Entities make their "break-free-of-swamp-stickyness" PSR
     */
    private void doTryUnstuck() {
        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {
            return;
        }

        Report r;

        Iterator<Entity> stuckEntities = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if (entity.isStuck()) {
                            return true;
                        }
                        return false;
                    }
                });
        PilotingRollData rollTarget;
        while (stuckEntities.hasNext()) {
            Entity entity = stuckEntities.next();
            if (entity.getPosition() == null) {
                if (entity.isDeployed()) {
                    System.out.println("Entity #" + entity.getId()
                            + " does not know its position.");
                } else { // If the Entity isn't deployed, then something goofy
                    // happened.  We'll just unstuck the Entity
                    entity.setStuck(false);
                    System.out.println("Entity #" + entity.getId()
                            + " was stuck in a swamp, but not deployed.  "
                            + "Stuck state reset");
                }
                continue;
            }
            rollTarget = entity.getBasePilotingRoll();
            entity.addPilotingModifierForTerrain(rollTarget);
            // apart from swamp & liquid magma, -1 modifier
            IHex hex = game.getBoard().getHex(entity.getPosition());
            rollTarget.addModifier(
                    hex.getUnstuckModifier(entity.getElevation()), "terrain");
            // okay, print the info
            r = new Report(2340);
            r.addDesc(entity);
            addReport(r);

            // roll
            final int diceRoll = entity.getCrew().rollPilotingSkill();
            r = new Report(2190);
            r.subject = entity.getId();
            r.add(rollTarget.getValueAsString());
            r.add(rollTarget.getDesc());
            r.add(diceRoll);
            if (diceRoll < rollTarget.getValue()) {
                r.choose(false);
            } else {
                r.choose(true);
                entity.setStuck(false);
                entity.setCanUnstickByJumping(false);
                entity.setElevation(0);
                entityUpdate(entity.getId());
            }
            addReport(r);
        }
    }

    /**
     * Remove all iNarc pods from all vehicles that did not move and shoot this
     * round NOTE: this is not quite what the rules say, the player should be
     * able to choose whether or not to remove all iNarc Pods that are attached.
     */
    private void resolveVeeINarcPodRemoval() {
        Iterator<Entity> vees = game
                .getSelectedEntities(new EntitySelector() {
                    public boolean accept(Entity entity) {
                        if ((entity instanceof Tank) && (entity.mpUsed == 0)) {
                            return true;
                        }
                        return false;
                    }
                });
        boolean canSwipePods;
        while (vees.hasNext()) {
            canSwipePods = true;
            Entity entity = vees.next();
            for (int i = 0; i <= 5; i++) {
                if (entity.weaponFiredFrom(i)) {
                    canSwipePods = false;
                }
            }
            if (((Tank) entity).getStunnedTurns() > 0) {
                canSwipePods = false;
            }
            if (canSwipePods && entity.hasINarcPodsAttached()
                && entity.getCrew().isActive()) {
                entity.removeAllINarcPods();
                Report r = new Report(2345);
                r.addDesc(entity);
                addReport(r);
            }
        }
    }

    /*
     * //See note above where knownDeadEntities variable is declared private
     * void deadEntitiesCleanup() { Entity en = null; for(Enumeration k =
     * game.getGraveyardEntities(); k.hasMoreElements(); en = (Entity)
     * k.nextElement()) { if (en != null) { if (!knownDeadEntities.contains(en))
     * { knownDeadEntities.add(en); } } } }
     */

    /**
     * remove Ice in the hex that's at the passed coords, and let entities fall
     * into water below it, if there is water
     *
     * @param c the <code>Coords</code> of the hex where ice should be removed
     * @return a <code>Vector<Report></code> for the phase report
     */
    private Vector<Report> resolveIceBroken(Coords c) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        IHex hex = game.getBoard().getHex(c);
        hex.removeTerrain(Terrains.ICE);
        sendChangedHex(c);
        // if there is water below the ice
        if (hex.terrainLevel(Terrains.WATER) > 0) {
            // drop entities on the surface into the water
            for (Entity e : game.getEntitiesVector(c)) {
                // If the unit is on the surface, and is no longer allowed in
                // the hex
                boolean isHoverOrWiGE = (e.getMovementMode() == EntityMovementMode.HOVER)
                        || (e.getMovementMode() == EntityMovementMode.WIGE);
                if ((e.getElevation() == 0)
                        && !(hex.containsTerrain(Terrains.BLDG_ELEV, 0))
                        && !(isHoverOrWiGE && (e.getRunMP() >= 0))
                        && (e.getMovementMode() != EntityMovementMode.INF_UMU)
                        && !e.hasUMU()) {
                    vPhaseReport.addAll(doEntityFallsInto(e, c,
                            new PilotingRollData(TargetRoll.AUTOMATIC_FAIL),
                            true));
                }
            }
        }
        return vPhaseReport;
    }

    /**
     * melt any snow or ice in a hex, including checking for the effects of
     * breaking through ice
     */
    private Vector<Report> meltIceAndSnow(Coords c, int entityId) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        IHex hex = game.getBoard().getHex(c);
        r = new Report(3069);
        r.indent(2);
        r.subject = entityId;
        vDesc.add(r);
        if (hex.containsTerrain(Terrains.SNOW)) {
            hex.removeTerrain(Terrains.SNOW);
            sendChangedHex(c);
        }
        if (hex.containsTerrain(Terrains.ICE)) {
            vDesc.addAll(resolveIceBroken(c));
        }
        // if we were not in water, then add mud
        if (!hex.containsTerrain(Terrains.MUD)
            && !hex.containsTerrain(Terrains.WATER)) {
            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                    Terrains.MUD, 1));
            sendChangedHex(c);
        }
        return vDesc;
    }

    /**
     * check to see if a swamp hex becomes quicksand
     */
    private Vector<Report> checkQuickSand(Coords c) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        IHex hex = game.getBoard().getHex(c);
        if (hex.terrainLevel(Terrains.SWAMP) == 1) {
            if (Compute.d6(2) == 12) {
                // better find a rope
                hex.removeTerrain(Terrains.SWAMP);
                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                        Terrains.SWAMP, 2));
                sendChangedHex(c);
                r = new Report(2440);
                r.indent(1);
                vDesc.add(r);
            }
        }
        return vDesc;
    }

    /**
     * check for vehicle fire, according to the MaxTech rules
     *
     * @param tank    the <code>Tank</code> to be checked
     * @param inferno a <code>boolean</code> parameter wether or not this check is
     *                because of inferno fire
     */
    public Vector<Report> checkForVehicleFire(Tank tank, boolean inferno) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        int boomroll = Compute.d6(2);
        int penalty = 0;
        switch (tank.getMovementMode()) {
            case HOVER:
                penalty = 4;
                break;
            case VTOL:
            case WHEELED:
                penalty = 2;
                break;
            default:
                break;
        }
        if (inferno) {
            boomroll = 12;
        }
        Report r = new Report(5250);
        r.subject = tank.getId();
        r.addDesc(tank);
        r.add(8 - penalty);
        r.add(boomroll);
        if ((boomroll + penalty) < 8) {
            // phew!
            r.choose(true);
            vPhaseReport.add(r);
        } else {
            // eek
            if (!inferno) {
                r.choose(false);
                vPhaseReport.add(r);
            }
            if ((boomroll + penalty) < 10) {
                addReport(vehicleMotiveDamage(tank, penalty - 1));
            } else {
                vPhaseReport.addAll(resolveVehicleFire(tank, false));
                if ((boomroll + penalty) >= 12) {
                    r = new Report(5255);
                    r.subject = tank.getId();
                    r.indent(3);
                    vPhaseReport.add(r);
                    tank.setOnFire(inferno);
                }
            }
        }
        return vPhaseReport;
    }

    private Vector<Report> resolveVehicleFire(Tank tank, boolean existingStatus) {
        Vector<Report> vPhaseReport = new Vector<Report>();
        if (existingStatus && !tank.isOnFire()) {
            return vPhaseReport;
        }
        for (int i = 0; i < tank.locations(); i++) {
            if ((i == Tank.LOC_BODY)
                || ((tank instanceof VTOL) && (i == VTOL.LOC_ROTOR))) {
                continue;
            }
            if (existingStatus && !tank.isLocationBurning(i)) {
                continue;
            }
            HitData hit = new HitData(i);
            int damage = Compute.d6(1);
            vPhaseReport.addAll(damageEntity(tank, hit, damage));
            if ((damage == 1) && existingStatus) {
                tank.extinguishLocation(i);
            }
        }
        return vPhaseReport;
    }

    private Vector<Report> vehicleMotiveDamage(Tank te, int modifier) {
        return vehicleMotiveDamage(te, modifier, false, -1, false);
    }

    private Vector<Report> vehicleMotiveDamage(Tank te, int modifier,
                                               boolean noroll, int damagetype) {
        return vehicleMotiveDamage(te, modifier, noroll, damagetype, false);
    }

    /**
     * do vehicle movement damage
     *
     * @param te         the Tank to damage
     * @param modifier   the modifier to the roll
     * @param noroll     don't roll, immediately deal damage
     * @param damagetype the type to deal (1 = minor, 2 = moderate, 3 = heavy
     * @param jumpDamage is this a movement daamge roll from using vehicular JJs
     * @return
     */
    private Vector<Report> vehicleMotiveDamage(Tank te, int modifier,
                                               boolean noroll, int damagetype, boolean jumpDamage) {
        Vector<Report> vDesc = new Vector<Report>();
        Report r;
        switch (te.getMovementMode()) {
            case HOVER:
            case HYDROFOIL:
                if (jumpDamage) {
                    modifier -= 1;
                } else {
                    modifier += 3;
                }
                break;
            case WHEELED:
                if (jumpDamage) {
                    modifier += 1;
                } else {
                    modifier += 2;
                }
                break;
            case WIGE:
                if (jumpDamage) {
                    modifier -= 2;
                } else {
                    modifier += 4;
                }
                break;
            case TRACKED:
                if (jumpDamage) {
                    modifier += 2;
                }
                break;
            case VTOL:
                // VTOL don't roll, auto -1 MP as long as the rotor location
                // still exists (otherwise don't bother reporting).
                if (!(te.isLocationBad(VTOL.LOC_ROTOR) || te
                        .isLocationDoomed(VTOL.LOC_ROTOR))) {
                    te.setMotiveDamage(te.getMotiveDamage() + 1);
                    if (te.getOriginalWalkMP() > te.getMotiveDamage()) {
                        r = new Report(6660);
                        r.indent(3);
                        r.subject = te.getId();
                        vDesc.add(r);
                    } else {
                        r = new Report(6670);
                        r.subject = te.getId();
                        vDesc.add(r);
                        te.immobilize();
                        // Being reduced to 0 MP by rotor damage forces a
                        // landing
                        // like an engine hit...
                        if (te.isAirborneVTOLorWIGE()
                            // ...but don't bother to resolve that if we're
                            // already otherwise destroyed.
                            && !(te.isDestroyed() || te.isDoomed())) {
                            vDesc.addAll(forceLandVTOLorWiGE(te));
                        }
                    }
                }
                // This completes our handling of VTOLs; the rest of the method
                // doesn't need to worry about them anymore.
                return vDesc;
            default:
                break;
        }
        // Apply vehicle effectiveness...except for jumps.
        if (game.getOptions().booleanOption("tacops_vehicle_effective")
            && !jumpDamage) {
            modifier = Math.max(modifier - 1, 0);
        }

        if (te.hasWorkingMisc(MiscType.F_ARMORED_MOTIVE_SYSTEM)) {
            modifier -= 2;
        }
        int roll = Compute.d6(2) + modifier;
        r = new Report(6306);
        r.subject = te.getId();
        r.newlines = 0;
        r.indent(3);
        vDesc.add(r);
        if (!noroll) {
            r = new Report(6310);
            r.subject = te.getId();
            r.add(roll);
            r.newlines = 0;
            vDesc.add(r);
            r = new Report(3340);
            r.add(modifier);
            r.subject = te.getId();
            vDesc.add(r);
        }

        if ((noroll && (damagetype == 0)) || (!noroll && (roll <= 5))) {
            // no effect
            r = new Report(6005);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
        } else if ((noroll && (damagetype == 1)) || (!noroll && (roll <= 7))) {
            // minor damage
            r = new Report(6470);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(1);
        } else if ((noroll && (damagetype == 2)) || (!noroll && (roll <= 9))) {
            // moderate damage
            r = new Report(6471);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(2);
        } else if ((noroll && (damagetype == 3)) || (!noroll && (roll <= 11))) {
            // heavy damage
            r = new Report(6472);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(3);
        } else {
            r = new Report(6473);
            r.subject = te.getId();
            r.indent(3);
            vDesc.add(r);
            te.addMovementDamage(4);
        }
        // These checks should perhaps be moved to Tank.applyDamage(), but I'm
        // unsure how to *report* any outcomes from there. Note that these treat
        // being reduced to 0 MP and being actually immobilized as the same
        // thing,
        // which for these particular purposes may or may not be the intent of
        // the rules in all cases.
        // Immobile hovercraft on water sink...
        if (((te.getMovementMode() == EntityMovementMode.HOVER) || ((te
                                                                             .getMovementMode() == EntityMovementMode
                                                                             .WIGE) && (te
                                                                                                .getElevation() == 0)))
            && (te.isMovementHitPending() || (te.getWalkMP() <= 0)) // HACK:
            // Have
            // to
            // check
            // for
            // *pending*
            // hit
            // here
            // and
            // below.
            && (game.getBoard().getHex(te.getPosition())
                    .terrainLevel(Terrains.WATER) > 0)
            && !game.getBoard().getHex(te.getPosition())
                    .containsTerrain(Terrains.ICE)) {
            vDesc.addAll(destroyEntity(te, "a watery grave", false));
        }
        // ...while immobile WiGEs crash.
        if (((te.getMovementMode() == EntityMovementMode.WIGE) && (te
                .isAirborneVTOLorWIGE()))
            && (te.isMovementHitPending() || (te.getWalkMP() <= 0))) {
            // report problem: add tab
            vDesc.addAll(crashVTOLorWiGE(te));
        }
        return vDesc;
    }

    /**
     * Add a whole lotta Reports to the players report queues as well as the
     * Master report queue vPhaseReport.
     */
    private void addReport(Vector<Report> reports) {
        vPhaseReport.addAll(reports);
    }

    /**
     * Add a whole lotta Reports to the players report queues as well as the
     * Master report queue vPhaseReport, indenting each report by the passed
     * value.
     */
    private void addReport(Vector<Report> reports, int indents) {
        for (Report r : reports) {
            r.indent(indents);
            vPhaseReport.add(r);
        }
    }

    /**
     * Add a single report to the report queue of all players and the master
     * vPhaseReport queue
     */
    private void addReport(Report report) {
        vPhaseReport.addElement(report);
    }

    /**
     * New Round has started clear everyone's report queue
     */
    private void clearReports() {
        vPhaseReport.removeAllElements();
    }

    /**
     * make sure all the new lines that were added to the old vPhaseReport get
     * added to all of the players filters
     */
    private void addNewLines() {
        Report.addNewline(vPhaseReport);
    }

    /**
     * resolve the landing of an assault drop
     *
     * @param entity the <code>Entity</code> for which to resolve it
     */
    public void doAssaultDrop(Entity entity) {
        //resolve according to SO p.22

        Report r = new Report(2380);

        // whatever else happens, this entity is on the ground now
        entity.setAltitude(0);

        PilotingRollData psr;
        if ((entity instanceof Protomech) || (entity instanceof BattleArmor)) {
            psr = new PilotingRollData(entity.getId(), 5,
                                       "landing assault drop");

        } else if (entity instanceof Infantry) {
            psr = new PilotingRollData(entity.getId(), 4,
                                       "landing assault drop");
        } else {
            psr = entity.getBasePilotingRoll();
        }
        int roll = Compute.d6(2);
        // check for a safe landing
        addNewLines();
        r.subject = entity.getId();
        r.add(entity.getDisplayName(), true);
        r.add(psr.getValueAsString());
        r.add(roll);
        r.newlines = 1;
        r.choose(roll >= psr.getValue());
        addReport(r);

        if (game.getBoard().inAtmosphere()) {
            // then just remove the entity
            // TODO: for this and when the unit scatters off the board, we
            // should really still apply damage
            // before we remove, but this causes all kinds of problems for
            // doEntityFallsInto
            // and related methods which expect a coord on the board - need to
            // make those more robust
            r = new Report(2388);
            addReport(r);
            r.subject = entity.getId();
            r.add(entity.getDisplayName(), true);
            game.removeEntity(entity.getId(),
                              IEntityRemovalConditions.REMOVE_IN_RETREAT);
            return;
        }

        if (roll < psr.getValue()) {
            int fallHeight = psr.getValue() - roll;

            // if you fail by more than 7, you automatically fail
            if (fallHeight > 7) {
                addReport(destroyEntity(entity, "failed assault drop", false,
                                        false));
                entityUpdate(entity.getId());
                return;
            }

            // determine where we really land
            Coords c = Compute.scatterAssaultDrop(entity.getPosition(),
                                                  fallHeight);
            int distance = entity.getPosition().distance(c);
            r = new Report(2385);
            r.subject = entity.getId();
            r.add(distance);
            r.indent();
            r.newlines = 0;
            addReport(r);
            if (!game.getBoard().contains(c)) {
                r = new Report(2386);
                addReport(r);
                game.removeEntity(entity.getId(),
                                  IEntityRemovalConditions.REMOVE_IN_RETREAT);
                return;
            } else {
                r = new Report(2387);
                r.add(c.getBoardNum());
                addReport(r);
            }
            entity.setPosition(c);

            // do fall damage from accidental fall
            //set elevation to fall height above ground or building roof
            IHex hex = game.getBoard().getHex(entity.getPosition());
            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV) ? hex
                    .terrainLevel(Terrains.BLDG_ELEV) : 0;
            entity.setElevation(fallHeight + bldgElev);
            if ((entity instanceof Infantry)
                && !(entity instanceof BattleArmor)) {
                HitData hit = new HitData(Infantry.LOC_INFANTRY);
                addReport(damageEntity(entity, hit, 1));
            } else {
                addReport(doEntityFallsInto(entity, c, psr, true));
            }
        } else {
            // set entity to expected elevation
            IHex hex = game.getBoard().getHex(entity.getPosition());
            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV) ? hex
                    .terrainLevel(Terrains.BLDG_ELEV) : 0;
            entity.setElevation(bldgElev);

            Building bldg = game.getBoard().getBuildingAt(entity.getPosition());
            if (bldg != null) {
                // whoops we step on the roof
                checkBuildingCollapseWhileMoving(bldg, entity, entity.getPosition());
            }

            // finally, check for any stacking violations
            Entity violated = Compute.stackingViolation(game, entity,
                                                        entity.getPosition(), null);
            if (violated != null) {
                // StratOps explicitly says that this is not treated as an accident
                // fall from above
                // so we just need to displace the violating unit
                // check to see if the violatoing unit is a dropship and if so, then
                // displace
                // the unit dropping instead
                if (violated instanceof Dropship) {
                    violated = entity;
                }
                Coords targetDest = Compute.getValidDisplacement(game,
                                                                 violated.getId(), violated.getPosition(),
                                                                 Compute.d6() - 1);
                if (null != targetDest) {
                    doEntityDisplacement(violated, violated.getPosition(),
                                         targetDest, null);
                    entityUpdate(violated.getId());
                } else {
                    // ack! automatic death! Tanks
                    // suffer an ammo/power plant hit.
                    // TODO : a Mech suffers a Head Blown Off crit.
                    vPhaseReport.addAll(destroyEntity(entity,
                                                      "impossible displacement", entity instanceof Mech,
                                                      entity instanceof Mech));
                }
            }
        }
    }

    /**
     * resolve assault drops for all entities
     */
    void doAllAssaultDrops() {
        for (Entity e : game.getEntitiesVector()) {
            if (e.isAssaultDropInProgress()) {
                doAssaultDrop(e);
                e.setLandedAssaultDrop();
            }
        }
    }

    /**
     * do damage from magma
     *
     * @param en       the affected <code>Entity</code>
     * @param eruption <code>boolean</code> indicating wether or not this is because
     *                 of an eruption
     */
    void doMagmaDamage(Entity en, boolean eruption) {
        if ((((en.getMovementMode() == EntityMovementMode.VTOL) && (en
                                                                            .getElevation() > 0))
             || (en.getMovementMode() == EntityMovementMode.HOVER) || ((en
                                                                                .getMovementMode() ==
                                                                        EntityMovementMode.WIGE)
                                                                       && (en.getOriginalWalkMP() > 0) && !eruption))
            && !en.isImmobile()) {
            return;
        }
        Report r;
        boolean isMech = en instanceof Mech;
        if (isMech) {
            r = new Report(2405);
        } else {
            r = new Report(2400);
        }
        r.addDesc(en);
        r.subject = en.getId();
        addReport(r);
        if (isMech) {
            HitData h;
            for (int i = 0; i < en.locations(); i++) {
                if (eruption || en.locationIsLeg(i) || en.isProne()) {
                    h = new HitData(i);
                    addReport(damageEntity(en, h, Compute.d6(2)));
                }
            }
        } else {
            addReport(destroyEntity(en, "fell into magma", false, false));
        }
        addNewLines();
    }

    /**
     * sink any entities in quicksand in the current hex
     */
    public void doSinkEntity(Entity en) {
        Report r;
        r = new Report(2445);
        r.addDesc(en);
        r.subject = en.getId();
        addReport(r);
        en.setElevation(en.getElevation() - 1);
        // if this means the entity is below the ground, then bye-bye!
        if (Math.abs(en.getElevation()) > en.getHeight()) {
            addReport(destroyEntity(en, "quicksand"));
        }
    }

    /**
     * deal area saturation damage to an individual hex
     *
     * @param coords         The hex being hit
     * @param attackSource   The location the attack came from. For hit table resolution
     * @param damage         Amount of damage to deal to each entity
     * @param ammo           The ammo type being used
     * @param subjectId      Subject for reports
     * @param killer         Who should be credited with kills
     * @param exclude        Entity that should take no damage (used for homing splash)
     * @param flak           Flak, hits flying units only, instead of flyers being immune
     * @param altitude       Absolute altitude for flak attack
     * @param vPhaseReport   The Vector of Reports for the phasereport
     * @param asfFlak        Is this flak against ASF?
     * @param alreadyHit     a vector of unit ids for units that have already been hit that
     *                       will be ignored
     * @param variableDamage if true, treat damage as the number of six-sided dice to roll
     */
    public Vector<Integer> artilleryDamageHex(Coords coords,
            Coords attackSource, int damage, AmmoType ammo, int subjectId,
            Entity killer, Entity exclude, boolean flak, int altitude,
            Vector<Report> vPhaseReport, boolean asfFlak,
            Vector<Integer> alreadyHit, boolean variableDamage) {

        IHex hex = game.getBoard().getHex(coords);
        if (hex == null) {
            return alreadyHit; // not on board.
        }

        Report r;

        // Non-flak artillery damages terrain
        if (!flak) {
            // Report that damage applied to terrain, if there's TF to damage
            IHex h = game.getBoard().getHex(coords);
            if ((h != null) && h.hasTerrainfactor()) {
                r = new Report(3384);
                r.indent(2);
                r.subject = subjectId;
                r.add(coords.getBoardNum());
                r.add(damage * 2);
                vPhaseReport.addElement(r);
            }
            // Update hex and report any changes
            Vector<Report> newReports =
                    tryClearHex(coords, damage * 2, subjectId);
            for (Report nr : newReports) {
                nr.indent(3);
            }
            vPhaseReport.addAll(newReports);
        }
        Building bldg = game.getBoard().getBuildingAt(coords);
        int bldgAbsorbs = 0;
        if ((bldg != null)
            && !(flak && (((altitude > hex.terrainLevel(Terrains.BLDG_ELEV)) || (altitude > hex
                .terrainLevel(Terrains.BRIDGE_ELEV)))))) {
            bldgAbsorbs = bldg.getAbsorbtion(coords);
            if (!((ammo != null) && (ammo.getMunitionType() == AmmoType.M_FLECHETTE))) {
                // damage the building
                Vector<Report> buildingReport = damageBuilding(bldg, damage,
                                                               coords);
                for (Report report : buildingReport) {
                    report.subject = subjectId;
                }
                vPhaseReport.addAll(buildingReport);
            }
        }

        if (flak
            && ((altitude <= 0)
                || (altitude <= hex.terrainLevel(Terrains.BLDG_ELEV)) || (altitude == hex
                .terrainLevel(Terrains.BRIDGE_ELEV)))) {
            // Flak in this hex would only hit landed units
            return alreadyHit;
        }

        // get units in hex
        for (Entity entity : game.getEntitiesVector(coords)) {
            int hits = damage;
            if (variableDamage) {
                hits = Compute.d6(damage);
            }
            ToHitData toHit = new ToHitData();
            if (entity instanceof Protomech) {
                toHit.setHitTable(ToHitData.HIT_SPECIAL_PROTO);
            }
            int cluster = 5;

            // Check: is entity excluded?
            if ((entity == exclude) || alreadyHit.contains(entity.getId())) {
                continue;
            }

            // Check: is entity inside building?
            if ((bldg != null)
                && (bldgAbsorbs > 0)
                && (entity.getElevation() < hex
                    .terrainLevel(Terrains.BLDG_ELEV))) {
                cluster -= bldgAbsorbs;
                // some buildings scale remaining damage that is not absorbed
                // TODO: this isn't quite right for castles brian
                cluster = (int) Math.floor(bldg.getDamageToScale() * cluster);
                if (entity instanceof Infantry) {
                    continue; // took its damage already from building damage
                } else if (cluster <= 0) {
                    // entity takes no damage
                    r = new Report(6426);
                    r.subject = subjectId;
                    r.addDesc(entity);
                    vPhaseReport.add(r);
                    continue;
                } else {
                    r = new Report(6425);
                    r.subject = subjectId;
                    r.add(bldgAbsorbs);
                    vPhaseReport.add(r);
                }
            }

            // flak against ASF should only hit Aeros, because their elevation
            // is actualyl altitude, so shouldn't hit VTOLs
            if (asfFlak && !(entity instanceof Aero)) {
                continue;
            }

            if (flak) {
                // Check: is entity not a VTOL in flight or an ASF
                if (!((entity instanceof VTOL)
                        || (entity.getMovementMode() == EntityMovementMode.VTOL)
                        || (entity instanceof Aero))) {
                    continue;
                }
                // Check: is entity at correct elevation?
                if (entity.getElevation() != altitude) {
                    continue;
                }
            } else {
                // Check: is entity a VTOL or Aero in flight?
                if ((entity instanceof VTOL)
                    || (entity.getMovementMode() == EntityMovementMode.VTOL)
                    || (entity instanceof Aero)) {
                    // VTOLs take no damage from normal artillery unless landed
                    if ((entity.getElevation() != 0)
                        && (entity.getElevation() != hex
                            .terrainLevel(Terrains.BLDG_ELEV))
                        && (entity.getElevation() != hex
                            .terrainLevel(Terrains.BRIDGE_ELEV))) {
                        continue;
                    }
                }
            }

            // Work out hit table to use
            if (attackSource != null) {
                toHit.setSideTable(entity.sideTable(attackSource));
                if ((ammo != null)
                    && (ammo.getMunitionType() == AmmoType.M_CLUSTER)
                    && attackSource.equals(coords)) {
                    if (entity instanceof Mech) {
                        toHit.setHitTable(ToHitData.HIT_ABOVE);
                    } else if (entity instanceof Tank) {
                        toHit.setSideTable(ToHitData.SIDE_FRONT);
                        toHit.addModifier(2, "cluster artillery hitting a Tank");
                    }
                }
            }

            // convention infantry take x2 damage from AE weapons
            if ((entity instanceof Infantry)
                && !(entity instanceof BattleArmor)) {
                hits *= 2;
            }
            boolean specialCaseFlechette = false;

            // Entity/ammo specific damage modifiers
            if (ammo != null) {
                if (ammo.getMunitionType() == AmmoType.M_CLUSTER) {
                    if (hex.containsTerrain(Terrains.FORTIFIED)
                        && (entity instanceof Infantry)
                        && !(entity instanceof BattleArmor)) {
                        hits *= 2;
                    }
                } else if (ammo.getMunitionType() == AmmoType.M_FLECHETTE) {

                    // wheeled and hover tanks take movement critical
                    if ((entity instanceof Tank)
                            && ((entity.getMovementMode() == EntityMovementMode.WHEELED) || (entity
                                    .getMovementMode() == EntityMovementMode.HOVER))) {
                        r = new Report(6480);
                        r.subject = entity.getId();
                        r.addDesc(entity);
                        r.add(toHit.getTableDesc());
                        r.add(0);
                        vPhaseReport.add(r);
                        vPhaseReport.addAll(vehicleMotiveDamage((Tank) entity,
                                0));
                        continue;
                    }
                    // only infantry and support vees with bar < 5 are affected
                    if ((entity instanceof BattleArmor)
                            || ((entity instanceof SupportTank)
                                && !entity.hasPatchworkArmor()
                                && (entity.getBARRating(1) > 4))) {
                        continue;
                    }
                    if (entity instanceof Infantry) {
                        hits = Compute.d6(damage);
                        hits *= 2;
                    } else {
                        if ((entity.getBARRating(1) < 5)
                                && !entity.hasPatchworkArmor()) {
                            switch (ammo.getAmmoType()) {
                                case AmmoType.T_LONG_TOM:
                                    // hack: check if damage is still at 4, so
                                    // we're in
                                    // the
                                    // center hex. otherwise, do no damage
                                    if (damage == 4) {
                                        damage = (5 - entity.getBARRating(1)) * 5;
                                    } else {
                                        continue;
                                    }
                                    break;
                                case AmmoType.T_SNIPER:
                                    // hack: check if damage is still at 2, so
                                    // we're in
                                    // the
                                    // center hex. otherwise, do no damage
                                    if (damage == 2) {
                                        damage = (5 - entity.getBARRating(1)) * 3;
                                    } else {
                                        continue;
                                    }
                                    break;
                                case AmmoType.T_THUMPER:
                                    // no need to check for damage, because
                                    // falloff =
                                    // damage for the thumper
                                    damage = 5 - entity.getBARRating(1);
                                    break;
                            }
                        } else {
                            // ugh, patchwork armor
                            // rules as written don't deal with this
                            // reset the damage to standard arty damage
                            // when we have each cluster's hit location,
                            // we'll multiply by the
                            // BAR-difference to BAR 5, per a rules question
                            // email
                            specialCaseFlechette = true;
                            switch (ammo.getAmmoType()) {
                                case AmmoType.T_LONG_TOM:
                                    // hack: check if damage is still at 4, so
                                    // we're in
                                    // the
                                    // center hex. otherwise, do no damage
                                    if (damage == 4) {
                                        damage = 25;
                                    } else {
                                        continue;
                                    }
                                    break;
                                case AmmoType.T_SNIPER:
                                    // hack: check if damage is still at 2, so
                                    // we're in
                                    // the
                                    // center hex. otherwise, do no damage
                                    if (damage == 2) {
                                        damage = 15;
                                    } else {
                                        continue;
                                    }
                                    break;
                                case AmmoType.T_THUMPER:
                                    // no need to check for damage, because
                                    // falloff =
                                    // damage for the thumper
                                    damage = 10;
                                    break;
                            }
                        }
                    }
                }
            }

            alreadyHit.add(entity.getId());

            // Do the damage
            r = new Report(6480);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(toHit.getTableDesc());
            r.add(hits);
            vPhaseReport.add(r);
            if (entity instanceof BattleArmor) {
                // BA take full damage to each trooper, ouch!
                for (int loc = 0; loc < entity.locations(); loc++) {
                    if (entity.getInternal(loc) > 0) {
                        HitData hit = new HitData(loc);
                        vPhaseReport.addAll(damageEntity(entity, hit, hits,
                                false, DamageType.NONE, false, true, false));
                    }
                }
            } else {
                while (hits > 0) {
                    int damageToDeal = Math.min(cluster, hits);
                    HitData hit = entity.rollHitLocation(toHit.getHitTable(),
                            toHit.getSideTable());
                    // per a rules question, for patchwork armor, we do this:
                    if (specialCaseFlechette && !(entity instanceof Infantry)) {
                        damageToDeal *= (5 - entity.getBARRating(hit
                                .getLocation()));
                    }
                    vPhaseReport.addAll(damageEntity(entity, hit, damageToDeal,
                            false, DamageType.NONE, false, true, false));
                    hits -= Math.min(cluster, hits);
                }
            }
            if (killer != null) {
                creditKill(entity, killer);
            }
        }

        return alreadyHit;
    }

    /**
     * deal area saturation damage to the map, used for artillery
     *
     * @param centre       The hex on which damage is centred
     * @param attackSource The position the attack came from
     * @param ammo         The ammo type doing the damage
     * @param subjectId    Subject for reports
     * @param killer       Who should be credited with kills
     * @param flak         Flak, hits flying units only, instead of flyers being immune
     * @param altitude     Absolute altitude for flak attack
     * @param mineClear    Does this clear mines?
     * @param vPhaseReport The Vector of Reports for the phasereport
     * @param asfFlak      Is this flak against ASF?
     * @param attackingBA  How many BA suits are in the squad if this is a BA Tube arty
     *                     attack, -1 otherwise
     */
    public void artilleryDamageArea(Coords centre, Coords attackSource,
            AmmoType ammo, int subjectId, Entity killer, boolean flak,
            int altitude, boolean mineClear, Vector<Report> vPhaseReport,
            boolean asfFlak, int attackingBA) {
        int damage = ammo.getRackSize();
        int falloff = 10;
        if (ammo.getAmmoType() == AmmoType.T_CRUISE_MISSILE) {
            falloff = 25;
        }
        if (ammo.getAmmoType() == AmmoType.T_BA_TUBE) {
            falloff = 2 * attackingBA;
        }
        if (ammo.getMunitionType() == AmmoType.M_CLUSTER) {
            // non-arrow-iv cluster does 5 less than standard
            if (ammo.getAmmoType() != AmmoType.T_ARROW_IV) {
                damage -= 5;
            }
            // thumper gets falloff 9 for 1 damage at 1 hex range
            if (ammo.getAmmoType() == AmmoType.T_THUMPER) {
                falloff = 9;
            }
            attackSource = centre;
        } else if (ammo.getMunitionType() == AmmoType.M_FLECHETTE) {
            switch (ammo.getAmmoType()) {
                // for flechette, damage and fallof is number of d6, not absolut
                // damage
                case AmmoType.T_LONG_TOM:
                    damage = 4;
                    falloff = 2;
                    break;
                case AmmoType.T_SNIPER:
                    damage = 2;
                    falloff = 1;
                    break;
                case AmmoType.T_THUMPER:
                    damage = 1;
                    falloff = 1;
            }
        } else
            // if this was a mine clearance, then it only affects the hex hit
            if (mineClear) {
                falloff = damage;
            }
        artilleryDamageArea(centre, attackSource, ammo, subjectId, killer,
                damage, falloff, flak, altitude, vPhaseReport, asfFlak);
    }

    /**
     * Deals area-saturation damage to an area of the board. Used for artillery,
     * bombs, or anything else with linear decreas in damage
     *
     * @param centre
     *            The hex on which damage is centred
     * @param attackSource
     *            The position the attack came from
     * @param ammo
     *            The ammo type doing the damage
     * @param subjectId
     *            Subject for reports
     * @param killer
     *            Who should be credited with kills
     * @param damage
     *            Damage at ground zero
     * @param falloff
     *            Reduction in damage for each hex of distance
     * @param flak
     *            Flak, hits flying units only, instead of flyers being immune
     * @param altitude
     *            Absolute altitude for flak attack
     * @param vPhaseReport
     *            The Vector of Reports for the phasereport
     * @param asfFlak
     *            Is this flak against ASF?
     */
    public void artilleryDamageArea(Coords centre, Coords attackSource,
            AmmoType ammo, int subjectId, Entity killer, int damage,
            int falloff, boolean flak, int altitude,
            Vector<Report> vPhaseReport, boolean asfFlak) {
        Vector<Integer> alreadyHit = new Vector<Integer>();
        for (int ring = 0; damage > 0; ring++, damage -= falloff) {
            ArrayList<Coords> hexes = Compute.coordsAtRange(centre, ring);
            for (Coords c : hexes) {
                alreadyHit = artilleryDamageHex(c, attackSource, damage, ammo,
                        subjectId, killer, null, flak, altitude, vPhaseReport,
                        asfFlak, alreadyHit, false);
            }
            attackSource = centre; // all splash comes from ground zero
        }
    }

    public void deliverBombDamage(Coords centre, int type, int subjectId,
            Entity killer, Vector<Report> vPhaseReport) {
        int range = 0;
        int damage = 10;
        if (type == BombType.B_CLUSTER) {
            range = 1;
            damage = 5;
        }
        Vector<Integer> alreadyHit = new Vector<Integer>();

        alreadyHit = artilleryDamageHex(centre, centre, damage, null,
                subjectId, killer, null, false, 0, vPhaseReport, false,
                alreadyHit, false);
        if (range > 0) {
            ArrayList<Coords> hexes = Compute.coordsAtRange(centre, range);
            for (Coords c : hexes) {
                alreadyHit = artilleryDamageHex(c, centre, damage, null,
                        subjectId, killer, null, false, 0, vPhaseReport, false,
                        alreadyHit, false);
            }
        }
    }

    /**
     * deliver inferno bomb
     *
     * @param coords    the <code>Coords</code> where to deliver
     * @param ae        the attacking <code>entity<code>
     * @param subjectId the <code>int</code> id of the target
     */
    public void deliverBombInferno(Coords coords, Entity ae, int subjectId,
                                   Vector<Report> vPhaseReport) {
        IHex h = game.getBoard().getHex(coords);
        Report r;
        // Unless there is a fire in the hex already, start one.
        if (h.terrainLevel(Terrains.FIRE) < Terrains.FIRE_LVL_INFERNO_BOMB) {
            ignite(coords, Terrains.FIRE_LVL_INFERNO_BOMB, vPhaseReport);
        }
        // possibly melt ice and snow
        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {
            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));
        }
        for (Entity entity : game.getEntitiesVector(coords)) {
            if (entity.isAirborne() || entity.isAirborneVTOLorWIGE()) {
                continue;
            }
            // TacOps, p. 359 - treat as if hit by 5 inferno missiles
            r = new Report(6696);
            r.indent(3);
            r.add(entity.getDisplayName());
            r.subject = entity.getId();
            r.newlines = 0;
            vPhaseReport.add(r);
            if (entity instanceof Tank) {
                Report.addNewline(vPhaseReport);
            }
            Vector<Report> vDamageReport = deliverInfernoMissiles(ae, entity, 5);
            Report.indentAll(vDamageReport, 2);
            vPhaseReport.addAll(vDamageReport);
        }
    }

    /**
     * Resolve any Infantry units which are fortifying hexes
     */
    void resolveFortify() {
        Report r;
        for (Entity ent : game.getEntitiesVector()) {
            if (ent instanceof Infantry) {
                Infantry inf = (Infantry) ent;
                int dig = inf.getDugIn();
                if (dig == Infantry.DUG_IN_WORKING) {
                    r = new Report(5300);
                    r.addDesc(inf);
                    r.subject = inf.getId();
                    addReport(r);
                } else if (dig == Infantry.DUG_IN_FORTIFYING2) {
                    Coords c = inf.getPosition();
                    r = new Report(5305);
                    r.addDesc(inf);
                    r.add(c.getBoardNum());
                    r.subject = inf.getId();
                    addReport(r);
                    // fortification complete - add to map
                    IHex hex = game.getBoard().getHex(c);
                    hex.addTerrain(Terrains.getTerrainFactory().createTerrain(
                            Terrains.FORTIFIED, 1));
                    sendChangedHex(c);
                    // Clear the dig in for any units in same hex, since they
                    // get it for free by fort
                    for (Entity ent2 : game.getEntitiesVector(c)) {
                        if (ent2 instanceof Infantry) {
                            Infantry inf2 = (Infantry) ent;
                            inf2.setDugIn(Infantry.DUG_IN_NONE);
                        }
                    }
                }
            }
        }
    }

    /**
     * check if spikes get breaken in the given location
     *
     * @param e   the <code>Entity</code> to check
     * @param loc the <code>int</code> location
     */
    private void checkBreakSpikes(Entity e, int loc) {
        int roll = Compute.d6(2);
        Report r;
        if (roll < 9) {
            r = new Report(4445);
            r.newlines = 0;
            r.add(roll);
            r.subject = e.getId();
            addReport(r);
            return;
        }
        r = new Report(4440);
        r.newlines = 0;
        r.add(roll);
        r.subject = e.getId();
        addReport(r);
        for (Mounted m : e.getMisc()) {
            if (m.getType().hasFlag(MiscType.F_SPIKES)
                && (m.getLocation() == loc)) {
                m.setHit(true);
            }
        }
    }

    /**
     * @return a <code>String</code> representing the hostname
     */
    public String getHost() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            e.printStackTrace();
            return "";
        }
    }

    /**
     * @return the <code>int</code> this server is listening on
     */
    public int getPort() {
        return serverSocket.getLocalPort();
    }

    /**
     * Loops through all the attacks the game has. Checks if they care about
     * current phase, if so, runs them, and removes them if they don't want to
     * stay. TODO: Refactor the new entity annoucement out of here.
     */
    private void handleAttacks() {
        Report r;
        int lastAttackerId = -1;
        Vector<AttackHandler> currentAttacks, keptAttacks;
        currentAttacks = game.getAttacksVector();
        keptAttacks = new Vector<AttackHandler>();
        Vector<Report> handleAttackReports = new Vector<Report>();
        // first, do any TAGs, so homing arty will have TAG
        for (AttackHandler ah : currentAttacks) {
            if (!(ah instanceof TAGHandler)) {
                continue;
            }
            if (ah.cares(game.getPhase())) {
                int aId = ah.getAttackerId();
                if ((aId != lastAttackerId) && !ah.announcedEntityFiring()) {
                    // report who is firing
                    r = new Report(3100);
                    r.subject = aId;
                    Entity ae = game.getEntity(aId);
                    r.addDesc(ae);
                    handleAttackReports.addElement(r);
                    ah.setAnnouncedEntityFiring(true);
                    lastAttackerId = aId;
                }
                boolean keep = ah.handle(game.getPhase(), handleAttackReports);
                if (keep) {
                    keptAttacks.add(ah);
                }
                Report.addNewline(handleAttackReports);
            }
        }
        // now resolve everything but TAG
        for (AttackHandler ah : currentAttacks) {
            if (ah instanceof TAGHandler) {
                continue;
            }
            if (ah.cares(game.getPhase())) {
                int aId = ah.getAttackerId();
                if ((aId != lastAttackerId) && !ah.announcedEntityFiring()) {
                    // if this is a new attacker then resolve any
                    // standard-to-cap damage
                    // from previous
                    handleAttackReports.addAll(checkFatalThresholds(aId,
                            lastAttackerId));
                    // report who is firing
                    if (ah.isStrafing()) {
                        r = new Report(3101);
                    } else {
                        r = new Report(3100);
                    }
                    r.subject = aId;
                    Entity ae = game.getEntity(aId);
                    // for arty, attacker may be dead, or fled, so check out-of-
                    // game entities
                    if (ae == null) {
                        ae = game.getOutOfGameEntity(aId);
                    }
                    r.addDesc(ae);
                    handleAttackReports.addElement(r);
                    ah.setAnnouncedEntityFiring(true);
                    lastAttackerId = aId;
                }
                boolean keep = ah.handle(game.getPhase(), handleAttackReports);
                if (keep) {
                    keptAttacks.add(ah);
                }
                Report.addNewline(handleAttackReports);
            } else {
                keptAttacks.add(ah);
            }
        }
        // resolve standard to capital one more time
        handleAttackReports.addAll(checkFatalThresholds(lastAttackerId,
                lastAttackerId));
        if (handleAttackReports.size() > 0) {
            Report.addNewline(handleAttackReports);
        }
        addReport(handleAttackReports);
        // HACK, but anything else seems to run into weird problems.
        game.setAttacksVector(keptAttacks);
    }

    /**
     * @return
     */
    public static Server getServerInstance() {
        return serverInstance;
    }

    /**
     * create a <code>SmokeCloud object and add it to the server list</code>
     *
     * @param coords
     */
    public void createSmoke(Coords coords) {
        createSmoke(coords, 1, 0);
    }

    /**
     * create a <code>SmokeCloud object and add it to the server list</code>
     *
     * @param coords
     * @param level  1=Light 2=Heavy Smoke
     */
    public void createSmoke(Coords coords, int level) {
        createSmoke(coords, level, 0);
    }

    /**
     * create a <code>SmokeCloud object and add it to the server list</code>
     *
     * @param coords
     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
     * @param duration How long the smoke will last.
     */
    public void createSmoke(Coords coords, int level, int duration) {
        SmokeCloud cloud = new SmokeCloud(coords, level, duration);
        game.addSmokeCloud(cloud);
        sendSmokeCloudAdded(cloud);
    }

    /**
     * create a <code>SmokeCloud object and add it to the server list</code>
     *
     * @param coords
     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
     * @param duration duration How long the smoke will last.
     */
    public void createSmoke(ArrayList<Coords> coords, int level, int duration) {
        SmokeCloud cloud = new SmokeCloud(coords, level, duration);
        game.addSmokeCloud(cloud);
        sendSmokeCloudAdded(cloud);
    }

    /**
     * Update the map with a new set of coords.
     *
     * @param newCoords
     */
    public void updateSmoke(SmokeCloud cloud, ArrayList<Coords> newCoords) {
        removeSmokeTerrain(cloud);
        cloud.getCoordsList().clear();
        cloud.getCoordsList().addAll(newCoords);
    }

    /**
     * remove a cloud from the map
     *
     * @param cloud
     */
    public void removeSmokeTerrain(SmokeCloud cloud) {
        for (Coords coords : cloud.getCoordsList()) {
            IHex nextHex = game.getBoard().getHex(coords);
            if ((nextHex != null) && nextHex.containsTerrain(Terrains.SMOKE)) {
                nextHex.removeTerrain(Terrains.SMOKE);
                sendChangedHex(coords);
            }
        }
    }

    public List<SmokeCloud> getSmokeCloudList() {
        return game.getSmokeCloudList();
    }

    /**
     * Check to see if blowing sand caused damage to airborne VTOL/WIGEs
     */
    private Vector<Report> resolveBlowingSandDamage() {
        Vector<Report> vFullReport = new Vector<Report>();
        vFullReport.add(new Report(5002, Report.PUBLIC));
        int damage_bonus = Math.max(0, game.getPlanetaryConditions()
                                           .getWindStrength() - PlanetaryConditions.WI_MOD_GALE);
        // cycle through each team and damage 1d6 airborne VTOL/WIGE
        for (Enumeration<Team> loop = game.getTeams(); loop.hasMoreElements(); ) {
            Team team = loop.nextElement();
            Vector<Integer> airborne = team.getAirborneVTOL();
            if (airborne.size() > 0) {
                // how many units are affected
                int unitsAffected = Math.min(Compute.d6(), airborne.size());
                while ((unitsAffected > 0) && (airborne.size() > 0)) {
                    int loc = Compute.randomInt(airborne.size());
                    Entity en = game.getEntity(airborne.get(loc));
                    int damage = Math.max(1, Compute.d6() / 2) + damage_bonus;
                    while (damage > 0) {
                        HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL,
                                                         ToHitData.SIDE_RANDOM);
                        vFullReport.addAll(damageEntity(en, hit, 1));
                        damage--;
                    }
                    unitsAffected--;
                    airborne.remove(loc);
                }
            }
        }
        Report.addNewline(vPhaseReport);
        return vFullReport;
    }

    /**
     * let an entity lay a mine
     *
     * @param entity the <code>Entity</code> that should lay a mine
     * @param mineId an <code>int</code> pointing to the mine
     */
    private void layMine(Entity entity, int mineId, Coords coords) {
        Mounted mine = entity.getEquipment(mineId);
        Report r;
        if (!mine.isMissing()) {
            int reportId = 0;
            switch (mine.getMineType()) {
                case Mounted.MINE_CONVENTIONAL:
                    deliverThunderMinefield(coords, entity.getOwnerId(), 10,
                                            entity.getId());
                    reportId = 3500;
                    break;
                case Mounted.MINE_VIBRABOMB:
                    deliverThunderVibraMinefield(coords, entity.getOwnerId(), 10,
                                                 mine.getVibraSetting(), entity.getId());
                    reportId = 3505;
                    break;
                case Mounted.MINE_ACTIVE:
                    deliverThunderActiveMinefield(coords, entity.getOwnerId(), 10,
                                                  entity.getId());
                    reportId = 3510;
                    break;
                case Mounted.MINE_INFERNO:
                    deliverThunderInfernoMinefield(coords, entity.getOwnerId(), 10,
                                                   entity.getId());
                    reportId = 3515;
                    break;
                // TODO: command-detonated mines
                // case 2:
            }
            mine.setShotsLeft(mine.getUsableShotsLeft() - 1);
            if (mine.getUsableShotsLeft() <= 0) {
                mine.setMissing(true);
            }
            r = new Report(reportId);
            r.subject = entity.getId();
            r.addDesc(entity);
            r.add(coords.getBoardNum());
            addReport(r);
            entity.setLayingMines(true);
        }
    }

    public void reportRoll(Roll roll) {
        Report r = new Report(1230);
        r.add(roll.getReport());
        addReport(r);
    }

    private void registerWithServerBrowser(boolean register, String urlString) {
        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setDoOutput(true);
            conn.setRequestProperty("Content-Type",
                                    "application/x-www-form-urlencoded");
            DataOutputStream printout = new DataOutputStream(
                    conn.getOutputStream());
            String content = "";
            content = "port="
                      + URLEncoder.encode(
                    Integer.toString(serverSocket.getLocalPort()),
                    "UTF-8");
            if (register) {
                for (IConnection iconn : connections) {
                    content += "&players[]="
                               + (getPlayer(iconn.getId()).getName());
                }
                if ((game.getPhase() != Phase.PHASE_LOUNGE)
                    && (game.getPhase() != Phase.PHASE_UNKNOWN)) {
                    content += "&close=yes";
                }
                content += "&version=" + MegaMek.VERSION;
                if (isPassworded()) {
                    content += "&pw=yes";
                }
            } else {
                content += "&delete=yes";
            }
            if (serverAccessKey != null) {
                content += "&key=" + serverAccessKey;
            }
            // System.out.println(content);
            printout.writeBytes(content);
            printout.flush();
            BufferedReader rd = new BufferedReader(new InputStreamReader(
                    conn.getInputStream()));
            String line;
            // System.out.println(conn.getResponseCode()+
            // " "+conn.getResponseMessage());
            if (conn.getResponseCode() == 200) {
                while ((line = rd.readLine()) != null) {
                    // System.out.println(line);
                    if (serverAccessKey == null) {
                        serverAccessKey = line;
                    }
                }
            } else {
                while ((line = rd.readLine()) != null) {
                    // System.out.println(line);
                }
            }
            rd.close();
            printout.close();
        } catch (Exception e) {
        }
    }

    public Set<Coords> getHexUpdateSet() {
        return hexUpdateSet;
    }

    public void setHexUpdateSet(HashSet<Coords> hexUpdateSet) {
        this.hexUpdateSet = hexUpdateSet;
    }
}
